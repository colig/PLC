{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(\"zoomcharts\", [], e) : \"object\" == typeof exports ? exports.zoomcharts = e() : t.zoomcharts = e();\n}(window, function () {\n  return function (t) {\n    var e = {};\n\n    function i(n) {\n      if (e[n]) return e[n].exports;\n      var r = e[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, n) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: n\n      });\n    }, i.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.t = function (t, e) {\n      if (1 & e && (t = i(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var n = Object.create(null);\n      if (i.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var r in t) {\n        i.d(n, r, function (e) {\n          return t[e];\n        }.bind(null, r));\n      }\n      return n;\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 1);\n  }([function (t, e, i) {\n    \"use strict\";\n\n    var n = n || {};\n    !function (e) {\n      /*!\n      @license\n      DVSL Charting library, version 1.18.9-dev.\n      (c) 2013 - 2018 Data Visualization Software Lab\n      \n      https://zoomcharts.com\n      \n      Embedded 3rd party software libraries:\n      \n        CssColorParser.js\n          author : Dean McNamee <dean@gmail.com>, 2012.\n          license : MIT\n          github.com/deanm/css-color-parser-js\n      \n        SHA-256 implementation in JavaScript\n          author : Chris Veness\n          license: MIT\n          github.com/chrisveness/crypto\n      \n        jsrsasign (RSA-Sign JavaScript Library)\n          version : 4.7.2\n          author : Kenji Urushima\n          license : MIT\n          kjur.github.io/jsrsasign/\n      \n        jsbn (RSA and ECC in JavaScript)\n          version : 1.4\n          author : Tom Wu\n          license : BSD (http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE)\n          www-cs-students.stanford.edu/~tjw/jsbn/\n      */\n      var i = e.Configuration || (e.Configuration = {}),\n          n = e.Internal || (e.Internal = {});\n      e.PackageInfo = {\n        LibraryName: \"zoomcharts\",\n        Version: \"1.18.9-dev\",\n        Revision: \"1c0c676ce80b5310be441e9c263505177bd98b7e\",\n        Built: \"2018-10-10\"\n      };\n\n      var r = function r(t, e) {\n        function i() {\n          this.constructor = t;\n        }\n\n        for (var n in t.__baseType = e, e) {\n          e.hasOwnProperty(n) && (t[n] = e[n]);\n        }\n\n        t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());\n      };\n\n      !function (n) {\n        n.GeoChart || (n.GeoChart = {}), n.FacetChart || (n.FacetChart = {});\n        var s = n.PieChart || (n.PieChart = {}),\n            a = (n.TimeChart || (n.TimeChart = {}), n.LinearChart || (n.LinearChart = {})),\n            o = (n.NetChart || (n.NetChart = {}), n.ItemsChart || (n.ItemsChart = {})),\n            l = n.Resources || (n.Resources = {}),\n            h = n.Base || (n.Base = {});\n        void 0 !== t && t.exports && (t.exports.Internal = n), function (s) {\n          function a() {}\n\n          function o(t, e) {\n            for (var i in e) {\n              e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i]);\n            }\n          }\n\n          var h = s.Bar || (s.Bar = {}),\n              u = Object.prototype.hasOwnProperty,\n              c = (\"undefined\" == typeof console ? null : console) || {};\n          c.log || (c.log = a), c.warn || (c.warn = a), c.error || (c.error = a), c.info || (c.info = a), s.overlayConsole = !1;\n\n          var d = \"undefined\" != typeof Document && !(document instanceof Document),\n              p = function () {\n            function e() {}\n\n            return e.exportSymbol = function (e, i) {\n              \"undefined\" != typeof window && (window[e] = i), void 0 !== t && t.exports && (t.exports[e] = i);\n            }, e.extendStyleTo = function (t, e, i) {\n              void 0 === i && (i = !0);\n\n              for (var n = Object.keys(t), r = 0; r < n.length; r++) {\n                var s = n[r],\n                    a = t[s];\n                void 0 === a || !i && void 0 !== e[s] || (e[s] = a);\n              }\n            }, e.extendDataItem = function (t, i) {\n              for (var n = t, r = Object.keys(i), s = 0; s < r.length; s++) {\n                var a = r[s],\n                    o = i[a];\n                \"style\" === a ? n.style ? e.extendDeep(n.style, o) : n.style = e.realClone(o) : n[a] = o;\n              }\n\n              return n;\n            }, e.extendDeep = function (t, i) {\n              if (null == t) throw new Error(\"Target object is not defined.\");\n              if (!e.isObjectOrArray(t)) throw new Error(\"Target is not an object.\");\n\n              for (var n = Object.keys(i), r = 0; r < n.length; r++) {\n                var s = n[r],\n                    a = i[s],\n                    o = t[s];\n                null == o && e.isObjectOrArray(a) && !e.isDomObject(a) ? t[s] = this.realClone(a) : e.isObjectOrArray(o) && e.isObjectOrArray(a) && !e.isDomObject(o) && !e.isDomObject(a) ? this.extendDeep(o, a) : t[s] = a;\n              }\n            }, e.extendCopy = function (t, e, i) {\n              if (void 0 === i && (i = null), !e) return t;\n\n              for (var n = Object.keys(e), r = 0; r < n.length; r++) {\n                var s = n[r],\n                    a = e[s];\n\n                if (i && (a = i(s, a)), void 0 !== a) {\n                  var o = t[s];\n                  this.isDomObject(a) ? t[s] = a : this.isObjectOrArray(o) && this.isObjectOrArray(a) ? this.extendCopy(o, a, i) : this.isObjectOrArray(a) ? Array.isArray(a) ? t[s] = this.extendCopy([], a, i) : t[s] = this.extendCopy({}, a, i) : t[s] = a;\n                }\n              }\n\n              return t;\n            }, e.clone = function (t) {\n              if (null == t) return t;\n              var i;\n              i = e.isObjectOrArray(t) ? new t.constructor() : t.constructor();\n\n              for (var n = Object.keys(t), r = 0; r < n.length; r++) {\n                var s = n[r],\n                    a = t[s];\n                i[s] = a;\n              }\n\n              return i;\n            }, e.isObjectOrArray = function (t) {\n              return null !== t && \"object\" == typeof t;\n            }, e.isDomObject = function (t) {\n              return t && (t instanceof Element || t instanceof CanvasGradient || t instanceof CanvasPattern || d && 2 === t.ATTRIBUTE_NODE);\n            }, e.isFunction = function (t) {\n              return \"function\" == typeof t;\n            }, e.isNumber = function (t) {\n              return !isNaN(t) && (\"number\" == typeof t || t instanceof Number);\n            }, e.isString = function (t) {\n              return \"string\" == typeof t || t instanceof String;\n            }, e.tryParseInt = function (t, e) {\n              void 0 === e && (e = 0);\n              var i = parseInt(t, 10);\n              return isNaN(i) ? e : i;\n            }, e.tryParseFloat = function (t, e) {\n              void 0 === e && (e = 0);\n              var i = parseFloat(t);\n              return isNaN(i) ? e : i;\n            }, e.hasProperty = function (t, e) {\n              return u.call(t, e);\n            }, e.hasProperties = function (t) {\n              return !!t && Object.keys(t).length > 0;\n            }, e.removePropertyValue = function (t) {\n              var e = Object.keys(t);\n              if (0 === e.length) return null;\n              var i = e[0],\n                  n = t[i];\n              return delete t[i], {\n                key: i,\n                value: n\n              };\n            }, e.countProperties = function (t) {\n              return Object.keys(t).length;\n            }, e.realClone = function (t) {\n              if (this.isFunction(t) || this.isDomObject(t)) return t;\n\n              if (Array.isArray(t)) {\n                for (var e = new Array(t.length), i = 0; i < t.length; i++) {\n                  e[i] = this.realClone(t[i]);\n                }\n\n                return e;\n              }\n\n              if (this.isObjectOrArray(t)) {\n                var n = new t.constructor(),\n                    r = Object.keys(t);\n\n                for (i = 0; i < r.length; i++) {\n                  var s = r[i];\n                  n[s] = this.realClone(t[s]);\n                }\n\n                return n;\n              }\n\n              return t;\n            }, e.realCloneSafe = function (t, e) {\n              if (void 0 === e && (e = []), this.isFunction(t) || this.isDomObject(t)) return t;\n\n              if (Array.isArray(t)) {\n                for (var i = 0; i < e.length; i++) {\n                  if ((r = e[i]).from === t) return r.to;\n                }\n\n                var n = new Array(t.length);\n                e.push({\n                  from: t,\n                  to: n\n                });\n\n                for (i = 0; i < t.length; i++) {\n                  n[i] = this.realCloneSafe(t[i], e);\n                }\n\n                return n;\n              }\n\n              if (this.isObjectOrArray(t)) {\n                for (i = 0; i < e.length; i++) {\n                  var r;\n                  if ((r = e[i]).from === t) return r.to;\n                }\n\n                var s = new t.constructor();\n                e.push({\n                  from: t,\n                  to: s\n                });\n                var a = Object.keys(t);\n\n                for (i = 0; i < a.length; i++) {\n                  var o = a[i];\n                  s[o] = this.realCloneSafe(t[o], e);\n                }\n\n                return s;\n              }\n\n              return t;\n            }, e.removeFromArray = function (t, e) {\n              for (var i, n = !1; (i = t.indexOf(e)) > -1;) {\n                t.splice(i, 1), n = !0;\n              }\n\n              return n;\n            }, e.removeFromArrayHasty = function (t, e) {\n              var i = t.indexOf(e);\n              if (i < 0) return !1;\n              var n = t.pop();\n              return i !== t.length && (t[i] = n), !0;\n            }, e.arrayToMap = function (t, e) {\n              for (var i = {}, n = 0; n < t.length; n++) {\n                var r = t[n];\n                r.index = n, i[r[e]] = r;\n              }\n\n              return i;\n            }, e.overlayConsoleMessage = function (t, i, n) {\n              var r = document.getElementById(\"zoomChartsOverlayConsole\");\n              r || ((r = document.createElement(\"div\")).id = \"zoomChartsOverlayConsole\", e.extendCopy(r.style, {\n                position: \"absolute\",\n                top: \"10px\",\n                left: \"10px\",\n                width: \"50%\",\n                height: \"300px\",\n                overflow: \"auto\",\n                backgroundColor: \"rgba(255,255,255,0.75)\",\n                border: \"1px solid black\",\n                zIndex: \"99999\"\n              }), document.body.appendChild(r));\n              var s = document.createElement(\"div\");\n              s.style.color = \"error\" === t ? \"red\" : \"warn\" === t ? \"yellow\" : \"black\", s.innerText = i + n.map(function (t) {\n                return JSON.stringify(t);\n              }).join(\"\"), r.appendChild(s), r.scrollTop = r.scrollHeight;\n            }, e.log = function (t) {\n              for (var i = [], n = 1; n < arguments.length; n++) {\n                i[n - 1] = arguments[n];\n              }\n\n              s.overlayConsole ? e.overlayConsoleMessage(\"log\", t, i) : i && i.length ? c.info.apply(c, [t].concat(i)) : c.info(t);\n            }, e.warn = function (t, i, n) {\n              if (void 0 === n && (n = null), n) {\n                var r = new Date().getTime();\n                if (this._previousConsoleMessages[t] > r) return;\n                !0 === n && (n = 5e3), this._previousConsoleMessages[t] = r + n;\n              }\n\n              s.overlayConsole ? e.overlayConsoleMessage(\"warn\", t, i) : i && i.length ? c.warn.apply(c, [t].concat(i)) : c.warn(t);\n            }, e.error = function (t) {\n              for (var i = [], n = 1; n < arguments.length; n++) {\n                i[n - 1] = arguments[n];\n              }\n\n              s.overlayConsole ? e.overlayConsoleMessage(\"error\", t, i) : i && i.length ? c.error.apply(c, [t].concat(i)) : c.error(t);\n            }, e.createDom = function (t, e, i, n) {\n              void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);\n              var r = document.createElement(t);\n              return null !== e && (r.className = e), null !== i && (r.innerHTML = i), null !== n && n.appendChild(r), r;\n            }, e.addClass = function (t, e) {\n              if (e = (e || \"\").trim()) {\n                var i = e.indexOf(\" \");\n                if (i > -1 && (this.addClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.add(e);else t.className.length > 0 && new RegExp(\"(^|s)\" + e.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\") + \"(s|$)\").test(t.className) || (t.className.length > 0 && (e = \" \" + e), t.className = e);\n              }\n            }, e.removeClass = function (t, e) {\n              if (e = (e || \"\").trim()) {\n                var i = e.indexOf(\" \");\n                if (i > -1 && (this.removeClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.remove(e);else {\n                  t.className = t.className.replace(/(\\S+)\\s*/g, function (t, i) {\n                    return i === e ? \"\" : t;\n                  }).trim();\n                }\n              }\n            }, e.isStyleSheetDefined = function (t, e) {\n              var i = document.createElement(\"dvsl-test\"),\n                  n = document.body;\n              n.appendChild(i);\n\n              try {\n                var r = window.getComputedStyle(i),\n                    s = r[e];\n                return i.className = t, n.removeChild(i), n.appendChild(i), s !== r[e];\n              } finally {\n                n.removeChild(i);\n              }\n            }, e.listen = function (t, e, i) {\n              t.addEventListener(e, i);\n            }, e.unlisten = function (t, e, i) {\n              t.removeEventListener(e, i);\n            }, e.stopPropagation = function (t) {\n              t.stopPropagation();\n            }, e.canvasScaling = function () {\n              var t, e;\n              return window.screen.deviceXDPI ? (t = window.screen.deviceXDPI / window.screen.logicalXDPI, e = window.screen.deviceYDPI / window.screen.logicalYDPI) : t = e = window.devicePixelRatio ? window.devicePixelRatio : 1, {\n                x: t,\n                y: e\n              };\n            }, e.convertPointFromPageToNode = function (t, e, i, n, r) {\n              if (window && window.webkitConvertPointFromPageToNode) {\n                var s = window.webkitConvertPointFromPageToNode(t, new WebKitPoint(e, i));\n                if (s) return s;\n              }\n\n              var a = t.getBoundingClientRect();\n              return {\n                x: n - a.left,\n                y: r - a.top\n              };\n            }, e.elementPos = function (t) {\n              var e = t.getBoundingClientRect(),\n                  i = e.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0);\n              return {\n                left: e.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0),\n                top: i\n              };\n            }, e.isParentOf = function (t, e) {\n              for (; e;) {\n                if (e === t) return !0;\n                e = e.parentElement;\n              }\n\n              return !1;\n            }, e.getProp = function (t, e, i) {\n              void 0 === i && (i = !1);\n\n              for (var n = 0, r = e.split(\".\"); n < r.length; n++) {\n                var s = r[n];\n                if (null == t || !this.hasProperty(t, s)) return;\n\n                if (i && n === r.length - 1) {\n                  var a = t[s];\n                  delete t[s], t = a;\n                } else t = t[s];\n              }\n\n              return t;\n            }, e.wrapValue = function (t, e) {\n              for (var i = t, n = e.split(\".\").reverse(), r = 0; r < n.length; r++) {\n                (s = {})[n[r]] = i, i = s;\n              }\n\n              return i;\n              var s;\n            }, e.hasProp = function (t, i) {\n              return void 0 !== e.getProp(t, i);\n            }, e.sign = function (t) {\n              return t ? t < 0 ? -1 : 1 : 0;\n            }, e.reversePolyline = function (t) {\n              var e = [];\n              if (t.length % 2 != 0) throw new Error(\"The length of a given polyline must be dividable by 2\");\n\n              for (var i = t.length - 1; i >= 0; i += -2) {\n                e.push(t[i - 1], t[i]);\n              }\n\n              return e;\n            }, e.toleranceMax = function (t, e, i) {\n              return t >= e * i ? t : e;\n            }, e.toleranceMin = function (t, e, i) {\n              return t * i <= e ? t : e;\n            }, e.getIdentifierStr = function () {\n              return e.SeparatorChar + (e.nextIdentifier++).toString();\n            }, e.doPostRequest = function (t, e, i, n, r) {\n              this.isString(i) || (i = JSON.stringify(i)), this.doRequestRaw(t, e, \"POST\", i, n, r);\n            }, e.doRequest = function (t, e, i, n, r) {\n              if (i && i.length) {\n                t += -1 !== t.indexOf(\"?\") ? \"&\" : \"?\";\n\n                for (var s = 0; s < i.length; s++) {\n                  var a = i[s];\n                  s > 0 && (t += \"&\"), t += encodeURIComponent(a[0]) + \"=\" + encodeURIComponent(a[1]);\n                }\n              }\n\n              this.doRequestRaw(t, e, \"GET\", \"\", n, r);\n            }, e.doRequestRaw = function (t, e, i, n, r, s) {\n              var a;\n              if (\"undefined\" == typeof XMLHttpRequest) throw new Error(\"Cannot create XMLHttpRequest. Please verify if the feature is not disabled in the browser configuration.\");\n\n              (a = new XMLHttpRequest()).onreadystatechange = function () {\n                4 === a.readyState && (200 === a.status ? r(a.responseText) : s(a.responseText));\n              };\n\n              try {\n                a.open(i, t, !0), a.timeout = e, a.ontimeout = function () {\n                  s('{\"error\": \"Request timeout.\"}');\n                }, a.send(n);\n              } catch (t) {\n                return void window.setTimeout(function () {\n                  return s(t);\n                }, 1);\n              }\n            }, e.openUrl = function (t, e) {\n              return window.open(t, e || \"_blank\");\n            }, e.parseData = function (t, e, i) {\n              void 0 === i && (i = !1);\n              var n = null,\n                  r = null;\n              if (\"json\" === (e = e.toLowerCase()) || \"geojson\" === e) {\n                if (s.Helpers.isString(t)) try {\n                  r = JSON.parse(t);\n                } catch (e) {\n                  n = i ? t : \"Failed to parse JSON response: \" + e + \". Response text: \" + t;\n                } else r = t;\n              } else n = \"Unsupported data format: \" + e;\n              return null == r && null == n && (n = \"NULL response\"), n ? {\n                error: n\n              } : r;\n            }, e.numberFormat = function (t, e, i, n) {\n              void 0 === e && (e = 2), void 0 === i && (i = \".\"), void 0 === n && (n = \" \");\n              var r,\n                  s = parseFloat(t);\n              if (isNaN(s)) return \"—\";\n              s < 0 ? (r = \"-\", s = -s) : r = \"\";\n\n              for (var a, o = Math.floor(s), l = e > 0 ? i + (s - o).toFixed(e).substr(2) : \"\"; l = (a = o % 1e3).toFixed(0) + l, o >= 1e3;) {\n                o = Math.floor(o / 1e3), a < 10 ? l = \"00\" + l : a < 100 && (l = \"0\" + l), l = n + l;\n              }\n\n              return r + l;\n            }, e.printPercentValue = function (t, e, i) {\n              void 0 === i && (i = \"\");\n              var n = \"\",\n                  r = 0;\n\n              if (e[1]) {\n                var a = e[1];\n                n = a.charAt(0), r = a.length - 1;\n              }\n\n              var o = e[2],\n                  l = s.Helpers.numberFormat(100 * t, r, n);\n              return \"\" !== i && \" \" === o.charAt(0) && (i = \" \" + i), l + i + o;\n            }, e.printCurrencyValue = function (t, e, i) {\n              void 0 === i && (i = \"\");\n              var n = \"\",\n                  r = 0;\n\n              if (e[2]) {\n                var a = e[2];\n                n = a.charAt(0), r = a.length - 1;\n              }\n\n              var o = e[1] ? e[1] : \"\",\n                  l = e[3] ? e[3] : \"\",\n                  h = s.Helpers.numberFormat(t, r, n);\n              return \"\" !== i && \" \" === l.charAt(0) && (i = \" \" + i), o && l && (l.indexOf(\"%\") > -1 || o.indexOf(\"%\") > -1) ? (this.warn(\"Incorrect valueFormat using '%'. To format as percentage, '%' must be used after digits without any prefix.\"), s.Helpers.numberFormat(t)) : o + h + i + l;\n            }, e.matchPercentFormat = function (t) {\n              return /^0([.,]0+)?( ?%)$/.exec(t);\n            }, e.matchCurrencyFormat = function (t) {\n              return /^([^0-9]+)?0?([.,]0+)?([^0-9]+)?$/.exec(t);\n            }, e.buildImage = function (t, e, i, n) {\n              var r = this,\n                  s = document.createElement(\"img\"),\n                  a = function a() {\n                return i(s);\n              };\n\n              return e && (s.crossOrigin = e), s.src = t, s.complete ? s.width > 0 ? a() : setTimeout(a, 0) : (s.onload = a, s.onerror = function (a) {\n                e ? r.buildImage(t, null, i, n) : n(s);\n              }), s;\n            }, e.sort = function (t, e) {\n              e || (e = function e(t, _e) {\n                return t - _e;\n              });\n\n              for (var i, n, r = t, s = 0 | r.length, a = 0; a <= s - 2; a += 2) {\n                e(i = r[a], n = r[a + 1]) > 0 && (r[a] = n, r[a + 1] = i);\n              }\n\n              for (var o = r.slice(0), l = 2; l < s;) {\n                for (var h = l << 1, u = 0; u <= s - 1; u += h) {\n                  var c = u,\n                      d = u + l;\n                  if (d >= s) for (a = c; a <= s - 1; a++) {\n                    o[a] = r[a];\n                  } else {\n                    var p = d,\n                        f = Math.min(d + l, s),\n                        g = u;\n\n                    for (i = r[c], n = r[d];;) {\n                      if (e(i, n) <= 0) {\n                        if (o[g] = i, g = g + 1 | 0, (c = c + 1 | 0) === p) {\n                          for (o[g] = n, g = g + 1 | 0, d = d + 1 | 0; d < f;) {\n                            o[g] = r[d], g = g + 1 | 0, d = d + 1 | 0;\n                          }\n\n                          break;\n                        }\n\n                        i = r[c];\n                      } else {\n                        if (o[g] = n, g = g + 1 | 0, (d = d + 1 | 0) === f) {\n                          for (o[g] = i, g = g + 1 | 0, c = c + 1 | 0; c < p;) {\n                            o[g] = r[c], g = g + 1 | 0, c = c + 1 | 0;\n                          }\n\n                          break;\n                        }\n\n                        n = r[d];\n                      }\n                    }\n                  }\n                }\n\n                l = h;\n                var m = o;\n                o = r, r = m;\n              }\n\n              if (t !== r) {\n                for (a = 0; a <= s - 1; a++) {\n                  t[a] = r[a];\n                }\n\n                r.length = 0;\n              } else o.length = 0;\n\n              return t;\n            }, e.binSearch = function (t, e) {\n              for (var i = 0, n = t.length - 1; i < n;) {\n                var r = (n + i) / 2 | 0;\n                if (t[r] < e) i = r + 1;else {\n                  if (!(t[r] > e)) {\n                    for (; r > 0 && t[r - 1] === e;) {\n                      r -= 1;\n                    }\n\n                    return r;\n                  }\n\n                  n = r;\n                }\n              }\n\n              return i < t.length && t[i] < e ? i + 1 : i;\n            }, e.listenResize = function (t, i) {\n              var n = document.documentMode;\n              if (n && n < 11) t.onresize = i;else {\n                var r = t,\n                    s = document.createElement(\"div\"),\n                    a = function a(t) {\n                  i(), e.updateResizeTriggers(s);\n                };\n\n                \"static\" === window.getComputedStyle(r).position && (r.style.position = \"relative\"), r.__resizeTriggers__ = s, s.className = \"DVSL-resize-triggers\", s.innerHTML = '<div class=\"DVSL-expand-trigger\"><div></div></div><div class=\"DVSL-contract-trigger\"></div>', r.insertBefore(s, r.firstChild), e.updateResize(s), r.__resizeListener__ = a, r.addEventListener(\"scroll\", a, !0);\n              }\n            }, e.updateResize = function (t) {\n              var e = t.__resizeTriggers__;\n              e && this.updateResizeTriggers(e);\n            }, e.updateResizeTriggers = function (t) {\n              var e = t.firstElementChild || t.firstChild,\n                  i = t.lastElementChild || t.lastChild,\n                  n = e.firstElementChild || e.firstChild;\n              i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight, n.style.width = e.offsetWidth + 1 + \"px\", n.style.height = e.offsetHeight + 1 + \"px\", e.scrollLeft = e.scrollWidth, e.scrollTop = e.scrollHeight;\n            }, e.unlistenResize = function (t) {\n              var e = t,\n                  i = e.__resizeTriggers__;\n              i ? (e.removeEventListener(\"scroll\", e.__resizeListener__, !0), i.parentNode && i.parentNode.removeChild(i), delete e.__resizeListener__, delete e.__resizeTriggers__) : delete t.onresize;\n            }, e.decodeEntities = function (t) {\n              return -1 === t.indexOf(\"&\") ? t : (e.decodeTextarea || (e.decodeTextarea = document.createElement(\"textarea\")), e.decodeTextarea.innerHTML = t, e.decodeTextarea.value);\n            }, e.base64Encode = function (t) {\n              if (window.btoa) return window.btoa(t);\n\n              for (var e = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", i = \"\", n = 0, r = 0; t.charAt(0 | r) || (e = \"=\", r % 1); i += e.charAt(63 & n >> 8 - r % 1 * 8)) {\n                var s = t.charCodeAt(r += .75);\n                if (s > 255) throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n                n = n << 8 | s;\n              }\n\n              return i;\n            }, e.compareVersions = function (t, e) {\n              for (var i = t.split(\".\"), n = i.length, r = e.length, s = 0; s < Math.max(n, r); s++) {\n                var a = s < n ? parseInt(i[s], 10) : 0,\n                    o = s < r ? e[s] : 0;\n                if (a > o) return !0;\n                if (a < o) return !1;\n              }\n\n              return !0;\n            }, e.aggregate = function (t, e, i) {\n              for (var n = 0, r = this.aggregationCallbacks[t], s = r.start; e();) {\n                var a = i();\n                r.increment(s, a), n += 1;\n              }\n\n              return n > 0 ? r.result(s, n) : null;\n            }, e.getRelativeClientRect = function (t) {\n              if (!t) return null;\n              if (!t.offsetParent) return null;\n              var e = t.getBoundingClientRect(),\n                  i = t.offsetParent.getBoundingClientRect();\n              return {\n                bottom: i.bottom - e.bottom,\n                height: e.height,\n                left: e.left - i.left,\n                right: i.right - e.right,\n                top: e.top - i.top,\n                width: e.width\n              };\n            }, e;\n          }();\n\n          if (p._previousConsoleMessages = {}, p.SeparatorChar = String.fromCharCode(63743), p.nextIdentifier = 0, p.decodeTextarea = null, p.aggregationCallbacks = {\n            sum: {\n              start: 0,\n              increment: function increment(t, e) {\n                return t + e;\n              },\n              result: function result(t, e) {\n                return t;\n              }\n            },\n            min: {\n              start: 1 / 0,\n              increment: function increment(t, e) {\n                return Math.min(t, e);\n              },\n              result: function result(t, e) {\n                return t;\n              }\n            },\n            max: {\n              start: -1 / 0,\n              increment: function increment(t, e) {\n                return Math.max(t, e);\n              },\n              result: function result(t, e) {\n                return t;\n              }\n            },\n            avg: {\n              start: 0,\n              increment: function increment(t, e) {\n                return t + e;\n              },\n              result: function result(t, e) {\n                return t / e;\n              }\n            },\n            count: {\n              start: 0,\n              increment: function increment(t, e) {\n                return 0;\n              },\n              result: function result(t, e) {\n                return e;\n              }\n            },\n            first: {\n              start: null,\n              increment: function increment(t, e) {\n                return null !== t && void 0 !== t ? t : e;\n              },\n              result: function result(t, e) {\n                return t;\n              }\n            },\n            last: {\n              start: null,\n              increment: function increment(t, e) {\n                return null !== e && void 0 !== e ? e : t;\n              },\n              result: function result(t, e) {\n                return t;\n              }\n            }\n          }, s.Helpers = p, \"undefined\" != typeof window) {\n            var f = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame,\n                g = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame;\n\n            if (!f) {\n              var m = 0;\n              f = function f(t) {\n                var e = new Date().getTime(),\n                    i = Math.max(0, 16 - (e - m)),\n                    n = window.setTimeout(function () {\n                  return t(e + i);\n                }, i);\n                return m = e + i, n;\n              }, g = window.clearTimeout;\n            }\n\n            g || (g = function g() {}), p.requestAnimationFrame = function (t) {\n              return f.call(window, t);\n            }, p.cancelAnimationFrame = function (t) {\n              return g.call(window, t);\n            };\n            var v = new Date().getTime();\n            \"performance\" in window == 0 ? p.performanceNow = function () {\n              return new Date().getTime() - v;\n            } : \"now\" in window.performance == 0 ? (performance.timing && performance.timing.navigationStart && (v = performance.timing.navigationStart), p.performanceNow = function () {\n              return new Date().getTime() - v;\n            }) : p.performanceNow = function () {\n              return window.performance.now();\n            };\n            var y = v - p.performanceNow();\n\n            p.timeToPerfNow = function (t) {\n              return t - y;\n            };\n          }\n\n          var S = function () {\n            return function () {\n              this.id = \"default\", this.url = null, this.urlParameters = [], this.postprocessorFunction = null, this.preloaded = null, this.format = \"JSON\", this.requestTimeout = 4e4, this.numberOfParallelRequests = 3;\n            };\n          }();\n\n          s.SettingsData = S;\n\n          var b = function () {\n            function t(t, e) {\n              this.removed = !1, this.requestScheduled = !1, this.requestsRunning = !1, this.requestCount = 0, this.dataSettings = e, this.chart = t, this.settings = t.settings;\n            }\n\n            return t.doRequest = function (t, e, i, n, r) {\n              if (e.urlParameters.length) {\n                i = i.slice();\n\n                for (var s = 0; s < e.urlParameters.length; s++) {\n                  var a = e.urlParameters[s];\n                  i.push([a.name, a.value]);\n                }\n              }\n\n              var o;\n              o = e.postprocessorFunction ? function (t) {\n                return n(e.postprocessorFunction(t));\n              } : n, p.doRequest(t, e.requestTimeout, i, o, r);\n            }, t.prototype.buildRequest = function () {\n              return null;\n            }, t.prototype.verifyData = function (t, e) {\n              return !0;\n            }, t.prototype.addVerifiedData = function (t, e) {\n              return {};\n            }, t.prototype.requestFailedPermanently = function (t) {}, t.prototype.remove = function () {\n              this.removed = !0;\n            }, t.prototype.hasPendingRequests = function () {\n              return !this.removed && this.requestCount > 0;\n            }, t.prototype.addData = function (t) {\n              this._dataArrived(null, t);\n            }, t.prototype.applyPreloadedData = function () {\n              this.dataSettings.preloaded && this._dataArrived(null, this.dataSettings.preloaded);\n            }, t.prototype.scheduleRequests = function (t) {\n              var e = this;\n              void 0 === t && (t = !1), t ? this._runRequests() : this.requestScheduled || (this.requestScheduled = !0, setTimeout(function () {\n                return e._runRequests();\n              }, 0));\n            }, t.prototype._runRequests = function () {\n              var t = this;\n\n              if (!this.removed && !this.requestsRunning) {\n                var e;\n                this.requestScheduled = !1;\n\n                try {\n                  for (this.requestsRunning = !0; this.requestCount < this.dataSettings.numberOfParallelRequests && null !== (e = this.buildRequest());) {\n                    !function (e) {\n                      t.requestCount += 1, t.chart.log(\"Requesting data for\", e), t.dataFunc(e, function (i) {\n                        return t._dataArrived(e, i);\n                      }, function (i) {\n                        return t._dataError(e, i);\n                      });\n                    }(e);\n                  }\n                } finally {\n                  this.requestsRunning = !1;\n                }\n              }\n            }, t.prototype._dataError = function (t, e) {\n              if (!this.removed) {\n                var i = p.parseData(e, this.dataSettings.format, !0),\n                    n = i.error ? i.error : \"Unknown error\";\n                t ? (this.requestCount -= 1, this.chart.error(\"Data request failed: \" + n, t)) : this.chart.error(\"Data loading failed: \" + n), this.requestFailedPermanently(t), this._runRequests();\n              }\n            }, t.prototype._dataArrived = function (t, e) {\n              if (!this.removed) {\n                var i = p.parseData(e, this.dataSettings.format);\n\n                if (t ? (this.requestCount -= 1, i.error ? this.chart.error(\"Data request succeeded, but contained an error: \" + i.error, t) : this.chart.log(\"Data arrived for request\", t)) : i.error ? this.chart.error(\"Loaded data contains error: \" + i.error) : this.chart.log(\"Data loaded\"), !i.error && this.verifyData(t, i)) {\n                  var n = this.addVerifiedData(t, i);\n                  n.dataArrived || (n.dataArrived = {}), n.dataArrived[this.dataSettings.id] = !0;\n                  var r = this.chart.createEventArguments(null, \"api\");\n                  r.dataArrived = i, r.dataRemoved = null, this.chart.notifyDataUpdated(r), this.chart.events.notifySceneChanges(n);\n                } else t && this.requestFailedPermanently(t);\n\n                this._runRequests();\n              }\n            }, t;\n          }();\n\n          s.Data = b;\n\n          var C = function () {\n            function t() {}\n\n            return t.detect = function () {\n              return this._cached || this.run();\n            }, t.run = function () {\n              var t,\n                  e,\n                  i = window,\n                  n = document.body;\n              document.domain && (t = document.createElement(\"iframe\"), n.appendChild(t), i = t.contentWindow);\n\n              try {\n                e = this.check(i);\n              } catch (t) {\n                e = this.check(window);\n              }\n\n              return this._cached = e, t && n.removeChild(t), e;\n            }, t.check = function (t) {\n              return {\n                isSafariDesktop: !!t.safari && !!t.safari.pushNotification,\n                isChrome: !!t.chrome && !!t.chrome.loadTimes\n              };\n            }, t;\n          }();\n\n          C._cached = null, s.Browser = C;\n\n          var x = function () {\n            function t(t, e, i, n) {\n              this.consumed = !1, this.defaultPrevented = !1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.wheely = 0, this.wheelx = 0, this.identifier = \"0\", this.pressed = !1, this.touch = !1, this.pageX = 0, this.pageY = 0, this.shiftKey = !1, this.altKey = !1, this.ctrlKey = !1, this.target = null, this.isRightMB = !1, this._vx = null, this._vy = null, this.velocityPointer = null, this._leaving = !1, this.swipeUp = !1, this.swipeDown = !1, this.swipeLeft = !1, this.swipeRight = !1, this.swipeSpeed = null, this.capture = !1, this.hovered = !1, this.cursor = null, this.changedPointerCount = 1, this.identifier = n, this.timeStamp = i, this.y = e, this.x = t;\n            }\n\n            return t.prototype.preventDefault = function () {\n              this.defaultPrevented = !0;\n            }, Object.defineProperty(t.prototype, \"vx\", {\n              get: function get() {\n                return null === this._vx && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vx || 0;\n              },\n              set: function set(t) {\n                this._vx = t;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), Object.defineProperty(t.prototype, \"vy\", {\n              get: function get() {\n                return null === this._vy && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vy || 0;\n              },\n              set: function set(t) {\n                this._vy = t;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), t.prototype.distance = function (t) {\n              return Math.sqrt((t.x - this.x) * (t.x - this.x) + (t.y - this.y) * (t.y - this.y));\n            }, t.prototype.isWithinDistance = function (t, e, i) {\n              if (!t) return !1;\n              var n = this.pageX - t.pageX,\n                  r = this.pageY - t.pageY;\n              return n * n + r * r < e * e && (null == i || t.timeStamp + i > this.timeStamp);\n            }, t;\n          }();\n\n          s.MouseEvent = x;\n\n          var w = function () {\n            function t(t, e) {\n              this.noClick = !1, this.scrolling = !1, this.ptsIndex = 0, this.ptsLength = 3, this.ptsMax = 72, this.settings = e, this.identifier = t.identifier, this.touch = !1, this.x = t.x, this.y = t.y, this.pageX = t.pageX, this.pageY = t.pageY, this.timeStamp = t.timeStamp, \"undefined\" != typeof Int32Array ? this.pts = new Int32Array(this.ptsMax) : this.pts = new Array(this.ptsMax), this.pts[0] = 0 | this.x, this.pts[1] = 0 | this.y, this.pts[2] = 0;\n            }\n\n            return t.prototype.moveTo = function (t) {\n              var e = this.ptsIndex + this.ptsLength,\n                  i = t.timeStamp - this.timeStamp | 0,\n                  n = this.ptsMax;\n              i === this.pts[e - 1] && (this.ptsLength -= 3, e -= 3), t.x || t.y ? (t.dx = t.x - this.x, t.dy = t.y - this.y, this.x = t.x, this.y = t.y) : (t.dx = 0, t.dy = 0, t.x = this.x, t.y = this.y), e === this.ptsMax && (e = 0), this.pts[e++] = 0 | this.x, this.pts[e++] = 0 | this.y, this.pts[e++] = 0 | i, (this.ptsLength += 3) > n && (this.ptsLength -= 3, n === (this.ptsIndex += 3) && (this.ptsIndex = 0));\n            }, t.prototype.getPosAndSpeed = function (t) {\n              t.touch = this.touch, t.velocityPointer = this, t.vx = null, t.vy = null;\n            }, t.prototype.calculatePosAndSpeed = function (t) {\n              var e,\n                  i,\n                  n = this.pts,\n                  r = this.ptsMax,\n                  s = 10 * r,\n                  a = (t.timeStamp - this.timeStamp | 0) - s;\n\n              for (e = this.ptsIndex; e < this.ptsIndex + this.ptsLength && !(n[(i = e % r) + 2] > a); e += 3) {\n                ;\n              }\n\n              return s = (t.timeStamp - this.timeStamp | 0) - n[i + 2], e === this.ptsIndex + this.ptsLength || s < 50 ? (t.vx = 0, void (t.vy = 0)) : (t.vx = (this.x - n[i + 0]) / s, void (t.vy = (this.y - n[i + 1]) / s));\n            }, t;\n          }(),\n              L = function () {\n            function t(e, i, n) {\n              void 0 === n && (n = null);\n              var r = this;\n              this.scaleX = 1, this.scaleY = 1, this.nextFakeMouseId = 1, this.doubleClickTimeout = null, this.longPressTimeout = null, this.longPressInitiator = null, this.listeners = {}, this.downPointers = {}, this.inPointers = {}, this.containerList = [], this.clickCounter = 1, this.lastClickEvent = null, this.topWindowEvents = {}, this.ID_MOUSE = \"mouse\", this.settings = i, this.container = e, this.lastEvent = null, this.lastTouchEvent = null, this.clickEvent = null, this.containerEvents = {\n                contextmenu: function contextmenu(t) {\n                  return r.filterEvent(t) && r.handleCMenu(t);\n                },\n                wheel: function wheel(t) {\n                  return r.filterEvent(t) && r.handleMouseWheel(t);\n                },\n                dragover: function dragover(t) {\n                  return r.filterEvent(t) && r.handleMouseMove(t);\n                }\n              };\n              var s,\n                  a,\n                  o = \"undefined\" != typeof PointerEvent,\n                  l = \"undefined\" != typeof TouchEvent,\n                  h = !o && \"undefined\" != typeof MSPointerEvent;\n\n              for (var u in h ? (this.container.style.msTouchAction = \"none\", this.windowEvents = ((s = {}).MSPointerDown = function (t) {\n                return r.filterEvent(t) && r.handlePointerDown(t);\n              }, s.MSPointerMove = function (t) {\n                return r.filterEvent(t) && r.handlePointerMove(t);\n              }, s.MSPointerUp = function (t) {\n                return r.filterEvent(t) && r.handlePointerUp(t);\n              }, s.MSPointerCancel = function (t) {\n                return r.filterEvent(t) && r.handlePointerCancel(t);\n              }, s.MSPointerOut = function (t) {\n                return r.filterEvent(t) && r.handlePointerLeave(t);\n              }, s)) : o && !l ? (this.container.style.touchAction = \"none\", this.windowEvents = ((a = {}).pointerdown = function (t) {\n                return r.filterEvent(t) && r.handlePointerDown(t);\n              }, a.pointermove = function (t) {\n                return r.filterEvent(t) && r.handlePointerMove(t);\n              }, a.pointerup = function (t) {\n                return r.filterEvent(t) && r.handlePointerUp(t);\n              }, a.pointercancel = function (t) {\n                return r.filterEvent(t) && r.handlePointerCancel(t);\n              }, a.pointerout = function (t) {\n                return r.filterEvent(t) && r.handlePointerLeave(t);\n              }, a)) : (this.windowEvents = {\n                mousedown: function mousedown(t) {\n                  return r.filterEvent(t) && r.handleMouseDown(t);\n                },\n                mouseup: function mouseup(t) {\n                  return r.filterEvent(t) && r.handleMouseUp(t);\n                },\n                mousemove: function mousemove(t) {\n                  return r.filterEvent(t) && r.handleMouseMove(t);\n                },\n                mouseout: function mouseout(t) {\n                  return r.filterEvent(t) && r.handleMouseLeave(t);\n                },\n                touchstart: function touchstart(t) {\n                  return r.filterEvent(t) && r.handleTouchStart(t);\n                },\n                touchend: function touchend(t) {\n                  return r.filterEvent(t) && r.handleTouchEnd(t);\n                },\n                touchcancel: function touchcancel(t) {\n                  return r.filterEvent(t) && r.handleTouchCancel(t);\n                },\n                touchmove: function touchmove(t) {\n                  return r.filterEvent(t) && r.handleTouchMove(t);\n                }\n              }, this.topWindowEvents = {\n                mouseup: function mouseup(t) {\n                  return r.filterEvent(t) && r.handleMouseUp(t);\n                },\n                touchend: function touchend(t) {\n                  return r.filterEvent(t) && r.handleTouchEnd(t);\n                }\n              }), !t._ignoreWindowTop && window.top && this.addTopWindowHandlers(), C.detect().isSafariDesktop && this.addSelectPrevention(), this.windowEvents) {\n                p.listen(window, u, this.windowEvents[u]);\n              }\n\n              if (this.addContainer(e), n) for (var c = 0; c < n.length; c++) {\n                this.addContainer(n[c]);\n              }\n            }\n\n            return t.prototype.addSelectPrevention = function () {\n              var t = this;\n              document.addEventListener(\"selectstart\", function (e) {\n                Object.keys(t.downPointers).length && e.preventDefault();\n              });\n            }, t.prototype.addTopWindowHandlers = function () {\n              try {\n                for (var e in this.topWindowEvents) {\n                  p.listen(window.top, e, this.topWindowEvents[e]);\n                }\n              } catch (e) {\n                t._ignoreWindowTop = !0;\n              }\n            }, t.prototype.addContainer = function (t) {\n              var e;\n\n              for (e in this.containerList.push(t), this.containerEvents) {\n                p.listen(t, e, this.containerEvents[e]);\n              }\n\n              for (e in this.windowEvents) {\n                p.listen(t, e, this.windowEvents[e]);\n              }\n            }, t.prototype.remove = function () {\n              for (var e in this.windowEvents) {\n                p.unlisten(window, e, this.windowEvents[e]);\n              }\n\n              if (!t._ignoreWindowTop && window.top) for (var e in this.topWindowEvents) {\n                p.unlisten(window.top, e, this.topWindowEvents[e]);\n              }\n\n              for (var i = 0; i < this.containerList.length; i++) {\n                var n = this.containerList[i];\n\n                for (var e in this.containerEvents) {\n                  p.unlisten(n, e, this.containerEvents[e]);\n                }\n              }\n            }, t.prototype.listen = function (t, e) {\n              this.listeners[t] = e;\n            }, t.prototype.processConsumed = function (t, e, i) {\n              e && (p.stopPropagation(t), i && t.preventDefault());\n            }, t.prototype.capturePointer = function (t) {\n              var e = t.target;\n              e.setPointerCapture ? e.setPointerCapture(t.pointerId) : e.msSetPointerCapture ? e.msSetPointerCapture(t.pointerId) : this.captureMouse(t);\n            }, t.prototype.releasePointer = function (t) {\n              this.releaseMouse(t);\n            }, t.prototype.releaseMouse = function (t) {\n              document.releaseCapture && document.releaseCapture();\n            }, t.prototype.captureMouse = function (t) {\n              var e = t.target;\n              e.setCapture && e.setCapture(!0);\n            }, t.prototype.filterEvent = function (t) {\n              return t !== this.lastEvent && (this.lastEvent = t, !0);\n            }, t.prototype.handlePointerDown = function (t) {\n              var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);\n              t.currentTarget !== window && this.capturePointer(t), this.downHappened(e), this.processConsumed(t, e.consumed);\n            }, t.prototype.handlePointerMove = function (t) {\n              var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);\n              this.moveHappened(e), this.processConsumed(t, e.consumed, !0);\n            }, t.prototype.handlePointerUp = function (t) {\n              if (0 === t.buttons) {\n                var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);\n                this.releasePointer(t), this.upHappened(e), this.processConsumed(t, e.consumed);\n              }\n            }, t.prototype.handlePointerCancel = function (t) {\n              var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);\n              this.cancelHappened(e);\n            }, t.prototype.handleMouseDown = function (t) {\n              if (!(t.timeStamp < this.lastTouchEvent)) {\n                var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);\n                t.currentTarget !== window && this.captureMouse(t), this.downHappened(e), this.processConsumed(t, e.consumed);\n              }\n            }, t.prototype.handleCMenu = function (t) {\n              this.processConsumed(t, !0, !0);\n            }, t.prototype.handleMouseWheel = function (t) {\n              if (this.isTargetOkay(t.target) && (!this.settings.mouseWheelRequiresFocus || document.activeElement === this.container)) {\n                if (5 === t.mozInputSource || 0 === t.deltaX && 0 === t.deltaY) return void p.stopPropagation(t);\n\n                if (t.deltaMode !== t.DOM_DELTA_PAGE) {\n                  var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0),\n                      i = t.deltaMode === t.DOM_DELTA_LINE ? -40 : -1;\n                  e.wheely = t.deltaY * i, e.wheelx = t.deltaX * i, this.wheelHappened(e), this.processConsumed(t, e.consumed, !0);\n                }\n              }\n            }, t.prototype.handleMouseUp = function (t) {\n              if (t.shiftKey && t.ctrlKey) return this.ID_MOUSE = \"mouse\" + this.nextFakeMouseId, void (this.nextFakeMouseId += 1);\n              var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);\n              this.releaseMouse(t), this.upHappened(e), this.processConsumed(t, e.consumed);\n            }, t.prototype.handlePointerLeave = function (t) {\n              var e = t.pointerId.toString();\n              this.inPointers[e] && !this.downPointers[e] && this.pointerLeave(this.buildEvent(t, e, t.timeStamp, !1));\n            }, t.prototype.handleMouseLeave = function (t) {\n              t.timeStamp < this.lastTouchEvent || this.inPointers[this.ID_MOUSE] && !this.downPointers[this.ID_MOUSE] && this.pointerLeave(this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1));\n            }, t.prototype.handleMouseMove = function (t) {\n              if (!(t.timeStamp < this.lastTouchEvent)) {\n                var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);\n                this.moveHappened(e), this.processConsumed(t, e.consumed, !0);\n              }\n            }, t.prototype.handleTouchStart = function (t) {\n              this.lastTouchEvent = t.timeStamp + 2e3, this.removeLostTouches(t, t.touches, t.changedTouches);\n\n              for (var e, i = !1, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {\n                var s = n[r];\n                e = this.buildTouchEvent(t, s, !0, n.length), this.downHappened(e), i = i || e.consumed;\n              }\n\n              this.processConsumed(t, i);\n            }, t.prototype.handleTouchEnd = function (t) {\n              this.lastTouchEvent = t.timeStamp + 2e3;\n\n              for (var e = t.changedTouches || t.touches, i = !1, n = 0; n < e.length; n++) {\n                var r = e[n],\n                    s = this.buildTouchEvent(t, r, !1, e.length),\n                    a = this.buildTouchEvent(t, r, !1, e.length);\n                a.x = a.y = a.pageX = a.pageY = -1e9, this.upHappened(s), this.pointerLeave(a), i = i || s.consumed || a.consumed, this.removeLostTouches(t, t.touches);\n              }\n\n              this.processConsumed(t, i);\n            }, t.prototype.handleTouchCancel = function (t) {\n              this.lastTouchEvent = t.timeStamp + 2e3;\n\n              for (var e = t.changedTouches || t.touches, i = 0; i < e.length; i++) {\n                var n = e[i],\n                    r = this.buildTouchEvent(t, n, !1, e.length);\n                this.cancelHappened(r);\n              }\n\n              this.removeLostTouches(t, t.touches);\n            }, t.prototype.handleTouchMove = function (t) {\n              this.lastTouchEvent = t.timeStamp + 2e3;\n              var e = !1;\n              this.removeLostTouches(t, t.touches);\n\n              for (var i, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {\n                var s = n[r];\n                i = this.buildTouchEvent(t, s, !0, n.length), this.moveHappened(i), e = e || i.consumed;\n              }\n\n              this.processConsumed(t, e, !0);\n            }, t.prototype.removeLostTouches = function (t, e, i) {\n              void 0 === i && (i = null);\n\n              for (var n = Object.create(null), r = 0; r < e.length; r++) {\n                n[(l = e[r]).identifier] = !0;\n              }\n\n              for (var s in this.downPointers) {\n                var a = this.downPointers[s];\n\n                if (this.downPointers.hasOwnProperty(s) && !n[s]) {\n                  var o = this.rebuildEvent(t, a, !1);\n                  this.upHappened(o);\n                }\n              }\n\n              if (null !== i) for (r = 0; r < i.length; r++) {\n                var l = i[r];\n\n                if (a = this.downPointers[l.identifier]) {\n                  o = this.rebuildEvent(t, a, !1);\n                  this.upHappened(o);\n                }\n              }\n            }, t.prototype.rebuildEvent = function (t, e, i) {\n              var n = new x(e.x, e.y, t.timeStamp, e.identifier);\n              return n.pageX = e.pageX, n.pageY = e.pageY, n.pressed = i, n.shiftKey = t.shiftKey, n.altKey = t.altKey, n.ctrlKey = t.ctrlKey, n;\n            }, t.prototype.buildTouchEvent = function (t, e, i, n) {\n              var r = p.convertPointFromPageToNode(this.container, e.pageX, e.pageY, e.clientX, e.clientY),\n                  s = r.x,\n                  a = r.y,\n                  o = new x(Math.round(s * this.scaleX), Math.round(a * this.scaleY), t.timeStamp, \"\" + e.identifier);\n              return o.target = e.target || t.target || t.srcElement, o.pageX = e.pageX, o.pageY = e.pageY, o.shiftKey = t.shiftKey, o.altKey = t.altKey, o.ctrlKey = t.ctrlKey, o.pressed = i, o.changedPointerCount = n, o.touch = !0, o;\n            }, t.prototype.buildEvent = function (t, e, i, n, r) {\n              void 0 === r && (r = 1);\n              var s,\n                  a,\n                  o = t.pageX,\n                  l = t.pageY,\n                  h = (!t.currentTarget || t.currentTarget === this.container) && t.target === this.container;\n              if (h && void 0 !== t.offsetX) s = t.offsetX, a = t.offsetY;else if (h && void 0 !== t.layerX) s = t.layerX, a = t.layerY;else {\n                var u = p.convertPointFromPageToNode(this.container, o, l, t.clientX, t.clientY);\n                s = u.x, a = u.y;\n              }\n              var c = new x(Math.round(s * this.scaleX), Math.round(a * this.scaleY), i, \"\" + e);\n              return c.target = t.target || t.srcElement, c.pageX = o, c.pageY = l, c.shiftKey = t.shiftKey, c.altKey = t.altKey, c.ctrlKey = t.ctrlKey, c.pressed = n, c.changedPointerCount = r, c.touch = \"touch\" === t.pointerType || 2 === t.pointerType, t.which ? c.isRightMB = 3 === t.which : c.isRightMB = 2 === t.button, c;\n            }, t.prototype.downHappened = function (e) {\n              if (e.pressed = !0, this.fireEvent(t.EVENT_GLOBAL_DOWN, e), this.isTargetOkay(e.target) && !this.downPointers[e.identifier]) {\n                this.click_Hold();\n                var i = new w(e, this.settings);\n                this.downPointers[e.identifier] = i, i.touch = e.touch, this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_DOWN, e), this.startLongPress(e);\n              }\n            }, t.prototype.upHappened = function (e) {\n              var i = this.downPointers[e.identifier];\n\n              if (i) {\n                this.cancelLongPress(), i.moveTo(e), i.getPosAndSpeed(e), delete this.downPointers[e.identifier];\n                var n = e.vx,\n                    r = e.vy,\n                    s = Math.abs(n),\n                    a = Math.abs(r);\n                s > 2 * a ? (e.swipeSpeed = s, n > 0 ? e.swipeLeft = !0 : e.swipeRight = !0) : a > 2 * s && (e.swipeSpeed = a, r < 0 ? e.swipeUp = !0 : e.swipeDown = !0), this.fireEvent(t.EVENT_UP, e), !i.noClick && e.isWithinDistance(i, this.settings.clickSensitivity, this.settings.doubleClickTimeout) && this.click_Next(e);\n              }\n            }, t.prototype.cancelHappened = function (e) {\n              this.downPointers[e.identifier] && (this.cancelLongPress(), delete this.downPointers[e.identifier], this.fireEvent(t.EVENT_CANCEL, e));\n            }, t.prototype.moveHappened = function (e) {\n              var i = this.downPointers[e.identifier];\n              e.pressed = void 0 !== i && null !== i, void 0 !== i && null !== i ? (this.cancelLongPress(e), i.scrolling = !0, i.moveTo(e), i.getPosAndSpeed(e), this.fireEvent(t.EVENT_DRAG, e), this.click_Cancel(e)) : this.click_OnMove(e) || (this.isTargetOkay(e.target) ? (this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_MOVE, e)) : this.pointerLeave(e));\n            }, t.prototype.wheelHappened = function (e) {\n              this.fireEvent(t.EVENT_WHEEL, e);\n            }, t.prototype.pointerLeave = function (e) {\n              this.inPointers.hasOwnProperty(e.identifier) && (this.click_Cancel(e) || this.fireEvent(t.EVENT_LEAVE, e), delete this.inPointers[e.identifier]);\n            }, t.prototype.click_Next = function (e) {\n              var i = this;\n              if (e.isRightMB) this.fireEvent(t.EVENT_RCLICK, e);else {\n                var n;\n\n                switch (this.settings.scrollIntoView && this.container.scrollIntoView(), this.clickCounter) {\n                  case 1:\n                    n = t.EVENT_CLICK;\n                    break;\n\n                  case 2:\n                    n = t.EVENT_DBLCLICK;\n                    break;\n\n                  default:\n                  case 3:\n                    n = t.EVENT_TPLCLICK;\n                }\n\n                var r = null !== this.clickEvent && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= e.timeStamp && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity;\n                r && clearTimeout(this.doubleClickTimeout), (r || 1 === this.clickCounter) && (this.settings.noClickOnDoubleClick && (this.doubleClickTimeout = setTimeout(function () {\n                  return i.fireClick(n);\n                }, this.settings.doubleClickTimeout)), this.settings.noClickOnDoubleClick || this.fireEvent(n, e), this.lastClickEvent = n), this.fireEvent(t.EVENT_INSTACLICK, e), this.clickEvent = e, this.clickCounter++, this.settings.noClickOnDoubleClick || setTimeout(function () {\n                  i.clickEvent = i.lastClickEvent = null, i.clickCounter = 1;\n                }, this.settings.doubleClickTimeout);\n              }\n            }, t.prototype.click_Cancel = function (t) {\n              return !(!this.clickEvent || this.clickEvent.identifier !== t.identifier || (this.clickEvent._leaving = !0, 0));\n            }, t.prototype.click_Hold = function () {\n              void 0 !== this.doubleClickTimeout && null !== this.doubleClickTimeout && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null);\n            }, t.prototype.click_OnMove = function (t) {\n              return !(!this.clickEvent || !this.settings.noClickOnDoubleClick) && (this.clickEvent.distance(t) < this.settings.doubleClickSensitivity || (this.fireEvent(this.lastClickEvent, this.clickEvent), this.clickEvent = this.lastClickEvent = null, this.clickCounter = 1, !1));\n            }, t.prototype.fireClick = function (e) {\n              this.clickEvent && (this.fireEvent(e, this.clickEvent), this.clickEvent._leaving && this.fireEvent(t.EVENT_LEAVE, this.clickEvent), this.clickEvent = null, this.clickCounter = 1);\n            }, t.prototype.startLongPress = function (e) {\n              var i = this;\n\n              if (!e.isRightMB) {\n                this.cancelLongPress(), this.longPressTimeout = setTimeout(function () {\n                  i.longPressTimeout = null, e.consumed = !1, i.downPointers[e.identifier].noClick = !0, i.fireEvent(t.EVENT_LONGPRESS, e), e.consumed || (e.touch && i.cancelHappened(e), i.fireEvent(t.EVENT_RCLICK, e));\n                }, this.settings.longPressTimeout), this.longPressInitiator = e;\n              }\n            }, t.prototype.cancelLongPress = function (t) {\n              if (null !== this.longPressTimeout) {\n                if (t && t.isWithinDistance(this.longPressInitiator, this.settings.longPressSensitivity)) return;\n                clearTimeout(this.longPressTimeout), this.longPressTimeout = null;\n              }\n            }, t.prototype.fireEvent = function (t, e) {\n              this.listeners[t] && this.listeners[t].call(this, e);\n            }, t.prototype.isTargetOkay = function (t) {\n              return -1 !== this.containerList.indexOf(t) || p.isParentOf(this.container, t);\n            }, t;\n          }();\n\n          L._ignoreWindowTop = !1, L.EVENT_MOVE = \"move\", L.EVENT_DOWN = \"down\", L.EVENT_GLOBAL_DOWN = \"gdown\", L.EVENT_DRAG = \"drag\", L.EVENT_CANCEL = \"cancel\", L.EVENT_UP = \"up\", L.EVENT_LEAVE = \"leave\", L.EVENT_CLICK = \"click\", L.EVENT_RCLICK = \"rclick\", L.EVENT_DBLCLICK = \"dblclick\", L.EVENT_INSTACLICK = \"instaclick\", L.EVENT_LONGPRESS = \"longpress\", L.EVENT_TPLCLICK = \"tplclick\", L.EVENT_WHEEL = \"mwheel\", L.EVENT_KEY = \"key\", s.MouseEvents = L;\n\n          var T = function () {\n            return function () {\n              this.timeStamp = 0, this.dtime = 0, this.animating = !1, this.isExport = !1, this.context = null, this.scaleX = 1, this.scaleY = 1, this.labelRenderer = null, this.changes = {};\n            };\n          }();\n\n          s.UpdateEvent = T;\n\n          var k = function () {\n            return function () {\n              this.keyCode = null, this.capture = !1, this.consumed = !1, this.noDefault = !1, this.cursor = null, this.target = null;\n            };\n          }();\n\n          s.KeyEvent = k;\n\n          var A = function () {\n            function t() {\n              this.animationOrder = 0, this.updateOrder = 0, this.paintOrder = 0;\n            }\n\n            return t.prototype.remove = function () {}, t.prototype.onSceneChange = function (t) {}, t.prototype.getPanels = function (t) {\n              return [];\n            }, t.prototype.doAnimations = function (t) {}, t.prototype.paintScene = function (t) {}, t.prototype.previewMouseEvent = function (t, e) {\n              this[\"preview\" + t](e);\n            }, t.prototype.onMouseEvent = function (t, e) {\n              this[\"on\" + t](e);\n            }, t.prototype.onClick = function (t) {}, t.prototype.onInstantClick = function (t) {}, t.prototype.onLongPress = function (t) {}, t.prototype.onRightClick = function (t) {}, t.prototype.onDoubleClick = function (t) {}, t.prototype.onTripleClick = function (t) {}, t.prototype.onPointerDown = function (t) {}, t.prototype.onPointerUp = function (t) {}, t.prototype.onPointerDrag = function (t) {}, t.prototype.onPointerMove = function (t) {}, t.prototype.onPointerOut = function (t) {}, t.prototype.onPointerCancel = function (t) {}, t.prototype.onWheel = function (t) {}, t.prototype.onKeyDown = function (t) {}, t.prototype.onGlobalPointerDown = function (t) {}, t.prototype.previewDoubleClick = function (t) {}, t.prototype.previewTripleClick = function (t) {}, t.prototype.previewRightClick = function (t) {}, t.prototype.previewClick = function (t) {}, t.prototype.previewInstantClick = function (t) {}, t.prototype.previewLongPress = function (t) {}, t.prototype.previewWheel = function (t) {}, t.prototype.previewGlobalPointerDown = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t.prototype.previewPointerUp = function (t) {}, t.prototype.previewPointerDrag = function (t) {}, t.prototype.previewPointerMove = function (t) {}, t.prototype.previewPointerOut = function (t) {}, t.prototype.previewPointerCancel = function (t) {}, t.prototype.containsCoordinate = function (t, e) {\n              var i = this.getPanels(!1);\n              if (!i || !i.length) return !1;\n\n              for (var n = 0; n < i.length; n++) {\n                var r = i[n];\n                if (r.left < t && r.right > t && r.top < e && r.bottom > e) return !0;\n              }\n\n              return !1;\n            }, t;\n          }();\n\n          s.ChartElement = A;\n\n          var M = function () {\n            return function (t, e, i, n) {\n              this.side = \"top\", this.align = \"fill\", this.floating = !1, this.margin = 0, this.location = \"outside\", this.packingOrder = void 0, void 0 !== t && (this.side = t), void 0 !== e && (this.align = e), void 0 !== i && (this.margin = i), void 0 !== n && (this.packingOrder = n);\n            };\n          }();\n\n          s.SettingsChartPanel = M;\n\n          var I = function () {\n            function t() {\n              this.packingOrder = 0, this.location = \"outside\", this.side = \"top\", this.align = \"fill\", this.outsideEdge = !1, this.floating = !1, this.desiredWidth = 0, this.desiredHeight = 0, this.margin = 0, this.left = 0, this.top = 0, this.right = 0, this.bottom = 0, this.visible = !1, this.enableClipping = !1, this._tempData = null;\n            }\n\n            return t.prototype.pushClip = function (t) {\n              this.enableClipping && s.Graphics.pushClip(t, this.left, this.top, this.right - this.left, this.bottom - this.top);\n            }, t.prototype.popClip = function (t) {\n              this.enableClipping && s.Graphics.popClip(t);\n            }, t.prototype.computeSize = function (t, e, i, n) {\n              return {\n                width: this.desiredWidth,\n                height: this.desiredHeight\n              };\n            }, t.prototype.placePanel = function (t, e, i, n) {\n              this.bottom = n, this.right = i, this.top = e, this.left = t;\n            }, t;\n          }();\n\n          s.ChartPanel = I;\n\n          var P = function () {\n            function t(t) {\n              this.framesCount = 0, this.shell = t, this.measureFpsIters = 0, this.measureFpsT0 = 0, this.measureFpsIter = 0, this.measureFpsCallback = null;\n            }\n\n            return t.prototype.hasPendingRequests = function () {\n              return this.shell.chart.hasPendingRequests();\n            }, t.prototype.measureFps = function (t, e) {\n              var i = this;\n\n              if (this.measureFpsCallback = e, this.measureFpsIters = t, this.shell.settings.advanced.useAnimationFrame) {\n                this.shell.chart.updateSettings({\n                  advanced: {\n                    useAnimationFrame: !1\n                  }\n                });\n                var n = this.measureFpsCallback;\n\n                this.measureFpsCallback = function (t, e, r) {\n                  i.shell.chart.updateSettings({\n                    advanced: {\n                      useAnimationFrame: !0\n                    }\n                  }), n && n.call(window, t, e, r);\n                };\n              }\n\n              return this.measureFpsIter = 0, this.measureFpsT0 = new Date().getTime(), this.shell.events.notifySceneChanges({\n                requestPaint: !0\n              }), !0;\n            }, t.prototype.paintDone = function () {\n              if (this.framesCount += 1, this.measureFpsIters) {\n                this.measureFpsIter += 1;\n                var t = new Date().getTime() - this.measureFpsT0;\n\n                if (this.measureFpsIter >= this.measureFpsIters && t > 4e3 || t > 1e4 && this.measureFpsIter >= 5) {\n                  var e = 1e3 * this.measureFpsIter / Math.max(1e-4, t);\n                  this.measureFpsCallback(e, this.measureFpsIter, t), this.measureFpsCallback = null, this.measureFpsIters = 0;\n                } else this.shell.events.notifySceneChanges({\n                  requestPaint: !0\n                });\n              }\n            }, t;\n          }();\n\n          s.Profiler = P;\n\n          var D = function () {\n            return function () {\n              this.subchart = null, this.element = null;\n            };\n          }(),\n              N = function () {\n            function t(t, e) {\n              this.sceneChanges = {}, this.forceFloating = !1, this._paintSuspended = 0, this.pointerState = {}, this.animationOrder = [], this.updateOrder = [], this.paintOrder = [], this.subcharts = [], this._lastPanelCount = [0, 0, 0], this.chartBounds = new vt(0, 0, 1, 1), this.chartOuterBounds = new vt(0, 0, 1, 1), this.chartBoundsIsOuter = !0, this.chart = t, this.shell = e, this.scene = t.scene;\n            }\n\n            return t.panelSortCallback = function (t, e) {\n              return t.packingOrder - e.packingOrder;\n            }, t.prototype.addElement = function (t) {\n              if (!t) throw new Error(\"`element` must be defined.\");\n              return this.paintOrder.push(t), this.updateOrder.push(t), this.animationOrder.push(t), this.refreshElementOrder(), t;\n            }, t.prototype.refreshElementOrder = function () {\n              this.animationOrder.sort(function (t, e) {\n                return t.animationOrder - e.animationOrder;\n              }), this.paintOrder.sort(function (t, e) {\n                return t.paintOrder - e.paintOrder;\n              }), this.updateOrder.sort(function (t, e) {\n                return t.updateOrder - e.updateOrder;\n              });\n            }, t.prototype.removeElement = function (t) {\n              p.removeFromArray(this.paintOrder, t), p.removeFromArray(this.animationOrder, t), p.removeFromArray(this.updateOrder, t);\n            }, t.prototype.addSubchart = function (t) {\n              this.subcharts.push(t);\n            }, t.prototype.removeSubchart = function (t) {\n              for (var e in p.removeFromArray(this.subcharts, t), this.pointerState) {\n                var i = this.pointerState[e];\n                i.subchart === t && (i.subchart = null);\n              }\n            }, t.prototype.suspendPaint = function () {\n              this._paintSuspended++;\n            }, t.prototype.resumePaint = function () {\n              this._paintSuspended--, this._paintSuspended <= 0 && (this._paintSuspended = 0, this.requestPaint());\n            }, t.prototype.notifySceneChanges = function (t, e) {\n              if (p.hasProperties(t)) {\n                var i = t.settingsChanges;\n                void 0 !== i && i instanceof s.Settings ? (this.sceneChanges.settingsChanges = p.extendCopy(this.sceneChanges.settingsChanges || {}, i, function (t, e) {\n                  return \"_\" === t[0] || e;\n                }), delete t.settingsChanges, p.extendDeep(this.sceneChanges, t), t.settingsChanges = i) : p.extendDeep(this.sceneChanges, t), this.requestPaint(e);\n              }\n            }, t.prototype.requestPaint = function (t) {\n              this._paintSuspended <= 0 && this.shell.requestPaint(t);\n            }, t.prototype.paintNow = function (t) {\n              void 0 === t && (t = !1), this.shell.paintNow(t = !1);\n            }, t.prototype.clearSceneChanges = function (t) {\n              for (var e in t) {\n                delete this.sceneChanges[e];\n              }\n            }, t.prototype.onMouseEvent = function (t, e) {\n              var i = e.name;\n              t.changes = {}, t.capture = !1;\n              var n,\n                  r,\n                  s = null,\n                  a = null,\n                  o = void 0,\n                  l = t.identifier,\n                  h = this.pointerState[l];\n              h || ((h = new D()).identifier = l, this.pointerState[l] = h);\n\n              for (var u = 0; u < this.updateOrder.length; u++) {\n                (r = this.updateOrder[u]).previewMouseEvent(i, t);\n              }\n\n              h.subchart && ((d = h.subchart.events).onMouseEvent(t, e), t.consumed || t.hovered || t.capture ? (a = h.subchart, t.capture = !0, o = t.cursor) : d.onMouseEvent(t, {\n                ev: L.EVENT_LEAVE,\n                name: \"PointerOut\"\n              }));\n              if (n = r = h.element, r && (r.onMouseEvent(i, t), (t.consumed || t.capture || e.captures && e.needsCapture) && !e.releasesCapture && (s = r, t.capture = !0, o = t.cursor)), !t.capture && !e.needsCapture) for (var c = this.subcharts.length - 1; c >= 0; c -= 1) {\n                var d,\n                    p = this.subcharts[c];\n\n                if ((d = p.events).chartOuterBounds.containsPoint(t.x, t.y)) {\n                  if (d.onMouseEvent(t, e), t.consumed || t.hovered || t.capture) {\n                    a = p, t.capture = !0;\n                    break;\n                  }\n\n                  d.onMouseEvent(t, {\n                    ev: L.EVENT_LEAVE,\n                    name: \"PointerOut\"\n                  });\n                }\n              }\n              if (!t.capture && !e.needsCapture) for (u = 0; u < this.updateOrder.length; u++) {\n                if ((r = this.updateOrder[u]) !== n && (r.onMouseEvent(i, t), t.consumed || t.capture)) {\n                  o = t.cursor, s = r, t.capture = !0;\n                  break;\n                }\n              }\n              void 0 !== o && (t.cursor = o), (e.releasesCapture || e.captures) && (h.element = e.captures ? s : null, h.subchart = e.captures ? a : null), this.notifySceneChanges(t.changes);\n            }, t.prototype.setNewSize = function (t, e, i) {\n              !i && this.chartBounds.equals(t) && e === this.chartBoundsIsOuter || (this.chartBounds = t.clone(), this.chartBoundsIsOuter = e, this.notifySceneChanges({\n                bounds: !0\n              }));\n            }, t.prototype.updateLayout = function (e) {\n              for (var i = this.scene, n = new Array(this._lastPanelCount[0]), r = new Array(this._lastPanelCount[1]), s = new Array(this._lastPanelCount[2]), a = 0, o = 0, l = 0, h = 0; h < this.paintOrder.length; h++) {\n                for (var u = this.paintOrder[h].getPanels(e.isExport), c = 0; c < u.length; c++) {\n                  var d = (y = u[c]).location;\n                  \"external\" === d ? s[l++] = y : \"outside\" === d ? r[o++] = y : \"inside\" === d && (n[a++] = y);\n                }\n              }\n\n              var f, g, m;\n\n              if (this._lastPanelCount = [a, o, l], n.length = a, r.length = o, s.length = l, p.sort(n, t.panelSortCallback), p.sort(r, t.panelSortCallback), p.sort(s, t.panelSortCallback), this.chartBoundsIsOuter) {\n                f = this.chartBounds.clone();\n\n                for (var v = 0; v < l; v++) {\n                  this._placePanel(s[v], f, !0, e);\n                }\n\n                g = this.chartBounds.clone(), m = this.chartBounds.clone();\n\n                for (v = 0; v < o; v++) {\n                  this._placePanel(r[v], m, !1, e);\n                }\n              } else {\n                m = this.chartBounds.clone(), g = this.chartBounds.clone();\n\n                for (v = 0; v < o; v++) {\n                  this._placePanel(r[v], g, !0, e);\n                }\n\n                f = g.clone();\n\n                for (v = 0; v < l; v++) {\n                  this._placePanel(s[v], f, !0, e);\n                }\n              }\n\n              this.chartOuterBounds = g, i.chartLeft = g.x0, i.chartTop = g.y0, i.chartHeight = g.h(), i.chartWidth = g.w();\n\n              for (v = 0; v < l; v++) {\n                this._placePanelFinal(s[v], m);\n              }\n\n              for (v = 0; v < o; v++) {\n                var y = r[v];\n\n                this._placePanelFinal(y, y.outsideEdge ? g : m);\n              }\n\n              i.x0 === m.x0 && i.y0 === m.y0 && i.width === m.w() && i.height === m.h() || this.chart.events.notifySceneChanges({\n                bounds: !0\n              }), i.x0 = m.x0, i.y0 = m.y0, i.width = m.w(), i.height = m.h(), i.leftMargin = m.x0 - g.x0, i.rightMargin = g.x1 - m.x1, i.topMargin = m.y0 - g.y0, i.bottomMargin = g.y1 - m.y1;\n\n              for (v = 0; v < a; v++) {\n                y = n[v];\n                this._placePanel(y, m, !1, e), this._placePanelFinal(y, m);\n              }\n\n              return f;\n            }, t.prototype._placePanel = function (t, e, i, n) {\n              var r = e.x0,\n                  s = e.y0,\n                  a = e.x1,\n                  o = e.y1,\n                  l = t.margin || 0,\n                  h = t.computeSize(e.x1 - e.x0, e.y1 - e.y0, n.context, n.labelRenderer),\n                  u = h.width || 0,\n                  c = h.height || 0;\n              u += 2 * l, c += 2 * l, i ? \"top\" === t.side ? (s = (o = s) - c, t.floating || this.forceFloating || (e.y0 = s)) : \"bottom\" === t.side ? (o = (s = o) + c, t.floating || this.forceFloating || (e.y1 = o)) : \"left\" === t.side ? (r = (a = r) - u, t.floating || this.forceFloating || (e.x0 = r)) : \"right\" === t.side && (a = (r = a) + u, t.floating || this.forceFloating || (e.x1 = a)) : \"top\" === t.side ? (o = Math.min(o, s + c), t.floating || this.forceFloating || (e.y0 = o)) : \"bottom\" === t.side ? (s = Math.max(s, o - c), t.floating || this.forceFloating || (e.y1 = s)) : \"left\" === t.side ? (a = Math.min(a, r + u), t.floating || this.forceFloating || (e.x0 = a)) : \"right\" === t.side && (r = Math.max(r, a - u), t.floating || this.forceFloating || (e.x1 = r)), t._tempData = {\n                left: r,\n                right: a,\n                top: s,\n                bottom: o,\n                desiredWidth: u,\n                desiredHeight: c\n              };\n            }, t.prototype._placePanelFinal = function (t, e) {\n              var i = t._tempData.left,\n                  n = t._tempData.right,\n                  r = t._tempData.top,\n                  s = t._tempData.bottom,\n                  a = t._tempData.desiredWidth,\n                  o = t._tempData.desiredHeight;\n              if (\"outside\" === t.location && (\"top\" === t.side || \"bottom\" === t.side ? (i = Math.max(i, e.x0), n = Math.min(n, e.x1)) : (r = Math.max(r, e.y0), s = Math.min(s, e.y1))), \"left\" === t.align) n = Math.min(n, i + a);else if (\"right\" === t.align) i = Math.max(i, n - a);else if (\"top\" === t.align) s = Math.min(s, r + o);else if (\"bottom\" === t.align) r = Math.max(r, s - o);else if (\"center\" === t.align) {\n                var l = Math.max(0, n - i - a) / 2,\n                    h = Math.max(0, s - r - o) / 2;\n                i += l, n -= l, r += h, s -= h;\n              }\n              var u = t.margin;\n              t.placePanel(i + u, r + u, n - u, s - u);\n            }, t.prototype.animateFrame = function (t) {\n              this.shell.prepareContext(t), t.changes = this.sceneChanges, this.sceneChanges = {};\n\n              for (var e = 0; e < this.updateOrder.length; e++) {\n                this.updateOrder[e].onSceneChange(t);\n              }\n\n              t.changes.bounds && this.updateLayout(t);\n\n              for (var i = 0; i < this.animationOrder.length; i++) {\n                this.animationOrder[i].doAnimations(t);\n              }\n\n              for (var n = 0; n < this.paintOrder.length; n++) {\n                this.paintOrder[n].paintScene(t);\n              }\n\n              t.changes.position && this.chart.notifyPositionChange(this.chart.createEventArguments(null, \"api\")), t.changes = null;\n              var r = [];\n\n              for (var s in this.pointerState) {\n                var a = this.pointerState[s];\n                a.subchart && r.push(a.subchart);\n              }\n\n              for (var o = 0; o < this.subcharts.length; o += 1) {\n                var l = this.subcharts[o];\n\n                if (!(r.indexOf(l) > -1)) {\n                  var h = l.events;\n                  (h.sceneChanges.bounds || h.chartOuterBounds.overlaps(this.chartOuterBounds)) && h.animateFrame(t);\n                }\n              }\n\n              for (o = 0; o < r.length; o += 1) {\n                (l = r[o]).events.animateFrame(t);\n              }\n\n              this.shell.finalizeContext(t);\n            }, t.prototype.doPaint = function (t) {\n              for (var e = 0; e < this.paintOrder.length; e++) {\n                this.paintOrder[e].paintScene(t);\n              }\n\n              for (var i = 0; i < this.subcharts.length; i += 1) {\n                var n = this.subcharts[i].events;\n                n.chartOuterBounds.overlaps(this.chartOuterBounds) && n.doPaint(t);\n              }\n            }, t;\n          }();\n\n          s.ChartEvents = N;\n\n          var F = function () {\n            return function () {\n              this.enabled = !1, this.enabledOnExport = !1, this.url = \"http://zoomcharts.com\", this.urlTarget = \"_blank\", this.image = \"builtin://logo-supported-by\", this.imageScaling = .5, this.location = \"outside\", this.imageExport = null;\n            };\n          }();\n\n          s.SettingsCredits = F;\n\n          var O = function (t) {\n            function e(e, i) {\n              var n = t.call(this) || this;\n              n.animationOrder = 2e3, n.paintOrder = 60, n.updateOrder = 400, n.settings = i, n.chart = e, n.scene = e.scene, (i.enabledOnExport || i.enabled) && (n.chart.assetsLoader.getAssetImage(n.settings.image, function (t) {\n                return n.imageLoaded(t);\n              }), n.settings.imageExport && n.settings.image !== n.settings.imageExport && n.chart.assetsLoader.getAssetImage(n.settings.imageExport, function (t) {\n                return n.imageLoaded(t);\n              }));\n              var r = n.panel = new I();\n              return r.packingOrder = 0, r.side = \"bottom\", r.align = \"right\", r.visible = !1, r.margin = 3, n;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              var e = t.changes;\n              e.settings && e.settingsChanges.credits && (e.bounds = !0);\n            }, e.prototype.getPanels = function (t) {\n              var e = this,\n                  i = this.settings,\n                  n = t ? i.enabledOnExport : i.enabled,\n                  r = this.panel;\n\n              if (n) {\n                r.location = \"outside\", r.outsideEdge = !0, \"outside\" === i.location ? (r.floating = !1, t && !i.enabled && (r.location = \"external\")) : r.floating = !0;\n                var s = this.chart.assetsLoader.getAssetImage(i.image, function (t) {\n                  return e.imageLoaded(t);\n                });\n                if (s) return r.desiredWidth = s.width * i.imageScaling, r.desiredHeight = s.height * i.imageScaling, r.visible = !0, [r];\n              }\n\n              return r.visible = !1, [];\n            }, e.prototype.paintScene = function (t) {\n              var e = this,\n                  i = this.panel;\n\n              if (i.visible) {\n                var n = this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {\n                  return e.imageLoaded(t);\n                }),\n                    r = this.settings.imageExport ? this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (t) {\n                  return e.imageLoaded(t);\n                }) : n;\n                t.isExport && (n = r), n ? t.context.drawImage(n, 0, 0, n.width, n.height, i.left, i.top, i.right - i.left, i.bottom - i.top) : t.animating = !0;\n              }\n            }, e.prototype.onPointerMove = function (t) {\n              var e = t.x,\n                  i = t.y,\n                  n = this.panel;\n              n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && this.settings.url && (t.cursor = \"pointer\");\n            }, e.prototype.onClick = function (t) {\n              var e = t.x,\n                  i = t.y,\n                  n = this.panel,\n                  r = this.settings;\n              n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && r.url && (this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented || p.openUrl(r.url, r.urlTarget), t.consumed = !0);\n            }, e.prototype.imageLoaded = function (t) {\n              this.chart.updateSize(!0), this.chart.events.notifySceneChanges({\n                settings: !0,\n                settingsChanges: {\n                  credits: !0\n                }\n              });\n            }, e.prototype.buildEventArgs = function (t) {\n              var e = this.chart.createEventArguments(t, \"user\");\n              return e.clickCredits = !0, e.credits = {\n                url: this.settings.url,\n                urlTarget: this.settings.urlTarget\n              }, e;\n            }, e;\n          }(A);\n\n          s.Credits = O;\n\n          var E = function () {\n            function t() {}\n\n            return t.isLight = function (t) {\n              return null == t ? null : .299 * t.R + .587 * t.G + .114 * t.B > 128;\n            }, t.format = function (t) {\n              return null == t ? null : \"rgba(\" + (0 | t.R) + \",\" + (0 | t.G) + \",\" + (0 | t.B) + \",\" + t.A.toFixed(3) + \")\";\n            }, t.areEqual = function (t, e) {\n              return null == t ? null == e : null != e && t.R === e.R && t.G === e.G && t.B === e.B && t.A === e.A;\n            }, t.parse = function (t) {\n              var e = R.parseCSSColor(t);\n              return null == e && t && p.warn(\"Color value '\" + t + \"' could not be parsed.\", null, !0), e;\n            }, t.normalize = function (t) {\n              return this.format(R.parseCSSColor(t));\n            }, t.derive = function (t, e, i) {\n              var n = \"string\" == typeof t,\n                  r = n ? this.parse(t) : t,\n                  s = 255 * (e - 1),\n                  a = {\n                R: Math.round(Math.min(255, Math.max(0, r.R + s))),\n                G: Math.round(Math.min(255, Math.max(0, r.G + s))),\n                B: Math.round(Math.min(255, Math.max(0, r.B + s))),\n                A: Math.min(1, r.A * i)\n              };\n              return n ? this.format(a) : a;\n            }, t.blend = function (t, e, i, n) {\n              void 0 === n && (n = !0);\n              var r,\n                  s = \"string\" == typeof t,\n                  a = s ? this.parse(t) : t,\n                  o = s ? this.parse(e) : e;\n\n              if (n) {\n                var l = 1 - i;\n                r = {\n                  R: Math.round(o.R * i + a.R * l),\n                  G: Math.round(o.G * i + a.G * l),\n                  B: Math.round(o.B * i + a.B * l),\n                  A: o.A * i + a.A * l\n                };\n              } else r = this._blendSlow(a, o, i);\n\n              return s ? this.format(r) : r;\n            }, t._blendSlow = function (t, e, i) {\n              var n = this._rgb2lab(t),\n                  r = this._rgb2lab(e),\n                  s = 1 - i,\n                  a = Math.round(r.L * i + n.L * s),\n                  o = Math.round(r.A * i + n.A * s),\n                  l = Math.round(r.B * i + n.B * s),\n                  h = this._lab2rgb(a, o, l);\n\n              return h.R = Math.max(0, Math.min(255, h.R)), h.G = Math.max(0, Math.min(255, h.G)), h.B = Math.max(0, Math.min(255, h.B)), h.A = e.A * i + t.A * s, h;\n            }, t.colorTone = function (t, e, i) {\n              var n = this.parse(t),\n                  r = this.derive(n, e, i);\n              return {\n                color: this.format(r),\n                opacity: n.A\n              };\n            }, t.copyHue = function (t, e) {\n              var i = \"string\" == typeof t,\n                  n = i ? this.parse(t) : t,\n                  r = i ? this.parse(e) : e,\n                  s = (n.R + n.G + n.B) / 765,\n                  a = (r.R + r.G + r.B) / 765,\n                  o = {\n                R: Math.round(n.R / s * a),\n                G: Math.round(n.G / s * a),\n                B: Math.round(n.B / s * a),\n                A: r.A\n              };\n              return i ? this.format(o) : o;\n            }, t.inverse = function (t) {\n              var e = \"string\" == typeof t,\n                  i = e ? this.parse(t) : t,\n                  n = {\n                R: 255 - i.R,\n                G: 255 - i.G,\n                B: 255 - i.B,\n                A: i.A\n              };\n              return e ? this.format(n) : n;\n            }, t._rgb2xyz = function (t) {\n              var e = t.R / 255,\n                  i = t.G / 255,\n                  n = t.B / 255;\n              return {\n                X: .4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92),\n                Y: .2126 * e + .7152 * i + .0722 * n,\n                Z: .0193 * e + .1192 * i + .9505 * n\n              };\n            }, t._rgb2lab = function (t) {\n              if (t._lab) return t._lab;\n\n              var e = this._rgb2xyz(t),\n                  i = e.X / .95047,\n                  n = e.Y,\n                  r = e.Z / 1.08883;\n\n              return i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, t._lab = {\n                L: 116 * n - 16,\n                A: 500 * (i - n),\n                B: 200 * (n - r)\n              };\n            }, t._xyz2rgb = function (t, e, i) {\n              var n = 3.2406 * t + -1.5372 * e + -.4986 * i,\n                  r = -.9689 * t + 1.8758 * e + .0415 * i,\n                  s = .0557 * t + -.204 * e + 1.057 * i;\n              return n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, s = s > .0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : 12.92 * s, {\n                R: Math.round(255 * n),\n                G: Math.round(255 * r),\n                B: Math.round(255 * s),\n                A: 1\n              };\n            }, t._lab2rgb = function (t, e, i) {\n              var n = (t + 16) / 116,\n                  r = e / 500 + n,\n                  s = n - i / 200;\n              n = n > this._lab2rgbConst ? Math.pow(n, 3) : (n - 16 / 116) / 7.787, r = r > this._lab2rgbConst ? Math.pow(r, 3) : (r - 16 / 116) / 7.787, s = s > this._lab2rgbConst ? Math.pow(s, 3) : (s - 16 / 116) / 7.787;\n\n              var a = this._xyz2rgb(.95047 * r, n, 1.08883 * s);\n\n              return a._lab = {\n                L: t,\n                A: e,\n                B: i\n              }, a;\n            }, t;\n          }();\n\n          E._lab2rgbConst = Math.pow(.008856, 1 / 3), s.Colors = E;\n\n          var R = function () {\n            function t() {}\n\n            return t.clamp_css_byte = function (t) {\n              return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n            }, t.clamp_css_float = function (t) {\n              return t < 0 ? 0 : t > 1 ? 1 : t;\n            }, t.parse_css_int = function (e) {\n              return \"%\" === e[e.length - 1] ? t.clamp_css_byte(parseFloat(e) / 100 * 255) : t.clamp_css_byte(parseInt(e, 10));\n            }, t.parse_css_float = function (e) {\n              return \"%\" === e[e.length - 1] ? t.clamp_css_float(parseFloat(e) / 100) : t.clamp_css_float(parseFloat(e));\n            }, t.css_hue_to_rgb = function (t, e, i) {\n              return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;\n            }, t.parseCSSColor = function (e) {\n              if (null == e) return {\n                R: 0,\n                G: 0,\n                B: 0,\n                A: 0\n              };\n              var i,\n                  n = e.replace(RegExp(\" \", \"g\"), \"\").toLowerCase();\n\n              if (n in t.kCSSColorTable) {\n                var r = t.kCSSColorTable[n];\n                return {\n                  R: r[0],\n                  G: r[1],\n                  B: r[2],\n                  A: r[3]\n                };\n              }\n\n              if (\"#\" === n[0]) return 4 === n.length ? (i = parseInt(n.substr(1), 16)) >= 0 && i <= 4095 ? {\n                R: (3840 & i) >> 4 | (3840 & i) >> 8,\n                G: 240 & i | (240 & i) >> 4,\n                B: 15 & i | (15 & i) << 4,\n                A: 1\n              } : null : 7 === n.length && (i = parseInt(n.substr(1), 16)) >= 0 && i <= 16777215 ? {\n                R: (16711680 & i) >> 16,\n                G: (65280 & i) >> 8,\n                B: 255 & i,\n                A: 1\n              } : null;\n              var s = n.indexOf(\"(\"),\n                  a = n.indexOf(\")\");\n\n              if (-1 !== s && a + 1 === n.length) {\n                var o = n.substr(0, s),\n                    l = n.substr(s + 1, a - (s + 1)).split(\",\"),\n                    h = 1;\n\n                if (\"rgba\" === o) {\n                  if (4 !== l.length) return null;\n                  h = t.parse_css_float(l.pop());\n                }\n\n                if (\"rgba\" === o || \"rgb\" === o) return 3 !== l.length ? null : {\n                  R: t.parse_css_int(l[0]),\n                  G: t.parse_css_int(l[1]),\n                  B: t.parse_css_int(l[2]),\n                  A: h\n                };\n\n                if (\"hsla\" === o) {\n                  if (4 !== l.length) return null;\n                  h = t.parse_css_float(l.pop());\n                }\n\n                if (\"hsla\" === o || \"hsl\" === o) {\n                  if (3 !== l.length) return null;\n                  var u = (parseFloat(l[0]) % 360 + 360) % 360 / 360,\n                      c = t.parse_css_float(l[1]),\n                      d = t.parse_css_float(l[2]),\n                      p = d <= .5 ? d * (c + 1) : d + c - d * c,\n                      f = 2 * d - p;\n                  return {\n                    R: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u + 1 / 3)),\n                    G: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u)),\n                    B: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u - 1 / 3)),\n                    A: h\n                  };\n                }\n              }\n\n              return null;\n            }, t;\n          }();\n\n          R.kCSSColorTable = {\n            transparent: [0, 0, 0, 0],\n            aliceblue: [240, 248, 255, 1],\n            antiquewhite: [250, 235, 215, 1],\n            aqua: [0, 255, 255, 1],\n            aquamarine: [127, 255, 212, 1],\n            azure: [240, 255, 255, 1],\n            beige: [245, 245, 220, 1],\n            bisque: [255, 228, 196, 1],\n            black: [0, 0, 0, 1],\n            blanchedalmond: [255, 235, 205, 1],\n            blue: [0, 0, 255, 1],\n            blueviolet: [138, 43, 226, 1],\n            brown: [165, 42, 42, 1],\n            burlywood: [222, 184, 135, 1],\n            cadetblue: [95, 158, 160, 1],\n            chartreuse: [127, 255, 0, 1],\n            chocolate: [210, 105, 30, 1],\n            coral: [255, 127, 80, 1],\n            cornflowerblue: [100, 149, 237, 1],\n            cornsilk: [255, 248, 220, 1],\n            crimson: [220, 20, 60, 1],\n            cyan: [0, 255, 255, 1],\n            darkblue: [0, 0, 139, 1],\n            darkcyan: [0, 139, 139, 1],\n            darkgoldenrod: [184, 134, 11, 1],\n            darkgray: [169, 169, 169, 1],\n            darkgreen: [0, 100, 0, 1],\n            darkgrey: [169, 169, 169, 1],\n            darkkhaki: [189, 183, 107, 1],\n            darkmagenta: [139, 0, 139, 1],\n            darkolivegreen: [85, 107, 47, 1],\n            darkorange: [255, 140, 0, 1],\n            darkorchid: [153, 50, 204, 1],\n            darkred: [139, 0, 0, 1],\n            darksalmon: [233, 150, 122, 1],\n            darkseagreen: [143, 188, 143, 1],\n            darkslateblue: [72, 61, 139, 1],\n            darkslategray: [47, 79, 79, 1],\n            darkslategrey: [47, 79, 79, 1],\n            darkturquoise: [0, 206, 209, 1],\n            darkviolet: [148, 0, 211, 1],\n            deeppink: [255, 20, 147, 1],\n            deepskyblue: [0, 191, 255, 1],\n            dimgray: [105, 105, 105, 1],\n            dimgrey: [105, 105, 105, 1],\n            dodgerblue: [30, 144, 255, 1],\n            firebrick: [178, 34, 34, 1],\n            floralwhite: [255, 250, 240, 1],\n            forestgreen: [34, 139, 34, 1],\n            fuchsia: [255, 0, 255, 1],\n            gainsboro: [220, 220, 220, 1],\n            ghostwhite: [248, 248, 255, 1],\n            gold: [255, 215, 0, 1],\n            goldenrod: [218, 165, 32, 1],\n            gray: [128, 128, 128, 1],\n            green: [0, 128, 0, 1],\n            greenyellow: [173, 255, 47, 1],\n            grey: [128, 128, 128, 1],\n            honeydew: [240, 255, 240, 1],\n            hotpink: [255, 105, 180, 1],\n            indianred: [205, 92, 92, 1],\n            indigo: [75, 0, 130, 1],\n            ivory: [255, 255, 240, 1],\n            khaki: [240, 230, 140, 1],\n            lavender: [230, 230, 250, 1],\n            lavenderblush: [255, 240, 245, 1],\n            lawngreen: [124, 252, 0, 1],\n            lemonchiffon: [255, 250, 205, 1],\n            lightblue: [173, 216, 230, 1],\n            lightcoral: [240, 128, 128, 1],\n            lightcyan: [224, 255, 255, 1],\n            lightgoldenrodyellow: [250, 250, 210, 1],\n            lightgray: [211, 211, 211, 1],\n            lightgreen: [144, 238, 144, 1],\n            lightgrey: [211, 211, 211, 1],\n            lightpink: [255, 182, 193, 1],\n            lightsalmon: [255, 160, 122, 1],\n            lightseagreen: [32, 178, 170, 1],\n            lightskyblue: [135, 206, 250, 1],\n            lightslategray: [119, 136, 153, 1],\n            lightslategrey: [119, 136, 153, 1],\n            lightsteelblue: [176, 196, 222, 1],\n            lightyellow: [255, 255, 224, 1],\n            lime: [0, 255, 0, 1],\n            limegreen: [50, 205, 50, 1],\n            linen: [250, 240, 230, 1],\n            magenta: [255, 0, 255, 1],\n            maroon: [128, 0, 0, 1],\n            mediumaquamarine: [102, 205, 170, 1],\n            mediumblue: [0, 0, 205, 1],\n            mediumorchid: [186, 85, 211, 1],\n            mediumpurple: [147, 112, 219, 1],\n            mediumseagreen: [60, 179, 113, 1],\n            mediumslateblue: [123, 104, 238, 1],\n            mediumspringgreen: [0, 250, 154, 1],\n            mediumturquoise: [72, 209, 204, 1],\n            mediumvioletred: [199, 21, 133, 1],\n            midnightblue: [25, 25, 112, 1],\n            mintcream: [245, 255, 250, 1],\n            mistyrose: [255, 228, 225, 1],\n            moccasin: [255, 228, 181, 1],\n            navajowhite: [255, 222, 173, 1],\n            navy: [0, 0, 128, 1],\n            oldlace: [253, 245, 230, 1],\n            olive: [128, 128, 0, 1],\n            olivedrab: [107, 142, 35, 1],\n            orange: [255, 165, 0, 1],\n            orangered: [255, 69, 0, 1],\n            orchid: [218, 112, 214, 1],\n            palegoldenrod: [238, 232, 170, 1],\n            palegreen: [152, 251, 152, 1],\n            paleturquoise: [175, 238, 238, 1],\n            palevioletred: [219, 112, 147, 1],\n            papayawhip: [255, 239, 213, 1],\n            peachpuff: [255, 218, 185, 1],\n            peru: [205, 133, 63, 1],\n            pink: [255, 192, 203, 1],\n            plum: [221, 160, 221, 1],\n            powderblue: [176, 224, 230, 1],\n            purple: [128, 0, 128, 1],\n            red: [255, 0, 0, 1],\n            rosybrown: [188, 143, 143, 1],\n            royalblue: [65, 105, 225, 1],\n            saddlebrown: [139, 69, 19, 1],\n            salmon: [250, 128, 114, 1],\n            sandybrown: [244, 164, 96, 1],\n            seagreen: [46, 139, 87, 1],\n            seashell: [255, 245, 238, 1],\n            sienna: [160, 82, 45, 1],\n            silver: [192, 192, 192, 1],\n            skyblue: [135, 206, 235, 1],\n            slateblue: [106, 90, 205, 1],\n            slategray: [112, 128, 144, 1],\n            slategrey: [112, 128, 144, 1],\n            snow: [255, 250, 250, 1],\n            springgreen: [0, 255, 127, 1],\n            steelblue: [70, 130, 180, 1],\n            tan: [210, 180, 140, 1],\n            teal: [0, 128, 128, 1],\n            thistle: [216, 191, 216, 1],\n            tomato: [255, 99, 71, 1],\n            turquoise: [64, 224, 208, 1],\n            violet: [238, 130, 238, 1],\n            wheat: [245, 222, 179, 1],\n            white: [255, 255, 255, 1],\n            whitesmoke: [245, 245, 245, 1],\n            yellow: [255, 255, 0, 1],\n            yellowgreen: [154, 205, 50, 1]\n          };\n\n          var H = function () {\n            function t(t, e, i) {\n              this.isFilling = i, this.lineDash = e, this.g = t, this.beginPath();\n            }\n\n            return t.prototype.beginPath = function () {\n              this.remaining = this.lineDash[0], this.dashes = [], this.pos = 0, this.x0 = 0, this.y0 = 0, this.x = 0, this.y = 0, this.hasPos = !1;\n            }, t.prototype.moveTo = function (t, e) {\n              this.y = e, this.x = t, this.isFilling && this.dashes.push(0, t, e), this.g.moveTo(t, e), this.x0 = t, this.y0 = e, this.hasPos = !0;\n            }, t.prototype.rect = function (t, e, i, n) {\n              this.moveTo(t, e), this.lineTo(t + i, n), this.lineTo(t + i, e + n), this.lineTo(t, e + n), this.lineTo(t, e);\n            }, t.prototype.lineTo = function (t, e) {\n              this.isFilling && this.g.lineTo(t, e);\n              var i = t - this.x,\n                  n = e - this.y,\n                  r = this.x,\n                  s = this.y;\n              this.x = t, this.y = e;\n              var a = Math.sqrt(i * i + n * n),\n                  o = 1 / a;\n              i *= o, n *= o;\n\n              for (var l = this.lineDash.length, h = this.pos, u = this.remaining;;) {\n                var c = Math.min(a, u);\n\n                if (r += i * c, s += n * c, h % 2 == 0 ? this.isFilling ? this.dashes.push(1, r, s) : this.g.lineTo(r, s) : this.isFilling ? this.dashes.push(0, r, s) : this.g.moveTo(r, s), !(a > c)) {\n                  u -= c;\n                  break;\n                }\n\n                h = (h + 1) % l, u = this.lineDash[h], a -= c;\n              }\n\n              this.pos = h, this.remaining = u, this.hasPos = !0;\n            }, t.prototype.arc = function (t, e, i, n, r, s) {\n              var a = 2 * Math.PI,\n                  o = Math.min(.6, 2 / i),\n                  l = Math.cos(o),\n                  h = Math.sin(o),\n                  u = Math.sin(n) * i,\n                  c = Math.cos(n) * i,\n                  d = Math.sin(r) * i,\n                  p = Math.cos(r) * i;\n\n              if (this.hasPos || (this.moveTo(t + c, e + u), this.hasPos = !0), s) {\n                n < r && (n += a);\n\n                for (var f = (n - r) / o; f >= 0; f--) {\n                  if (f - 1 <= 0) {\n                    this.lineTo(t + p, e + d);\n                    break;\n                  }\n\n                  this.lineTo(t + c, e + u);\n                  var g = -c * h + u * l;\n                  c = c * l + u * h, u = g;\n                }\n              } else {\n                n > r && (n -= 2 * Math.PI);\n\n                for (f = (r - n) / o; f >= 0; f--) {\n                  if (f - 1 <= 0) {\n                    this.lineTo(t + p, e + d);\n                    break;\n                  }\n\n                  this.lineTo(t + c, e + u);\n                  g = c * h + u * l;\n                  c = c * l - u * h, u = g;\n                }\n              }\n            }, t.prototype.quadraticCurveTo = function (e, i, n, r) {\n              this.g.quadraticCurveTo(e, i, n, r), t.bezierWarning || (t.bezierWarning = !0, p.warn(\"Dashed Bézier curves not supported in this browser!\"));\n            }, t.prototype.bezierCurveTo = function (e, i, n, r, s, a) {\n              this.g.bezierCurveTo(e, i, n, r, s, a), t.bezierWarning || (t.bezierWarning = !0, p.warn(\"Dashed Bézier curves not supported in this browser!\"));\n            }, t.prototype.closePath = function () {\n              this.lineTo(this.x0, this.y0);\n            }, t.prototype.strokeDashes = function () {\n              for (var t = this.dashes, e = 0; e < t.length; e += 3) {\n                var i = t[e],\n                    n = t[e + 1],\n                    r = t[e + 2];\n                0 === i ? this.g.moveTo(n, r) : this.g.lineTo(n, r);\n              }\n            }, t;\n          }();\n\n          H.bezierWarning = !1, s.GraphicsDashedLineContext = H;\n\n          var B = function () {\n            function t() {}\n\n            return t.stroke = function (t, e) {\n              0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && e.lineDash.length > 0 && void 0 !== t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke(), e.lineWidth && (t.lineWidth = 1));\n            }, t.strokeWithShadow = function (t, e) {\n              0 !== e.lineWidth && e.lineColor && !e.shadowColor && (e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, t.stroke(), e.lineWidth && (t.lineWidth = 1), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\"));\n            }, t.beginStroke = function (t, e, i) {\n              return void 0 === i && (i = !1), t.beginPath(), e.lineColor && e.lineDash && e.lineDash.length > 1 && void 0 === t.setLineDash ? (i && !e.fillColor && (i = !1), new H(t, e.lineDash, i)) : t;\n            }, t.endStroke = function (e, i, n, r) {\n              void 0 === r && (r = !1), i instanceof H ? (i.isFilling && (t.fill(e, n), e.beginPath(), i.strokeDashes()), t.strokeWithShadow(e, n)) : r ? t.paint(e, n) : t.stroke(e, n);\n            }, t.beginStrokeAndFill = function (e, i) {\n              return t.beginStroke(e, i, !0);\n            }, t.endStrokeAndFill = function (e, i, n) {\n              return t.endStroke(e, i, n, !0);\n            }, t.fill = function (t, e) {\n              e.fillColor && (t.fillStyle = e.fillColor, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.fill(), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\"));\n            }, t.paint = function (t, e) {\n              e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.fillColor && (t.fillStyle = e.fillColor, t.fill()), 0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && void 0 !== t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke()), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\");\n            }, t.textStyle = function (t, e) {\n              t.__textStyle && this.resetTextStyle(t);\n              var i = e.fillColor;\n              void 0 === i && (i = \"#000\"), t.fillStyle = i, t.__font = t.font = e.font || null, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.outlineColor && (t.strokeStyle = e.outlineColor, t.lineWidth = 2 * (e.outlineWidth || 1), t.lineJoin = e.outlineJoin || \"miter\", t.miterLimit = 2), t.__textStyle = e;\n            }, t.getTextWidth = function (t, e, i) {\n              if (e) {\n                var n = e.font;\n                t.__font !== n && (t.__textStyle = null, t.__font = t.font = n || null);\n              }\n\n              var r = t.measureText(i).width;\n              return e.outlineColor && (r += 2 * (e.outlineWidth || 1)), r;\n            }, t.drawText = function (t, e, i, n, r) {\n              t.__textStyle !== e && this.textStyle(t, e), null != i && i.length && (e.outlineColor && t.strokeText(i, n, r), t.fillText(i, n, r));\n            }, t.resetTextStyle = function (t) {\n              t.__font = null;\n              var e = t.__textStyle;\n              e && (e.shadowColor && (t.shadowColor = \"transparent\", t.shadowBlur = 0), e.outlineColor && (t.lineJoin = \"miter\", t.miterLimit = 10, t.lineWidth = 1), t.__textStyle = null);\n            }, t.restore = function (t) {\n              this.resetTextStyle(t), t.restore();\n            }, t.rectStyle = function (t, e) {\n              void 0 !== e.lineColor && (t.strokeStyle = e.lineColor), void 0 !== e.fillColor && (t.fillStyle = e.fillColor), void 0 !== e.lineWidth && (t.lineWidth = e.lineWidth);\n            }, t.pushClip = function (t, e, i, n, r) {\n              var s = t.context,\n                  a = t.scaleX,\n                  o = t.scaleY;\n              1 === a && 1 === o || !window.screen.deviceXDPI ? (s.save(), s.beginPath(), s.rect(e, i, n, r), s.clip()) : (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.beginPath(), s.rect(e * a | 0, i * o | 0, n * a | 0, r * o | 0), s.clip(), s.setTransform(a, 0, 0, o, 0, 0));\n            }, t.popClip = function (t) {\n              this.restore(t.context);\n            }, t.arcBetweenTwoPoints = function (t, e, i, n, r, s, a, o) {\n              var l = (r + a) / 2,\n                  h = (s + o) / 2,\n                  u = o - s,\n                  c = r - a,\n                  d = u * u + c * c;\n\n              if (0 !== d) {\n                var p = Math.sqrt(d);\n                n = Math.min(Math.max(n, p / 2), 3 * p);\n                var f = Math.sqrt(n * n / d - .25),\n                    g = l + u * f,\n                    m = h + c * f,\n                    v = l - u * f,\n                    y = h - c * f;\n                (g - e) * (g - e) + (m - i) * (m - i) > (v - e) * (v - e) + (y - i) * (y - i) ? (e = v, i = y) : (e = g, i = m);\n                var S = Math.atan2(s - i, r - e),\n                    b = Math.atan2(o - i, a - e);\n                b < S && (b += 2 * Math.PI);\n                var C = Math.abs(S - b) > Math.PI;\n                t.arc(e, i, n, S, b, C);\n              }\n            }, t.strokeMarker = function (e, i, n, r, s) {\n              var a = 1.41421356237 * s;\n\n              switch (i) {\n                case \"rect\":\n                case \"square\":\n                  e.moveTo(n - s, r - s), e.lineTo(n + s, r - s), e.lineTo(n + s, r + s), e.lineTo(n - s, r + s), e.lineTo(n - s, r - s);\n                  break;\n\n                case \"romb\":\n                case \"rhombus\":\n                  a *= .9, e.moveTo(n - a, r), e.lineTo(n, r - a), e.lineTo(n + a, r), e.lineTo(n, r + a), e.lineTo(n - a, r);\n                  break;\n\n                case \"triangle\":\n                  var o = t.SQRT3D6 * (3 * s);\n                  e.moveTo(n - s, r + o), e.lineTo(n + s, r + o), e.lineTo(n, r - o), e.lineTo(n - s, r + o);\n                  break;\n\n                case \"triangle2\":\n                  e.moveTo(n - a, r - a), e.lineTo(n + a, r - a), e.lineTo(n, r + a), e.lineTo(n - a, r - a);\n                  break;\n\n                case \"circle\":\n                  e.moveTo(n + s, r), e.arc(n, r, s, 0, 2 * Math.PI, !1);\n                  break;\n\n                default:\n                  throw new Error(\"Unknown marker shape \" + i + \". Valid values are `square`, `rhombus`, `triangle`, `triangle2`, `circle`.\");\n              }\n            }, t.strokeBalloon = function (t, e, i, n, r) {\n              n = Math.max(n, 2 * r);\n              var s = (r + 8) / 2,\n                  a = e,\n                  o = i;\n              t.moveTo(a, o), a += 3, o += 6, t.lineTo(a, o), a += n - 4, t.lineTo(a, o), t.arc(a, o + s, s, -Math.PI / 2, Math.PI / 2), o += 2 * s, a -= n - 4, t.lineTo(a, o), t.arc(a, o - s, s, .5 * Math.PI, 1.3 * Math.PI), t.closePath();\n            }, t.strokeBalloon2 = function (t, e, i, n, r) {\n              var s = (r + 8) / 2,\n                  a = e + (n = Math.max(n, 2 * r) / 2 - 4),\n                  o = i - s;\n              t.moveTo(a, o), t.arc(a, o + s, s, -Math.PI / 2, Math.PI / 2, !1), o += 2 * s, a -= 2 * n, t.lineTo(a, o), t.arc(a, o - s, s, .5 * Math.PI, 1.5 * Math.PI, !1), t.closePath();\n            }, t.applyColorToImage = function (t, e, i) {\n              void 0 === i && (i = !0);\n              var n = E.parse(e),\n                  r = n.R,\n                  s = n.G,\n                  a = n.B,\n                  o = document.createElement(\"canvas\"),\n                  l = o.width = t.width,\n                  h = o.height = t.height,\n                  u = o.getContext(\"2d\");\n              u.drawImage(t, 0, 0);\n              var c = u.getImageData(0, 0, l, h),\n                  d = c.data;\n              if (i) for (var p = 0; p <= d.length; p += 4) {\n                255 === d[p + 3] && (d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8);\n              } else for (p = 0; p <= d.length; p += 4) {\n                d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8;\n              }\n              return u.putImageData(c, 0, 0), o;\n            }, t.cropImageToCircle = function (t, e) {\n              var i = Math.min(t.width, t.height),\n                  n = Math.max(t.width, t.height),\n                  r = Math.min(n, 2 * i),\n                  s = document.createElement(\"canvas\");\n              s.width = r, s.height = r;\n              var a = s.getContext(\"2d\"),\n                  o = t.width,\n                  l = t.height;\n              a.fillStyle = \"rgba(0,0,0,1)\", a.beginPath(), a.arc(r / 2, r / 2, r / 2, 0, 2 * -Math.PI, !1), a.fill();\n              var h = a.globalCompositeOperation;\n\n              if (a.globalCompositeOperation = \"source-in\", \"crop\" === e) {\n                var u = Math.min(o, l) / 2;\n                a.drawImage(t, o / 2 - u, l / 2 - u, 2 * u, 2 * u, 0, 0, r, r);\n              } else if (\"letterbox\" === e) {\n                a.fillStyle = \"black\", a.fillRect(0, 0, r, r);\n                var c = r / Math.max(o, l);\n                a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c);\n              } else if (\"fit\" === e) {\n                a.fillStyle = \"black\", a.fillRect(0, 0, r, r);\n                c = r / Math.sqrt(o * o + l * l);\n                a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c);\n              } else a.drawImage(t, 0, 0, o, l, 0, 0, r, r);\n\n              return a.globalCompositeOperation = h, s;\n            }, t.applyShadow = function (t, e) {\n              e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor);\n            }, t.clearShadow = function (t) {\n              t.shadowBlur = 0, t.shadowColor = \"transparent\";\n            }, t.drawImageInSquare = function (t, e, i, n, r, s, a, o, l) {\n              var h = l / Math.max(r, s),\n                  u = r * h,\n                  c = s * h;\n              this.drawImageHighQuality(t, e, i, n, r, s, a - u, o - c, 2 * u, 2 * c);\n            }, t.drawImageHighQuality = function (t, e, i, n, r, s, a, o, l, h) {\n              void 0 === a && (a = i, o = n, l = r, h = s, r = e.width, s = e.height, i = 0, n = 0);\n              var u = t.__scaleX || 1,\n                  c = t.__scaleY || 1;\n\n              if (!(h < 1 / c || l < 1 / u)) {\n                for (var d = r, p = s, f = e, g = 1, m = \"__size:\" + i + \"/\" + n + \"/\" + r + \"/\" + s + \"/\"; d >= l * u * 2 && p >= h * c * 2;) {\n                  var v = Math.round(d / 2),\n                      y = Math.round(p / 2),\n                      S = m + (g /= 2),\n                      b = e[S];\n                  if (!b) (b = e[S] = document.createElement(\"canvas\")).width = v, b.height = y, b.getContext(\"2d\").drawImage(f, i, n, d, p, 0, 0, v, y);\n                  i = 0, n = 0, f = b, p = y, d = v;\n                }\n\n                t.drawImage(f, i, n, 0 | d, 0 | p, a, o, l, h);\n              }\n            }, t.getTextHeight = function (e, i) {\n              var n = t._heightCache;\n              if (n.hasOwnProperty(i)) return n[i];\n              var r = t._heightElem;\n\n              if (!r) {\n                var a = document.createElement(\"div\");\n                a.className = \"DVSL-font-height\", t._heightElem = r = document.createElement(\"div\"), r.appendChild(document.createTextNode(\"Mg9!\")), a.appendChild(r), document.body.appendChild(a);\n              }\n\n              r.style.font = i;\n              var o = r.getBoundingClientRect();\n              return o.top >= 0 && o.left >= 0 ? (s.Helpers.error(\"getTextHeight called before CSS loaded\"), o.height) : n[i] = o.height;\n            }, t;\n          }();\n\n          B.SQRT3D6 = Math.sqrt(3) / 6, B._heightElem = null, B._heightCache = {}, s.Graphics = B;\n\n          var z = function () {\n            return function () {\n              this.enabled = !0, this.enabledOnExport = !0, this.align = \"center\", this.margin = 25, this.style = {\n                font: \"20px Arial\",\n                fillColor: \"#000\"\n              }, this.text = \"\", this.advanced = {\n                addAfterToolbar: !1\n              };\n            };\n          }();\n\n          s.SettingsTitle = z;\n\n          var U = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.lineSpacing = 0, i.animationOrder = 2e3, i.paintOrder = 55, i.updateOrder = 500, i.chart = e, i.scene = e.scene, i.settings = i.scene.settings.title, i.panel = new I(), i.panel.packingOrder = 10, i.settings.advanced && !0 === i.settings.advanced.addAfterToolbar && (i.panel.packingOrder = 20), i.panel.side = \"top\", i.panel.outsideEdge = !0, i.panel.align = \"fill\", i.panel.visible = !1, i.panel.computeSize = function (t, e, n) {\n                return i.computePanelSize(t, e, n);\n              }, i.lines = null, i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              var e = t.changes;\n              e.settings && e.settingsChanges.title && (e.bounds = !0);\n            }, e.prototype.getPanels = function (t) {\n              var e = this.settings;\n              return this.panel.visible = !!e.text && (t ? e.enabledOnExport : e.enabled), this.panel.visible ? (this.panel.margin = e.margin, t && !e.enabled ? this.panel.location = \"external\" : this.panel.location = \"outside\", [this.panel]) : [];\n            }, e.prototype.computePanelSize = function (t, e, i) {\n              if (!this.chart.assetsLoaded) return {\n                width: 0,\n                height: 0\n              };\n              this.lines = [];\n              var n = this.settings.text,\n                  r = this.settings.style;\n              i.save();\n              var s = B.getTextWidth(i, r, n),\n                  a = B.getTextHeight(i, r.font);\n\n              if (this.lineSpacing = 1.15 * a, s > t) {\n                for (var o = n.split(\" \"), l = o[0], h = B.getTextWidth(i, r, l), u = 1; u <= o.length - 1; u++) {\n                  var c = l + \" \" + o[u],\n                      d = B.getTextWidth(i, r, c);\n                  d <= t ? (l = c, h = d) : (this.lines.push(l), s = Math.max(s, h), l = o[u], h = B.getTextWidth(i, r, l));\n                }\n\n                this.lines.push(l), s = Math.max(0, h);\n              } else this.lines.push(n);\n\n              return B.restore(i), {\n                width: s,\n                height: a = (this.lines.length - 1) * this.lineSpacing + a\n              };\n            }, e.prototype.paintScene = function (t) {\n              if (this.panel.visible && this.lines) {\n                var e,\n                    i = this.settings,\n                    n = t.context,\n                    r = this.panel.left,\n                    s = this.panel.right,\n                    a = this.panel.top,\n                    o = i.style;\n                n.textBaseline = \"top\", \"left\" === i.align ? (n.textAlign = \"start\", e = r) : \"right\" === i.align ? (n.textAlign = \"end\", e = s) : (n.textAlign = \"center\", e = (r + s) / 2);\n\n                for (var l = 0; l < this.lines.length; l++) {\n                  B.drawText(n, o, this.lines[l], e, a), a += this.lineSpacing;\n                }\n\n                B.resetTextStyle(n);\n              }\n            }, e;\n          }(A);\n\n          s.Title = U;\n\n          var G = function () {\n            function t(t, e) {\n              void 0 === e && (e = !1), this.style = {\n                textStyle: {}\n              }, this._textOverride = void 0, this.visible = !0, this.allowCache = !0, this.shouldBeVisible = !0, this.userPlaced = !1, this.rows = null, this.lineHeight = 0, this.lineHeightM = 0, this.hwidth = null, this.hheight = null, this.currentBounds = null, this.x = null, this.originX = null, this.y = null, this.prop = null, this._pendingImage = !1, this._textCache = null, this._measureStyles = null, t.textStyle || (t.textStyle = {}), null == t.lineSpacing && (t.lineSpacing = .2), this.style = e ? t : s.Helpers.realClone(t);\n            }\n\n            return Object.defineProperty(t.prototype, \"text\", {\n              get: function get() {\n                var t = this._textOverride;\n                return void 0 === t && null != (t = this.style.text) && \"string\" != typeof t && (t = \"\" + t), t;\n              },\n              set: function set(t) {\n                void 0 === t && (t = null), null != t && \"string\" != typeof t && (t = \"\" + t), this._textOverride = t;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), t.prototype.needTextParsing = function () {\n              var t = this._textCache;\n              return !t || t.sourceText !== this.text || t.sourceFont !== this.style.textStyle.font;\n            }, t.prototype.needMeasure = function () {\n              var t = this._measureStyles,\n                  e = t && t.customMeasure;\n              if (this._pendingImage) return !e || null;\n              var i = this.style,\n                  n = i.textStyle,\n                  r = !t || t.align !== i.align || t.text !== this.text || t.aspectRatio !== i.aspectRatio || t.borderRadius !== i.borderRadius || t.font !== n.font || t.image !== i.image || t.imageSlicing !== \"\" + i.imageSlicing || t.margin !== i.margin || t.maxWidth !== i.maxWidth || t.padding !== i.padding;\n              return r && e ? null : r;\n            }, t.prototype.measureComplete = function (t) {\n              var e = this.style,\n                  i = e.textStyle;\n              this._measureStyles = {\n                customMeasure: t,\n                text: this.text,\n                align: e.align,\n                aspectRatio: e.aspectRatio,\n                borderRadius: e.borderRadius,\n                font: i.font,\n                image: e.image,\n                imageSlicing: \"\" + e.imageSlicing,\n                lineSpacing: e.lineSpacing,\n                margin: e.margin,\n                maxWidth: e.maxWidth,\n                padding: e.padding\n              };\n            }, t;\n          }();\n\n          s.Label = G;\n\n          var j = function () {\n            function t(t, e, i) {\n              if (this.cache = {}, this.frameLabels = {}, this.numPaints = 0, this.numCachedPaints = 0, this.allowCache = !0, this.chartArea = 0, this.scaleX = 0, this.scaleY = 0, this.settings = t, this.assetsLoader = e, !i) throw new Error(\"chartContainer must be specified\");\n              this.chartContainer = i;\n            }\n\n            return t.prototype.startFrame = function (t, e, i, n) {\n              this.chartArea = t * e, this.scaleX = i, this.scaleY = n;\n            }, t.prototype.finishFrame = function () {\n              var t = p.countProperties(this.cache);\n\n              if (!(t < 1e3)) {\n                if (t > 3 * p.countProperties(this.frameLabels)) for (var e in this.cache) {\n                  this.frameLabels[e] || delete this.cache[e];\n                }\n                this.frameLabels = {};\n              }\n            }, t.prototype.measure = function (t, e) {\n              var i = e.needMeasure();\n\n              if (!0 === i) {\n                var n = e.style,\n                    r = new W().totalPadding(n),\n                    s = 0,\n                    a = 0;\n\n                if (e.text) {\n                  var o = this.measureText(t, e),\n                      l = o.w,\n                      h = o.h;\n                  a = Math.max(a, h), s += l;\n                } else e.rows = {\n                  subLines: [],\n                  rowWidths: []\n                };\n\n                if (n.image) {\n                  var u = n.imageSlicing;\n                  if (u) s += u[2], a = Math.max(a, u[3]);else {\n                    var c = this.assetsLoader.getAssetImage(n.image, null);\n                    c && c.width ? (s += c.width, a = Math.max(a, c.height)) : e._pendingImage = !0;\n                  }\n                }\n\n                if (0 === s && (s = 10, a = 10), s += 2 * r, a += 2 * r, n.borderRadius > 0 && e.text) {\n                  var d = Math.min(n.borderRadius, a / 2);\n                  s += .45 * d, n.image || (s += .45 * d);\n                }\n\n                e.hwidth = s / 2, e.hheight = a / 2, e.measureComplete(!1);\n              } else if (null === i) throw new Error(\"Label.needMeasure assert.\");\n            }, t.prototype.measureText = function (t, e) {\n              var i,\n                  n,\n                  r = e.style,\n                  s = r.aspectRatio,\n                  a = r.maxWidth,\n                  o = new W(),\n                  l = o.styleTagParser(t, e);\n\n              if ((s > 0 || a > 0) && l.maxLines > 1) {\n                s || (s = 1e9), a || (a = 1e9);\n                o.fitLabelInRect(t, e, function (t) {\n                  return {\n                    x: 0,\n                    y: 0,\n                    dx: 0,\n                    dy: 0,\n                    width: Math.min(a, t * (s + .2))\n                  };\n                }, !1), i = 2 * e.hwidth, n = 2 * e.hheight;\n              } else {\n                for (var h = l.words, u = l.breaks, c = 0; c < u.length; c++) {\n                  u[c] = u[c] - 1;\n                }\n\n                var d = o.stringsByFont(h, u);\n                e.lineHeight = n = B.getTextHeight(t, r.textStyle.font), e.rows = d, i = d.rowWidths.reduce(function (t, e) {\n                  return Math.max(t, e);\n                }), n = n * (1 + (r.lineSpacing || 0)) * d.rowWidths.length;\n              }\n\n              return {\n                w: i,\n                h: n\n              };\n            }, t.prototype.canCache = function (t, e) {\n              var i = this.settings.advanced,\n                  n = t.style;\n              if (!this.allowCache || !t.allowCache || !i.labelCache) return !1;\n              if (n.angle && !i.labelCacheRotated) return !1;\n              var r = t.hwidth * t.hheight * e * e * 2;\n              if (this.chartArea / r < 10) return !1;\n              if (n.image && !this.assetsLoader.getAssetImage(n.image, null)) return !1;\n              return !0;\n            }, t.prototype.styleRequiresDocumentCanvas = function (t) {\n              return !!(t && t.font && /[0-9]+em/.test(t.font));\n            }, t.prototype.realPaint = function (t, e, i, n) {\n              var r = n.hwidth,\n                  s = n.hheight,\n                  a = n.style,\n                  o = a.backgroundStyle,\n                  l = new W().totalPadding(a),\n                  h = Math.min(a.borderRadius || 0, s);\n\n              if (o) {\n                var u = o.lineWidth;\n                r -= u = null == u && o.lineColor ? .5 : (u || 0) / 2, s -= u;\n                var c = B.beginStrokeAndFill(t, o);\n\n                if (h >= s) {\n                  var d = e + r - s;\n                  c.moveTo(d, i - s), c.arc(d, i, s, -Math.PI / 2, Math.PI / 2, !1), d = e - r + s, c.lineTo(d, i + s), c.arc(d, i, s, Math.PI / 2, -Math.PI / 2, !1), c.closePath();\n                } else h > 0 ? (c.moveTo(e - r + h, i - s), c.lineTo(e + r - h, i - s), c.arc(e + r - h, i - s + h, h, -Math.PI / 2, 0, !1), c.lineTo(e + r, i + s - h), c.arc(e + r - h, i + s - h, h, 0, +Math.PI / 2, !1), c.lineTo(e - r + h, i + s), c.arc(e - r + h, i + s - h, h, +Math.PI / 2, Math.PI, !1), c.lineTo(e - r, i - s + h), c.arc(e - r + h, i - s + h, h, Math.PI, Math.PI + Math.PI / 2, !1)) : (c.moveTo(e - r, i - s), c.lineTo(e + r, i - s), c.lineTo(e + r, i + s), c.lineTo(e - r, i + s), c.closePath());\n\n                B.endStrokeAndFill(t, c, o), r += u, s += u;\n              }\n\n              var p = a.image;\n              s -= l;\n              var f = e - (r -= l),\n                  g = e + r;\n\n              if (p) {\n                var m = this.assetsLoader.getAssetImage(p);\n\n                if (m) {\n                  var v = a.imageSlicing;\n                  v ? (B.drawImageHighQuality(t, m, v[0], v[1], v[2], v[3], e - r, i - s, v[2], v[3]), f += v[2]) : (t.drawImage(m, e - r, i - s), f += m.width);\n                }\n              }\n\n              var y = n.rows.subLines,\n                  S = n.rows.rowWidths,\n                  b = S.length;\n\n              if (y.length > 0) {\n                var C = n.lineHeight * (1 + (a.lineSpacing || 0)),\n                    x = a.align,\n                    w = void 0,\n                    L = void 0;\n                t.textBaseline = \"bottom\";\n                var T = i - (b + 1) * C / 2 + .58 * n.lineHeight;\n                \"left\" === x ? (L = f, p || (L += .45 * h), w = \"start\") : \"right\" === x ? (L = g - .45 * h, w = \"end\") : (L = (f + g) / 2, w = \"center\");\n                var k = a.textStyle,\n                    A = -1,\n                    M = 0;\n                t.textAlign = w;\n                var I = void 0;\n                B.textStyle(t, k);\n\n                for (var P = k.font, D = 0; D < y.length; D++) {\n                  var N = y[D],\n                      F = M;\n\n                  if (M += N.width, A !== N.row) {\n                    A = N.row, T += C, F = 0, M = N.width;\n                    var O = S[A];\n                    I = \"center\" === w ? L - O / 2 : \"start\" === w ? L : L - O;\n                  }\n\n                  t.textAlign = \"left\", P !== N.font && (t.font = P = N.font), F += I, B.drawText(t, k, N.text, F, T);\n                }\n\n                B.resetTextStyle(t);\n              }\n            }, t.prototype.paint = function (t, e, i, n, r) {\n              this.measure(t, r);\n              var a = r.style,\n                  o = (a.angle || 0) / 180 * Math.PI,\n                  l = this.scaleX,\n                  h = this.scaleY,\n                  u = 0 === (a.angle || 0) ? 1 : 1.7,\n                  c = l * n * u,\n                  d = h * n * u,\n                  p = this.canCache(r, n),\n                  f = r.hwidth,\n                  g = r.hheight,\n                  m = 3 / h;\n\n              if (r.currentBounds = new vt(e - f * n, i - g * n, e + f * n, i + g * n), p) {\n                var v = c,\n                    y = d;\n                g * d < m && (v = c / d * (y = m / g));\n                var S = r.text + JSON.stringify(r.style) + v.toFixed(2) + \",\" + y.toFixed(2) + \",\" + r.hwidth + \",\" + r.hheight,\n                    b = this.cache[S] || null,\n                    C = void 0,\n                    x = void 0,\n                    w = void 0,\n                    L = void 0;\n                if (b) w = (C = b.width) / 2, L = (x = b.height) / 2, this.numCachedPaints += 1;else {\n                  var T = a.backgroundStyle,\n                      k = T && T.lineWidth ? T.lineWidth : 0;\n                  C = Math.ceil((2 * f + k + 1) * v), x = Math.ceil((2 * g + k + 1) * y), b = document.createElement(\"canvas\"), w = (C += C % 2) / 2, L = (x += x % 2) / 2, b.width = C, b.height = x;\n                  var A = this.styleRequiresDocumentCanvas(a.textStyle),\n                      M = void 0;\n                  A && ((M = this.chartContainer).ownerDocument || (s.Helpers.warn(\"chartContainer must be appended to the document in order to use `em` when specifying font size.\"), M = document.body), b.style.display = \"none\", M.appendChild(b));\n                  var I = b.getContext(\"2d\");\n                  I.transform(v, 0, 0, y, w, L), this.realPaint(I, 0, 0, r), A && M.removeChild(b), this.cache[S] = b, this.numPaints += 1;\n                }\n                var P = C / c * n,\n                    D = x / d * n;\n                v !== c && (P = P / v * c, D = D / y * d);\n                var N = e - (P = Math.round(P / 2 * 1e3) / 1e3),\n                    F = i - (D = Math.round(D / 2 * 1e3) / 1e3);\n                0 !== o ? (t.save(), t.translate(e, i), t.rotate(o), N = -P, F = -D) : v === c && (N = Math.round(N * l) / l, F = Math.round(F * h) / h), B.drawImageHighQuality(t, b, 0, 0, C, x, N, F, 2 * P, 2 * D), this.frameLabels[S] = 1, 0 !== o && B.restore(t);\n              } else {\n                var O = 1 !== n || 0 !== o;\n                O && (t.save(), t.transform(n, 0, 0, n, e, i), 0 !== o && t.rotate(o), e = 0, i = 0), this.realPaint(t, e, i, r), this.numPaints += 1, O && B.restore(t);\n              }\n            }, t;\n          }();\n\n          s.LabelRenderer = j;\n\n          var W = function () {\n            function t() {}\n\n            return t.prototype.totalPadding = function (t) {\n              var e = t.padding || 0,\n                  i = t.backgroundStyle;\n\n              if (i) {\n                var n = i.lineWidth;\n                e += null == n && i.lineColor ? 1 : n || 0;\n              }\n\n              return e;\n            }, t.prototype.fitLabelInRect = function (t, e, i, n) {\n              void 0 === n && (n = !0);\n              var r = e.style,\n                  s = r.margin || 0,\n                  a = this.totalPadding(r),\n                  o = B.getTextHeight(t, r.textStyle.font),\n                  l = r.lineSpacing || 0,\n                  h = o * (l + 1),\n                  u = -o * l;\n              e.needTextParsing() && this.styleTagParser(t, e);\n\n              for (var c, d, p = e._textCache.words, f = e._textCache.breaks, g = e._textCache.maxLines, m = -1 / 0, v = null, y = 0, S = 0, b = 0, C = 0, x = Math.min(g, f.length); x <= g; x++) {\n                var w = i((u + h * x) / 2 + s + a),\n                    L = w.width;\n                L -= 2 * (s + a);\n                var T = this.splitWordsToLines(p, f, x, function () {\n                  return L;\n                }),\n                    k = T.prop,\n                    A = T.actualWidthForLines,\n                    M = T.positions;\n\n                if (k > m) {\n                  v = M, m = k, c = w.dx, d = w.dy, y = w.x, S = w.y, b = L, C = 0;\n\n                  for (var I = 0; I < A.length; I++) {\n                    var P = A[I];\n                    C = Math.max(P, C);\n                  }\n                }\n\n                if (k >= 1) break;\n              }\n\n              if (v) {\n                if (!e.userPlaced) {\n                  var D,\n                      N = e.style.align;\n                  y += c * (D = \"left\" === N ? (C - b) / 2 : \"right\" === N ? (b - C) / 2 : 0), S += d * D;\n                }\n\n                n && (e.x = y, e.y = S), e.rows = this.stringsByFont(p, v), e.hheight = (u + h * v.length) / 2 + a, e.lineHeight = o, e.lineHeightM = h, e.hwidth = C / 2 + a, e.visible = !0, e.measureComplete(!0), r.borderRadius > 0 && (e.hwidth += .45 * Math.min(r.borderRadius, e.hheight));\n              } else e.rows = {\n                subLines: [],\n                rowWidths: []\n              }, e.visible = !1;\n\n              return m;\n            }, t.prototype.styleTagParser = function (t, e) {\n              return e.needTextParsing() && (e._textCache = this.styleTagParser2(t, e.text, e.style.textStyle)), e._textCache;\n            }, t.prototype.styleTagParser2 = function (e, i, n) {\n              var r = n.font;\n              r ? (e.font = r, e.font) : r = \"11px Arial\";\n              var s = t._spaceWidth;\n              s[r] || (s[r] = B.getTextWidth(e, {\n                font: r\n              }, \" \"));\n              var a = r,\n                  o = 0,\n                  l = 0,\n                  h = !0,\n                  u = i;\n              i = null == i ? \"\" : \"\" + i;\n              var c = 0,\n                  d = 0,\n                  f = [],\n                  g = [],\n                  m = -1;\n              f.push({\n                word: \"\",\n                width: 0,\n                font: a,\n                spaceWidth: 0\n              });\n              var v = {\n                word: \"\",\n                width: 0,\n                font: a,\n                spaceWidth: 0\n              };\n              f.push(v);\n\n              for (var y = i.length, S = 0 === y ? -1 : i.charCodeAt(0); c < y;) {\n                switch (S) {\n                  case 32:\n                    for (; 32 === S && ++c < y;) {\n                      S = i.charCodeAt(c);\n                    }\n\n                    h || (v.spaceWidth = s[a], h = !0), d = c;\n                    break;\n\n                  case 60:\n                    if (c + 4 > y) {\n                      S = -1;\n                      break;\n                    }\n\n                    var b = c,\n                        C = i.charCodeAt(++c),\n                        x = 47 === C ? -1 : 1;\n                    x < 0 && (C = i.charCodeAt(++c));\n                    var w = i.charCodeAt(++c),\n                        L = -1;\n\n                    if (98 === C || 66 === C ? 82 === w || 114 === w ? (w = ++c === y ? -1 : i.charCodeAt(c), L = 2) : L = 0 : 73 !== C && 105 !== C || (L = 1), L > -1 && 62 === w) {\n                      S = ++c === y ? -1 : i.charCodeAt(c), d = c;\n                      var T = !1,\n                          k = v.word || v.spaceWidth > 0;\n                      if (2 === L) m === f.length - 1 && (k = !0), g.push(m = f.length - (k ? 0 : 1)), h = !0, T = !0;else {\n                        1 === L ? l = Math.max(0, l + x) : o = Math.max(0, o + x);\n                        var A = (l ? \"italic \" : \"\") + (o ? \"bold \" : \"\") + r;\n                        A !== a && (T = !0, s[a = A] || (s[a] = B.getTextWidth(e, {\n                          font: a\n                        }, \" \")));\n                      }\n                      T && (k ? (v = {\n                        word: \"\",\n                        width: 0,\n                        font: a,\n                        spaceWidth: 0\n                      }, f.push(v)) : v.font = a);\n                    } else c = b, S = -1;\n\n                    break;\n\n                  default:\n                    for (var M = !1; 32 !== S && 60 !== S && ++c < y;) {\n                      M = M || 38 === S, S = i.charCodeAt(c);\n                    }\n\n                    var I = i.substring(d, c);\n                    M && (I = p.decodeEntities(I)), v.spaceWidth > 0 || v.font !== a ? (v = {\n                      word: I,\n                      width: 0,\n                      font: a,\n                      spaceWidth: 0\n                    }, f.push(v)) : v.word += I, h = !1, d = c;\n                }\n              }\n\n              for (var P = 0; P < f.length; P++) {\n                (F = f[P]).word && (F.width = B.getTextWidth(e, {\n                  font: F.font\n                }, F.word));\n              }\n\n              B.resetTextStyle(e);\n              var D = f.length;\n              g[g.length - 1] !== D && g.push(D);\n              var N = D;\n              0 === f[0].width && N--;\n\n              for (P = D - 1; P >= 0; P--) {\n                var F;\n                if ((F = f[P]).width > 0) break;\n                N--;\n              }\n\n              return {\n                sourceText: u,\n                sourceFont: n.font,\n                breaks: g,\n                maxLines: N,\n                words: f\n              };\n            }, t.prototype.stringsByFont = function (t, e) {\n              for (var i = t[0].font, n = e.slice(0), r = [], s = [], a = 0, o = 0, l = \"\", h = 0, u = 0, c = 0; c <= t.length - 1; c++) {\n                var d = t[c];\n                u = d.spaceWidth;\n                var p = c === n[0];\n                d.font !== i && (o && r.push({\n                  text: l,\n                  width: o,\n                  font: i,\n                  row: h\n                }), i = d.font, l = \"\", o = 0), o += d.width, l += d.word, a += d.width + d.spaceWidth, p && (r.push({\n                  text: l,\n                  width: o,\n                  font: i,\n                  row: h\n                }), s.push(a - d.spaceWidth), l = \"\", h++, o = a = 0, n.shift()), p || d.spaceWidth && (o += d.spaceWidth, l += \" \");\n              }\n\n              return l && (r.push({\n                text: l,\n                width: o,\n                font: i,\n                row: h\n              }), s.push(a - u)), {\n                subLines: r,\n                rowWidths: s\n              };\n            }, t.prototype.fitLabelInLines = function (t, e, i, n, r, s, a) {\n              var o = e.style,\n                  l = o.margin || 0,\n                  h = this.totalPadding(o),\n                  u = B.getTextHeight(t, o.textStyle.font),\n                  c = o.lineSpacing || 0,\n                  d = u * (c + 1),\n                  p = -u * c;\n              this.styleTagParser(t, e);\n              var f = e._textCache.words,\n                  g = e._textCache.breaks,\n                  m = e._textCache.maxLines,\n                  v = -1 / 0,\n                  y = null,\n                  S = null,\n                  b = null,\n                  C = 0,\n                  x = [],\n                  w = [];\n              w.push(a(i, n));\n\n              for (var L = 1; L <= g.length - 1; L++) {\n                var T = p + d * L,\n                    k = void 0;\n                k = L % 2 == 1 ? x : w;\n                var A = a(i, n - T / 2 - l);\n                k.unshift([A[0] - l, A[1] - l]), A = a(i, n + T / 2 + l), k.push([A[0] - l, A[1] - l]);\n              }\n\n              for (L = Math.min(m, g.length); L <= m; L++) {\n                var M;\n                T = p + d * L;\n                M = L % 2 == 1 ? x : w;\n                A = a(i, n - T / 2 - l);\n                M.unshift([A[0] - l, A[1] - l]), A = a(i, n + T / 2 + l), M.push([A[0] - l, A[1] - l]);\n                var I = this.splitWordsToLines(f, g, L, function (t) {\n                  return Math.min(M[t][0] + M[t][1], M[t + 1][0] + M[t + 1][1]);\n                }),\n                    P = I.prop,\n                    D = I.actualWidthForLines,\n                    N = I.positions;\n                if (P > v && (C = n - T / 2, y = N, v = P, S = D, b = M.slice(0), N.length + 1 > M.length)) throw new Error(\"Internal error - fitLabelInLines\");\n                if (P >= 1) break;\n              }\n\n              if (y) {\n                var F = 0,\n                    O = 0,\n                    E = void 0,\n                    R = void 0;\n\n                if (\"left\" === r) {\n                  for (var H = 1e30, z = 0; z <= y.length; z++) {\n                    H = Math.min(b[z][0]);\n                  }\n\n                  var U = -H;\n                  E = U, R = U;\n\n                  for (z = 0; z <= y.length - 1; z++) {\n                    var G = S[z],\n                        j = Math.min(b[z][1], b[z + 1][1]);\n                    R = Math.max(U + G), O = Math.max(O, G - (j - U));\n                  }\n                } else if (\"right\" === r) {\n                  for (j = 1e30, z = 0; z <= y.length; z++) {\n                    j = Math.min(b[z][1]);\n                  }\n\n                  var W = j;\n                  E = W, R = W;\n\n                  for (z = 0; z <= y.length - 1; z++) {\n                    G = S[z];\n                    E = Math.min(W - G), F = Math.max(F, G - (j + W));\n                  }\n                } else if (\"center\" === r) {\n                  for (H = 1e30, j = 1e30, z = 0; z <= y.length - 1; z++) {\n                    G = S[z] / 2;\n                    H = Math.min(b[z][0] - G, Math.min(b[z + 1][0] - G, H)), j = Math.min(b[z][1] - G, Math.min(b[z + 1][1] - G, j));\n                  }\n\n                  var V;\n                  E = V = H > 0 && j > 0 ? 0 : H > -j ? j : j > -H ? -H : (j - H) / 2, R = V;\n\n                  for (z = 0; z <= y.length - 1; z++) {\n                    G = S[z];\n                    H = Math.min(b[z][0], b[z + 1][0]), j = Math.min(b[z][1], b[z + 1][1]), E = Math.min(E, V - G / 2), R = Math.max(R, V + G / 2), F = Math.max(F, G / 2 - H - V), O = Math.max(O, G / 2 - j + V);\n                  }\n                }\n\n                if (\"left\" === s && F > 0) E += F, R += F;else if (\"right\" === s && O > 0) E -= O, R -= O;else if (\"center\" === s) {\n                  var Z = (F - O) / 2;\n                  E += Z, R += Z;\n                }\n                e.rows = this.stringsByFont(f, y), e.hwidth = (R - E) / 2 + h, e.hheight = (p + d * y.length) / 2 + h, e.lineHeight = u, e.lineHeightM = d, e.visible = !0, e.measureComplete(!0), o.borderRadius > 0 && (e.hwidth += .45 * Math.min(o.borderRadius, e.hheight)), e.userPlaced || (e.x = i + (E + R) / 2, e.y = C + e.hheight);\n              } else e.rows = {\n                subLines: [],\n                rowWidths: []\n              }, e.visible = !1;\n\n              return v;\n            }, t.prototype.splitWordsToLines = function (t, e, i, n) {\n              for (var r = 100, s = [], a = [], o = 0, l = e[o], h = i - e.length, u = t[0], c = 0, d = n(0), p = 0, f = 1; f <= t.length - 1; f++) {\n                var g = t[f],\n                    m = c + (u.spaceWidth + g.width);\n                l === f || u.spaceWidth > 0 && m > d && h > 0 ? (a.push(f - 1), s.push(c), r = Math.min(r, d / c), c = g.width, d = n(p += 1), l !== f ? h -= 1 : l = e[o += 1]) : c = m, u = g;\n              }\n\n              return a.push(t.length), s.push(c), {\n                prop: r = Math.min(r, d / c),\n                actualWidthForLines: s,\n                positions: a\n              };\n            }, t.prototype.getFormatedText = function (t, e, i, n, r) {\n              var s,\n                  a = e.style,\n                  o = a.textStyle,\n                  l = B.getTextHeight(t, a.textStyle.font),\n                  h = a.lineSpacing || 0,\n                  u = l * (h + 1),\n                  c = a.margin || 0,\n                  d = this.totalPadding(a),\n                  p = !a.angle || 0 === a.angle,\n                  f = 90 === a.angle || -90 === a.angle,\n                  g = p || f;\n              f ? (s = n - 2 * c, n = i - c) : s = r(l / 2 + d, i - 2 * c, (n -= c) - c).width;\n              var m = this.getIncludingPart(t, o, e.text, \"\", s, 0),\n                  v = e.text,\n                  y = null,\n                  S = !1,\n                  b = B.getTextWidth(t, e.style.textStyle, \"…\");\n              if (g) for (var C = Math.floor(n / l) - 2, x = 0; x <= C;) {\n                if (v = v.replace(/\\s+$/g, \"\"), (m = this.getIncludingPart(t, o, v, \"\", s, 0)) === v) {\n                  this.addLine(t, e, m, x, S);\n                  break;\n                }\n\n                if (S = !0, m.length <= 1) {\n                  m = v.slice(0, 1), S = e.text !== m, this.addLine(t, e, m, x, S), y = e.rows.rowWidths[0];\n                  break;\n                }\n\n                if (x === C) m = this.getIncludingPart(t, o, v, \"\", s - b, 0);else {\n                  var w = m.lastIndexOf(\" \"),\n                      L = void 0;\n\n                  if (-1 === w) {\n                    var T = -1 === (L = v.indexOf(\" \")) ? v : v.substring(0, L);\n                    (S = m !== T) && (m = this.getIncludingPart(t, o, v, \"\", s - b, 0).replace(/\\s+$/g, \"\"), T = -1 === (L = v.indexOf(\" \")) ? v : v.substring(0, L)), v = -1 === (L = (v = v.substr(m.length)).indexOf(\" \")) ? \"\" : v.substr(L + 1);\n                  } else m = m.substr(0, w), v = v.substr(w + 1), S = !1;\n                }\n\n                if (m.length <= 1) {\n                  if (0 !== x) break;\n                  m = e.text.slice(0, 1);\n                }\n\n                if (this.addLine(t, e, m, x, S), \"\" === v) break;\n                v = v.trim(), S = !1, x++;\n              } else (S = m !== v) && (m = this.getIncludingPart(t, o, v, \"\", s - b, 0).replace(/\\s+$/g, \"\")), this.addLine(t, e, m, 0, S);\n              e.rows || this.addLine(t, e, \"\", 0, !1);\n              var k = (u * e.rows.subLines.length - l * h) / 2,\n                  A = 0;\n\n              if (\"left\" === a.align || \"right\" === a.align) {\n                var M = (s - Math.max.apply(Math, e.rows.rowWidths)) / 2;\n                A = \"right\" === a.align ? M : -M;\n              }\n\n              a.angle && (y = Math.max.apply(Math, e.rows.rowWidths));\n              var I = r(k, y || i, n);\n              e.x = I.x + I.dx * A, e.y = c + I.y, e.hheight = k + d, e.hwidth = Math.max.apply(Math, e.rows.rowWidths) / 2 + d, e.lineHeight = l, e.lineHeightM = u, e.visible = !0, e.measureComplete(!0), a.borderRadius > 0 && (e.hwidth += .45 * Math.min(a.borderRadius, e.hheight));\n            }, t.prototype.addLine = function (t, e, i, n, r) {\n              r && (i = i.replace(/\\s+$/g, \"\") + \"…\");\n              var s = e.style.textStyle,\n                  a = B.getTextWidth(t, s, i);\n              null == e.rows && (e.rows = {\n                rowWidths: [],\n                subLines: []\n              }), e.rows.rowWidths.push(a), e.rows.subLines.push({\n                font: s.font,\n                row: n,\n                text: i,\n                width: a\n              });\n            }, t.prototype.getIncludingPart = function (t, e, i, n, r, s) {\n              if (i.length <= 1) return s + B.getTextWidth(t, e, i) <= r && (n += i), n;\n              var a = i.slice(0, i.length / 2),\n                  o = B.getTextWidth(t, e, a);\n              if (s + o <= r && (n += a), s + o === r) return n;\n\n              if (s + o < r) {\n                var l = i.slice(i.length / 2, i.length);\n                return s += o, this.getIncludingPart(t, e, l, n, r, s);\n              }\n\n              return this.getIncludingPart(t, e, a, n, r, s);\n            }, t;\n          }();\n\n          W._spaceWidth = {}, s.LabelLayoutBase = W;\n\n          var V = function () {\n            function t(t, e, i, n) {\n              this.labelEnabled = null, this.labelDisabled = null, this.groupId = null, this.hoverCount = 0, this.enabled = !0, this.labelText = t, this.textColorEnabled = e, this.textColorDisabled = i, this.groupId = n;\n            }\n\n            return t.prototype.isHovered = function () {\n              return this.hoverCount > 0;\n            }, t.prototype.isEnabled = function () {\n              return this.enabled;\n            }, t;\n          }();\n\n          s.LegendEntry = V;\n\n          var Z = function () {\n            return function () {\n              this.enabled = !1, this.width = null, this.height = null, this.minWidth = null, this.minHeight = null, this.numberOfRows = null, this.numberOfColumns = null, this.margin = 1, this.padding = 5, this.maxLineSymbols = 15, this.lineSpacing = .2, this.text = {\n                font: \"12px Arial\",\n                fillColor: \"#000\"\n              }, this.marker = new X(), this.equalizeRowsColumns = !0, this.panel = new _(\"left\", \"fill\", 1), this.advanced = new q(), this.interaction = new Y();\n            };\n          }();\n\n          s.SettingsLegend = Z;\n\n          var Y = function () {\n            return function () {\n              this.click = !0;\n            };\n          }();\n\n          s.SettingsLegendInteraction = Y;\n\n          var q = function () {\n            return function () {\n              this.selectedBackground = \"rgba(208,233,255,0.3)\", this.selectedBorder = \"rgba(208,233,255,0.3)\";\n            };\n          }();\n\n          s.SettingsLegendAdvanced = q;\n\n          var _ = function (t) {\n            function e(e, i, n, r, s) {\n              var a = t.call(this, e, i, n, r) || this;\n              return a.padding = 0, void 0 !== s && (a.padding = s), a;\n            }\n\n            return r(e, t), e;\n          }(s.SettingsChartPanel);\n\n          s.SettingsLegendPanel = _;\n\n          var X = function () {\n            return function () {\n              this.size = 20, this.alignment = \"left\", this.lineColor = \"#fff\";\n            };\n          }();\n\n          s.SettingsLegendMarker = X;\n\n          var Q = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 300, i.entries = [], i.hoverPointers = {}, i.hoverOrder = [], i.entryWidth = 0, i.textHeight = 0, i.columns = null, i.rows = null, i.contentWidth = 0, i.contentHeight = 0, i.markerSize = 0, i.drawingEntries = 0, i.lastInsensitive = !1, i.needsMeasure = !1, i.chart = e, i.settings = e.settings.legend, i.panel = new I(), i.panel.packingOrder = 50, i.panel.location = \"outside\", i.panel.computeSize = function (t, e, n, r) {\n                return i.computePanelSize(t, e, n, r);\n              }, p.extendDeep(i.panel, i.settings.panel), i.orientation = \"left\" === i.settings.panel.side || \"right\" === i.settings.panel.side ? \"vertical\" : \"horizontal\", i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              var e = t.changes;\n              e.settings && e.settingsChanges.legend && (e.bounds = !0, p.extendDeep(this.panel, this.settings.panel));\n            }, e.prototype.getPanels = function () {\n              return this.settings.enabled ? [this.panel] : [];\n            }, e.prototype.computePanelSize = function (t, e, i, n) {\n              if (this.needsMeasure = !1, !this.settings.enabled || 0 === this.entries.length || !this.chart.assetsLoaded) return {\n                width: 0,\n                height: 0\n              };\n\n              for (var r = B.getTextWidth(i, this.settings.text, \"M\") * this.settings.maxLineSymbols, s = 0, a = this.settings.numberOfRows, o = this.settings.numberOfColumns, l = 2 * (this.settings.margin + this.settings.padding), h = 2 * (this.settings.panel.margin + this.settings.panel.padding), u = 0; u < this.entries.length; u++) {\n                var c = this.entries[u],\n                    d = {\n                  lineSpacing: this.settings.lineSpacing,\n                  textStyle: this.settings.text,\n                  text: c.labelText,\n                  maxWidth: r,\n                  align: \"left\",\n                  padding: 0,\n                  aspectRatio: null\n                };\n                c.labelEnabled = new G(d), c.labelEnabled.style.textStyle.fillColor = c.textColorEnabled, c.labelDisabled = new G(d), c.labelDisabled.style.textStyle.fillColor = c.textColorDisabled, n.measure(i, c.labelEnabled), n.measure(i, c.labelDisabled), s = Math.max(s, 2 * c.labelEnabled.hheight, 2 * c.labelDisabled.hheight);\n              }\n\n              this.textHeight = this.entries[0].labelEnabled.lineHeight, this.markerSize = this.settings.marker.size || this.textHeight, s = Math.max(s, this.markerSize), this.entryHeight = Math.max(s, this.markerSize) + l, this.entryWidth = r + this.markerSize + this.settings.padding + l;\n              var p,\n                  f,\n                  g = (this.settings.width > 0 ? Math.min(t, Math.max(this.settings.width, this.entryWidth) + h) : t) - h,\n                  m = (this.settings.height > 0 ? Math.min(e, Math.max(this.settings.height, this.entryHeight) + h) : e) - h;\n\n              if (\"vertical\" === this.orientation) {\n                this.rows = Math.floor(m / this.entryHeight);\n                var v = Math.min(Math.ceil(this.entries.length / this.rows), Math.max(1, Math.floor(g / this.entryWidth)));\n                this.columns = o > 0 ? Math.min(o, v) : v, this.drawingEntries = Math.min(Math.floor(m / this.entryHeight) * this.columns, this.entries.length), f = this.columns * this.entryWidth, this.drawingEntries > this.rows ? (this.settings.equalizeRowsColumns && (this.rows = Math.ceil(this.drawingEntries / this.columns)), p = this.rows * this.entryHeight) : p = this.drawingEntries * this.entryHeight;\n              }\n\n              if (\"horizontal\" === this.orientation) {\n                this.columns = Math.floor(g / this.entryWidth);\n                var y = Math.min(Math.ceil(this.entries.length / this.columns), Math.max(1, Math.floor(m / this.entryHeight)));\n                this.rows = a > 0 ? Math.min(a, y) : y, this.drawingEntries = Math.min(Math.floor(g / this.entryWidth) * this.rows, this.entries.length), p = this.rows * this.entryHeight, this.drawingEntries > this.columns ? (this.settings.equalizeRowsColumns && (this.columns = Math.ceil(this.drawingEntries / this.rows)), f = this.columns * this.entryWidth) : f = this.drawingEntries * this.entryWidth;\n              }\n\n              if (f <= 0 || p <= 0) return {\n                width: this.settings.minWidth ? this.settings.minWidth : 0,\n                height: this.settings.minHeight ? this.settings.minHeight : 0\n              };\n              this.contentHeight = p, this.contentWidth = f;\n              var S = this.settings.panel.padding;\n              return this.resetHovers(), {\n                width: Math.max(this.settings.minWidth ? this.settings.minWidth : 0, f + 2 * S),\n                height: Math.max(this.settings.minHeight ? this.settings.minHeight : 0, p + 2 * S)\n              };\n            }, e.prototype.paintScene = function (t) {\n              if (!(this.needsMeasure || !this.settings.enabled || this.entries.length < 1 || this.drawingEntries < 1)) {\n                this.lastInsensitive = !1;\n\n                for (var e = t.context, i = t.labelRenderer, n = this.panel.top, r = this.panel.left, a = this.settings.margin, o = this.settings.padding, l = this.settings.panel.padding, h = 0, u = 0, c = 0; c < this.drawingEntries; c++) {\n                  var d = l + a,\n                      p = r + d + h * this.entryWidth,\n                      f = n + d + u * this.entryHeight,\n                      g = this.entries[c],\n                      m = g.isEnabled() ? g.labelEnabled : g.labelDisabled,\n                      v = void 0,\n                      y = void 0;\n                  \"right\" === this.settings.marker.alignment ? (v = p + o + m.hwidth, y = p + this.entryWidth - 2 * (a + o) - this.markerSize / 2) : (v = p + this.markerSize + 2 * o + m.hwidth, y = p + o + this.markerSize / 2);\n                  var S = m.hheight > this.markerSize / 2 ? 0 : this.markerSize / 2 - this.textHeight / 2,\n                      b = f + o + this.markerSize / 2,\n                      C = f + S + o + m.hheight;\n\n                  if (this.drawingEntries < this.entries.length && c + 1 === this.drawingEntries) {\n                    this.lastInsensitive = !0, s.Graphics.resetTextStyle(e), e.fillStyle = \"#000\", e.textAlign = \"left\", e.font = \"bold 12px Arial\", e.fillText(\". . .\", v - m.hwidth, C);\n                    break;\n                  }\n\n                  if (g.isHovered() && this.rect(e, p, f, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * a, this.entryHeight - 2 * a), i.paint(e, v, C, 1, m), this.paintMarker(t, y, b, this.markerSize / 2, g), \"vertical\" === this.orientation) {\n                    if ((u += 1) === this.rows && (u = 0, h += 1), h === this.columns) break;\n                  } else if ((h += 1) === this.columns && (h = 0, u += 1), u === this.rows) break;\n                }\n              }\n            }, e.prototype.findItemAt = function (t, e) {\n              if (0 === this.entries.length) return null;\n              var i = this.panel.top + this.settings.panel.padding,\n                  n = this.panel.left + this.settings.panel.padding;\n              if (t < n || t > n + this.contentWidth || e < i || e > i + this.contentHeight) return null;\n              var r,\n                  s,\n                  a = \"vertical\" === this.orientation ? Math.abs(this.contentHeight / this.entryHeight) : Math.abs(this.contentWidth / this.entryWidth);\n              \"vertical\" === this.orientation ? (r = Math.floor((t - n) / this.entryWidth), s = Math.floor((e - i) / this.entryHeight)) : (r = Math.floor((e - i) / this.entryHeight), s = Math.floor((t - n) / this.entryWidth));\n              var o = Math.floor(a * r + s);\n              return o > this.drawingEntries - 1 ? null : this.lastInsensitive && o === this.drawingEntries - 1 ? null : this.entries[o];\n            }, e.prototype.rect = function (t, e, i, n, r, s, a) {\n              t.beginPath(), t.rect(e, i, s, a), t.fillStyle = r, t.fill(), t.lineWidth = 1, t.strokeStyle = n, t.stroke();\n            }, e.prototype.resetEntries = function (t) {\n              this.entries = t, this.needsMeasure = !0;\n            }, e.prototype.getLastHoveredEntry = function () {\n              return this.hoverOrder.length < 1 ? null : this.hoverOrder[this.hoverOrder.length - 1].entry;\n            }, e.prototype.resetHovers = function () {\n              for (var t = this.hoverOrder.length - 1; t >= 0; t--) {\n                var e = this.hoverOrder[t],\n                    i = this.findItemAt(e.lastX, e.lastY);\n                e.entry !== i && (i ? (this.itemUnhovered(null, e.entry), e.entry = i, this.itemHovered(null, i)) : (this.itemUnhovered(null, e.entry), delete this.hoverPointers[e.id], this.hoverOrder.splice(t, 1)));\n              }\n            }, e.prototype.pointerHoverIn = function (t) {\n              var e = this.hoverPointers[t.identifier],\n                  i = this.findItemAt(t.x, t.y);\n              return i ? (this.settings.interaction.click && (t.cursor = \"pointer\"), void (e ? (e.lastX = t.x, e.lastY = t.y, e.entry !== i && (this.itemUnhovered(t, e.entry), e.entry = i, this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1), this.hoverOrder.push(e), this.itemHovered(t, i))) : (e = {\n                id: t.identifier,\n                lastX: t.x,\n                lastY: t.y,\n                entry: i\n              }, this.hoverPointers[t.identifier] = e, this.hoverOrder.push(e), this.itemHovered(t, i)))) : void (e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1)));\n            }, e.prototype.pointerHoverOut = function (t) {\n              var e = this.hoverPointers[t.identifier];\n              e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1));\n            }, e.prototype.itemHovered = function (t, e) {\n              e.hoverCount++, 1 === e.hoverCount && this.chart.events.notifySceneChanges({\n                hover: !0\n              });\n            }, e.prototype.itemUnhovered = function (t, e) {\n              e.hoverCount--, 0 === e.hoverCount && this.chart.events.notifySceneChanges({\n                hover: !0\n              });\n            }, e.prototype.itemClicked = function (t, e) {\n              if (this.chart.events.requestPaint(), this.chart.notifyChartUpdate(\"user\", !0), t.consumed = !0, t.preventDefault(), null != e.groupId && e.enabled) {\n                var i = this.entries.filter(function (t) {\n                  return t.groupId === e.groupId;\n                });\n                if (i.length < 2) e.enabled = !e.enabled;else {\n                  for (var n = !1, r = !1, s = 0; s < i.length; s++) {\n                    if (i[s] !== e) if (i[s].enabled) {\n                      if (n = !0, r) break;\n                    } else if (r = !0, n) break;\n                  }\n\n                  if (n) {\n                    if (r) e.enabled = !e.enabled;else for (s = 0; s < i.length; s++) {\n                      i[s] !== e && (i[s].enabled = !1);\n                    }\n                  } else for (s = 0; s < i.length; s++) {\n                    i[s].enabled = !0;\n                  }\n                }\n              } else e.enabled = !e.enabled;\n            }, e.prototype.previewPointerMove = function (t) {\n              this.pointerHoverIn(t);\n            }, e.prototype.previewPointerCancel = function (t) {\n              this.pointerHoverOut(t);\n            }, e.prototype.previewPointerOut = function (t) {\n              this.pointerHoverOut(t);\n            }, e.prototype.previewPointerUp = function (t) {\n              t.touch ? this.pointerHoverOut(t) : this.pointerHoverIn(t);\n            }, e.prototype.previewPointerDown = function (t) {\n              this.pointerHoverIn(t), this.settings.interaction.click && this.hoverPointers[t.identifier] && (t.consumed = !0);\n            }, e.prototype.previewInstantClick = function (t) {\n              if (this.settings.interaction.click) {\n                var e = this.findItemAt(t.x, t.y);\n                e && this.itemClicked(t, e);\n              }\n            }, e;\n          }(A);\n\n          s.Legend = Q, function (t) {\n            var e = function () {\n              function t(t, e) {\n                this.chart = t, this.domElement = null, e instanceof $ ? this.options = e : (this.options = new $(), at.updateRecursive(this.options, e, rt.BaseSettingsToolbarItem, {}));\n              }\n\n              return t.prototype.onSceneChange = function (t) {}, t.prototype.doAnimations = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t;\n            }();\n\n            t.Item = e;\n\n            var i = function (t) {\n              function e(e, i, n, r) {\n                void 0 === r && (r = !0);\n                var s = t.call(this, e, i) || this;\n                return s.captureClick = r, s.onClickProxy = function (t) {\n                  return s.onClick(t);\n                }, s.createButton(n), s;\n              }\n\n              return r(e, t), e.prototype.createButton = function (t) {\n                this.domElement = p.createDom(\"li\", null, null, null), this.a = p.createDom(\"a\", null, null, this.domElement), this.p = t ? this.a : p.createDom(\"p\", null, null, this.a), p.listen(this.a, \"click\", this.onClickProxy), this.updateSettings();\n              }, e.prototype.updateSettings = function () {\n                var t = this.options,\n                    e = t.title || t.label || \"\",\n                    i = t.image;\n                this.a.title = e;\n                var n = \"DVSL-bar-btn \" + (t.cssClass ? t.cssClass : i ? \"DVSL-bar-btn-image\" : \"DVSL-bar-btn-none\");\n                t.enabled || (n += \" DVSL-bar-disabled\"), this.a.className = n, this.p.innerHTML = !1 !== t.showLabel && t.label || \"\", this.p.style.backgroundImage = i ? 'url(\"' + encodeURI(i) + '\")' : null;\n              }, e.prototype.remove = function () {\n                p.unlisten(this.a, \"click\", this.onClickProxy);\n              }, e.prototype.onClick = function (t) {\n                var e = this.options;\n                e.enabled && e.onClick && (e.onClick(t, this.chart.api), this.captureClick && p.stopPropagation(t));\n              }, e;\n            }(e);\n\n            t.Button = i;\n\n            var n = function (t) {\n              function e(e, i) {\n                return t.call(this, e, i) || this;\n              }\n\n              return r(e, t), e.prototype.createButton = function () {\n                t.prototype.createButton.call(this), p.createDom(\"span\", null, null, this.a), p.addClass(this.a, \"DVSL-bar-show-more\");\n              }, e.prototype.buildDropdownList = function () {\n                return [];\n              }, e.prototype.onHideDropdown = function () {}, e.prototype.onClick = function (e) {\n                this.dropdown ? this.hideDropdown() : this.showDropdown(), t.prototype.onClick.call(this, e), p.stopPropagation(e);\n              }, e.prototype.showDropdown = function () {\n                var t = this.dropdown = p.createDom(\"div\", \"DVSL-bar-dropdown\", null, this.domElement);\n                t.style.display = \"block\";\n\n                for (var e = p.createDom(\"ul\", null, null, t), i = this.buildDropdownList(), n = 0; n < i.length; n++) {\n                  var r = i[n];\n                  e.appendChild(r);\n                }\n\n                var s = t.getBoundingClientRect();\n                if (s.top < 0) t.style.marginBottom = (0 | s.top) + \"px\", t.className += \" DVSL-no-triangle\";else {\n                  var a = Math.max(window.innerHeight - s.bottom, -s.top);\n                  a < 0 && (t.style.marginTop = (0 | a) + \"px\", t.className += \" DVSL-no-triangle\");\n                }\n              }, e.prototype.hideDropdown = function () {\n                this.onHideDropdown(), this.dropdown.parentNode.removeChild(this.dropdown), this.dropdown = null, this.chart.shell.forceChromeRedraw();\n              }, e.prototype.previewPointerDown = function (t) {\n                var e = p.isParentOf(this.domElement, t.target);\n\n                if (this.dropdown && !e) {\n                  var i = p.elementPos(this.chart.shell.interactiveContainer),\n                      n = i.left,\n                      r = i.top,\n                      s = (i = p.elementPos(this.dropdown)).left,\n                      a = i.top;\n                  a -= r;\n                  var o = (s -= n) + this.dropdown.offsetWidth,\n                      l = a + this.dropdown.offsetHeight;\n                  (s > t.x || a > t.y || l < t.y || o < t.x) && this.hideDropdown();\n                }\n              }, e;\n            }(i);\n\n            t.DropdownBase = n;\n\n            var s = function (e) {\n              function i(i, n) {\n                var r = e.call(this, i, n) || this;\n                r.htmlItems = [], r.clickProxy = function () {\n                  r.hideDropdown();\n                };\n                var s = n.dropDownItems;\n                r.items = new Array(s.length);\n\n                for (var a = 0; a < s.length; a++) {\n                  r.items[a] = new t.Button(i, s[a], !0, !1);\n                }\n\n                return r;\n              }\n\n              return r(i, e), i.prototype.buildDropdownList = function () {\n                this.htmlItems = new Array(this.items.length);\n\n                for (var t = 0; t < this.items.length; t++) {\n                  var e = this.items[t];\n                  p.listen(e.domElement, \"click\", this.clickProxy), this.htmlItems[t] = e.domElement;\n                }\n\n                return this.htmlItems;\n              }, i.prototype.onHideDropdown = function () {\n                if (this.htmlItems) {\n                  for (var t = 0; t < this.htmlItems.length; t++) {\n                    var e = this.htmlItems[t];\n                    e.parentNode.removeChild(e), p.unlisten(e, \"click\", this.clickProxy);\n                  }\n\n                  this.htmlItems = null;\n                }\n              }, i;\n            }(n);\n\n            t.Dropdown = s;\n\n            var a = function (t) {\n              function e(e, i) {\n                var n = t.call(this, e, i) || this;\n                return n._lastLabel = \"\", n;\n              }\n\n              return r(e, t), e.prototype.buildDropdownList = function () {\n                for (var t = this, e = [], i = 0, n = this.getItems(); i < n.length; i++) {\n                  var r = n[i],\n                      s = p.createDom(\"li\", null, null, null),\n                      a = p.createDom(\"a\", null, r.name, s);\n                  r.selected && (a.className = \"DVSL-bar-dropdown-active\"), r.disabled ? a.className = \"DVSL-bar-dropdown-disabled\" : function (e, i) {\n                    p.listen(e, \"click\", function () {\n                      return t.userSelected(i);\n                    });\n                  }(a, r), e.push(s);\n                }\n\n                return e;\n              }, e.prototype.userSelected = function (t) {\n                this.hideDropdown(), this.setSelectedItem(t), this.onSelectionChange(t);\n              }, e.prototype.setSelectedItem = function (t) {\n                var e = t.name || \"\";\n                !1 !== this.options.showLabel && this._lastLabel !== e && (this.p.innerHTML = this._lastLabel = e);\n              }, e;\n            }(n);\n\n            t.Combobox = a;\n\n            var o = function (t) {\n              function e(e, i, n) {\n                var r = t.call(this, e, i) || this;\n                return r.additionalOptions = n, r.curState = null, r.onSceneChange({}), r;\n              }\n\n              return r(e, t), e.prototype.onSceneChange = function (t) {\n                var e = this.additionalOptions.getChartState();\n\n                if (e !== this.curState) {\n                  var i = this.options,\n                      n = this.additionalOptions;\n                  this.curState = e, i.cssClass = e && n.cssClassEnabled || n.cssClassDisabled, i.label = e && n.labelEnabled || n.labelDisabled, i.title = e && n.titleEnabled || n.titleDisabled, this.updateSettings();\n                }\n              }, e.prototype.onClick = function (e) {\n                this.options.enabled && (this.curState ? this.additionalOptions.onDisable() : this.additionalOptions.onEnable()), this.onSceneChange(null), t.prototype.onClick.call(this, e), p.stopPropagation(e);\n              }, e;\n            }(i);\n\n            t.ToggleButton = o, t.ToolbarItemNames = {};\n          }(h = s.Bar || (s.Bar = {}));\n\n          var J = function () {\n            return function (t, e, i, n, r) {\n              void 0 === t && (t = !1), this.enabled = !1, this.location = \"inside\", this.side = \"top\", this.align = \"right\", this.showLabels = !0, this.cssClass = null, this.items = [], this.extraItems = [], this.back = !0, this.export = !0, this.fullscreen = !1, this.exportOptions = null, this.zoomOut = !1, this.enabled = t, void 0 !== e && (this.items = e), void 0 !== i && (this.side = i), void 0 !== n && (this.align = n), void 0 !== r && (this.showLabels = r);\n            };\n          }();\n\n          s.SettingsToolbar = J;\n\n          var K = function () {\n            return function () {\n              this.label = null, this.title = null, this.image = null, this.enabled = !0, this.onClick = null, this.cssClass = null;\n            };\n          }();\n\n          s.SettingsToolbarItemBase = K;\n\n          var $ = function (t) {\n            function e(e, i, n, r) {\n              var s = t.call(this) || this;\n              return s.location = void 0, s.side = void 0, s.align = void 0, s.showLabel = void 0, s.item = null, s.dropDownItems = null, void 0 !== e && (s.item = e), void 0 !== i && (s.align = i), void 0 !== n && (s.side = n), void 0 !== r && (s.location = r), s;\n            }\n\n            return r(e, t), e;\n          }(K);\n\n          s.SettingsToolbarItem = $;\n\n          var tt = function (t) {\n            function e(e, i) {\n              var n = t.call(this) || this;\n              return n.panels = {}, n.panelList = [], n.items = [], n.animationOrder = 2e3, n.options = i, n.chart = e, n.scene = n.chart.scene, n.addItems(), n.chart.events.addElement(n), n.chart.events.notifySceneChanges({\n                bounds: !0\n              }), n;\n            }\n\n            return r(e, t), e.prototype.rebuildItems = function () {\n              this.removeItems(), this.addItems();\n            }, e.prototype.addItems = function () {\n              if (this.options.enabled) {\n                for (var t = 0; t < this.options.items.length; t++) {\n                  var e = this.options.items[t];\n                  this.addItem(e);\n                }\n\n                for (t = 0; t < this.options.extraItems.length; t++) {\n                  e = this.options.extraItems[t];\n                  this.addItem(e);\n                }\n              }\n            }, e.prototype.removeItems = function () {\n              for (var t = 0; t < this.items.length; t++) {\n                this.items[t].remove();\n              }\n\n              for (var e = 0; e < this.panelList.length; e++) {\n                this.panelList[e].clear();\n              }\n\n              this.items = [];\n            }, e.prototype.remove = function () {\n              this.removeItems();\n\n              for (var t = 0; t < this.panelList.length; t++) {\n                this.panelList[t].remove();\n              }\n\n              this.chart.events.removeElement(this);\n            }, e.prototype.addItem = function (t) {\n              var e,\n                  i = this.options;\n              p.isString(t) ? e = new $(t, i.align, i.side, i.location) : ((e = p.clone(t)).align = e.align || this.options.align, e.side = e.side || this.options.side, e.location = e.location || this.options.location);\n              var n,\n                  r,\n                  s = e.location + e.side;\n\n              if (this.panels.hasOwnProperty(s) ? n = this.panels[s] : (n = new et(this, e.location, e.side, this.chart), this.panelList.push(n), this.panels[s] = n), null != e.showLabel || !n.hideLabels && i.showLabels || (e.showLabel = !1), null != e.item) {\n                var a = e.item;\n                if (!1 === this.options[a]) return;\n                if (!h.ToolbarItemNames.hasOwnProperty(a)) return void this.chart.error(\"Toolbar item name '\" + a + \"' not recognized.\");\n                r = h.ToolbarItemNames[a](this.chart, e);\n              } else r = e.dropDownItems ? new h.Dropdown(this.chart, e) : new h.Button(this.chart, e);\n\n              n.addItem(r, e.align), this.items.push(r);\n            }, e.prototype.getPanels = function () {\n              return this.panelList;\n            }, e.prototype.onSceneChange = function (t) {\n              for (var e = 0; e < this.items.length; e++) {\n                this.items[e].onSceneChange(t.changes);\n              }\n            }, e.prototype.doAnimations = function (t) {\n              for (var e = 0; e < this.items.length; e++) {\n                this.items[e].doAnimations(t);\n              }\n            }, e.prototype.previewGlobalPointerDown = function (t) {\n              for (var e = 0; e < this.items.length; e++) {\n                this.items[e].previewPointerDown(t);\n              }\n            }, e;\n          }(A);\n\n          s.Toolbar = tt;\n\n          var et = function (t) {\n            function e(e, i, n, r) {\n              var s = t.call(this) || this;\n              s.hideLabels = !1, s.chart = r, s.side = n, s.location = i, s.toolbar = e, s.packingOrder = \"inside\" === i ? 1e3 : 15, s.container = s.toolbar.chart.shell.menuContainer, s.floating = !1, s.align = \"fill\";\n              var a = e.options.cssClass ? e.options.cssClass + \" \" : \"\";\n              return \"top\" === s.side ? (s.vertical = !1, s.leftPanel = p.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal\", null, s.container), s.rightPanel = p.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal\", null, s.container)) : \"bottom\" === s.side ? (s.vertical = !1, s.leftPanel = p.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal\", null, s.container), s.rightPanel = p.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal\", null, s.container)) : \"left\" === s.side ? (s.vertical = !0, s.leftPanel = p.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-top DVSL-bar-vertical\", null, s.container), s.rightPanel = p.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical\", null, s.container)) : \"right\" === s.side ? (s.vertical = !0, s.leftPanel = p.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-top DVSL-bar-vertical\", null, s.container), s.rightPanel = p.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical\", null, s.container)) : s.chart.error(\"Unrecognized side: '\" + s.side + \"'\"), s.leftPanel.style.visibility = \"hidden\", s.rightPanel.style.visibility = \"hidden\", s;\n            }\n\n            return r(e, t), e.prototype.addItem = function (t, e) {\n              \"left\" === e || \"top\" === e ? this.leftPanel.appendChild(t.domElement) : \"right\" === e || \"bottom\" === e ? this.rightPanel.appendChild(t.domElement) : this.chart.error(\"Unrecognized align: '\" + e + \"'\");\n            }, e.prototype.clear = function () {\n              this.leftPanel.innerHTML = \"\", this.rightPanel.innerHTML = \"\";\n            }, e.prototype.computeSize = function (t, e, i) {\n              var n = 0;\n\n              if (\"outside\" == this.location) {\n                var r = p.getRelativeClientRect(this.leftPanel),\n                    s = p.getRelativeClientRect(this.rightPanel);\n                this.leftPanel && r && (n += r.left), this.rightPanel && s && (n += s.right);\n              }\n\n              if (!this.vertical) {\n                this.hideLabels || this.contentWidthWithLabels || (this.contentWidthWithLabels = this.leftPanel.offsetWidth + this.rightPanel.offsetWidth);\n                var a = (this.contentWidthWithLabels, this.contentWidthWithLabels > 0 && this.contentWidthWithLabels + n > t);\n                a !== this.hideLabels && (1 == a ? -1 == this.container.className.indexOf(\"DVSL-menu-narrow\") && (this.container.className += \" DVSL-menu-narrow\") : this.container.className.indexOf(\"DVSL-menu-narrow\") > -1 && (this.container.className = this.container.className.replace(/ ?DVSL-menu-narrow/, \"\")), this.hideLabels = a);\n              }\n\n              return this.vertical ? {\n                width: Math.max(this.leftPanel.offsetWidth, this.rightPanel.offsetWidth),\n                height: 0\n              } : {\n                width: 0,\n                height: Math.max(this.leftPanel.offsetHeight, this.rightPanel.offsetHeight)\n              };\n            }, e.prototype.placePanel = function (t, e, i, n) {\n              var r = this.leftPanel,\n                  s = this.rightPanel,\n                  a = r.style,\n                  o = s.style,\n                  l = \"px\",\n                  h = this.toolbar.scene,\n                  u = h.chartHeight,\n                  c = h.chartWidth;\n              if (this.vertical) a.top = e + l, o.bottom = u - n + l, \"left\" === this.side ? (a.left = t + l, o.left = t + l) : (a.right = c - i + l, o.right = c - i + l);else {\n                a.left = t + l, o.right = c - i + l;\n                var d = \"top\" === this.side;\n\n                if (d ? (a.top = e + l, o.top = e + l) : (a.bottom = u - n + l, o.bottom = u - n + l), this.hideLabels) {\n                  var p = r.offsetLeft + r.offsetWidth;\n                  o.marginLeft = p + \"px\", s.offsetLeft < p && (d ? o.top = e + r.offsetHeight + l : o.bottom = u - n + r.offsetHeight + l);\n                }\n              }\n              r.offsetWidth > 0 && (a.visibility = \"visible\"), s.offsetWidth > 0 && (o.visibility = \"visible\");\n            }, e.prototype.remove = function () {\n              this.container.removeChild(this.leftPanel), this.container.removeChild(this.rightPanel);\n            }, e;\n          }(I);\n\n          s.ToolbarPanel = et;\n\n          var it = function () {\n            return function () {\n              this.enabled = !0, this.fixedAspect = !1, this.visibilityDistance = 45, this.grabDistance = 10;\n            };\n          }();\n\n          s.SettingsResizer = it;\n\n          var nt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 300, i.oh = 0, i.sy = 0, i.barVisible = !1, i.resizing = !1, i.aspect = null, i.chart = e, i.scene = i.chart.scene, i.options = i.scene.settings.interaction.resizing, i.resizerBar = s.Helpers.createDom(\"div\", \"DVSL-resizer\", null, i.chart.shell.interactiveContainer), i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              this.options.enabled || this.hideUI();\n            }, e.prototype.doAnimations = function (t) {\n              t.changes.bounds && this.resizerBar && (this.resizerBar.style.width = this.scene.chartWidth + \"px\");\n            }, e.prototype.onPointerOut = function (t) {\n              this.options.enabled && this.hideUI();\n            }, e.prototype.onPointerMove = function (t) {\n              if (this.options.enabled) {\n                var e = this.scene.chartHeight - t.y;\n                e < this.options.visibilityDistance ? (this.barVisible || this.showUI(), e < this.options.grabDistance && (t.consumed = !0, t.cursor = \"ns-resize\")) : this.barVisible && this.hideUI();\n              }\n            }, e.prototype.onPointerDown = function (t) {\n              if (this.options.enabled) {\n                this.sy = t.y;\n                var e = this.scene.chartHeight - t.y;\n                this.resizing = e < this.options.grabDistance && t.y <= this.scene.chartHeight, this.resizing && (this.options.fixedAspect ? this.aspect = Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight) : this.aspect = 0, this.oh = this.scene.chartHeight, this.showUI(), t.cursor = \"ns-resize\", t.consumed = !0);\n              }\n            }, e.prototype.onDoubleClick = function (t) {\n              this.resizing && this.chart.setFullscreen(!this.chart.isFullscreen());\n            }, e.prototype.onPointerDrag = function (t) {\n              if (this.options.enabled) if (this.chart.isFullscreen()) this.chart.setFullscreen(!1), this.hideUI(), t.consumed = !0;else if (this.resizing) {\n                var e = this.scene.settings.area;\n                t.consumed = !0, this.wasMaximized = !1, e.height = Math.min(e.maxHeight, Math.max(e.minHeight, this.oh + (t.y - this.sy))), this.aspect && (e.width = e.height * this.aspect), this.chart.updateSize(!0);\n              }\n            }, e.prototype.showUI = function () {\n              this.barVisible || (this.barVisible = !0, this.resizerBar.style.display = \"block\");\n            }, e.prototype.hideUI = function () {\n              this.barVisible && (this.barVisible = !1, this.resizing = !1, this.resizerBar.style.display = \"none\");\n            }, e;\n          }(A);\n\n          s.Resizer = nt;\n\n          var rt = function () {\n            return function () {};\n          }();\n\n          rt.BaseIChartErrorEventArguments = {}, rt.BaseIChartEventArguments = {}, rt.BaseIChartSettingsChangeEventArguments = {}, rt.BaseIDataErrorResponse = {\n            error: {\n              t: 0\n            }\n          }, rt.BaseIDataObjectBase = {\n            extra: {\n              t: 10\n            }\n          }, rt.BaseISettingsClassMap = {}, rt.BaseSettings = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsAdvanced;\n              },\n              x: function x() {\n                return n.Base.SettingsAdvanced;\n              }\n            },\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsArea;\n              },\n              x: function x() {\n                return n.Base.SettingsArea;\n              }\n            },\n            assetsUrlBase: {\n              t: 0\n            },\n            container: {\n              t: 3\n            },\n            credits: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsCredits;\n              },\n              x: function x() {\n                return n.Base.SettingsCredits;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.BaseSettingsData;\n                },\n                x: function x() {\n                  return n.Base.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsEvents(rt.BaseIChartEventArguments, rt.BaseIChartEventArguments);\n              },\n              x: function x() {\n                return n.Base.SettingsEvents;\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsInteraction;\n              },\n              x: function x() {\n                return n.Base.SettingsInteraction;\n              }\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegend;\n              },\n              x: function x() {\n                return n.Base.SettingsLegend;\n              }\n            },\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLocalization;\n              },\n              x: function x() {\n                return n.Base.SettingsLocalization;\n              }\n            },\n            parentChart: {\n              t: 5\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.BaseSettings;\n              },\n              x: function x() {\n                return n.Base.Settings;\n              },\n              y: !0\n            },\n            title: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTitle;\n              },\n              x: function x() {\n                return n.Base.SettingsTitle;\n              }\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsToolbar;\n              },\n              x: function x() {\n                return n.Base.SettingsToolbar;\n              }\n            }\n          }, rt.BaseSettingsAdvanced = {\n            assets: {\n              t: 6,\n              u: 3,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return {\n                      url: {\n                        t: 0\n                      },\n                      required: {\n                        t: 4\n                      }\n                    };\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            crossOriginHeader: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            dataExportFunction: {\n              t: 4\n            },\n            exportPdfSize: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            exportProxyURL: {\n              t: 0,\n              d: 5\n            },\n            highDPI: {\n              t: 7,\n              b: [{\n                t: 9\n              }, {\n                t: 1\n              }]\n            },\n            labelCache: {\n              t: 9\n            },\n            labelCacheRotated: {\n              t: 9\n            },\n            logging: {\n              t: 9\n            },\n            maxCanvasHeight: {\n              t: 1,\n              d: 0\n            },\n            maxCanvasWidth: {\n              t: 1,\n              d: 0\n            },\n            pointer: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsAdvancedPointer;\n              },\n              x: function x() {\n                return n.Base.SettingsAdvancedPointer;\n              }\n            },\n            showFPS: {\n              t: 9\n            },\n            showTimestamp: {\n              t: 9\n            },\n            showTouchTrail: {\n              t: 9\n            },\n            showTouches: {\n              t: 9\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsAdvancedStyle;\n              },\n              x: function x() {\n                return n.Base.SettingsAdvancedStyle;\n              }\n            },\n            themeCSSClass: {\n              t: 0\n            },\n            useAnimationFrame: {\n              t: 9\n            }\n          }, rt.BaseSettingsAdvancedPointer = {\n            clickSensitivity: {\n              t: 1\n            },\n            doubleClickSensitivity: {\n              t: 1\n            },\n            doubleClickTimeout: {\n              t: 1,\n              d: 0\n            },\n            longPressSensitivity: {\n              t: 1,\n              d: 0\n            },\n            longPressTimeout: {\n              t: 1,\n              d: 0\n            },\n            mouseWheelRequiresFocus: {\n              t: 9\n            },\n            noClickOnDoubleClick: {\n              t: 9\n            },\n            scrollIntoView: {\n              t: 9\n            },\n            speedAveragingPeriod: {\n              t: 1,\n              d: 0\n            }\n          }, rt.BaseSettingsAdvancedStyle = {\n            loadingArcStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  lineColor: {\n                    t: 0\n                  },\n                  lineWidth: {\n                    t: 1\n                  },\n                  location: {\n                    t: 0,\n                    d: 6\n                  },\n                  r: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            messageBackgroundStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsAdvancedStyleMessageBackground;\n              }\n            },\n            messageTextStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTextStyle;\n              }\n            }\n          }, rt.BaseSettingsAdvancedStyleMessageBackground = {\n            padding: {\n              t: 1\n            }\n          }, rt.BaseSettingsArea = {\n            height: {\n              t: 1\n            },\n            left: {\n              t: 1\n            },\n            maxHeight: {\n              t: 1\n            },\n            maxWidth: {\n              t: 1\n            },\n            minHeight: {\n              t: 1\n            },\n            minWidth: {\n              t: 1\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsAreaStyle;\n              },\n              x: function x() {\n                return n.Base.SettingsAreaStyle;\n              }\n            },\n            top: {\n              t: 1\n            },\n            width: {\n              t: 1\n            }\n          }, rt.BaseSettingsAreaStyle = {\n            fillColor: {\n              t: 0,\n              d: 3\n            },\n            image: {\n              t: 0,\n              d: 4\n            },\n            overlayColor: {\n              t: 0,\n              d: 3\n            }\n          }, rt.BaseSettingsBackgroundStyle = {\n            fillColor: {\n              t: 7,\n              b: [{\n                t: 14\n              }, {\n                t: 0\n              }]\n            },\n            shadowBlur: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0\n            },\n            shadowOffsetX: {\n              t: 1\n            },\n            shadowOffsetY: {\n              t: 1\n            }\n          }, rt.BaseSettingsChartPanel = {\n            align: {\n              t: 0,\n              d: 6\n            },\n            floating: {\n              t: 9\n            },\n            location: {\n              t: 0,\n              d: 6\n            },\n            margin: {\n              t: 1\n            },\n            side: {\n              t: 0,\n              d: 6\n            }\n          }, rt.BaseSettingsCredits = {\n            enabled: {\n              t: 9\n            },\n            enabledOnExport: {\n              t: 9\n            },\n            image: {\n              t: 0,\n              d: 4\n            },\n            imageExport: {\n              t: 0,\n              d: 4\n            },\n            imageScaling: {\n              t: 1\n            },\n            location: {\n              t: 0,\n              d: 6\n            },\n            url: {\n              t: 0,\n              d: 5\n            },\n            urlTarget: {\n              t: 0\n            }\n          }, rt.BaseSettingsData = {\n            format: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            id: {\n              t: 0\n            },\n            numberOfParallelRequests: {\n              t: 1,\n              d: 0\n            },\n            postprocessorFunction: {\n              t: 4\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.BaseIDataErrorResponse;\n              }\n            },\n            requestTimeout: {\n              t: 1,\n              d: 0\n            },\n            url: {\n              t: 0,\n              d: 5\n            },\n            urlParameters: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    name: {\n                      t: 0\n                    },\n                    value: {\n                      t: 0\n                    }\n                  };\n                }\n              }]\n            }\n          }, rt.BaseSettingsEvents = function (t, e) {\n            return {\n              chartUpdateDelay: {\n                t: 1,\n                d: 0\n              },\n              onChartUpdate: {\n                t: 4\n              },\n              onClick: {\n                t: 4\n              },\n              onDoubleClick: {\n                t: 4\n              },\n              onError: {\n                t: 4\n              },\n              onHoverChange: {\n                t: 4\n              },\n              onPositionChange: {\n                t: 4\n              },\n              onRightClick: {\n                t: 4\n              },\n              onSelectionChange: {\n                t: 4\n              },\n              onSettingsChange: {\n                t: 4\n              },\n              onTripleClick: {\n                t: 4\n              }\n            };\n          }, rt.BaseSettingsInteraction = {\n            resizing: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsResizer;\n              },\n              x: function x() {\n                return n.Base.SettingsResizer;\n              }\n            }\n          }, rt.BaseSettingsLabelStyle = {\n            align: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            angle: {\n              t: 1,\n              d: 0\n            },\n            aspectRatio: {\n              t: 1\n            },\n            backgroundStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsBackgroundStyle;\n              }\n            },\n            borderRadius: {\n              t: 1\n            },\n            extra: {\n              t: 10\n            },\n            image: {\n              t: 0,\n              d: 4\n            },\n            imageSlicing: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }, {\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            lineSpacing: {\n              t: 1\n            },\n            margin: {\n              t: 1\n            },\n            maxWidth: {\n              t: 1\n            },\n            padding: {\n              t: 1\n            },\n            text: {\n              t: 0\n            },\n            textStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTextStyle;\n              }\n            }\n          }, rt.BaseSettingsLegend = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendAdvanced;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendAdvanced;\n              }\n            },\n            enabled: {\n              t: 9\n            },\n            equalizeRowsColumns: {\n              t: 9\n            },\n            height: {\n              t: 1\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendInteraction;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendInteraction;\n              }\n            },\n            lineSpacing: {\n              t: 1\n            },\n            margin: {\n              t: 1\n            },\n            marker: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendMarker;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendMarker;\n              }\n            },\n            maxLineSymbols: {\n              t: 1,\n              d: 0\n            },\n            minHeight: {\n              t: 1\n            },\n            minWidth: {\n              t: 1\n            },\n            numberOfColumns: {\n              t: 1,\n              d: 0\n            },\n            numberOfRows: {\n              t: 1,\n              d: 0\n            },\n            padding: {\n              t: 1\n            },\n            panel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendPanel;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendPanel;\n              }\n            },\n            text: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTextStyle;\n              }\n            },\n            width: {\n              t: 1\n            }\n          }, rt.BaseSettingsLegendAdvanced = {\n            selectedBackground: {\n              t: 0,\n              d: 3\n            },\n            selectedBorder: {\n              t: 0,\n              d: 3\n            }\n          }, rt.BaseSettingsLegendInteraction = {\n            click: {\n              t: 9\n            }\n          }, rt.BaseSettingsLegendMarker = {\n            alignment: {\n              t: 0,\n              d: 6\n            },\n            lineColor: {\n              t: 0,\n              d: 3\n            },\n            size: {\n              t: 1\n            }\n          }, rt.BaseSettingsLegendPanel = {\n            padding: {\n              t: 1\n            }\n          }, rt.BaseSettingsLineStyle = {\n            lineColor: {\n              t: 0\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineWidth: {\n              t: 1\n            }\n          }, rt.BaseSettingsLocalization = {\n            closeButton: {\n              t: 0\n            },\n            dataRequestFailed: {\n              t: 0\n            },\n            exportNotAvailable: {\n              t: 0\n            },\n            loadingLabel: {\n              t: 0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLocalizationToolbar;\n              },\n              x: function x() {\n                return n.Base.SettingsLocalizationToolbar;\n              }\n            }\n          }, rt.BaseSettingsLocalizationToolbar = {\n            backButton: {\n              t: 0\n            },\n            backTitle: {\n              t: 0\n            },\n            exportButton: {\n              t: 0\n            },\n            exportCSV: {\n              t: 0\n            },\n            exportJpeg: {\n              t: 0\n            },\n            exportPDF: {\n              t: 0\n            },\n            exportPNG: {\n              t: 0\n            },\n            exportTitle: {\n              t: 0\n            },\n            exportXLS: {\n              t: 0\n            },\n            fullscreenButton: {\n              t: 0\n            },\n            fullscreenTitle: {\n              t: 0\n            },\n            zoomoutButton: {\n              t: 0\n            },\n            zoomoutTitle: {\n              t: 0\n            }\n          }, rt.BaseSettingsResizer = {\n            enabled: {\n              t: 9\n            },\n            fixedAspect: {\n              t: 9\n            },\n            grabDistance: {\n              t: 1\n            },\n            visibilityDistance: {\n              t: 1\n            }\n          }, rt.BaseSettingsTextStyle = {\n            fillColor: {\n              t: 0\n            },\n            font: {\n              t: 0\n            },\n            outlineColor: {\n              t: 0\n            },\n            outlineJoin: {\n              t: 0,\n              d: 6\n            },\n            outlineWidth: {\n              t: 1\n            },\n            shadowBlur: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0\n            },\n            shadowOffsetX: {\n              t: 1\n            },\n            shadowOffsetY: {\n              t: 1\n            }\n          }, rt.BaseSettingsTitle = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  addAfterToolbar: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            align: {\n              t: 0,\n              d: 6\n            },\n            enabled: {\n              t: 9\n            },\n            enabledOnExport: {\n              t: 9\n            },\n            margin: {\n              t: 1\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  },\n                  font: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            text: {\n              t: 0\n            }\n          }, rt.BaseSettingsToolbar = {\n            align: {\n              t: 0,\n              d: 6\n            },\n            back: {\n              t: 9\n            },\n            cssClass: {\n              t: 0\n            },\n            enabled: {\n              t: 9\n            },\n            export: {\n              t: 9\n            },\n            exportOptions: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                b: [{\n                  t: 0\n                }]\n              }]\n            },\n            extraItems: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return rt.BaseSettingsToolbarItem;\n                  },\n                  x: function x() {\n                    return n.Base.SettingsToolbarItem;\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            fullscreen: {\n              t: 9\n            },\n            items: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return rt.BaseSettingsToolbarItem;\n                  },\n                  x: function x() {\n                    return n.Base.SettingsToolbarItem;\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            location: {\n              t: 0,\n              d: 6\n            },\n            showLabels: {\n              t: 9\n            },\n            side: {\n              t: 0,\n              d: 6\n            },\n            zoomOut: {\n              t: 9\n            }\n          }, rt.BaseSettingsToolbarItem = {\n            align: {\n              t: 0,\n              d: 6\n            },\n            dropDownItems: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.BaseSettingsToolbarItemBase;\n                },\n                x: function x() {\n                  return n.Base.SettingsToolbarItemBase;\n                }\n              }]\n            },\n            item: {\n              t: 0,\n              d: 6\n            },\n            location: {\n              t: 0,\n              d: 6\n            },\n            showLabel: {\n              t: 9\n            },\n            side: {\n              t: 0,\n              d: 6\n            }\n          }, rt.BaseSettingsToolbarItemBase = {\n            cssClass: {\n              t: 0\n            },\n            enabled: {\n              t: 9\n            },\n            image: {\n              t: 0,\n              d: 4\n            },\n            label: {\n              t: 0\n            },\n            onClick: {\n              t: 4\n            },\n            title: {\n              t: 0\n            }\n          }, rt.FacetChartIChartClickEventArguments = {}, rt.FacetChartIChartEventArguments = {}, rt.FacetChartIDataObject = {\n            id: {\n              t: 0\n            },\n            name: {\n              t: 0\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsFacetStyle;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsFacetStyle;\n              }\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.FacetChartIDataObject;\n                }\n              }]\n            },\n            value: {\n              t: 1\n            }\n          }, rt.FacetChartIDataObjectCommon = {\n            id: {\n              t: 0\n            },\n            name: {\n              t: 0\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.FacetChartIDataObject;\n                }\n              }]\n            }\n          }, rt.FacetChartIDataObjectRoot = {\n            afterSum: {\n              t: 1\n            },\n            beforeSum: {\n              t: 1\n            },\n            id: {\n              t: 0\n            },\n            limit: {\n              t: 1\n            },\n            name: {\n              t: 0\n            },\n            offset: {\n              t: 1\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.FacetChartIDataObject;\n                }\n              }]\n            },\n            sum: {\n              t: 1\n            }\n          }, rt.FacetChartSettings = {\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsArea;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsArea;\n              }\n            },\n            chartTypes: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  columns: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.FacetChartSettingsSeriesColumns;\n                    },\n                    x: function x() {\n                      return n.FacetChart.SettingsSeriesColumns;\n                    },\n                    y: !0\n                  },\n                  line: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.FacetChartSettingsSeriesLines;\n                    },\n                    x: function x() {\n                      return n.FacetChart.SettingsSeriesLines;\n                    },\n                    y: !0\n                  }\n                };\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.FacetChartSettingsData;\n                },\n                x: function x() {\n                  return n.FacetChart.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsEvents(rt.FacetChartIChartEventArguments, rt.FacetChartIChartClickEventArguments);\n              },\n              x: function x() {\n                return n.LinearChart.SettingsEvents;\n              }\n            },\n            facetAxis: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsFacetAxis;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsFacetAxis;\n              }\n            },\n            filters: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  allowZeroValues: {\n                    t: 9\n                  },\n                  sliceFilter: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsInteraction;\n              }\n            },\n            items: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  style: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        expandable: {\n                          t: 9\n                        },\n                        label: {\n                          t: 0\n                        }\n                      };\n                    }\n                  },\n                  styleFunction: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLegend;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLegend;\n              }\n            },\n            navigation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  initialDrilldown: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 0\n                    }]\n                  },\n                  initialOffset: {\n                    t: 1,\n                    d: 0\n                  }\n                };\n              }\n            },\n            scrollButtons: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsScrollButtons;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsScrollButtons;\n              }\n            },\n            series: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.FacetChartSettingsSeries;\n                },\n                x: function x() {\n                  return n.FacetChart.SettingsSeries;\n                },\n                y: !0\n              }]\n            },\n            seriesDefault: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeries;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeries;\n              },\n              y: !0\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.FacetChartSettings;\n              },\n              x: function x() {\n                return n.FacetChart.Settings;\n              },\n              y: !0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsToolbar;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsToolbar;\n              }\n            }\n          }, rt.FacetChartSettingsArea = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsAreaStyle;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsAreaStyle;\n              }\n            }\n          }, rt.FacetChartSettingsAreaStyle = {\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsAreaStyleSelection;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsAreaStyleSelection;\n              }\n            }\n          }, rt.FacetChartSettingsAreaStyleSelection = {\n            behindSeries: {\n              t: 9\n            },\n            fillColor: {\n              t: 0\n            },\n            lineColor: {\n              t: 0\n            },\n            lineWidth: {\n              t: 1\n            }\n          }, rt.FacetChartSettingsData = {\n            dataFunction: {\n              t: 4\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.FacetChartIDataObjectRoot;\n              }\n            },\n            sortField: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 4\n              }, {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }, {\n                t: 0\n              }]\n            }\n          }, rt.FacetChartSettingsFacetAxis = {\n            defaultUnitWidth: {\n              t: 1\n            },\n            enabled: {\n              t: 9\n            },\n            labels: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsFacetAxisLabels;\n              }\n            },\n            maxUnitWidth: {\n              t: 1\n            },\n            size: {\n              t: 1\n            },\n            title: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsFacetAxisTitleStyle;\n              }\n            },\n            zoomOutUnitWidth: {\n              t: 1\n            }\n          }, rt.FacetChartSettingsFacetAxisLabels = {\n            allowOverflow: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            interLabelSpacing: {\n              t: 1\n            },\n            text: {\n              t: 0\n            }\n          }, rt.FacetChartSettingsFacetAxisTitleStyle = {\n            enabled: {\n              t: 9\n            },\n            text: {\n              t: 0\n            },\n            useFacetName: {\n              t: 9\n            }\n          }, rt.FacetChartSettingsFacetStyle = {\n            expandable: {\n              t: 9\n            }\n          }, rt.FacetChartSettingsInteraction = {\n            animation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  scrollDuration: {\n                    t: 1,\n                    d: 0\n                  }\n                };\n              }\n            },\n            mode: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsInteractionSelection;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsInteractionSelection;\n              }\n            }\n          }, rt.FacetChartSettingsInteractionSelection = {\n            enabled: {\n              t: 9\n            },\n            tolerance: {\n              t: 1\n            }\n          }, rt.FacetChartSettingsScrollButtons = {\n            enabled: {\n              t: 9\n            },\n            enabledOnExport: {\n              t: 9\n            },\n            size: {\n              t: 1\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  },\n                  hoverFillColor: {\n                    t: 0\n                  },\n                  hoverLineColor: {\n                    t: 0\n                  },\n                  lineColor: {\n                    t: 0\n                  }\n                };\n              }\n            }\n          }, rt.FacetChartSettingsSeries = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeriesData;\n              }\n            },\n            type: {\n              t: 0,\n              d: 6\n            }\n          }, rt.FacetChartSettingsSeriesColumns = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeriesData;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeriesColumnsStyle;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeriesColumnsStyle;\n              }\n            }\n          }, rt.FacetChartSettingsSeriesColumnsStyle = {\n            previewContents: {\n              t: 9\n            },\n            previewLineColor: {\n              t: 0\n            }\n          }, rt.FacetChartSettingsSeriesData = {\n            field: {\n              t: 0\n            },\n            valueFunction: {\n              t: 4\n            }\n          }, rt.FacetChartSettingsSeriesLines = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeriesData;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.FacetChartSettingsSeriesLinesStyle;\n              },\n              x: function x() {\n                return n.FacetChart.SettingsSeriesLinesStyle;\n              }\n            }\n          }, rt.FacetChartSettingsSeriesLinesStyle = {\n            markerStyleFunction: {\n              t: 4\n            }\n          }, rt.FacetChartSettingsToolbar = {\n            enabled: {\n              t: 9\n            },\n            items: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.BaseSettingsToolbarItem;\n                },\n                x: function x() {\n                  return n.Base.SettingsToolbarItem;\n                }\n              }]\n            },\n            logScale: {\n              t: 9\n            },\n            zoomOut: {\n              t: 9\n            }\n          }, rt.GeoChartIAggregationDataObjectNode = {\n            aggregatedNodes: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartIGeoDataObjectNode;\n                }\n              }]\n            },\n            aggregatedWeight: {\n              t: 1\n            }\n          }, rt.GeoChartIDataObject = {\n            clearCache: {\n              t: 9\n            },\n            east: {\n              t: 1\n            },\n            links: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartIGeoDataObjectLink;\n                }\n              }]\n            },\n            nodes: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartIGeoDataObjectNode;\n                }\n              }]\n            },\n            north: {\n              t: 1\n            },\n            south: {\n              t: 1\n            },\n            west: {\n              t: 1\n            }\n          }, rt.GeoChartIGeoDataObjectLink = {}, rt.GeoChartIGeoDataObjectNode = {\n            aggregate: {\n              t: 9\n            },\n            coordinates: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 6,\n                  u: 0,\n                  b: [{\n                    t: 1\n                  }]\n                }]\n              }, {\n                t: 12,\n                b: [{\n                  t: 1\n                }, {\n                  t: 1\n                }]\n              }]\n            },\n            count: {\n              t: 1\n            },\n            shapeFeature: {\n              t: 10\n            },\n            shapeGeometry: {\n              t: 10\n            },\n            type: {\n              t: 0\n            }\n          }, rt.GeoChartSettings = {\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsArea;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsArea;\n              }\n            },\n            background: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsBackground;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsBackground;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartSettingsData;\n                },\n                x: function x() {\n                  return n.GeoChart.SettingsData;\n                }\n              }]\n            },\n            filters: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  nodeFilter: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsInteraction;\n              }\n            },\n            layerTypes: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  aggregateOnShapes: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.GeoChartSettingsLayerAggregated;\n                    },\n                    x: function x() {\n                      return n.GeoChart.SettingsLayerAggregated;\n                    },\n                    y: !0\n                  },\n                  charts: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.GeoChartSettingsLayerCharts;\n                    },\n                    x: function x() {\n                      return n.GeoChart.SettingsLayerCharts;\n                    },\n                    y: !0\n                  },\n                  items: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.GeoChartSettingsLayerItems;\n                    },\n                    x: function x() {\n                      return n.GeoChart.SettingsLayerItems;\n                    },\n                    y: !0\n                  },\n                  shapes: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.GeoChartSettingsLayerShapes;\n                    },\n                    x: function x() {\n                      return n.GeoChart.SettingsLayerShapes;\n                    },\n                    y: !0\n                  }\n                };\n              }\n            },\n            layers: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartSettingsLayerBase;\n                },\n                x: function x() {\n                  return n.GeoChart.SettingsLayerBase;\n                },\n                y: !0\n              }]\n            },\n            layersDefault: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsLayerBase;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsLayerBase;\n              },\n              y: !0\n            },\n            navigation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  drilldownLayer: {\n                    t: 0\n                  },\n                  initialDrilldown: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 0\n                    }]\n                  },\n                  initialLat: {\n                    t: 1\n                  },\n                  initialLng: {\n                    t: 1\n                  },\n                  initialZoom: {\n                    t: 1\n                  },\n                  maxBounds: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        east: {\n                          t: 1\n                        },\n                        north: {\n                          t: 1\n                        },\n                        south: {\n                          t: 1\n                        },\n                        west: {\n                          t: 1\n                        }\n                      };\n                    }\n                  },\n                  maxZoom: {\n                    t: 1\n                  },\n                  minZoom: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fadeTime: {\n                    t: 1\n                  },\n                  selection: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        fillColor: {\n                          t: 0\n                        },\n                        sizeConstant: {\n                          t: 1\n                        },\n                        sizeProportional: {\n                          t: 1\n                        }\n                      };\n                    }\n                  }\n                };\n              }\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.GeoChartSettings;\n              },\n              x: function x() {\n                return n.GeoChart.Settings;\n              },\n              y: !0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsToolbar;\n              },\n              x: function x() {\n                return n.Base.SettingsToolbar;\n              }\n            }\n          }, rt.GeoChartSettingsAggregatedShapeStyle = {\n            mode: {\n              t: 2,\n              e: function e() {\n                return i.GeoChartSettingsAggregatedShapeStyleMode;\n              }\n            }\n          }, rt.GeoChartSettingsAggregation = {\n            distance: {\n              t: 1,\n              d: 0\n            },\n            enabled: {\n              t: 9\n            },\n            ignoreZeroWeight: {\n              t: 9\n            },\n            maxZoom: {\n              t: 1,\n              d: 0\n            },\n            postProcessAggregatedNodes: {\n              t: 4\n            },\n            weightFunction: {\n              t: 4\n            }\n          }, rt.GeoChartSettingsArea = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsAreaStyle;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsAreaStyle;\n              }\n            }\n          }, rt.GeoChartSettingsAreaStyle = {}, rt.GeoChartSettingsBackground = {\n            enabled: {\n              t: 9\n            },\n            params: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartSettingsBackgroundParams;\n                }\n              }, {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.GeoChartSettingsWmsParams;\n                }\n              }]\n            },\n            type: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            url: {\n              t: 0\n            }\n          }, rt.GeoChartSettingsBackgroundParams = {\n            attribution: {\n              t: 0\n            },\n            continuousWorld: {\n              t: 9\n            },\n            detectRetina: {\n              t: 9\n            },\n            errorTileUrl: {\n              t: 0\n            },\n            maxNativeZoom: {\n              t: 1\n            },\n            maxZoom: {\n              t: 1\n            },\n            minZoom: {\n              t: 1\n            },\n            noWrap: {\n              t: 9\n            },\n            opacity: {\n              t: 1\n            },\n            reuseTiles: {\n              t: 9\n            },\n            subdomains: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }, {\n                t: 0\n              }]\n            },\n            tileSize: {\n              t: 1\n            },\n            tms: {\n              t: 9\n            },\n            unloadInvisibleTiles: {\n              t: 9\n            },\n            updateWhenIdle: {\n              t: 9\n            },\n            zIndex: {\n              t: 1\n            },\n            zoomOffset: {\n              t: 1\n            },\n            zoomReverse: {\n              t: 9\n            }\n          }, rt.GeoChartSettingsData = {\n            aggregationGridSize: {\n              t: 1\n            },\n            aggregationMinCount: {\n              t: 1\n            },\n            bounds: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }, {\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            dataFunction: {\n              t: 4\n            },\n            maxRequestRect: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            perBoundsData: {\n              t: 9\n            },\n            perDrilldownData: {\n              t: 9\n            },\n            perZoomData: {\n              t: 9\n            },\n            prefetchRatio: {\n              t: 1\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.GeoChartIDataObject;\n              }\n            },\n            useGridBasedAggregation: {\n              t: 9\n            },\n            wrapLng: {\n              t: 9\n            }\n          }, rt.GeoChartSettingsInteraction = {\n            mode: {\n              t: 0,\n              d: 6\n            },\n            zooming: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsInteractionZooming;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsInteractionZooming;\n              }\n            }\n          }, rt.GeoChartSettingsInteractionZooming = {\n            zoomInOnDoubleClick: {\n              t: 9\n            }\n          }, rt.GeoChartSettingsLayerAggregated = {\n            aggregation: {\n              t: 0,\n              d: 6\n            },\n            aggregationField: {\n              t: 0\n            },\n            aggregationFunction: {\n              t: 4\n            },\n            shapesLayer: {\n              t: 0\n            },\n            styleFunction: {\n              t: 4\n            }\n          }, rt.GeoChartSettingsLayerBase = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  id: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            enabled: {\n              t: 9\n            },\n            id: {\n              t: 0\n            },\n            maxZoom: {\n              t: 1,\n              d: 0\n            },\n            minZoom: {\n              t: 1,\n              d: 0\n            },\n            name: {\n              t: 0\n            },\n            perZoomStyle: {\n              t: 9\n            },\n            type: {\n              t: 0,\n              d: 6\n            }\n          }, rt.GeoChartSettingsLayerCharts = {\n            chartType: {\n              t: 0,\n              d: 6\n            },\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  id: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            settings: {\n              t: 7,\n              b: [{\n                t: 5,\n                c: function c() {\n                  return rt.FacetChartSettings;\n                },\n                x: function x() {\n                  return n.FacetChart.Settings;\n                },\n                y: !0\n              }, {\n                t: 5,\n                c: function c() {\n                  return rt.PieChartSettings;\n                },\n                x: function x() {\n                  return n.PieChart.Settings;\n                },\n                y: !0\n              }, {\n                t: 5,\n                c: function c() {\n                  return rt.TimeChartSettings;\n                },\n                x: function x() {\n                  return n.TimeChart.Settings;\n                },\n                y: !0\n              }]\n            },\n            settingsFunction: {\n              t: 4\n            },\n            shapesLayer: {\n              t: 0\n            }\n          }, rt.GeoChartSettingsLayerItems = {\n            aggregation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsAggregation;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsAggregation;\n              }\n            },\n            auras: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodesLayerAuras;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsNodesLayerAuras;\n              }\n            },\n            layout: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsNodesLayout;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsNodesLayout;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsNodesLayerStyle;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsNodesLayerStyle;\n              }\n            }\n          }, rt.GeoChartSettingsLayerOverlay = {\n            shapesLayer: {\n              t: 0\n            }\n          }, rt.GeoChartSettingsLayerShapes = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsShapesLayerStyle;\n              },\n              x: function x() {\n                return n.GeoChart.SettingsShapesLayerStyle;\n              }\n            }\n          }, rt.GeoChartSettingsNodesLayerStyle = {\n            aggregatedShape: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsAggregatedShapeStyle;\n              }\n            }\n          }, rt.GeoChartSettingsNodesLayout = {\n            anchorStrength: {\n              t: 1\n            },\n            mode: {\n              t: 0,\n              d: 6\n            },\n            nodeSpacing: {\n              t: 1,\n              d: 0\n            }\n          }, rt.GeoChartSettingsShapesLayerNodeStyle = {\n            expandable: {\n              t: 9\n            }\n          }, rt.GeoChartSettingsShapesLayerStyle = {\n            node: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.GeoChartSettingsShapesLayerNodeStyle;\n              }\n            },\n            shapeSimplificationPrecision: {\n              t: 1\n            }\n          }, rt.GeoChartSettingsWmsParams = {\n            format: {\n              t: 0\n            },\n            layers: {\n              t: 0\n            },\n            styles: {\n              t: 0\n            },\n            transparent: {\n              t: 9\n            },\n            version: {\n              t: 0\n            }\n          }, rt.ItemsChartIChartClickEventArguments = {}, rt.ItemsChartIChartEventArguments = {}, rt.ItemsChartIDataObjectBase = {}, rt.ItemsChartIDataObjectLink = {\n            className: {\n              t: 0\n            },\n            from: {\n              t: 0\n            },\n            id: {\n              t: 0\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkStyle;\n              }\n            },\n            to: {\n              t: 0\n            }\n          }, rt.ItemsChartIDataObjectNode = {\n            className: {\n              t: 0\n            },\n            id: {\n              t: 0\n            },\n            loaded: {\n              t: 9\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            }\n          }, rt.ItemsChartSettings = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsAdvanced;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsAdvanced;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsData;\n                },\n                x: function x() {\n                  return n.ItemsChart.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsEvents(rt.ItemsChartIChartEventArguments, rt.ItemsChartIChartClickEventArguments);\n              },\n              x: function x() {\n                return n.Base.SettingsEvents;\n              }\n            },\n            info: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  enabled: {\n                    t: 9\n                  },\n                  linkContentsFunction: {\n                    t: 4\n                  },\n                  nodeContentsFunction: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsInteraction;\n              }\n            },\n            linkMenu: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkMenu;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsLinkMenu;\n              }\n            },\n            nodeMenu: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeMenu;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsNodeMenu;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {};\n              }\n            }\n          }, rt.ItemsChartSettingsAdvanced = {\n            perNodeLoadingIndicator: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsAuraStyle = {\n            enabled: {\n              t: 9\n            },\n            legendGroupId: {\n              t: 0\n            },\n            nameLegend: {\n              t: 0\n            },\n            showInLegend: {\n              t: 9\n            },\n            zIndex: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsCustomShape = {\n            distanceToEdge: {\n              t: 4\n            },\n            hitTest: {\n              t: 4\n            },\n            onUpdate: {\n              t: 4\n            },\n            paint: {\n              t: 4\n            },\n            paintSelection: {\n              t: 4\n            }\n          }, rt.ItemsChartSettingsData = {\n            cacheSize: {\n              t: 1,\n              d: 0\n            },\n            random: {\n              t: 0,\n              d: 6\n            },\n            randomGridLinkProbability: {\n              t: 1\n            },\n            randomLinks: {\n              t: 1,\n              d: 0\n            },\n            randomNodes: {\n              t: 1,\n              d: 0\n            },\n            randomTreeDensity: {\n              t: 1\n            },\n            requestMaxUnits: {\n              t: 1,\n              d: 0\n            }\n          }, rt.ItemsChartSettingsInteraction = {\n            nodesMovable: {\n              t: 9\n            },\n            panning: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  enabled: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsInteractionSelection;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsInteractionSelection;\n              }\n            },\n            zooming: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsInteractionZooming;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsInteractionZooming;\n              }\n            }\n          }, rt.ItemsChartSettingsInteractionSelection = {\n            allowMoveNodesOffscreen: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            linksSelectable: {\n              t: 9\n            },\n            lockNodesOnMove: {\n              t: 9\n            },\n            nodesSelectable: {\n              t: 9\n            },\n            tolerance: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsInteractionZooming = {\n            autoZoomAfterClick: {\n              t: 9\n            },\n            doubleClickZoom: {\n              t: 1\n            },\n            fingers: {\n              t: 9\n            },\n            sensitivity: {\n              t: 1\n            },\n            wheel: {\n              t: 9\n            },\n            zoomInOnDoubleClick: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsItemClass = {\n            className: {\n              t: 0\n            },\n            legendGroupId: {\n              t: 0\n            },\n            nameLegend: {\n              t: 0\n            },\n            showInLegend: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsItemsLayerItemStyle = {\n            hoverEffect: {\n              t: 9\n            },\n            zIndex: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsItemsLayerLabelStyle = {\n            scaleWithSize: {\n              t: 9\n            },\n            scaleWithZoom: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsItemsLayerLinkLabelStyle = {\n            rotateWithLink: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsItemsLayerStyle = {\n            allObjectsStyleFunction: {\n              t: 4\n            },\n            item: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsItemsLayerItemStyle;\n              }\n            },\n            link: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkStyle;\n              }\n            },\n            linkClasses: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsLinkClass;\n                },\n                x: function x() {\n                  return n.ItemsChart.SettingsLinkClass;\n                }\n              }]\n            },\n            linkDecorationMinSize: {\n              t: 1\n            },\n            linkDecorationScale: {\n              t: 1\n            },\n            linkDetailMinSize: {\n              t: 1\n            },\n            linkDetailMinZoom: {\n              t: 1\n            },\n            linkHovered: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkStyle;\n              }\n            },\n            linkLabel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsItemsLayerLinkLabelStyle;\n              }\n            },\n            linkLabelScaleBase: {\n              t: 1\n            },\n            linkRules: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 4\n              }]\n            },\n            linkSelected: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkStyle;\n              }\n            },\n            linkStyleFunction: {\n              t: 4\n            },\n            node: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeAnchor: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeAnchorStyle;\n              }\n            },\n            nodeBackground: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeClasses: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsNodeClass;\n                },\n                x: function x() {\n                  return n.ItemsChart.SettingsNodeClass;\n                }\n              }]\n            },\n            nodeDetailMinSize: {\n              t: 1\n            },\n            nodeDetailMinZoom: {\n              t: 1\n            },\n            nodeExpanded: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeFocused: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeHovered: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeLabel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsItemsLayerLabelStyle;\n              }\n            },\n            nodeLabelScaleBase: {\n              t: 1\n            },\n            nodeLocked: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeNotLoaded: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeRules: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 4\n              }]\n            },\n            nodeSelected: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            },\n            nodeStyleFunction: {\n              t: 4\n            },\n            removedColor: {\n              t: 0,\n              d: 3\n            },\n            scaleLinksWithZoom: {\n              t: 9\n            },\n            scaleObjectsWithZoom: {\n              t: 9\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  enabled: {\n                    t: 9\n                  },\n                  fillColor: {\n                    t: 0\n                  },\n                  lineColor: {\n                    t: 0\n                  },\n                  lineWidth: {\n                    t: 1\n                  },\n                  shadowBlur: {\n                    t: 1\n                  },\n                  shadowColor: {\n                    t: 0\n                  },\n                  shadowOffsetX: {\n                    t: 1\n                  },\n                  shadowOffsetY: {\n                    t: 1\n                  },\n                  sizeConstant: {\n                    t: 1\n                  },\n                  sizeProportional: {\n                    t: 1\n                  }\n                };\n              }\n            }\n          }, rt.ItemsChartSettingsLinkClass = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsLinkStyle;\n              }\n            }\n          }, rt.ItemsChartSettingsLinkItem = {\n            lx: {\n              t: 1\n            },\n            ly: {\n              t: 1\n            },\n            px: {\n              t: 1\n            },\n            py: {\n              t: 1\n            },\n            rotateWithLink: {\n              t: 9\n            },\n            x: {\n              t: 1\n            },\n            y: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsLinkMenu = {\n            buttons: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsMenuButton;\n                },\n                x: function x() {\n                  return n.ItemsChart.SettingsMenuButton;\n                }\n              }]\n            },\n            contentsFunction: {\n              t: 4\n            }\n          }, rt.ItemsChartSettingsLinkStyle = {\n            cursor: {\n              t: 0\n            },\n            direction: {\n              t: 0\n            },\n            fillColor: {\n              t: 0\n            },\n            fromDecoration: {\n              t: 0,\n              d: 6\n            },\n            invisible: {\n              t: 9\n            },\n            items: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsLinkItem;\n                }\n              }]\n            },\n            label: {\n              t: 0\n            },\n            length: {\n              t: 1\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineDashBackgroundFillColor: {\n              t: 0\n            },\n            lineDashShape: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            radius: {\n              t: 1\n            },\n            shadowBlur: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0\n            },\n            shadowOffsetX: {\n              t: 1\n            },\n            shadowOffsetY: {\n              t: 1\n            },\n            strength: {\n              t: 1\n            },\n            toDecoration: {\n              t: 0,\n              d: 6\n            },\n            toPieColor: {\n              t: 0\n            },\n            toPieValue: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsMenu = {\n            buttons: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return rt.ItemsChartSettingsMenuButton;\n                  },\n                  x: function x() {\n                    return n.ItemsChart.SettingsMenuButton;\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            contentsFunction: {\n              t: 4\n            },\n            enabled: {\n              t: 9\n            },\n            showData: {\n              t: 9\n            }\n          }, rt.ItemsChartSettingsMenuButton = {\n            className: {\n              t: 0\n            },\n            onClick: {\n              t: 4\n            },\n            onInit: {\n              t: 4\n            },\n            onRefresh: {\n              t: 4\n            },\n            text: {\n              t: 0\n            },\n            title: {\n              t: 0\n            }\n          }, rt.ItemsChartSettingsNodeAnchorStyle = {\n            lineColor: {\n              t: 0\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineWidth: {\n              t: 1\n            },\n            shadowBlur: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0\n            },\n            shadowOffsetX: {\n              t: 1\n            },\n            shadowOffsetY: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsNodeClass = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeStyle;\n              }\n            }\n          }, rt.ItemsChartSettingsNodeItem = {\n            px: {\n              t: 1\n            },\n            py: {\n              t: 1\n            },\n            x: {\n              t: 1\n            },\n            y: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsNodeMenu = {\n            buttons: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return rt.ItemsChartSettingsMenuButton;\n                  },\n                  x: function x() {\n                    return n.ItemsChart.SettingsMenuButton;\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            contentsFunction: {\n              t: 4\n            }\n          }, rt.ItemsChartSettingsNodeStyle = {\n            anchorMode: {\n              t: 2,\n              e: function e() {\n                return n.ItemsChart.NodeAnchorMode;\n              }\n            },\n            anchorStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodeAnchorStyle;\n              }\n            },\n            anchorX: {\n              t: 1\n            },\n            anchorY: {\n              t: 1\n            },\n            aspectRatio: {\n              t: 1\n            },\n            aura: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }, {\n                t: 0\n              }]\n            },\n            coordinates: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 6,\n                  u: 0,\n                  b: [{\n                    t: 1\n                  }]\n                }]\n              }, {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 1\n                }]\n              }]\n            },\n            cursor: {\n              t: 0,\n              d: 7\n            },\n            customShape: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsCustomShape;\n              }\n            },\n            display: {\n              t: 0\n            },\n            draggable: {\n              t: 9\n            },\n            fillColor: {\n              t: 0\n            },\n            image: {\n              t: 0\n            },\n            imageCropping: {\n              t: 7,\n              b: [{\n                t: 0\n              }, {\n                t: 9\n              }]\n            },\n            invisible: {\n              t: 9\n            },\n            items: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsNodeItem;\n                }\n              }]\n            },\n            label: {\n              t: 0\n            },\n            labelStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsItemsLayerLabelStyle;\n              }\n            },\n            lineColor: {\n              t: 0\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineWidth: {\n              t: 1\n            },\n            opacity: {\n              t: 1\n            },\n            radius: {\n              t: 1\n            },\n            shadowBlur: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0\n            },\n            shadowOffsetX: {\n              t: 1\n            },\n            shadowOffsetY: {\n              t: 1\n            }\n          }, rt.ItemsChartSettingsNodesLayerAuras = {\n            cellSize: {\n              t: 1\n            },\n            defaultColors: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            defaultStyle: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsAuraStyle;\n              }\n            },\n            drawLimit: {\n              t: 1\n            },\n            enabled: {\n              t: 9\n            },\n            intensity: {\n              t: 1\n            },\n            overlap: {\n              t: 9\n            },\n            style: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.ItemsChartSettingsAuraStyle;\n                }\n              }]\n            }\n          }, rt.ItemsChartSettingsNodesLayerStyle = {\n            fadeTime: {\n              t: 1,\n              d: 0\n            },\n            hiddenLinks: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  lineColor: {\n                    t: 0\n                  },\n                  lineWidth: {\n                    t: 1\n                  },\n                  size: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            linkAutoScaling: {\n              t: 0,\n              d: 6\n            },\n            linkLengthAutoScaling: {\n              t: 0,\n              d: 6\n            },\n            linkLengthExtent: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            linkRadiusExtent: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            linkStrengthAutoScaling: {\n              t: 0,\n              d: 6\n            },\n            linkStrengthExtent: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            multilinkSpacing: {\n              t: 1\n            },\n            nodeAutoScaling: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            nodeRadiusExtent: {\n              t: 12,\n              b: [{\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }]\n            },\n            selfLinkAngle: {\n              t: 1\n            },\n            selfLinkHeightFactor: {\n              t: 1\n            },\n            selfLinkShape: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            selfLinkWidthFactor: {\n              t: 1\n            }\n          }, rt.LinearChartSettings = {\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsArea;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsArea;\n              }\n            },\n            chartTypes: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  candlestick: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsSeriesCandleStick;\n                    },\n                    x: function x() {\n                      return n.LinearChart.SettingsSeriesCandleStick;\n                    },\n                    y: !0\n                  },\n                  columns: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsSeriesColumns;\n                    },\n                    x: function x() {\n                      return n.LinearChart.SettingsSeriesColumns;\n                    },\n                    y: !0\n                  },\n                  line: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsSeriesLines;\n                    },\n                    x: function x() {\n                      return n.LinearChart.SettingsSeriesLines;\n                    },\n                    y: !0\n                  }\n                };\n              }\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsEvents(rt.BaseIChartEventArguments, rt.BaseIChartEventArguments);\n              },\n              x: function x() {\n                return n.LinearChart.SettingsEvents;\n              }\n            },\n            info: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsInfoPopup;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsInfoPopup;\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsInteraction;\n              }\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLegend;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLegend;\n              }\n            },\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLocalization;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLocalization;\n              }\n            },\n            series: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.LinearChartSettingsSeries;\n                },\n                x: function x() {\n                  return n.LinearChart.SettingsSeries;\n                },\n                y: !0\n              }]\n            },\n            seriesDefault: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeries;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeries;\n              },\n              y: !0\n            },\n            stacks: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.LinearChartSettingsStack;\n                },\n                x: function x() {\n                  return n.LinearChart.SettingsStack;\n                }\n              }]\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  columnColors: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 0\n                    }]\n                  },\n                  lineColors: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 0\n                    }]\n                  }\n                };\n              }\n            },\n            valueAxis: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.LinearChartSettingsValueAxis;\n                },\n                x: function x() {\n                  return n.LinearChart.SettingsValueAxis;\n                },\n                y: !0\n              }]\n            },\n            valueAxisDefault: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsValueAxis;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsValueAxis;\n              }\n            }\n          }, rt.LinearChartSettingsArea = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsAreaStyle;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsAreaStyle;\n              }\n            }\n          }, rt.LinearChartSettingsAreaStyle = {\n            noData: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  },\n                  image: {\n                    t: 0,\n                    d: 5\n                  }\n                };\n              }\n            },\n            zoomHighlight: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsHighlightStyle;\n              }\n            },\n            zoomHighlightInactive: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  }\n                };\n              }\n            }\n          }, rt.LinearChartSettingsCandleStickMotionStyle = {\n            bar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  lineColor: {\n                    t: 0\n                  },\n                  lineDash: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 1\n                    }]\n                  },\n                  lineWidth: {\n                    t: 1\n                  },\n                  shadowBlur: {\n                    t: 1\n                  },\n                  shadowColor: {\n                    t: 0\n                  },\n                  shadowOffsetX: {\n                    t: 1\n                  },\n                  shadowOffsetY: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            candlestick: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  },\n                  lineColor: {\n                    t: 0,\n                    d: 3\n                  },\n                  lineDash: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 1\n                    }]\n                  },\n                  lineWidth: {\n                    t: 1\n                  },\n                  shadowBlur: {\n                    t: 1\n                  },\n                  shadowColor: {\n                    t: 0\n                  },\n                  shadowOffsetX: {\n                    t: 1\n                  },\n                  shadowOffsetY: {\n                    t: 1\n                  }\n                };\n              }\n            }\n          }, rt.LinearChartSettingsEvents = function (t, e) {\n            return {\n              onAnimationDone: {\n                t: 4\n              }\n            };\n          }, rt.LinearChartSettingsHighlightStyle = {\n            fadeIn: {\n              t: 1,\n              d: 0\n            },\n            fadeOut: {\n              t: 1,\n              d: 0\n            },\n            fillColor: {\n              t: 0\n            }\n          }, rt.LinearChartSettingsInfoPopup = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  contentsFunction: {\n                    t: 4\n                  },\n                  scope: {\n                    t: 0,\n                    d: 6\n                  },\n                  showHeader: {\n                    t: 9\n                  },\n                  showOnlyHoveredSeries: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            aggregations: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0,\n                d: 6\n              }]\n            },\n            enabled: {\n              t: 9\n            },\n            position: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            showNoData: {\n              t: 9\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  highlight: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsHighlightStyle;\n                    }\n                  }\n                };\n              }\n            },\n            valueFormatterFunction: {\n              t: 4\n            }\n          }, rt.LinearChartSettingsInteraction = {\n            ignoreBottomAxis: {\n              t: 9\n            },\n            scrolling: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsInteractionScrolling;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsInteractionScrolling;\n              }\n            },\n            swipeSensitivity: {\n              t: 1\n            },\n            zooming: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsInteractionZooming;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsInteractionZooming;\n              }\n            }\n          }, rt.LinearChartSettingsInteractionScrolling = {\n            enabled: {\n              t: 9\n            },\n            kineticFriction: {\n              t: 1\n            },\n            maxAnimationLength: {\n              t: 1,\n              d: 0\n            },\n            swipePageFlipping: {\n              t: 9\n            }\n          }, rt.LinearChartSettingsInteractionZooming = {\n            enabled: {\n              t: 9\n            },\n            fingers: {\n              t: 9\n            },\n            fingersMaxZoom: {\n              t: 1\n            },\n            sensitivity: {\n              t: 1\n            },\n            swipe: {\n              t: 9\n            },\n            upDownTreshold: {\n              t: 1\n            },\n            wheel: {\n              t: 9\n            },\n            wheelSensitivity: {\n              t: 1\n            },\n            zoomHighlightThreshold: {\n              t: 1\n            }\n          }, rt.LinearChartSettingsLegend = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLegendAdvanced;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLegendAdvanced;\n              }\n            },\n            marker: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLegendMarker;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLegendMarker;\n              }\n            },\n            panel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendPanel;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendPanel;\n              }\n            }\n          }, rt.LinearChartSettingsLegendAdvanced = {\n            disabledSeries: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0\n                  },\n                  lineColor: {\n                    t: 0\n                  },\n                  textColor: {\n                    t: 0\n                  }\n                };\n              }\n            }\n          }, rt.LinearChartSettingsLegendMarker = {\n            shape: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            }\n          }, rt.LinearChartSettingsLocalization = {\n            noDataLabel: {\n              t: 0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsLocalizationToolbar;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsLocalizationToolbar;\n              }\n            },\n            unnamedSeries: {\n              t: 0\n            },\n            valueUnits: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 1,\n                d: 0\n              }]\n            }\n          }, rt.LinearChartSettingsLocalizationToolbar = {\n            linButton: {\n              t: 0\n            },\n            linLogTitle: {\n              t: 0\n            },\n            logButton: {\n              t: 0\n            }\n          }, rt.LinearChartSettingsSeries = {\n            cluster: {\n              t: 0\n            },\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeriesData;\n              }\n            },\n            enabled: {\n              t: 9\n            },\n            extra: {\n              t: 10\n            },\n            id: {\n              t: 0\n            },\n            legendGroupId: {\n              t: 0\n            },\n            name: {\n              t: 0\n            },\n            nameLegend: {\n              t: 0\n            },\n            showInLegend: {\n              t: 9\n            },\n            stack: {\n              t: 0\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesStyle;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeriesStyle;\n              }\n            },\n            type: {\n              t: 0,\n              d: 6\n            },\n            valueAxis: {\n              t: 0\n            }\n          }, rt.LinearChartSettingsSeriesCandleStick = {\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  close: {\n                    t: 0\n                  },\n                  high: {\n                    t: 0\n                  },\n                  low: {\n                    t: 0\n                  },\n                  open: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesCandleStickStyle;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeriesCandleStickStyle;\n              }\n            }\n          }, rt.LinearChartSettingsSeriesCandleStickStyle = {\n            decrease: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsCandleStickMotionStyle;\n              }\n            },\n            increase: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsCandleStickMotionStyle;\n              }\n            },\n            padding: {\n              t: 12,\n              b: [{\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }]\n            },\n            pattern: {\n              t: 0,\n              d: 6\n            }\n          }, rt.LinearChartSettingsSeriesColumns = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesColumnsStyle;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeriesColumnsStyle;\n              }\n            },\n            valueLabels: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsValueLabels;\n              }\n            }\n          }, rt.LinearChartSettingsSeriesColumnsStyle = {\n            depth: {\n              t: 1\n            },\n            depthBrightness: {\n              t: 1\n            },\n            fillGradientMode: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            fillGradientType: {\n              t: 0\n            },\n            gradient: {\n              t: 1\n            },\n            lineColor: {\n              t: 0,\n              d: 3\n            },\n            minHeight: {\n              t: 1,\n              d: 0\n            },\n            padding: {\n              t: 12,\n              b: [{\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }]\n            },\n            radius: {\n              t: 12,\n              b: [{\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }, {\n                t: 1,\n                d: 0\n              }]\n            },\n            shadowBlur: {\n              t: 1,\n              d: 0\n            }\n          }, rt.LinearChartSettingsSeriesData = {\n            aggregatedValueFunction: {\n              t: 4\n            },\n            aggregation: {\n              t: 0,\n              d: 6\n            },\n            noDataPolicy: {\n              t: 0,\n              d: 6\n            },\n            source: {\n              t: 0\n            },\n            valueFunction: {\n              t: 4\n            }\n          }, rt.LinearChartSettingsSeriesLines = {\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesLinesStyle;\n              },\n              x: function x() {\n                return n.LinearChart.SettingsSeriesLinesStyle;\n              }\n            },\n            valueLabels: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsValueLabels;\n              }\n            }\n          }, rt.LinearChartSettingsSeriesLinesStyle = {\n            marker: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.LinearChartSettingsSeriesStyleMarker;\n              }\n            },\n            markerStyleFunction: {\n              t: 4\n            },\n            shadowBlur: {\n              t: 1,\n              d: 0\n            },\n            smoothing: {\n              t: 9\n            },\n            steps: {\n              t: 9\n            }\n          }, rt.LinearChartSettingsSeriesStyle = {\n            depth: {\n              t: 1\n            },\n            fillColor: {\n              t: 0,\n              d: 3\n            },\n            fillGradient: {\n              t: 11\n            },\n            fillPattern: {\n              t: 0\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  marker: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsSeriesStyleMarker;\n                    }\n                  },\n                  textColor: {\n                    t: 0,\n                    d: 3\n                  }\n                };\n              }\n            },\n            lineColor: {\n              t: 0\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineWidth: {\n              t: 1\n            },\n            shadowColor: {\n              t: 0,\n              d: 3\n            },\n            shadowOffsetX: {\n              t: 1,\n              d: 0\n            },\n            shadowOffsetY: {\n              t: 1,\n              d: 0\n            }\n          }, rt.LinearChartSettingsSeriesStyleMarker = {\n            fillColor: {\n              t: 0,\n              d: 3\n            },\n            lineColor: {\n              t: 0,\n              d: 3\n            },\n            lineWidth: {\n              t: 1\n            },\n            shape: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            width: {\n              t: 1,\n              d: 0\n            }\n          }, rt.LinearChartSettingsStack = {\n            name: {\n              t: 0\n            },\n            separateNegativeValues: {\n              t: 9\n            },\n            type: {\n              t: 0,\n              d: 6\n            }\n          }, rt.LinearChartSettingsValueAxis = {\n            animate: {\n              t: 0,\n              d: 6\n            },\n            axisLine: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            hgrid: {\n              t: 9\n            },\n            initialAnimationValue: {\n              t: 1\n            },\n            initialAnimationValueMultiplier: {\n              t: 1\n            },\n            logScale: {\n              t: 9\n            },\n            maxValue: {\n              t: 1\n            },\n            minValue: {\n              t: 1\n            },\n            position: {\n              t: 0,\n              d: 6\n            },\n            scaleAdjustmentAnimation: {\n              t: 0,\n              d: 6\n            },\n            scaleAdjustmentAnimationDelay: {\n              t: 1,\n              d: 0\n            },\n            scaleAdjustmentTolerance: {\n              t: 1\n            },\n            scaleMinStep: {\n              t: 1\n            },\n            scaleStep: {\n              t: 1\n            },\n            side: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            size: {\n              t: 1,\n              d: 0\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  axisLine: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  },\n                  baseLine: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsValueAxisBaseLineStyle;\n                    }\n                  },\n                  hgrid: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  },\n                  labelSpacing: {\n                    t: 1\n                  },\n                  tick: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  },\n                  title: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.LinearChartSettingsValueAxisTitleStyle;\n                    }\n                  },\n                  valueLabel: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLabelStyle;\n                    }\n                  }\n                };\n              }\n            },\n            thresholds: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.LinearChartSettingsValueAxisThreshold;\n                },\n                x: function x() {\n                  return n.LinearChart.SettingsValueAxisThreshold;\n                }\n              }]\n            },\n            title: {\n              t: 0\n            },\n            valueFormat: {\n              t: 0\n            },\n            valueFormatterFunction: {\n              t: 4\n            },\n            zeroLine: {\n              t: 0,\n              d: 6\n            }\n          }, rt.LinearChartSettingsValueAxisBaseLineStyle = {\n            depthColor: {\n              t: 0,\n              d: 3\n            },\n            lineDepth: {\n              t: 1,\n              d: 0\n            },\n            showLabel: {\n              t: 2,\n              e: function e() {\n                return i.LinearChartSettingsValueAxisBaseLineLabelMode;\n              }\n            }\n          }, rt.LinearChartSettingsValueAxisThreshold = {\n            from: {\n              t: 1\n            },\n            position: {\n              t: 0,\n              d: 6\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fillColor: {\n                    t: 0,\n                    d: 3\n                  },\n                  lineColor: {\n                    t: 0,\n                    d: 3\n                  },\n                  lineDash: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 1\n                    }]\n                  },\n                  lineWidth: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            to: {\n              t: 1\n            }\n          }, rt.LinearChartSettingsValueAxisTitleStyle = {\n            reverseDirection: {\n              t: 9\n            }\n          }, rt.LinearChartSettingsValueLabels = {\n            contentsFunction: {\n              t: 4\n            },\n            enabled: {\n              t: 9\n            },\n            minFontSize: {\n              t: 1\n            },\n            position: {\n              t: 0,\n              d: 6\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLabelStyle;\n              }\n            },\n            useStackedValue: {\n              t: 9\n            }\n          }, rt.NetChartBarSettingsLocalizationToolbar = {\n            fitButton: {\n              t: 0\n            },\n            fitTitle: {\n              t: 0\n            },\n            freezeButton: {\n              t: 0\n            },\n            freezeTitle: {\n              t: 0\n            },\n            rearrangeButton: {\n              t: 0\n            },\n            rearrangeTitle: {\n              t: 0\n            },\n            unfreezeTitle: {\n              t: 0\n            }\n          }, rt.NetChartBarSettingsToolbar = {\n            zoomControl: {\n              t: 9\n            }\n          }, rt.NetChartGravitySettings = {\n            from: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            fromCenter: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            strength: {\n              t: 1\n            },\n            to: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            toCenter: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            }\n          }, rt.NetChartIChartClickEventArguments = {}, rt.NetChartIChartEventArguments = {}, rt.NetChartIDataObject = {\n            links: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.NetChartIDataObjectLink;\n                }\n              }]\n            },\n            nodes: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.NetChartIDataObjectNode;\n                }\n              }]\n            }\n          }, rt.NetChartIDataObjectLink = {}, rt.NetChartIDataObjectNode = {\n            locked: {\n              t: 9\n            },\n            x: {\n              t: 1\n            },\n            y: {\n              t: 1\n            }\n          }, rt.NetChartSettings = {\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsArea;\n              },\n              x: function x() {\n                return n.NetChart.SettingsArea;\n              }\n            },\n            auras: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.ItemsChartSettingsNodesLayerAuras;\n              },\n              x: function x() {\n                return n.ItemsChart.SettingsNodesLayerAuras;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.NetChartSettingsData;\n                },\n                x: function x() {\n                  return n.NetChart.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsEvents;\n              },\n              x: function x() {\n                return n.NetChart.SettingsEvents;\n              }\n            },\n            filters: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  linkFilter: {\n                    t: 4\n                  },\n                  multilinkProcessor: {\n                    t: 4\n                  },\n                  nodeFilter: {\n                    t: 4\n                  },\n                  nodeLinksProcessor: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.NetChart.SettingsInteraction;\n              }\n            },\n            layout: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsLayout;\n              },\n              x: function x() {\n                return n.NetChart.SettingsLayout;\n              }\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsLegend;\n              },\n              x: function x() {\n                return n.NetChart.SettingsLegend;\n              }\n            },\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsLocalization;\n              },\n              x: function x() {\n                return n.NetChart.SettingsLocalization;\n              }\n            },\n            navigation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsNavigation;\n              },\n              x: function x() {\n                return n.NetChart.SettingsNavigation;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsStyle;\n              },\n              x: function x() {\n                return n.NetChart.SettingsStyle;\n              }\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.NetChartSettings;\n              },\n              x: function x() {\n                return n.NetChart.Settings;\n              },\n              y: !0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartBarSettingsToolbar;\n              },\n              x: function x() {\n                return n.NetChart.Bar.SettingsToolbar;\n              }\n            }\n          }, rt.NetChartSettingsArea = {\n            centerX: {\n              t: 1\n            },\n            centerY: {\n              t: 1\n            },\n            paddingBottom: {\n              t: 1\n            },\n            paddingLeft: {\n              t: 1\n            },\n            paddingRight: {\n              t: 1\n            },\n            paddingTop: {\n              t: 1\n            }\n          }, rt.NetChartSettingsData = {\n            dataFunction: {\n              t: 4\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.NetChartIDataObject;\n              }\n            }\n          }, rt.NetChartSettingsEvents = {\n            onDataUpdated: {\n              t: 4\n            },\n            onPointerDown: {\n              t: 4\n            },\n            onPointerDrag: {\n              t: 4\n            },\n            onPointerMove: {\n              t: 4\n            },\n            onPointerUp: {\n              t: 4\n            }\n          }, rt.NetChartSettingsInteraction = {\n            rotation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fingers: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsInteractionSelection;\n              },\n              x: function x() {\n                return n.NetChart.SettingsInteractionSelection;\n              }\n            },\n            zooming: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsInteractionZooming;\n              },\n              x: function x() {\n                return n.NetChart.SettingsInteractionZooming;\n              }\n            }\n          }, rt.NetChartSettingsInteractionSelection = {\n            dragSelect: {\n              t: 9\n            }\n          }, rt.NetChartSettingsInteractionZooming = {\n            autoZoomExtent: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            },\n            autoZoomPositionElasticity: {\n              t: 1\n            },\n            autoZoomSize: {\n              t: 1\n            },\n            initialAutoZoom: {\n              t: 7,\n              b: [{\n                t: 9\n              }, {\n                t: 0\n              }]\n            },\n            zoomExtent: {\n              t: 12,\n              b: [{\n                t: 1\n              }, {\n                t: 1\n              }]\n            }\n          }, rt.NetChartSettingsLayout = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  adaptiveFreezeTreshold: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            aspectRatio: {\n              t: 9\n            },\n            globalLayoutOnChanges: {\n              t: 9\n            },\n            gravity: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartGravitySettings;\n              },\n              x: function x() {\n                return n.NetChart.GravitySettings;\n              }\n            },\n            groupSpacing: {\n              t: 1,\n              d: 0\n            },\n            incrementalLayoutMaxTime: {\n              t: 1,\n              d: 0\n            },\n            initialLayoutMaxTime: {\n              t: 1,\n              d: 0\n            },\n            layoutFreezeMinTimeout: {\n              t: 1,\n              d: 0\n            },\n            layoutFreezeTimeout: {\n              t: 1,\n              d: 0\n            },\n            mode: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            nodeSpacing: {\n              t: 1,\n              d: 0\n            },\n            rotation: {\n              t: 1\n            },\n            rowSpacing: {\n              t: 1,\n              d: 0\n            },\n            twoRingRadialLayout: {\n              t: 9\n            }\n          }, rt.NetChartSettingsLegend = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartSettingsLegendAdvanced;\n              },\n              x: function x() {\n                return n.NetChart.SettingsLegendAdvanced;\n              }\n            },\n            panel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLegendPanel;\n              },\n              x: function x() {\n                return n.Base.SettingsLegendPanel;\n              }\n            }\n          }, rt.NetChartSettingsLegendAdvanced = {\n            showItemsWithClasses: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            textColorDisabled: {\n              t: 0\n            }\n          }, rt.NetChartSettingsLocalization = {\n            menu: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  close: {\n                    t: 0\n                  },\n                  collapse: {\n                    t: 0\n                  },\n                  dynamic: {\n                    t: 0\n                  },\n                  expand: {\n                    t: 0\n                  },\n                  fixed: {\n                    t: 0\n                  },\n                  focus: {\n                    t: 0\n                  },\n                  hide: {\n                    t: 0\n                  },\n                  unfocus: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.NetChartBarSettingsLocalizationToolbar;\n              },\n              x: function x() {\n                return n.NetChart.Bar.SettingsLocalizationToolbar;\n              }\n            }\n          }, rt.NetChartSettingsNavigation = {\n            autoUnfocus: {\n              t: 9\n            },\n            autoZoomOnFocus: {\n              t: 9\n            },\n            expandDelay: {\n              t: 1,\n              d: 0\n            },\n            expandOnClick: {\n              t: 9\n            },\n            focusAutoFadeout: {\n              t: 9\n            },\n            focusNodeExpansionRadius: {\n              t: 1\n            },\n            focusNodeTailExpansionRadius: {\n              t: 1\n            },\n            initialNodes: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            minNumberOfFocusNodes: {\n              t: 1,\n              d: 0\n            },\n            mode: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            },\n            numberOfFocusNodes: {\n              t: 1,\n              d: 0\n            }\n          }, rt.NetChartSettingsStyle = {\n            dragSelection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsBackgroundStyle;\n              }\n            }\n          }, rt.PieChartIChartClickEventArguments = {}, rt.PieChartIChartEventArguments = {}, rt.PieChartIDataObject = {\n            id: {\n              t: 0\n            },\n            name: {\n              t: 0\n            },\n            nameLegend: {\n              t: 0\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsSliceStyle;\n              }\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.PieChartIDataObject;\n                }\n              }]\n            },\n            value: {\n              t: 1\n            }\n          }, rt.PieChartIDataObjectCommon = {\n            id: {\n              t: 0\n            },\n            name: {\n              t: 0\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.PieChartIDataObject;\n                }\n              }]\n            }\n          }, rt.PieChartIDataObjectRoot = {\n            afterSum: {\n              t: 1\n            },\n            beforeSum: {\n              t: 1\n            },\n            id: {\n              t: 0\n            },\n            limit: {\n              t: 1\n            },\n            name: {\n              t: 0\n            },\n            offset: {\n              t: 1\n            },\n            subvalues: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.PieChartIDataObject;\n                }\n              }]\n            },\n            sum: {\n              t: 1\n            }\n          }, rt.PieChartSettings = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsAdvanced;\n              },\n              x: function x() {\n                return n.PieChart.SettingsAdvanced;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.PieChartSettingsData;\n                },\n                x: function x() {\n                  return n.PieChart.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsEvents;\n              },\n              x: function x() {\n                return n.PieChart.SettingsEvents;\n              }\n            },\n            filters: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  allowZeroValues: {\n                    t: 9\n                  },\n                  sliceFilter: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            icons: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  autohideWhenTooSmall: {\n                    t: 9\n                  },\n                  placement: {\n                    t: 0,\n                    d: 6\n                  },\n                  sizeExtent: {\n                    t: 12,\n                    b: [{\n                      t: 1\n                    }, {\n                      t: 1\n                    }]\n                  }\n                };\n              }\n            },\n            info: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  contentsFunction: {\n                    t: 4\n                  },\n                  enabled: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.PieChart.SettingsInteraction;\n              }\n            },\n            labels: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsLabels;\n              },\n              x: function x() {\n                return n.PieChart.SettingsLabels;\n              }\n            },\n            legend: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsLegend;\n              },\n              x: function x() {\n                return n.PieChart.SettingsLegend;\n              }\n            },\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsLocalization;\n              },\n              x: function x() {\n                return n.PieChart.SettingsLocalization;\n              }\n            },\n            navigation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  initialDrilldown: {\n                    t: 6,\n                    u: 0,\n                    b: [{\n                      t: 0\n                    }]\n                  },\n                  initialOffset: {\n                    t: 1,\n                    d: 0\n                  }\n                };\n              }\n            },\n            pie: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  adaptiveRadius: {\n                    t: 9\n                  },\n                  backgroundHoveredStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsPieStyle;\n                    }\n                  },\n                  backgroundStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsPieStyle;\n                    }\n                  },\n                  centerMargin: {\n                    t: 1,\n                    d: 0\n                  },\n                  depth: {\n                    t: 1,\n                    d: 0\n                  },\n                  endAngle: {\n                    t: 1\n                  },\n                  innerRadius: {\n                    t: 1\n                  },\n                  innerRadiusWhenDrilldown: {\n                    t: 1\n                  },\n                  margin: {\n                    t: 1\n                  },\n                  noDataStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsPieStyle;\n                    }\n                  },\n                  outerMargin: {\n                    t: 1\n                  },\n                  radius: {\n                    t: 1\n                  },\n                  rotationSpeed: {\n                    t: 1\n                  },\n                  showInnerPies: {\n                    t: 9\n                  },\n                  showInnerPiesExport: {\n                    t: 9\n                  },\n                  startAngle: {\n                    t: 1\n                  },\n                  style: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsPieStyle;\n                    }\n                  },\n                  styleFunction: {\n                    t: 4\n                  },\n                  theme: {\n                    t: 0,\n                    d: 6\n                  },\n                  x: {\n                    t: 1\n                  },\n                  y: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            slice: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  backgroundActiveStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        brightness: {\n                          t: 1\n                        }\n                      };\n                    }\n                  },\n                  backgroundStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        fillColor: {\n                          t: 0\n                        },\n                        fillColor2: {\n                          t: 0,\n                          d: 3\n                        }\n                      };\n                    }\n                  },\n                  connectorStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  },\n                  expandableMarkStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        distance: {\n                          t: 1\n                        },\n                        lineColor: {\n                          t: 0\n                        },\n                        lineDash: {\n                          t: 6,\n                          u: 0,\n                          b: [{\n                            t: 1\n                          }]\n                        },\n                        lineWidth: {\n                          t: 1\n                        }\n                      };\n                    }\n                  },\n                  hoverStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsSliceStyle;\n                    }\n                  },\n                  margin: {\n                    t: 1\n                  },\n                  minFraction: {\n                    t: 1\n                  },\n                  othersStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        fillColor: {\n                          t: 0\n                        },\n                        lineDecoration: {\n                          t: 0,\n                          d: 6\n                        }\n                      };\n                    }\n                  },\n                  previousStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        fillColor: {\n                          t: 0\n                        },\n                        lineDecoration: {\n                          t: 0,\n                          d: 6\n                        }\n                      };\n                    }\n                  },\n                  selectedStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsSliceStyle;\n                    }\n                  },\n                  style: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.PieChartSettingsSliceStyle;\n                    }\n                  },\n                  styleFunction: {\n                    t: 4\n                  }\n                };\n              }\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.PieChartSettings;\n              },\n              x: function x() {\n                return n.PieChart.Settings;\n              },\n              y: !0\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsToolbar;\n              },\n              x: function x() {\n                return n.Base.SettingsToolbar;\n              }\n            }\n          }, rt.PieChartSettingsAdvanced = {\n            backAlwaysVisible: {\n              t: 9\n            },\n            backImage: {\n              t: 0,\n              d: 4\n            },\n            backImageBackground: {\n              t: 0\n            },\n            iconMinSize: {\n              t: 1\n            },\n            initialAnimation: {\n              t: 9\n            },\n            labelInsideTreshold: {\n              t: 1,\n              d: 0\n            },\n            renderQuality: {\n              t: 1,\n              d: 0\n            }\n          }, rt.PieChartSettingsData = {\n            autoCategories: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                b: [{\n                  t: 4\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            dataFunction: {\n              t: 4\n            },\n            itemsToLoad: {\n              t: 1,\n              d: 0\n            },\n            partialLoad: {\n              t: 9\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.PieChartIDataObjectRoot;\n              }\n            },\n            sortField: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 4\n              }, {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }, {\n                t: 0\n              }]\n            }\n          }, rt.PieChartSettingsEvents = {\n            onPieChange: {\n              t: 4\n            },\n            onPieReadyStateChanged: {\n              t: 4\n            }\n          }, rt.PieChartSettingsInteraction = {\n            animation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  hoverDuration: {\n                    t: 1,\n                    d: 0\n                  },\n                  scrollDuration: {\n                    t: 1,\n                    d: 0\n                  }\n                };\n              }\n            },\n            coverCenter: {\n              t: 9\n            },\n            mode: {\n              t: 0,\n              d: 6\n            },\n            others: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  centerGoesToPrevious: {\n                    t: 9\n                  },\n                  enabled: {\n                    t: 9\n                  },\n                  maxOthersFraction: {\n                    t: 1\n                  },\n                  maxSlicesVisible: {\n                    t: 1,\n                    d: 0\n                  },\n                  minSliceFraction: {\n                    t: 1\n                  },\n                  minSlices: {\n                    t: 1\n                  },\n                  navigationFraction: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            scrolling: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  enabled: {\n                    t: 9\n                  }\n                };\n              }\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  enabled: {\n                    t: 9\n                  },\n                  maxSwipeDistance: {\n                    t: 1\n                  },\n                  partialSwipe: {\n                    t: 9\n                  },\n                  swipe: {\n                    t: 9\n                  },\n                  swipeSensitivity: {\n                    t: 1\n                  },\n                  tolerance: {\n                    t: 1\n                  }\n                };\n              }\n            }\n          }, rt.PieChartSettingsLabels = {\n            angle: {\n              t: 1,\n              d: 0\n            },\n            connectorLength: {\n              t: 1,\n              d: 0\n            },\n            connectors: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            insideLabel: {\n              t: 0,\n              d: 6\n            },\n            insideLabelVisibilityFraction: {\n              t: 1\n            },\n            interLabelSpacing: {\n              t: 1\n            },\n            placement: {\n              t: 0,\n              d: 6\n            }\n          }, rt.PieChartSettingsLegend = {\n            marker: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.PieChartSettingsLegendMarker;\n              },\n              x: function x() {\n                return n.PieChart.SettingsLegendMarker;\n              }\n            },\n            showOthers: {\n              t: 9\n            }\n          }, rt.PieChartSettingsLegendMarker = {\n            shape: {\n              t: 7,\n              d: 6,\n              b: [{\n                t: 0\n              }]\n            }\n          }, rt.PieChartSettingsLocalization = {\n            othersLabel: {\n              t: 0\n            },\n            previousLabel: {\n              t: 0\n            }\n          }, rt.PieChartSettingsPieStyle = {\n            background: {\n              t: 9\n            },\n            brightness: {\n              t: 1\n            },\n            colorDistribution: {\n              t: 0,\n              d: 6\n            },\n            fillColor: {\n              t: 0,\n              d: 3\n            },\n            sliceColors: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0,\n                d: 3\n              }]\n            }\n          }, rt.PieChartSettingsSliceStyle = {\n            brightness: {\n              t: 1\n            },\n            cutoutDistance: {\n              t: 1\n            },\n            expandable: {\n              t: 9\n            },\n            fillColor: {\n              t: 0,\n              d: 3\n            },\n            icon: {\n              t: 0,\n              d: 4\n            },\n            insideLabel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLabelStyle;\n              }\n            },\n            label: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLabelStyle;\n              }\n            },\n            lineBrightness: {\n              t: 1,\n              d: 0\n            },\n            lineColor: {\n              t: 0,\n              d: 3\n            },\n            lineDash: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            },\n            lineWidth: {\n              t: 1,\n              d: 0\n            },\n            url: {\n              t: 0,\n              d: 5\n            }\n          }, rt.TimeChartIChartEventArguments = {}, rt.TimeChartIDataObject = {\n            data: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 7,\n                  b: [{\n                    t: 1\n                  }, {\n                    t: 0\n                  }]\n                }]\n              }]\n            },\n            dataLimitFrom: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            dataLimitTo: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            from: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            timeZone: {\n              t: 0\n            },\n            to: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            unit: {\n              t: 0\n            },\n            values: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 18\n                }, {\n                  t: 17\n                }, {\n                  t: 16\n                }, {\n                  t: 15\n                }, {\n                  t: 6,\n                  u: 0,\n                  b: [{\n                    t: 7,\n                    b: [{\n                      t: 1\n                    }, {\n                      t: 0\n                    }]\n                  }]\n                }]\n              }]\n            }\n          }, rt.TimeChartSettings = {\n            advanced: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsAdvanced;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsAdvanced;\n              }\n            },\n            area: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsArea;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsArea;\n              }\n            },\n            chartTypes: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  candlestick: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsSeriesCandleStick;\n                    },\n                    x: function x() {\n                      return n.TimeChart.SettingsSeriesCandleStick;\n                    },\n                    y: !0\n                  },\n                  columns: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsSeriesColumns;\n                    },\n                    x: function x() {\n                      return n.TimeChart.SettingsSeriesColumns;\n                    },\n                    y: !0\n                  },\n                  line: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsSeriesLines;\n                    },\n                    x: function x() {\n                      return n.TimeChart.SettingsSeriesLines;\n                    },\n                    y: !0\n                  }\n                };\n              }\n            },\n            currentTime: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsCurrentTime;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsCurrentTime;\n              }\n            },\n            data: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.TimeChartSettingsData;\n                },\n                x: function x() {\n                  return n.TimeChart.SettingsData;\n                }\n              }]\n            },\n            events: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsEvents;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsEvents;\n              }\n            },\n            interaction: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsInteraction;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsInteraction;\n              }\n            },\n            localization: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsLocalization;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsLocalization;\n              }\n            },\n            milestones: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.TimeChartSettingsMarker;\n                },\n                x: function x() {\n                  return n.TimeChart.SettingsMarker;\n                }\n              }]\n            },\n            navigation: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  followAnchor: {\n                    t: 9\n                  },\n                  initialDisplayAnchor: {\n                    t: 7,\n                    b: [{\n                      t: 0\n                    }, {\n                      t: 1\n                    }]\n                  },\n                  initialDisplayPeriod: {\n                    t: 0\n                  },\n                  initialDisplayUnit: {\n                    t: 0\n                  }\n                };\n              }\n            },\n            series: {\n              t: 6,\n              u: 4,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.TimeChartSettingsSeries;\n                },\n                x: function x() {\n                  return n.TimeChart.SettingsSeries;\n                },\n                y: !0\n              }]\n            },\n            seriesDefault: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeries;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeries;\n              },\n              y: !0\n            },\n            theme: {\n              t: 5,\n              c: function c() {\n                return rt.TimeChartSettings;\n              },\n              x: function x() {\n                return n.TimeChart.Settings;\n              },\n              y: !0\n            },\n            timeAxis: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsTimeAxis;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsTimeAxis;\n              }\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsToolbar;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsToolbar;\n              }\n            }\n          }, rt.TimeChartSettingsAdvanced = {\n            dataUpdateInterval: {\n              t: 1,\n              d: 0\n            },\n            maxUnitsToDisplay: {\n              t: 1\n            },\n            timeUpdateInterval: {\n              t: 1,\n              d: 0\n            }\n          }, rt.TimeChartSettingsArea = {\n            displayPeriods: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    unit: {\n                      t: 0\n                    }\n                  };\n                }\n              }]\n            },\n            displayUnits: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    unit: {\n                      t: 0\n                    },\n                    name: {\n                      t: 0\n                    }\n                  };\n                }\n              }]\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsAreaStyle;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsAreaStyle;\n              }\n            }\n          }, rt.TimeChartSettingsAreaDisplayPeriod = {\n            displayAnchor: {\n              t: 7,\n              b: [{\n                t: 0\n              }, {\n                t: 1\n              }]\n            },\n            displayPeriod: {\n              t: 0\n            },\n            displayUnit: {\n              t: 0\n            },\n            name: {\n              t: 0\n            }\n          }, rt.TimeChartSettingsAreaStyle = {\n            markerText: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTextStyle;\n              }\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsAreaStyleSelection;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsAreaStyleSelection;\n              }\n            },\n            selectionLabel: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsTextStyle;\n              }\n            }\n          }, rt.TimeChartSettingsAreaStyleSelection = {\n            behindSeries: {\n              t: 9\n            },\n            fillColor: {\n              t: 0\n            },\n            lineColor: {\n              t: 0\n            },\n            lineWidth: {\n              t: 1\n            }\n          }, rt.TimeChartSettingsCurrentTime = {\n            align: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            label: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLabelStyle;\n              }\n            },\n            showTime: {\n              t: 9\n            },\n            side: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLineStyle;\n              }\n            }\n          }, rt.TimeChartSettingsData = {\n            cacheSize: {\n              t: 1,\n              d: 0\n            },\n            dataFunction: {\n              t: 4\n            },\n            minimizeRequests: {\n              t: 9\n            },\n            prefetchRatio: {\n              t: 1\n            },\n            preloaded: {\n              t: 5,\n              c: function c() {\n                return rt.TimeChartIDataObject;\n              }\n            },\n            requestMaxUnits: {\n              t: 1,\n              d: 0\n            },\n            stringTimestampFormat: {\n              t: 7,\n              u: 0,\n              b: [{\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }, {\n                t: 0\n              }]\n            },\n            suppressWarnings: {\n              t: 9\n            },\n            timeZoneOffset: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            timestampInSeconds: {\n              t: 9\n            },\n            units: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            url: {\n              t: 0,\n              d: 5\n            },\n            urlByUnit: {\n              t: 8,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            useSmallerUnitCache: {\n              t: 9\n            }\n          }, rt.TimeChartSettingsEvents = {\n            onTimeChange: {\n              t: 4\n            },\n            selectionChangeDuringInteraction: {\n              t: 9\n            }\n          }, rt.TimeChartSettingsInteraction = {\n            scrolling: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsInteractionScrolling;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsInteractionScrolling;\n              }\n            },\n            selection: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsInteractionSelection;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsInteractionSelection;\n              }\n            },\n            snapMode: {\n              t: 0,\n              d: 6\n            },\n            zooming: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsInteractionZooming;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsInteractionZooming;\n              }\n            }\n          }, rt.TimeChartSettingsInteractionScrolling = {\n            limitFrom: {\n              t: 7,\n              b: [{\n                t: 0\n              }, {\n                t: 1\n              }]\n            },\n            limitMode: {\n              t: 0,\n              d: 6\n            },\n            limitTo: {\n              t: 7,\n              b: [{\n                t: 0\n              }, {\n                t: 1\n              }]\n            },\n            overscrollProportion: {\n              t: 1\n            }\n          }, rt.TimeChartSettingsInteractionSelection = {\n            clearOnRightClick: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            moveByDragging: {\n              t: 9\n            },\n            resizeSensitivity: {\n              t: 1\n            },\n            resizeTolerance: {\n              t: 1\n            },\n            tolerance: {\n              t: 1\n            }\n          }, rt.TimeChartSettingsInteractionZooming = {\n            click: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            }\n          }, rt.TimeChartSettingsLocalization = {\n            calendar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsLocalizationCalendar;\n              }\n            },\n            determiningDataBounds: {\n              t: 0\n            },\n            holidayWeekdays: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1,\n                d: 0\n              }]\n            },\n            infoDates: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  fullTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  },\n                  majorTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  },\n                  minorTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  }\n                };\n              }\n            },\n            loadingLabel: {\n              t: 0\n            },\n            markerDates: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  timeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  }\n                };\n              }\n            },\n            timeAxisDates: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  majorLabelFullTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  },\n                  majorLabelTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  },\n                  minorLabelTimeFormats: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.TimeChartSettingsLocalizationTimeUnits;\n                    }\n                  }\n                };\n              }\n            },\n            timeUnitsNames: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsLocalizationTimeUnits;\n              }\n            },\n            timeUnitsNamesPlural: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsLocalizationTimeUnits;\n              }\n            },\n            toolbar: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsLocalizationToolbar;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsLocalizationToolbar;\n              }\n            }\n          }, rt.TimeChartSettingsLocalizationCalendar = {\n            months: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            monthsShort: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            parentLocale: {\n              t: 0\n            },\n            week: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  dow: {\n                    t: 1,\n                    d: 0\n                  },\n                  doy: {\n                    t: 1\n                  }\n                };\n              }\n            },\n            weekdays: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            weekdaysMin: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            },\n            weekdaysShort: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 0\n              }]\n            }\n          }, rt.TimeChartSettingsLocalizationTimeUnits = {\n            M: {\n              t: 0\n            },\n            d: {\n              t: 0\n            },\n            h: {\n              t: 0\n            },\n            m: {\n              t: 0\n            },\n            ms: {\n              t: 0\n            },\n            s: {\n              t: 0\n            },\n            w: {\n              t: 0\n            },\n            y: {\n              t: 0\n            }\n          }, rt.TimeChartSettingsLocalizationToolbar = {\n            customPeriod: {\n              t: 0\n            },\n            periodDropdownTitle: {\n              t: 0\n            },\n            unavailableUnitTitle: {\n              t: 0\n            },\n            unitDropdownTitle: {\n              t: 0\n            },\n            zoomoutButton: {\n              t: 0\n            },\n            zoomoutTitle: {\n              t: 0\n            }\n          }, rt.TimeChartSettingsMarker = {\n            align: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            enabled: {\n              t: 9\n            },\n            label: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLabelStyle;\n              }\n            },\n            overrideLimits: {\n              t: 9\n            },\n            showTime: {\n              t: 9\n            },\n            side: {\n              t: 7,\n              b: [{\n                t: 0\n              }]\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.BaseSettingsLineStyle;\n              }\n            },\n            time: {\n              t: 1,\n              d: 0\n            }\n          }, rt.TimeChartSettingsSeries = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeriesData;\n              }\n            }\n          }, rt.TimeChartSettingsSeriesCandleStick = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeriesCandleStickData;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeriesCandleStickData;\n              }\n            }\n          }, rt.TimeChartSettingsSeriesCandleStickData = {\n            close: {\n              t: 1\n            },\n            high: {\n              t: 1\n            },\n            low: {\n              t: 1\n            },\n            open: {\n              t: 1\n            }\n          }, rt.TimeChartSettingsSeriesColumns = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeriesData;\n              }\n            }\n          }, rt.TimeChartSettingsSeriesData = {\n            countIndex: {\n              t: 1\n            },\n            index: {\n              t: 1,\n              d: 0\n            }\n          }, rt.TimeChartSettingsSeriesLines = {\n            data: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeriesData;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeriesData;\n              }\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return rt.TimeChartSettingsSeriesLinesStyle;\n              },\n              x: function x() {\n                return n.TimeChart.SettingsSeriesLinesStyle;\n              }\n            }\n          }, rt.TimeChartSettingsSeriesLinesStyle = {\n            markerStyleFunction: {\n              t: 4\n            }\n          }, rt.TimeChartSettingsTimeAxis = {\n            enabled: {\n              t: 9\n            },\n            maxUnitWidth: {\n              t: 1\n            },\n            minUnitWidth: {\n              t: 1\n            },\n            miniTimeRuler: {\n              t: 9\n            },\n            showHolidays: {\n              t: 9\n            },\n            style: {\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  dateHolidays: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsBackgroundStyle;\n                    }\n                  },\n                  dateLighten: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return {\n                        fillColor: {\n                          t: 0\n                        }\n                      };\n                    }\n                  },\n                  majorTimeBalloonStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsBackgroundStyle;\n                    }\n                  },\n                  majorTimeLabel: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsTextStyle;\n                    }\n                  },\n                  minorTimeBalloonStyle: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsBackgroundStyle;\n                    }\n                  },\n                  minorTimeLabel: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsTextStyle;\n                    }\n                  },\n                  minorTimeRuler: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  },\n                  showMajorTimeBalloons: {\n                    t: 9\n                  },\n                  showMinorTimeBalloons: {\n                    t: 9\n                  },\n                  vgrid: {\n                    t: 5,\n                    u: 0,\n                    c: function c() {\n                      return rt.BaseSettingsLineStyle;\n                    }\n                  }\n                };\n              }\n            },\n            timeZone: {\n              t: 0\n            },\n            timeZoneOffset: {\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            },\n            unitSizePolicy: {\n              t: 0,\n              d: 6\n            },\n            vgrid: {\n              t: 9\n            }\n          }, rt.TimeChartSettingsToolbar = {\n            displayPeriod: {\n              t: 9\n            },\n            displayUnit: {\n              t: 9\n            },\n            enabled: {\n              t: 9\n            },\n            items: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                u: 0,\n                b: [{\n                  t: 5,\n                  u: 0,\n                  c: function c() {\n                    return rt.BaseSettingsToolbarItem;\n                  },\n                  x: function x() {\n                    return n.Base.SettingsToolbarItem;\n                  }\n                }, {\n                  t: 0\n                }]\n              }]\n            },\n            logScale: {\n              t: 9\n            },\n            periods: {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return rt.TimeChartSettingsAreaDisplayPeriod;\n                },\n                x: function x() {\n                  return n.TimeChart.SettingsAreaDisplayPeriod;\n                }\n              }]\n            },\n            zoomOut: {\n              t: 9\n            },\n            zoomOutFunction: {\n              t: 4\n            }\n          }, s.SettingsMapping = rt, o(rt.BaseIChartErrorEventArguments, rt.BaseIChartEventArguments), o(rt.BaseIChartSettingsChangeEventArguments, rt.BaseIChartEventArguments), o(rt.BaseIDataErrorResponse, rt.BaseIDataObjectBase), o(rt.BaseSettingsBackgroundStyle, rt.BaseSettingsLineStyle), o(rt.BaseSettingsAdvancedStyleMessageBackground, rt.BaseSettingsBackgroundStyle), o(rt.BaseSettingsLegendPanel, rt.BaseSettingsChartPanel), o(rt.BaseSettingsToolbarItem, rt.BaseSettingsToolbarItemBase), o(rt.FacetChartIChartEventArguments, rt.BaseIChartEventArguments), o(rt.FacetChartIChartClickEventArguments, rt.FacetChartIChartEventArguments), o(rt.FacetChartIDataObjectCommon, rt.BaseIDataObjectBase), o(rt.FacetChartIDataObject, rt.FacetChartIDataObjectCommon), o(rt.FacetChartIDataObjectRoot, rt.FacetChartIDataObjectCommon), o(rt.FacetChartIDataObjectRoot, rt.BaseIDataErrorResponse), o(rt.LinearChartSettings, rt.BaseSettings), o(rt.FacetChartSettings, rt.LinearChartSettings), o(rt.LinearChartSettingsArea, rt.BaseSettingsArea), o(rt.FacetChartSettingsArea, rt.LinearChartSettingsArea), o(rt.LinearChartSettingsAreaStyle, rt.BaseSettingsAreaStyle), o(rt.FacetChartSettingsAreaStyle, rt.LinearChartSettingsAreaStyle), o(rt.PieChartSettingsData, rt.BaseSettingsData), o(rt.FacetChartSettingsData, rt.PieChartSettingsData), o(rt.FacetChartSettingsFacetAxisLabels, rt.BaseSettingsLabelStyle), o(rt.FacetChartSettingsFacetAxisTitleStyle, rt.BaseSettingsLabelStyle), o(rt.LinearChartSettingsSeriesColumnsStyle, rt.LinearChartSettingsSeriesStyle), o(rt.FacetChartSettingsSeriesColumnsStyle, rt.LinearChartSettingsSeriesColumnsStyle), o(rt.FacetChartSettingsFacetStyle, rt.FacetChartSettingsSeriesColumnsStyle), o(rt.LinearChartSettingsInteraction, rt.BaseSettingsInteraction), o(rt.FacetChartSettingsInteraction, rt.LinearChartSettingsInteraction), o(rt.FacetChartSettingsSeries, rt.LinearChartSettingsSeries), o(rt.LinearChartSettingsSeriesColumns, rt.LinearChartSettingsSeries), o(rt.FacetChartSettingsSeriesColumns, rt.LinearChartSettingsSeriesColumns), o(rt.FacetChartSettingsSeriesData, rt.LinearChartSettingsSeriesData), o(rt.LinearChartSettingsSeriesLines, rt.LinearChartSettingsSeries), o(rt.FacetChartSettingsSeriesLines, rt.LinearChartSettingsSeriesLines), o(rt.LinearChartSettingsSeriesLinesStyle, rt.LinearChartSettingsSeriesStyle), o(rt.FacetChartSettingsSeriesLinesStyle, rt.LinearChartSettingsSeriesLinesStyle), o(rt.FacetChartSettingsToolbar, rt.BaseSettingsToolbar), o(rt.ItemsChartIDataObjectBase, rt.BaseIDataErrorResponse), o(rt.ItemsChartIDataObjectNode, rt.ItemsChartIDataObjectBase), o(rt.GeoChartIGeoDataObjectNode, rt.ItemsChartIDataObjectNode), o(rt.GeoChartIAggregationDataObjectNode, rt.GeoChartIGeoDataObjectNode), o(rt.GeoChartIDataObject, rt.BaseIDataErrorResponse), o(rt.ItemsChartIDataObjectLink, rt.ItemsChartIDataObjectBase), o(rt.GeoChartIGeoDataObjectLink, rt.ItemsChartIDataObjectLink), o(rt.ItemsChartSettings, rt.BaseSettings), o(rt.GeoChartSettings, rt.ItemsChartSettings), o(rt.GeoChartSettingsAggregatedShapeStyle, rt.BaseSettingsBackgroundStyle), o(rt.GeoChartSettingsArea, rt.BaseSettingsArea), o(rt.GeoChartSettingsAreaStyle, rt.BaseSettingsAreaStyle), o(rt.ItemsChartSettingsData, rt.BaseSettingsData), o(rt.GeoChartSettingsData, rt.ItemsChartSettingsData), o(rt.ItemsChartSettingsInteraction, rt.BaseSettingsInteraction), o(rt.GeoChartSettingsInteraction, rt.ItemsChartSettingsInteraction), o(rt.GeoChartSettingsInteractionZooming, rt.ItemsChartSettingsInteractionZooming), o(rt.GeoChartSettingsLayerOverlay, rt.GeoChartSettingsLayerBase), o(rt.GeoChartSettingsLayerAggregated, rt.GeoChartSettingsLayerOverlay), o(rt.GeoChartSettingsLayerCharts, rt.GeoChartSettingsLayerOverlay), o(rt.GeoChartSettingsLayerItems, rt.GeoChartSettingsLayerBase), o(rt.GeoChartSettingsLayerShapes, rt.GeoChartSettingsLayerBase), o(rt.ItemsChartSettingsNodesLayerStyle, rt.ItemsChartSettingsItemsLayerStyle), o(rt.GeoChartSettingsNodesLayerStyle, rt.ItemsChartSettingsNodesLayerStyle), o(rt.GeoChartSettingsShapesLayerNodeStyle, rt.ItemsChartSettingsNodeStyle), o(rt.GeoChartSettingsShapesLayerStyle, rt.GeoChartSettingsNodesLayerStyle), o(rt.ItemsChartIChartEventArguments, rt.BaseIChartEventArguments), o(rt.ItemsChartIChartClickEventArguments, rt.ItemsChartIChartEventArguments), o(rt.ItemsChartSettingsAdvanced, rt.BaseSettingsAdvanced), o(rt.ItemsChartSettingsAuraStyle, rt.BaseSettingsBackgroundStyle), o(rt.ItemsChartSettingsItemsLayerLabelStyle, rt.BaseSettingsLabelStyle), o(rt.ItemsChartSettingsItemsLayerItemStyle, rt.ItemsChartSettingsItemsLayerLabelStyle), o(rt.ItemsChartSettingsItemsLayerLinkLabelStyle, rt.ItemsChartSettingsItemsLayerLabelStyle), o(rt.ItemsChartSettingsLinkClass, rt.ItemsChartSettingsItemClass), o(rt.ItemsChartSettingsLinkItem, rt.ItemsChartSettingsItemsLayerItemStyle), o(rt.ItemsChartSettingsLinkMenu, rt.ItemsChartSettingsMenu), o(rt.ItemsChartSettingsNodeClass, rt.ItemsChartSettingsItemClass), o(rt.ItemsChartSettingsNodeItem, rt.ItemsChartSettingsItemsLayerItemStyle), o(rt.ItemsChartSettingsNodeMenu, rt.ItemsChartSettingsMenu);\n          var st = rt.LinearChartSettingsEvents;\n          rt.LinearChartSettingsEvents = function (t, e) {\n            var i = st(t, e);\n            return o(i, rt.BaseSettingsEvents(t, e)), i;\n          }, o(rt.LinearChartSettingsLegend, rt.BaseSettingsLegend), o(rt.LinearChartSettingsLegendAdvanced, rt.BaseSettingsLegendAdvanced), o(rt.LinearChartSettingsLegendMarker, rt.BaseSettingsLegendMarker), o(rt.LinearChartSettingsLocalization, rt.BaseSettingsLocalization), o(rt.LinearChartSettingsLocalizationToolbar, rt.BaseSettingsLocalizationToolbar), o(rt.LinearChartSettingsSeriesCandleStick, rt.LinearChartSettingsSeries), o(rt.LinearChartSettingsSeriesCandleStickStyle, rt.LinearChartSettingsSeriesStyle), o(rt.LinearChartSettingsValueAxisBaseLineStyle, rt.BaseSettingsLineStyle), o(rt.LinearChartSettingsValueAxisTitleStyle, rt.BaseSettingsLabelStyle), o(rt.NetChartBarSettingsLocalizationToolbar, rt.BaseSettingsLocalizationToolbar), o(rt.NetChartBarSettingsToolbar, rt.BaseSettingsToolbar), o(rt.NetChartIChartEventArguments, rt.ItemsChartIChartEventArguments), o(rt.NetChartIChartClickEventArguments, rt.NetChartIChartEventArguments), o(rt.NetChartIDataObject, rt.BaseIDataErrorResponse), o(rt.NetChartIDataObjectLink, rt.ItemsChartIDataObjectLink), o(rt.NetChartIDataObjectNode, rt.ItemsChartIDataObjectNode), o(rt.NetChartSettings, rt.ItemsChartSettings), o(rt.NetChartSettingsArea, rt.BaseSettingsArea), o(rt.NetChartSettingsData, rt.ItemsChartSettingsData), o(rt.NetChartSettingsEvents, rt.BaseSettingsEvents(rt.NetChartIChartEventArguments, rt.NetChartIChartClickEventArguments)), o(rt.NetChartSettingsInteraction, rt.ItemsChartSettingsInteraction), o(rt.NetChartSettingsInteractionSelection, rt.ItemsChartSettingsInteractionSelection), o(rt.NetChartSettingsInteractionZooming, rt.ItemsChartSettingsInteractionZooming), o(rt.NetChartSettingsLegend, rt.BaseSettingsLegend), o(rt.NetChartSettingsLegendAdvanced, rt.BaseSettingsLegendAdvanced), o(rt.NetChartSettingsLocalization, rt.BaseSettingsLocalization), o(rt.NetChartSettingsStyle, rt.ItemsChartSettingsNodesLayerStyle), o(rt.PieChartIChartEventArguments, rt.BaseIChartEventArguments), o(rt.PieChartIChartClickEventArguments, rt.PieChartIChartEventArguments), o(rt.PieChartIDataObjectCommon, rt.BaseIDataObjectBase), o(rt.PieChartIDataObject, rt.PieChartIDataObjectCommon), o(rt.PieChartIDataObjectRoot, rt.PieChartIDataObjectCommon), o(rt.PieChartIDataObjectRoot, rt.BaseIDataErrorResponse), o(rt.PieChartSettings, rt.BaseSettings), o(rt.PieChartSettingsAdvanced, rt.BaseSettingsAdvanced), o(rt.PieChartSettingsEvents, rt.BaseSettingsEvents(rt.PieChartIChartEventArguments, rt.PieChartIChartClickEventArguments)), o(rt.PieChartSettingsInteraction, rt.BaseSettingsInteraction), o(rt.PieChartSettingsLegend, rt.BaseSettingsLegend), o(rt.PieChartSettingsLegendMarker, rt.BaseSettingsLegendMarker), o(rt.PieChartSettingsLocalization, rt.BaseSettingsLocalization), o(rt.TimeChartIChartEventArguments, rt.BaseIChartEventArguments), o(rt.TimeChartIDataObject, rt.BaseIDataErrorResponse), o(rt.TimeChartSettings, rt.LinearChartSettings), o(rt.TimeChartSettingsAdvanced, rt.BaseSettingsAdvanced), o(rt.TimeChartSettingsArea, rt.LinearChartSettingsArea), o(rt.TimeChartSettingsAreaStyle, rt.LinearChartSettingsAreaStyle), o(rt.TimeChartSettingsCurrentTime, rt.TimeChartSettingsMarker), o(rt.TimeChartSettingsData, rt.BaseSettingsData), o(rt.TimeChartSettingsEvents, rt.LinearChartSettingsEvents(rt.TimeChartIChartEventArguments, rt.TimeChartIChartEventArguments)), o(rt.TimeChartSettingsInteraction, rt.LinearChartSettingsInteraction), o(rt.TimeChartSettingsInteractionScrolling, rt.LinearChartSettingsInteractionScrolling), o(rt.TimeChartSettingsInteractionZooming, rt.LinearChartSettingsInteractionZooming), o(rt.TimeChartSettingsLocalization, rt.LinearChartSettingsLocalization), o(rt.TimeChartSettingsLocalizationToolbar, rt.LinearChartSettingsLocalizationToolbar), o(rt.TimeChartSettingsSeries, rt.LinearChartSettingsSeries), o(rt.TimeChartSettingsSeriesCandleStick, rt.LinearChartSettingsSeriesCandleStick), o(rt.TimeChartSettingsSeriesData, rt.LinearChartSettingsSeriesData), o(rt.TimeChartSettingsSeriesCandleStickData, rt.TimeChartSettingsSeriesData), o(rt.TimeChartSettingsSeriesColumns, rt.LinearChartSettingsSeriesColumns), o(rt.TimeChartSettingsSeriesLines, rt.LinearChartSettingsSeriesLines), o(rt.TimeChartSettingsSeriesLinesStyle, rt.LinearChartSettingsSeriesLinesStyle), o(rt.TimeChartSettingsToolbar, rt.BaseSettingsToolbar);\n\n          var at = function () {\n            function t() {}\n\n            return t.mergeDefaultValues = function (e, i, n, r, s, a) {\n              var o = i ? i.type : null;\n\n              if (!e || 0 === e.length) {\n                if (!o) return [];\n                e = [{\n                  type: o\n                }];\n              }\n\n              for (var l = [], h = 0; h < e.length; h++) {\n                var u = e[h],\n                    c = a + \"[\" + h + \"]\";\n\n                if (p.isObjectOrArray(u)) {\n                  var d = u.type || o;\n                  if (!d) throw new Error(\"`type` property must be specified in the settings for value: \" + c);\n                  var f = r(u, d),\n                      g = n[d];\n                  i && (delete i.type, t.updateRecursive(f, i, s(f, i), {}, c), i.type = o), g && t.updateRecursive(f, g, s(f, g), {}, c), t.updateRecursive(f, u, s(f, u), {}, c), l.push(f);\n                }\n              }\n\n              return l;\n            }, t.updateRecursive = function (t, e, i, n, r) {\n              if (void 0 === r && (r = \"\"), !t) throw new Error(\"Cannot update settings path '\" + r + \"' because the target object is not defined.\");\n              if (e) for (var s in e) {\n                if (e.hasOwnProperty(s)) {\n                  var a = e[s],\n                      o = (r.length ? r + \".\" : \"\") + s,\n                      l = this.findPropertyConfiguration(s, i, o);\n                  null !== l && void 0 !== a && this.copyValue(t, s, a, l, n, o);\n                }\n              }\n            }, t.copyValueMergeByID = function (t, e, i, n, r, s) {\n              if (null != i) {\n                if (6 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use merge-by-ID update mode which is only supported on arrays.\");\n                if (this.replacingSettings) return this.copyValueRecursive(t, e, i, n, r, s);\n                var a = t[e];\n                null == a && (t[e] = a = []);\n\n                for (var o = {}, l = 0; l < a.length; l++) {\n                  o[a[l].id] = a[l];\n                }\n\n                for (var h = 0; h < i.length; h++) {\n                  var u = i[h];\n\n                  if (null != u) {\n                    u.id || (u.id = p.getIdentifierStr());\n                    var c = o[u.id];\n                    r[e] || (r[e] = {}), this.copyValue(o, u.id, u, n.b[0], r[e], s + \"[\" + u.id + \"]\"), c || a.push(o[u.id]);\n                  }\n                }\n              }\n            }, t.retrieveOwnMethod = function (t, e) {\n              if (!t) return null;\n              var i = t[e],\n                  n = t.__baseType;\n              return n && n[e] === i ? null : i;\n            }, t.copyValueRecursive = function (t, e, i, n, r, s) {\n              if (null != i) {\n                var a = t[e];\n\n                if (n.c) {\n                  var o = n.x ? n.x() : null,\n                      l = this.retrieveOwnMethod(o, \"getMapping\"),\n                      h = l ? l(a, i) : n.c();\n\n                  if (null == a) {\n                    if (!o || n.y || this._ignoringCtor) a = {};else {\n                      var u = this.retrieveOwnMethod(o, \"createInstance\");\n                      a = u ? u(i) : new o();\n                    }\n                    t[e] = a;\n                  }\n\n                  if (n.y) try {\n                    this._ignoringCtor++, this.updateRecursive(a, i, h, r[e] = {}, s);\n                  } finally {\n                    this._ignoringCtor--;\n                  } else this.updateRecursive(a, i, h, r[e] = {}, s);\n                } else if (6 === n.t) t[e] = a = [], this.copyArray(a, i, n.b[0], r[e] = [], s);else {\n                  if (8 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use recursive update but does not define target object mapping.\");\n                  (null == a || this.replacingSettings) && (t[e] = a = {}), this.copyDictionary(a, i, n.b[0], r[e] = {}, s);\n                }\n              }\n            }, t.copyValue = function (t, e, i, n, r, s) {\n              if (void 0 === i) return delete t[e], void (r[e] = !0);\n              var a = this.ensurePropertyType(i, n, s);\n\n              if (a) {\n                i = a.value, n = a.configuration || n;\n                var o = t[e];\n                if (1 === n.u || void 0 === n.u) o !== i && (r[e] = i, t[e] = i);else if (2 === n.u) i = JSON.parse(JSON.stringify(i)), r[e] = i, t[e] = i;else if (4 === n.u) this.copyValueMergeByID(t, e, i, n, r, s);else if (3 === n.u) {\n                  if (null != i) {\n                    if (6 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use concat update which is only supported for arrays.\");\n                    o && !this.replacingSettings || (t[e] = o = []), this.copyArray(o, i, n.b[0], r[e] = [], s);\n                  }\n                } else {\n                  if (0 !== n.u) throw new Error(\"Property '\" + s + \"' does not have an update mode defined in the settings mapping or it is not implemented.\");\n                  this.copyValueRecursive(t, e, i, n, r, s);\n                }\n              }\n            }, t.copyDictionary = function (t, e, i, n, r) {\n              for (var s = Object.keys(e), a = 0; a < s.length; a++) {\n                var o = s[a],\n                    l = {};\n                this.copyValue(t, o, e[o], i, l, r + \".\" + o), p.hasProperties(l) && (n[o] = l);\n              }\n            }, t.copyArray = function (t, e, i, n, r) {\n              for (var s = 0; s < e.length; s++) {\n                this.copyValue(t, t.length, e[s], i, n, r + \"[\" + s + \"]\");\n              }\n            }, t.ensurePropertyType = function (t, e, i, n) {\n              if (void 0 === n && (n = !1), null == t) return {\n                value: t\n              };\n              var r = null,\n                  s = null,\n                  a = void 0,\n                  o = null;\n\n              switch (e.t) {\n                case 0:\n                  t instanceof String && (t = t.valueOf()), p.isString(t) || (r = \"String\");\n                  break;\n\n                case 1:\n                  if (t instanceof Number && (t = t.valueOf()), 0 === e.d) {\n                    a = parseFloat(t);\n                    var l = Math.round(a);\n                    if (isNaN(a)) r = \"Integer\";else if (l !== a) {\n                      var h = Math.abs(l - a);\n                      n || p.warn(\"Settings value '\" + i + \"' expected to be an Integer but contains a decimal point: \" + a + \".\"), h < 1e-8 && (a = l);\n                    }\n                  } else a = parseFloat(t), isNaN(a) && (r = \"Float\");\n\n                  break;\n\n                case 3:\n                  p.isString(t) ? (a = document.getElementById(t)) || (s = \"the property expects either a reference to a DOM element or a string containing the ID of the element. There is no element with the given ID '\" + t + \"'.\") : p.isDomObject(t) || (s = \"the property expects either a reference to a DOM element or a string containing the ID of the element.\");\n                  break;\n\n                case 4:\n                  p.isFunction(t) || (r = \"Function\");\n                  break;\n\n                case 6:\n                  Array.isArray(t) || (n ? r = \"Array\" : (p.warn(\"Settings value '\" + i + \"' expected to be an array but found \" + typeof t + \". The value will be wrapped in an array.\"), a = [t]));\n                  break;\n\n                case 16:\n                case 16:\n                  \"undefined\" != typeof Float32Array && t instanceof Float32Array || (r = \"Float32Array\");\n                  break;\n\n                case 17:\n                  \"undefined\" != typeof Int32Array && t instanceof Int32Array || (r = \"Int32Array\");\n                  break;\n\n                case 18:\n                  \"undefined\" != typeof Uint32Array && t instanceof Uint32Array || (r = \"UInt32Array\");\n                  break;\n\n                case 11:\n                  if (Array.isArray(t)) for (var u = 0; u < t.length; u++) {\n                    var c = t[u];\n\n                    if (!Array.isArray(c) || 2 !== c.length || !p.isNumber(c[0]) || !p.isString(c[1])) {\n                      s = \"the property at index \" + u + \" has to be an array with two elements - a number and a string.\";\n                      break;\n                    }\n                  } else s = \"the property has to be an array where each item is an array with two elements - a number and a string.\";\n                  break;\n\n                case 2:\n                  var d = e.e(),\n                      f = p.isNumber(t);\n                  f || p.isString(t) ? (void 0 === (a = d[t]) && (s = \"'\" + t + \"' is not a valid enumeration value. Please review the documentation for valid values.\", t = d), f && (a = t)) : (s = \"the value must be a number or a string (the preferred way is to use the enumeration from 'ZoomCharts.Configuration' namespace).\", t = d);\n                  break;\n\n                case 14:\n                  t instanceof CanvasGradient || (r = \"CanvasGradient\");\n                  break;\n\n                case 12:\n                  if (Array.isArray(t) && t.length === e.b.length) for (var g = 0; g < t.length; g++) {\n                    var m = this.ensurePropertyType(t[g], e.b[g], i + \"[\" + g + \"]\", n);\n                    if (!m) return null;\n                    t[g] = m.value;\n                  } else s = \"the property expects an array with exactly \" + e.b.length + \" elements.\";\n                  break;\n\n                case 7:\n                  for (var v = !1, y = 0; y < e.b.length; y++) {\n                    var S = this.ensurePropertyType(t, e.b[y], i, !0);\n\n                    if (S) {\n                      a = S.value, o = S.configuration || e.b[y], v = !0;\n                      break;\n                    }\n                  }\n\n                  v || (s = \"the the given value does not match any constituent of the union type. Please review the documentation on the correct type.\");\n                  break;\n\n                case 5:\n                case 8:\n                  p.isObjectOrArray(t) || (r = \"Object\");\n                  break;\n\n                case 9:\n                  t instanceof Boolean && (t = t.valueOf()), null !== t && !0 !== t && !1 !== t && (r = \"Boolean\");\n                  break;\n\n                case 10:\n                  break;\n\n                default:\n                  throw new Error(\"Unsupported data type: \" + e.t);\n              }\n\n              return null !== r && null === s && (s = \"the given value '\" + t + \"' is not of type '\" + r + \"'.\"), null !== s ? (n || p.error(\"Cannot update settings value '\" + i + \"' because \" + s, t), null) : (void 0 !== a && (t = a), {\n                value: t,\n                configuration: o\n              });\n            }, t.findPropertyConfiguration = function (t, e, i) {\n              var n = e[t];\n              return void 0 !== n ? n : (p.warn(\"Cannot update settings value '\" + i + \"' because such property does not exist.\", null, !0), null);\n            }, t;\n          }();\n\n          at._ignoringCtor = 0, at.replacingSettings = !1, s.SettingsHelper = at;\n\n          var ot = function () {\n            function t(t) {\n              this._mapping = null, this._computedDataMap = {}, this._initializing = !0, this.container = null, this.theme = null, this.assetsUrlBase = \"\", this.area = new ct(), this.data = [], this.advanced = new ft(), this.events = new lt(), this.interaction = new pt(), this.localization = new ht(), this.toolbar = new J(), this.title = new z(), this.credits = new F(), this.legend = new Z(), this._mapping = t;\n            }\n\n            return t.prototype.applyGlobalCustomizations = function () {\n              this.theme && at.updateRecursive(this, this.theme, this._mapping, {});\n            }, t.prototype.applyCompatibility = function (t, e, i) {\n              i = null == i ? \"\" : i + \".\";\n\n              for (var n = 0; n < e.length; n++) {\n                var r = e[n],\n                    s = r.from,\n                    a = p.getProp(t, s, !!r.to && !r.filter);\n                if (void 0 !== a && (!r.filter || r.filter(a))) if (r.to) r.transform && (a = r.transform(a)), p.extendDeep(t, p.wrapValue(a, r.to)), p.warn(\"Setting `\" + i + s + \"` is being deprecated. Compatibility layer moved the value automatically to `\" + i + r.to + \"`. Please update the configuration to avoid using the obsolete property.\", null, !0);else {\n                  var o = r.alternativeAsWarning,\n                      l = \"Setting `\" + i + s + \"` \" + (o ? \"is being deprecated\" : \"is no longer supported\") + \". Consider using `\" + r.alternative + \"` instead.\";\n                  o ? p.warn(l, null, !0) : p.error(l);\n                }\n              }\n            }, t.prototype.apply = function (t) {\n              this.applyCompatibility(t, [{\n                from: \"width\",\n                to: \"area.width\"\n              }, {\n                from: \"height\",\n                to: \"area.height\"\n              }, {\n                from: \"minHeight\",\n                to: \"area.minHeight\"\n              }, {\n                from: \"maxHeight\",\n                to: \"area.maxHeight\"\n              }, {\n                from: \"minWidth\",\n                to: \"area.minWidth\"\n              }, {\n                from: \"maxWidth\",\n                to: \"area.maxWidth\"\n              }]);\n              var e = {},\n                  i = !1;\n              if (this._initializing) this.applyGlobalCustomizations(), t || (t = {}), t.data || (t.data = [{}]);else if (!t) return e;\n\n              if (t.data) {\n                Array.isArray(t.data) || (t.data = [t.data], i = !0);\n\n                for (var n = 0; n < t.data.length; n++) {\n                  var r = t.data[n];\n                  r.id || (r.name ? (p.warn(\"The property `name` in the data object configuration is deprecated in favor of `id` property. Please update the configuration to avoid using the obsolete property.\", null, !0), r.id = r.name, delete r.name) : r.id = 0 === n ? \"default\" : \"default-\" + n.toString(10));\n                }\n              }\n\n              if (at.updateRecursive(this, t.theme, this._mapping, e), at.updateRecursive(this, t, this._mapping, e), i && (t.data = t.data[0]), e.data || this._initializing) {\n                this._computedDataMap = {};\n\n                for (n = 0; n < this.data.length; n++) {\n                  var s = this.data[n];\n                  this._computedDataMap[s.id] = s;\n                }\n              }\n\n              return e;\n            }, t;\n          }();\n\n          s.Settings = ot;\n\n          var lt = function () {\n            return function () {\n              this.onError = null, this.onSettingsChange = null, this.onClick = null, this.onDoubleClick = null, this.onTripleClick = null, this.onRightClick = null, this.onHoverChange = null, this.onSelectionChange = null, this.onChartUpdate = null, this.onPositionChange = null, this.chartUpdateDelay = 0;\n            };\n          }();\n\n          s.SettingsEvents = lt;\n\n          var ht = function () {\n            return function () {\n              this.toolbar = new ut(), this.loadingLabel = \"Loading...\", this.closeButton = \"Close\", this.dataRequestFailed = \"Data request failed\", this.exportNotAvailable = \"Your browser does not support exporting the chart.\";\n            };\n          }();\n\n          s.SettingsLocalization = ht;\n\n          var ut = function () {\n            return function () {\n              this.backButton = \"Back\", this.backTitle = \"Move one step back in navigation\", this.fullscreenButton = \"Fullscreen\", this.fullscreenTitle = \"Toggle fullscreen mode\", this.zoomoutButton = \"Zoom-out\", this.zoomoutTitle = \"Zoom out\", this.exportButton = \"Export\", this.exportTitle = \"Export Data\", this.exportJpeg = \"For Office and Web (jpeg)\", this.exportPNG = \"For Photoshop (png)\", this.exportPDF = \"For Printer (pdf)\", this.exportCSV = \"Spreadsheet (csv)\", this.exportXLS = \"Spreadsheet (xls)\";\n            };\n          }();\n\n          s.SettingsLocalizationToolbar = ut;\n\n          var ct = function () {\n            return function () {\n              this.defaultHeight = 300, this.width = null, this.height = null, this.top = null, this.left = null, this.minHeight = 50, this.maxHeight = 2e4, this.minWidth = 50, this.maxWidth = 2e4, this.style = new dt();\n            };\n          }();\n\n          s.SettingsArea = ct;\n\n          var dt = function () {\n            return function () {\n              this.fillColor = \"transparent\", this.image = null, this.overlayColor = null;\n            };\n          }();\n\n          s.SettingsAreaStyle = dt;\n\n          var pt = function () {\n            return function () {\n              this.resizing = new it();\n            };\n          }();\n\n          s.SettingsInteraction = pt;\n\n          var ft = function () {\n            return function () {\n              this.labelCache = !0, this.labelCacheRotated = !0, this.highDPI = !0, this.pointer = new gt(), this.useAnimationFrame = !0, this.showTouches = !1, this.showTouchTrail = !0, this.showFPS = !1, this.showTimestamp = !1, this.logging = !1, this.style = new mt(), this.maxCanvasWidth = 4096, this.maxCanvasHeight = 4096, this.themeCSSClass = \"DVSL-round\", this.assets = [{\n                url: \"assets://zc.css\",\n                required: function required() {\n                  return !p.isStyleSheetDefined(\"DVSL-suppress-default-styles\", \"color\");\n                }\n              }], this.builtinAssets = {\n                \"logo-blank\": l.LicenseBannerBlank,\n                \"logo-supported-by\": l.LicenseBannerSupportedBy,\n                \"logo-development\": l.LicenseBannerDevelopment,\n                \"logo-license-expired\": l.LicenseBannerExpired,\n                \"logo-unlicensed\": l.LicenseBannerUnlicensed\n              }, this.exportProxyURL = \"https://echo.zoomcharts-cloud.com/download\", this.exportPdfSize = [210, 297], this.crossOriginHeader = null, this.dataExportFunction = null;\n            };\n          }();\n\n          s.SettingsAdvanced = ft;\n\n          var gt = function () {\n            return function () {\n              this.noClickOnDoubleClick = !0, this.clickSensitivity = 10, this.doubleClickSensitivity = 20, this.doubleClickTimeout = 300, this.longPressTimeout = 500, this.longPressSensitivity = 10, this.speedAveragingPeriod = 200, this.scrollIntoView = !1, this.mouseWheelRequiresFocus = !1;\n            };\n          }();\n\n          s.SettingsAdvancedPointer = gt;\n\n          var mt = function () {\n            return function () {\n              this.messageTextStyle = {\n                fillColor: \"#000\",\n                font: \"15px Arial\"\n              }, this.messageBackgroundStyle = {\n                padding: 5\n              }, this.loadingArcStyle = {\n                r: 10,\n                lineColor: \"#444\",\n                lineWidth: 1,\n                location: \"center\"\n              };\n            };\n          }();\n\n          s.SettingsAdvancedStyle = mt;\n\n          var vt = function () {\n            function t(t, e, i, n) {\n              t !== 1 / 0 && t > i ? (this.x1 = t, this.x0 = i) : (this.x1 = i, this.x0 = t), e !== 1 / 0 && e > n ? (this.y1 = e, this.y0 = n) : (this.y1 = n, this.y0 = e);\n            }\n\n            return t.createEmpty = function () {\n              return new t(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n            }, t.prototype.isEmpty = function () {\n              return this.x0 >= this.x1 || this.y0 >= this.y1;\n            }, t.prototype.clone = function () {\n              return new t(this.x0, this.y0, this.x1, this.y1);\n            }, t.prototype.w = function () {\n              return this.x1 - this.x0;\n            }, t.prototype.h = function () {\n              return this.y1 - this.y0;\n            }, t.prototype.equals = function (t) {\n              return this.x0 === t.x0 && this.x1 === t.x1 && this.y0 === t.y0 && this.y1 === t.y1;\n            }, t.prototype.inflate = function (t) {\n              var e = (this.x0 + this.x1) / 2,\n                  i = (this.y0 + this.y1) / 2;\n              return this.x0 = (this.x0 - e) * t + e, this.x1 = (this.x1 - e) * t + e, this.y0 = (this.y0 - i) * t + i, this.y1 = (this.y1 - i) * t + i, this;\n            }, t.prototype.clip = function (t) {\n              return this.x0 = Math.max(this.x0, t.x0), this.x1 = Math.min(this.x1, t.x1), this.y0 = Math.max(this.y0, t.y0), this.y1 = Math.min(this.y1, t.y1), this;\n            }, t.prototype.isInside = function (t) {\n              return this.x0 >= t.x0 && this.x1 <= t.x1 && this.y0 >= t.y0 && this.y1 <= t.y1;\n            }, t.prototype.isOutside = function (t) {\n              return this.x0 > t.x1 || this.x1 < t.x0 || this.y0 > t.y1 || this.y1 < t.y0;\n            }, t.prototype.overlapsRect = function (t, e, i, n) {\n              return t < this.x1 && i > this.x0 && e < this.y1 && n > this.y0;\n            }, t.prototype.intersectsSegment = function (t, e, i, n) {\n              return null != s.Geometry.clipSegmentToRect(t, e, i - t, n - e, this.x0, this.y0, this.x1, this.y1);\n            }, t.prototype.area = function () {\n              return (this.x1 - this.x0) * (this.y1 - this.y0);\n            }, t.prototype.toString = function () {\n              return this.x0 + \",\" + this.y0 + \", \" + this.x1 + \", \" + this.y1;\n            }, t.prototype.addPoint = function (t, e) {\n              return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, t), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, e), this;\n            }, t.prototype.addBounds = function (t, e, i, n) {\n              return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, i), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, n), this;\n            }, t.prototype.addRect = function (t) {\n              return this.x0 = Math.min(this.x0, t.x0), this.x1 = Math.max(this.x1, t.x1), this.y0 = Math.min(this.y0, t.y0), this.y1 = Math.max(this.y1, t.y1), this;\n            }, t.prototype.moveBy = function (t, e) {\n              return this.x0 += t, this.x1 += t, this.y0 += e, this.y1 += e, this;\n            }, t.prototype.containsPoint = function (t, e) {\n              return t >= this.x0 && t < this.x1 && e >= this.y0 && e < this.y1;\n            }, t.prototype.addLine = function (t) {\n              for (var e = 0; e <= t.length - 2; e += 2) {\n                this.addPoint(t[e], t[e + 1]);\n              }\n\n              return this;\n            }, t.prototype.translate = function (t, e, i, n) {\n              return this.x0 = this.x0 * t + e, this.x1 = this.x1 * t + e, this.y0 = this.y0 * i + n, this.y1 = this.y1 * i + n, this;\n            }, t.prototype.overlaps = function (t) {\n              return this.x0 < t.x1 && this.x1 > t.x0 && this.y0 < t.y1 && this.y1 > t.y0;\n            }, t;\n          }();\n\n          s.Rect = vt;\n\n          var yt = function () {\n            return function (t, e) {\n              this.msg = t, this.pri = e;\n            };\n          }(),\n              St = function () {\n            function t() {\n              this.settings = null, this.assetsLoader = null, this.mainData = null, this.mainDataEnabled = !0, this.chartLeft = 0, this.chartTop = 0, this.chartWidth = 1, this.chartHeight = 1, this.x0 = 0, this.y0 = 0, this.height = 0, this.width = 0, this.leftMargin = 0, this.rightMargin = 0, this.topMargin = 0, this.bottomMargin = 0, this.loading = !0, this.messages = {}, this.backStack = [];\n            }\n\n            return t.prototype.setMessage = function (t, e, i) {\n              var n;\n              return void 0 === i && (i = 0), e ? (n = !this.messages[t] || this.messages[t].msg !== e || this.messages[t].pri !== i, this.messages[t] = new yt(e, i)) : (n = this.messages.hasOwnProperty(t), delete this.messages[t]), n;\n            }, t.prototype.getMessage = function () {\n              var t = null,\n                  e = 0;\n\n              for (var i in this.messages) {\n                var n = this.messages[i];\n                n.pri > e && (t = n.msg, e = n.pri);\n              }\n\n              return t;\n            }, t.prototype.pushBack = function (t) {\n              this.backStack.push(t), this.backStack.length > 1e3 && (this.backStack = this.backStack.slice(200));\n            }, t;\n          }();\n\n          s.Scene = St;\n\n          var bt = 2 * Math.PI,\n              Ct = function () {\n            function t() {}\n\n            return t.distanceToSegmentSq = function (t, e, i, n, r, s) {\n              var a,\n                  o,\n                  l = i - t,\n                  h = n - e,\n                  u = l * l + h * h,\n                  c = -1;\n              0 !== u && (c = ((r - t) * l + (s - e) * h) / u), c < 0 ? (a = t, o = e) : c > 1 ? (a = i, o = n) : (a = t + c * l, o = e + c * h);\n              var d = r - a,\n                  p = s - o;\n              return d * d + p * p;\n            }, t.rayIntersectsSegment = function (t, e, i, n, r, s, a, o) {\n              var l = 1 / 0,\n                  h = a - r,\n                  u = o - s,\n                  c = i * u - n * h;\n\n              if (0 !== c) {\n                var d,\n                    p = (e * h - t * u + r * u - s * h) / c;\n                (d = Math.abs(h) > Math.abs(u) ? (t + i * p - r) / h : (e + n * p - s) / u) >= 0 && d <= 1 && p >= 0 && (l = p);\n              }\n\n              return l;\n            }, t.lineIntersectsSegment = function (t, e, i, n, r, s, a, o) {\n              var l = 1 / 0,\n                  h = a - r,\n                  u = o - s,\n                  c = i * u - n * h;\n\n              if (0 !== c) {\n                var d,\n                    p = (e * h - t * u + r * u - s * h) / c;\n                (d = Math.abs(h) > Math.abs(u) ? (t + i * p - r) / h : (e + n * p - s) / u) >= 0 && d <= 1 && (l = p);\n              }\n\n              return l;\n            }, t.lineIntersectsLine = function (t, e, i, n, r, s, a, o) {\n              var l = 1 / 0,\n                  h = i - t,\n                  u = n - e,\n                  c = a - r,\n                  d = o - s,\n                  p = h * d - u * c;\n\n              if (0 !== p) {\n                var f = (e * c - t * d + r * d - s * c) / p;\n                Math.abs(c) > Math.abs(d) ? (t + h * f - r) / c : (e + u * f - s) / d, l = f;\n              }\n\n              return l;\n            }, t.rayIntersectsCircle = function (t, e, i, n, r) {\n              var s = i * i + n * n,\n                  a = t * i + e * n,\n                  o = a * a - s * (t * t + e * e - r * r),\n                  l = 1 / 0;\n\n              if (o > 0) {\n                var h = (-a - (o = Math.sqrt(o))) / s,\n                    u = (-a + o) / s;\n                h >= 0 && (l = h), u >= 0 && (l = Math.min(l, u));\n              }\n\n              return l;\n            }, t.clipSegmentToRect = function (t, e, i, n, r, s, a, o) {\n              var l = 0,\n                  h = 1;\n\n              if (0 !== n) {\n                var u = 1 / n,\n                    c = (s - e) * u,\n                    d = (o - e) * u;\n                if (l = Math.min(c, d), h = Math.max(c, d), l > 1 || h < 0) return null;\n              } else if (e < s || e > o) return null;\n\n              if (0 !== i) {\n                var p = 1 / i,\n                    f = (r - t) * p,\n                    g = (a - t) * p,\n                    m = Math.min(f, g),\n                    v = Math.max(f, g);\n                if (l = Math.max(l, m), h = Math.min(h, v), l > 1 || h < 0 || l > h) return null;\n              } else if (t < r || t > a) return null;\n\n              return [l, h];\n            }, t.rayIntersectsCircleOuter = function (t, e, i, n, r) {\n              var s = i * i + n * n,\n                  a = t * i + e * n,\n                  o = a * a - s * (t * t + e * e - r * r);\n              return o = Math.sqrt(o), Math.max((-a + o) / s, (-a - o) / s);\n            }, t.lineTouchingCircle = function (t, e, i, n, r) {\n              var s = Math.sqrt(t * t + e * e);\n              if (!(s > r)) return null;\n              var a = r * Math.sqrt(s * s - r * r) / s,\n                  o = r * r / s,\n                  l = t / s,\n                  h = e / s;\n              return t * n - e * i < 0 && (a = -a), {\n                x: l * o - h * a,\n                y: h * o + l * a\n              };\n            }, t.distanceToPolygonSq = function (e, i, n) {\n              if (t.isInsidePolygon(e, i, n)) return 0;\n\n              for (var r = 1 / 0, s = 0; s < n.length; s++) {\n                for (var a = n[s], o = a.length, l = a[o - 2], h = a[o - 1], u = 0; u <= o - 2; u += 2) {\n                  var c = a[u],\n                      d = a[u + 1];\n                  r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d;\n                }\n              }\n\n              return r;\n            }, t.distanceToLinesSq = function (e, i, n) {\n              for (var r = 1 / 0, s = 0; s < n.length; s++) {\n                var a = n[s],\n                    o = a.length;\n                if (2 === o) r = Math.min(r, (e - a[0]) * (e - a[0]) + (i - a[1]) * (i - a[1]));else if (o > 2) for (var l = a[0], h = a[1], u = 2; u <= o - 2; u += 2) {\n                  var c = a[u],\n                      d = a[u + 1];\n                  r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d;\n                }\n              }\n\n              return r;\n            }, t.isInsidePolygon = function (t, e, i) {\n              for (var n = !1, r = 0; r < i.length; r++) {\n                for (var s = i[r], a = s.length, o = s[a - 2], l = s[a - 1], h = 0; h <= a - 2; h += 2) {\n                  var u = s[h],\n                      c = s[h + 1];\n                  c > e != l > e && t < (u - o) * (e - l) / (c - l) + o && (n = !n), o = u, l = c;\n                }\n              }\n\n              return n;\n            }, t.distanceToBalloon = function (e, i, n, r) {\n              var s;\n              if (e >= i) s = e;else if (0 === r) s = i;else {\n                s = e / r * p.sign(r), Math.abs(n * s) > i - e && (s = t.rayIntersectsCircleOuter(-(i - e), 0, Math.abs(n), r, e));\n              }\n              return s;\n            }, t.distanceToRect = function (t, e, i, n, r, a, o) {\n              var l, h, u, c;\n              return void 0 === o && (o = !1), i instanceof s.Rect ? (o = n, l = i.x0, h = i.y0, r = i.x1, a = i.y1) : (l = i, h = n), u = t < l ? l - t : t > r ? t - r : 0, c = e < h ? h - e : e > a ? e - a : 0, o ? u * u + c * c : Math.sqrt(u * u + c * c);\n            }, t.clipSegmentToBounds = function (e, i, n, r, s, a, o, l, h, u) {\n              var c = Math.max(s, a),\n                  d = n - e,\n                  p = r - i,\n                  f = t.clipSegmentToRect(e, i, d, p, o - c, l - c, h + c, u + c);\n              if (null === f) return null;\n              var g = Math.max(0, f[0]),\n                  m = Math.min(1, f[1]);\n              return [e + d * g, i + p * g, e + d * m, i + p * m];\n            }, t.computeBoundsSize = function (t) {\n              for (var e = 1 / 0, i = -1 / 0, n = 1 / 0, r = -1 / 0, s = t.length, a = 0; a < s; a += 2) {\n                var o = t[a],\n                    l = t[a + 1];\n                e = Math.min(o, e), i = Math.max(o, i), n = Math.min(l, n), r = Math.max(l, r);\n              }\n\n              return Math.max(i - e, r - n);\n            }, t.simplify = function (e, i) {\n              if (!i || !e.length) return e;\n              var n = i * i;\n              return e = t.reducePoints(e, n), t.simplifyDP(e, n);\n            }, t.simplifyDP = function (e, i) {\n              var n,\n                  r = e.length;\n              (n = \"undefined\" != typeof Uint8Array ? new Uint8Array(r) : new Array(r))[0] = n[r - 2] = 1, t.simplifyDPStep(e, n, i, 0, r - 2);\n\n              for (var s = [], a = 0; a < r; a += 2) {\n                n[a] && (s.push(e[a]), s.push(e[a + 1]));\n              }\n\n              return s;\n            }, t.simplifyDPStep = function (e, i, n, r, s) {\n              for (var a = 0, o = 0, l = e[r], h = e[r + 1], u = e[s], c = e[s + 1], d = r + 2; d <= s - 2; d += 2) {\n                var p = t.distanceToSegmentSq(l, h, u, c, e[d], e[d + 1]);\n                p > a && (o = d, a = p);\n              }\n\n              a > n && (i[o] = 1, t.simplifyDPStep(e, i, n, r, o), t.simplifyDPStep(e, i, n, o, s));\n            }, t.reducePoints = function (t, e) {\n              for (var i, n, r = t[0], s = t[1], a = [r, s], o = t.length, l = 2; l < o; l += 2) {\n                (r - (i = t[l])) * (r - i) + (s - (n = t[l + 1])) * (s - n) > e && (a.push(i), a.push(n), r = i, s = n);\n              }\n\n              return r !== i && s !== n && a.push(i, n), a;\n            }, t.transformPolyline = function (t, e, i, n, r) {\n              for (var s = [], a = 0; a < t.length; a += 2) {\n                s.push(t[a] * e + i, t[a + 1] * n + r);\n              }\n\n              return s;\n            }, t.outlinePolylineByVectors = function (t, e, i) {\n              for (var n = [], r = [], a = t.length - 2, o = 0; o < a; o += 2) {\n                var l = e[o] * i,\n                    h = e[o + 1] * i,\n                    u = t[o] + l,\n                    c = t[o + 1] + h,\n                    d = t[o + 2] + l,\n                    p = t[o + 3] + h;\n                n.push(u, c, d, p);\n              }\n\n              r = n.slice(0, 2), a = n.length - 4;\n\n              for (o = 0; o < a; o += 4) {\n                var f = s.Geometry.lineIntersectsLine(n[o], n[o + 1], n[o + 2], n[o + 3], n[o + 4], n[o + 5], n[o + 6], n[o + 7]);\n                f === 1 / 0 ? r.push(n[o + 2], n[o + 3]) : r.push(n[o] + (n[o + 2] - n[o]) * f, n[o + 1] + (n[o + 3] - n[o + 1]) * f);\n              }\n\n              return r.push.apply(r, n.slice(-2)), r;\n            }, t.calculatePolyArea = function (t) {\n              for (var e = 0, i = t, n = t.length - 2, r = 0; r < n; r += 2) {\n                e += i[r] * i[r + 3] - i[r + 2] * i[r + 1];\n              }\n\n              return e / 2;\n            }, t.calculatePolyCentroid = function (t, e) {\n              var i,\n                  n = 0,\n                  r = 0,\n                  s = t.length - 2;\n              e *= 6;\n\n              for (var a = 0; a < s; a += 2) {\n                i = t[a] * t[a + 3] - t[a + 2] * t[a + 1], n += (t[a] + t[a + 2]) * i, r += (t[a + 1] + t[a + 3]) * i;\n              }\n\n              return {\n                x: n / e,\n                y: r / e\n              };\n            }, t.normalizeAngle = function (t) {\n              return t < 0 ? (t %= bt, t += bt) : t >= bt && (t %= bt), t;\n            }, t.sectorBetweenAngles = function (t, e) {\n              for (; e < t;) {\n                e += bt;\n              }\n\n              return e - t;\n            }, t.subtractAngle = function (t, e) {\n              var i = t - e;\n              return i > Math.PI ? i -= bt : i < -Math.PI && (i += bt), i;\n            }, t.rotateVector = function (t, e, i, n) {\n              return {\n                x: t * n - e * i,\n                y: t * i + e * n\n              };\n            }, t.circle2 = function (t, e, i) {\n              i.x = (t[0] + e[0]) / 2, i.y = (t[1] + e[1]) / 2, i.r = ((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) / 4;\n            }, t.circle3 = function (t, e, i, n) {\n              var r = t[0],\n                  s = t[1],\n                  a = e[0],\n                  o = e[1],\n                  l = i[0],\n                  h = i[1],\n                  u = 2 * (r * (o - h) + a * (h - s) + l * (s - o));\n\n              if (0 === u) {\n                var c = Math.min(r, a, l),\n                    d = Math.min(s, o, h);\n                n.x = (c + Math.max(r, a, l)) / 2, n.y = (d + Math.max(s, o, h)) / 2, n.r = (n.x - c) * (n.x - c) + (n.y - d) * (n.y - d);\n              } else n.x = ((r * r + s * s) * (o - h) + (a * a + o * o) * (h - s) + (l * l + h * h) * (s - o)) / u, n.y = ((r * r + s * s) * (l - a) + (a * a + o * o) * (r - l) + (l * l + h * h) * (a - r)) / u, n.r = (r - n.x) * (r - n.x) + (s - n.y) * (s - n.y);\n            }, t.pointDistance = function (t, e) {\n              return (e[0] - t.x) * (e[0] - t.x) + (e[1] - t.y) * (e[1] - t.y);\n            }, t.pointsInCircle = function (e, i, n) {\n              return t.pointDistance(e, i) - e.r <= 1e-5 && (!n || t.pointDistance(e, n) - e.r <= 1e-5);\n            }, t.circumscribeCircle = function (e) {\n              function i(e, i, n, l, h) {\n                if (n ? t.circle3(e, i, n, s) : t.circle2(e, i, s), (!l || t.pointsInCircle(s, l, h)) && !(o && r.r <= s.r)) {\n                  var u = r;\n                  r = s, s = u, a[0] = e, a[1] = i, a[2] = n, o = !0;\n                }\n              }\n\n              if (null == e || e.length < 1) return null;\n              if (1 === e.length) return {\n                x: e[0].x,\n                y: e[0].y,\n                r: e[0].r\n              };\n              var n = [[e[0].x - e[0].r, e[0].y], [e[0].x + e[0].r, e[0].y], null],\n                  r = {\n                x: 0,\n                y: 0,\n                r: 0\n              };\n              t.circle2(n[0], n[1], r);\n\n              for (var s = {\n                x: 0,\n                y: 0,\n                r: 0\n              }, a = [[0, 0], [0, 0], [0, 0]], o = !1, l = t.pointKoef, h = [0, 0], u = 0; u < e.length; u++) {\n                for (var c = 0; c < 8; c++) {\n                  if (h[0] = e[u].x + e[u].r * l[c][0], h[1] = e[u].y + e[u].r * l[c][1], !(n[0][0] === h[0] && n[0][1] === h[1] || n[1][0] === h[0] && n[1][1] === h[1] || n[2] && n[2][0] === h[0] && n[2][1] === h[1] || t.pointsInCircle(r, h))) {\n                    var d = [h[0], h[1]];\n                    o = !1, i(n[0], d, null, n[1], n[2]), i(n[1], d, null, n[0], n[2]), i(n[0], n[1], d, n[2], null), n[2] && (i(n[2], d, null, n[0], n[1]), i(n[0], n[1], d, n[2], null), i(n[1], n[2], d, n[0], null), i(n[0], n[2], d, n[1], null));\n                    var p = n;\n                    n = a, a = p, u = -1;\n                    break;\n                  }\n                }\n              }\n\n              return r.r = Math.sqrt(r.r), r;\n            }, t.findWeightedCenter = function (t) {\n              for (var e = 0, i = 0, n = 0, r = 0; r < t.length; r++) {\n                var s = t[r];\n                e += s.x * s.r, i += s.y * s.r, n += s.r;\n              }\n\n              return {\n                x: e / n,\n                y: i / n,\n                r: n / t.length\n              };\n            }, t;\n          }();\n\n          Ct.pointKoef = [[-1, 0], [0, -1], [1, 0], [0, 1], [Math.SQRT1_2, Math.SQRT1_2], [-Math.SQRT1_2, Math.SQRT1_2], [Math.SQRT1_2, -Math.SQRT1_2], [-Math.SQRT1_2, -Math.SQRT1_2]], s.Geometry = Ct;\n\n          var xt = function () {\n            function t(t) {\n              this.scene = t, this.bounds = null;\n            }\n\n            return t.prototype.setBounds = function (t, e, i, n) {\n              this.bounds = new vt(t, e, i, n);\n            }, t.prototype.findObjectAt = function (t, e, i) {\n              return null;\n            }, t.prototype.remove = function () {}, t;\n          }();\n\n          s.Layer = xt, function (t) {\n            t.ToolbarItemNames.fullscreen = function (t, e) {\n              var i = t.settings.localization.toolbar;\n              return new s.Bar.ToggleButton(t, e, {\n                labelDisabled: e.label || i.fullscreenButton,\n                titleDisabled: e.title || i.fullscreenTitle,\n                cssClassEnabled: \"DVSL-bar-btn-fullscreen-active\",\n                cssClassDisabled: e.cssClass || \"DVSL-bar-btn-fullscreen\",\n                onEnable: function onEnable() {\n                  return t.setFullscreen(!0);\n                },\n                onDisable: function onDisable() {\n                  return t.setFullscreen(!1);\n                },\n                getChartState: function getChartState() {\n                  return t.isFullscreen();\n                }\n              });\n            };\n\n            var e = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.onSceneChange = function (e) {\n                t.prototype.onSceneChange.call(this, e);\n                var i = this.chart.scene.backStack.length > 0,\n                    n = this.options;\n                n.enabled !== i && (n.enabled = i, this.updateSettings());\n              }, e;\n            }(t.Button);\n\n            t.ToolbarItemNames.back = function (t, i) {\n              var n = t.settings.localization.toolbar;\n              i.label = i.label || n.backButton, i.title = i.title || n.backTitle, i.cssClass = i.cssClass || \"DVSL-bar-btn-back\";\n              var r = i.onClick;\n              return i.onClick = function (e, i) {\n                t.back(!0, \"user\"), r && r(e, i);\n              }, new e(t, i);\n            };\n          }(h = s.Bar || (s.Bar = {}));\n\n          var wt = function () {\n            function t(t) {\n              this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.oneOverM = 1 / this.M;\n            }\n\n            return t.prototype.get = function () {\n              var t = this.seed / this.Q,\n                  e = this.seed % this.Q,\n                  i = this.A * e - this.R * t;\n              return this.seed = i > 0 ? i : i + this.M, this.seed * this.oneOverM;\n            }, t.prototype.getArrayElement = function (t) {\n              return t[t.length * this.get() | 0];\n            }, t;\n          }();\n\n          s.Random = wt;\n\n          var Lt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 600, i.container = null, i.backgroundContainer = null, i.background = null, i.canvas = null, i.interactionContainer = null, i.menuContainer = null, i.outerBorder = null, i.scene = null, i.curThemeClass = null, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.setContainerStyle = function (t) {\n              t.style.position = \"absolute\", t.style.left = \"0px\", t.style.right = \"0px\", t.style.top = \"0px\", t.style.bottom = \"0px\";\n            }, e.prototype.createDom = function (t) {\n              this.shell = t, this.container = s.Helpers.createDom(\"div\", \"DVSL-container DVSL-\" + t.chart.api.typeName), this.container.style.position = \"relative\", this.container.style.width = \"100%\", this.backgroundContainer = s.Helpers.createDom(\"div\", \"DVSL-background-container\", null, this.container), e.setContainerStyle(this.backgroundContainer), this.background = s.Helpers.createDom(\"div\", \"DVSL-background\", null, this.backgroundContainer), e.setContainerStyle(this.background), this.backgroundImage = s.Helpers.createDom(\"div\", \"DVSL-background-image\", null, this.background), this.canvas = s.Helpers.createDom(\"canvas\", \"DVSL-canvas\", null, this.container), e.setContainerStyle(this.canvas), this.outerBorder = s.Helpers.createDom(\"div\", \"DVSL-border\", null, this.container), e.setContainerStyle(this.outerBorder), this.interactionContainer = s.Helpers.createDom(\"div\", \"DVSL-interaction\", null, this.container), e.setContainerStyle(this.interactionContainer), this.menuContainer = s.Helpers.createDom(\"div\", \"DVSL-menu-container DVSL-menu-workaround\", null, this.container), e.setContainerStyle(this.menuContainer), s.Helpers.createDom(\"span\", \"DVSL-empty\", \" \", this.menuContainer), this.updateSettings(this.scene.settings), this.interactionContainer.tabIndex = 0;\n            }, e.prototype.updateSettings = function (t) {\n              if (s.Helpers.hasProp(t, \"area.style.image\")) {\n                var e = t.area.style.image;\n                this.backgroundImage.style.backgroundImage = e ? \"url(\" + e + \")\" : \"\";\n              }\n\n              var i = this.curThemeClass,\n                  n = this.scene.settings.advanced.themeCSSClass;\n              n !== i && (i && s.Helpers.removeClass(this.container, i), this.curThemeClass = n, s.Helpers.addClass(this.container, n));\n            }, e.prototype.doAnimations = function (t) {\n              t.changes.bounds && (this.backgroundImage.style.bottom = this.scene.bottomMargin + \"px\", this.backgroundImage.style.top = this.scene.topMargin + \"px\");\n            }, e;\n          }(A);\n\n          s.DomLayer = Lt;\n\n          var Tt = function () {\n            function t(t, e, i) {\n              void 0 === i && (i = []), this.x = i, this.y1 = e, this.y0 = t;\n            }\n\n            return t.prototype.isEmpty = function () {\n              return 0 === this.x.length;\n            }, t.prototype.makeCopy = function () {\n              return new t(this.y0, this.y1, this.x.slice(0));\n            }, t.prototype.split = function (e) {\n              var i = new t(e, this.y1);\n              return this.y1 = e, i.x = this.x.slice(0), i;\n            }, t.prototype.add = function (t, e) {\n              for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] < t;) {\n                i.push(this.x[r], this.x[r + 1]), r += 2;\n              }\n\n              for (r < n && (t = Math.min(this.x[r], t)); r < n && this.x[r] <= e;) {\n                e = Math.max(e, this.x[r + 1]), r += 2;\n              }\n\n              for (i.push(t, e); r < n;) {\n                i.push(this.x[r], this.x[r + 1]), r += 2;\n              }\n\n              return this.x = i, this;\n            }, t.prototype.subtract = function (t, e) {\n              for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] <= t;) {\n                i.push(this.x[r], this.x[r + 1]), r += 2;\n              }\n\n              for (r < n && this.x[r] < t && i.push(this.x[r], t); r < n && this.x[r + 1] <= e;) {\n                r += 2;\n              }\n\n              for (r < n && this.x[r] < e && (i.push(e, this.x[r + 1]), r += 2); r < n;) {\n                i.push(this.x[r], this.x[r + 1]), r += 2;\n              }\n\n              return this.x = i, this;\n            }, t.prototype.subtractSlice = function (t) {\n              if (this.isEmpty() || t.isEmpty()) return this;\n\n              for (var e = [], i = this.x, n = t.x, r = i.length, s = n.length, a = 0, o = 0, l = i[a], h = i[a + 1]; o < s;) {\n                var u = n[o],\n                    c = n[o + 1];\n                if (l >= c) o += 2;else if (u >= h) {\n                  if (e.push(l, h), (a += 2) === r) break;\n                  l = i[a], h = i[a + 1];\n                } else if (u > l && e.push(l, u), c < h) l = c, o += 2;else {\n                  if ((a += 2) === r) break;\n                  l = i[a], h = i[a + 1];\n                }\n              }\n\n              for (; a < r && (e.push(l, h), (a += 2) !== r);) {\n                l = i[a], h = i[a + 1];\n              }\n\n              return this.x = e, this;\n            }, t.prototype.intersectsSlice = function (t) {\n              if (this.isEmpty() || t.isEmpty()) return !1;\n\n              for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n                var o = e[s],\n                    l = e[s + 1],\n                    h = i[a];\n                if (o >= i[a + 1]) a += 2;else {\n                  if (!(h >= l)) return !0;\n                  s += 2;\n                }\n              }\n\n              return !1;\n            }, t.prototype.coversSlice = function (t) {\n              if (t.isEmpty()) return !0;\n\n              for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n                var o = e[s],\n                    l = e[s + 1],\n                    h = i[a],\n                    u = i[a + 1];\n                if (h >= l) s += 2;else {\n                  if (!(h >= o && u <= l)) return !1;\n                  a += 2;\n                }\n              }\n\n              return a === r;\n            }, t.prototype.clip = function (t, e) {\n              for (var i = [], n = 0; n <= this.x.length - 2; n += 2) {\n                var r = this.x[n],\n                    s = this.x[n + 1];\n                s > t && r < e && (i.push(Math.max(r, t)), i.push(Math.min(s, e)));\n              }\n\n              return this.x = i, this;\n            }, t.prototype.tryMerge = function (t) {\n              if (this.x.length !== t.x.length || this.y1 !== t.y0) return !1;\n\n              for (var e = 0; e <= this.x.length - 1; e++) {\n                if (this.x[e] !== t.x[e]) return !1;\n              }\n\n              return this.y1 = t.y1, !0;\n            }, t.prototype.intersects = function (t, e) {\n              for (var i = 0; i <= this.x.length - 2; i += 2) {\n                var n = this.x[i],\n                    r = this.x[i + 1];\n                if (n < e && r > t) return !0;\n              }\n\n              return !1;\n            }, t.prototype.covers = function (t, e) {\n              for (var i = 0; i <= this.x.length - 2; i += 2) {\n                var n = this.x[i],\n                    r = this.x[i + 1];\n                if (n <= t && r >= e) return !0;\n              }\n\n              return !1;\n            }, t.prototype.findOverlappingRect = function (t, e, i) {\n              for (var n = !1, r = 0; r <= this.x.length - 2; r += 2) {\n                var s = this.x[r],\n                    a = this.x[r + 1];\n                s < e && e - i < a && (t = Math.min(t, Math.max(s, e - i)), n = !0), a > t && t + i > s && (e = Math.max(e, Math.min(a, t + i)), n = !0);\n              }\n\n              return {\n                x0: t,\n                x1: e,\n                overlaps: n\n              };\n            }, t.prototype.toRects = function (t) {\n              for (var e = 0; e <= this.x.length - 2; e += 2) {\n                var i = this.x[e],\n                    n = this.x[e + 1];\n                t.push(new s.Rect(i, this.y0, n, this.y1));\n              }\n            }, t;\n          }();\n\n          s.AreaSlice = Tt;\n\n          var kt = function () {\n            function t() {\n              this.slices = [new Tt(-1e30, 1e30)];\n            }\n\n            return t.prototype.makeCopy = function () {\n              var e = new t();\n              e.slices = [];\n\n              for (var i = 0; i < this.slices.length; i++) {\n                var n = this.slices[i];\n                e.slices.push(n.makeCopy());\n              }\n\n              return e;\n            }, t.prototype.getBounds = function () {\n              var t = 1 / 0,\n                  e = -1 / 0,\n                  i = 1 / 0,\n                  n = -1 / 0;\n\n              if (this.slices.length > 1) {\n                i = this.slices[1].y0, n = this.slices[this.slices.length - 1].y1;\n\n                for (var r = 0; r < this.slices.length; r++) {\n                  var a = this.slices[r];\n                  a.x.length > 0 && (t = Math.min(t, a.x[0]), e = Math.max(e, a.x[a.x.length - 1]));\n                }\n              }\n\n              return new s.Rect(t, i, e, n);\n            }, t.prototype.addRect = function (t) {\n              if (t.isEmpty()) return this;\n\n              for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {\n                var l = this.slices[o];\n                if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);else {\n                  if (n > l.y0) {\n                    var h = l.split(n);\n                    a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n                  }\n\n                  if (r < l.y1) {\n                    h = l.split(r);\n                    l.add(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n                  } else l.add(e, i);\n\n                  a && a.tryMerge(l) || (s.push(l), a = l);\n                }\n              }\n\n              return this.slices = s, this;\n            }, t.prototype.subtractRect = function (t) {\n              if (t.isEmpty()) return this;\n\n              for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {\n                var l = this.slices[o];\n                if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);else {\n                  if (n > l.y0) {\n                    var h = l.split(n);\n                    a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n                  }\n\n                  if (r < l.y1) {\n                    h = l.split(r);\n                    l.subtract(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n                  } else l.subtract(e, i);\n\n                  a && a.tryMerge(l) || (s.push(l), a = l);\n                }\n              }\n\n              return this.slices = s, this;\n            }, t.prototype.clip = function (t) {\n              return 1;\n            }, t.prototype.subtractArea = function (t) {\n              if (t.isEmpty()) return this;\n\n              for (var e = [], i = null, n = this.slices, r = t.slices, s = n.length, a = r.length, o = 0, l = 0, h = n[o]; l < a;) {\n                var u = r[l];\n\n                if (h.y1 <= u.y0) {\n                  if (i && i.tryMerge(h) || (e.push(h), i = h), (o += 1) === s) break;\n                  h = n[o];\n                } else if (u.y1 <= h.y0 || u.isEmpty()) l += 1;else {\n                  if (h.y0 < u.y0) {\n                    var c = h.split(u.y0);\n                    i && i.tryMerge(h) || (e.push(h), i = h), h = c;\n                  }\n\n                  if (h.y1 > u.y1) {\n                    c = h.split(u.y1);\n                    h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), h = c, l += 1;\n                  } else {\n                    if (h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), (o += 1) === s) break;\n                    h = n[o];\n                  }\n                }\n              }\n\n              for (; o < s && (i && i.tryMerge(h) || (e.push(h), i = h), (o += 1) !== s);) {\n                h = n[o];\n              }\n\n              return this.slices = e, this;\n            }, t.prototype.intersectsArea = function (t) {\n              if (t.isEmpty() || this.isEmpty()) return !1;\n\n              for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n                var o = i[a],\n                    l = e[s];\n                if (l.intersectsSlice(o)) return !0;\n                l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1);\n              }\n\n              return !1;\n            }, t.prototype.coversArea = function (t) {\n              if (t.isEmpty()) return !0;\n\n              for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n                var o = i[a],\n                    l = e[s];\n                if (!l.coversSlice(o)) return !1;\n                l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1);\n              }\n\n              return !0;\n            }, t.prototype.findOverlappingRect = function (t, e) {\n              if (this.isEmpty()) return null;\n\n              for (var i = this.slices[1].x[0], n = Math.min(this.slices[1].x[1], i + t), r = this.slices[1].y0, a = Math.min(this.slices[1].y1, r + e), o = 0; o < this.slices.length; o++) {\n                var l = this.slices[o];\n                if (l.y0 >= r + e) break;\n                var h = l.findOverlappingRect(i, n, t);\n                i = h.x0, n = h.x1, h.overlaps && (a = Math.min(l.y1, r + e));\n              }\n\n              return new s.Rect(i, r, n, a);\n            }, t.prototype.findTopPosition = function (t, e) {\n              for (var i = 1 / 0, n = 0; n < this.slices.length; n++) {\n                var r = this.slices[n];\n                r.covers(t, e) && (i = Math.min(i, r.y0));\n              }\n\n              return i === 1 / 0 ? 0 : i;\n            }, t.prototype.intersects = function (t) {\n              for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {\n                var a = this.slices[s];\n                if (a.y0 < r && a.y1 > n && a.intersects(e, i)) return !0;\n              }\n\n              return !1;\n            }, t.prototype.isEmpty = function () {\n              return 1 === this.slices.length && this.slices[0].isEmpty();\n            }, t.prototype.coversRect = function (t) {\n              for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {\n                var a = this.slices[s];\n                if (n < a.y1 && r > a.y0 && !a.covers(e, i)) return !1;\n              }\n\n              return !0;\n            }, t.prototype.toRects = function () {\n              for (var t = [], e = 0; e < this.slices.length; e++) {\n                this.slices[e].toRects(t);\n              }\n\n              return t;\n            }, t;\n          }();\n\n          s.AreaCollection = kt;\n\n          var At = navigator.userAgent.match(/AppleWebKit\\/(\\d+)/),\n              Mt = At ? parseInt(At[1], 10) : 1e6,\n              It = function () {\n            function t(e, i) {\n              var n = this;\n              this.chart = null, this.settings = null, this.scene = null, this.events = null, this.profiler = null, this.container = null, this.canvas = null, this.scaleX = 1, this.scaleY = 1, this.paintRequested = null, this.labelRenderer = null, this.prevTime = null, this.paintNowInProgreess = !1, this.animationInProgress = !1, this.mouseEvents = null, this.innerAreaCache = null, this.chartWidth = 0, this.chartHeight = 0, this.sizeChanged = !0, this.fullScreenMode = !1, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0, this.lastCursor = null, this.chart = e, this.settings = e.settings, this.scene = e.scene, this.domLayer = i, this.buildDom(), this.labelRenderer = new j(this.settings, this.chart.assetsLoader, this.container), this.mouseEvents = new L(this.domLayer.interactionContainer, this.settings.advanced.pointer, [this.domLayer.menuContainer]), this.profiler = new P(this);\n\n              for (var r = 0; r < t.MouseEventConfig.length; r++) {\n                !function (t) {\n                  n.mouseEvents.listen(t.ev, function (e) {\n                    return n.notifyMouseEvent(e, t);\n                  });\n                }(t.MouseEventConfig[r]);\n              }\n\n              this.events = new N(e, this), this.events.addElement(this.domLayer), this.containerResizeFunc = function () {\n                return n.updateSize(!1);\n              }, p.listenResize(this.container, this.containerResizeFunc), p.listen(window, \"resize\", this.containerResizeFunc);\n            }\n\n            return t.prototype.forceChromeRedraw = function () {\n              var t = this.menuContainer.style,\n                  e = t.transform;\n              t.transform = \"translateZ(0)\", window.setTimeout(function () {\n                t.transform = e;\n              }, 1);\n            }, t.prototype.updateSize = function (t) {\n              var e,\n                  i,\n                  n = this.settings.area;\n              this.fullScreenMode ? (e = window.innerWidth, i = window.innerHeight) : this.fullscreenBeforeW > 0 ? (e = this.fullscreenBeforeW, i = this.fullscreenBeforeH, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0) : (e = n.width || Math.min(n.maxWidth, this.container.clientWidth), i = n.height || Math.min(n.maxHeight, this.container.clientHeight), e > 0 && i < 2 && (i = this.settings.area.height || this.settings.area.defaultHeight), e = Math.max(n.minWidth, e), i = Math.max(n.minHeight, i)), (t || e >= 2 && e !== this.chartWidth || i >= 2 && i !== this.chartHeight) && this.setSize(e, i, t), p.updateResize(this.container);\n            }, t.prototype.setSize = function (t, e, i) {\n              this.chart.log(\"Update size: \" + e + \", \" + t);\n              var n = this.domLayer.container.style;\n              n.height = e + \"px\", n.width = t + \"px\", this.chartHeight = e, this.chartWidth = t, this.sizeChanged = !0, this.events.setNewSize(new vt(0, 0, t, e), !0, i);\n            }, t.prototype.setFullscreen = function (t) {\n              t !== this.fullScreenMode && (this.fullScreenMode = t, t ? (this.fullscreenBeforeW = this.scene.chartWidth, this.fullscreenBeforeH = this.scene.chartHeight, p.addClass(this.domLayer.container, \"DVSL-fullscreen\")) : p.removeClass(this.domLayer.container, \"DVSL-fullscreen\"), this.updateSize(!0));\n            }, t.prototype.buildDom = function () {\n              if (!this.settings.container) throw new Error(\"Chart container is not defined in the settings.\");\n              if (!p.isDomObject(this.settings.container)) throw new Error(\"Chart container is not a DOM object.\");\n              this.container = this.settings.container, null != this.container._DVSL_ChartInstance && this.container._DVSL_ChartInstance.remove(), this.container.innerHTML = \"\\x3c!--ZoomCharts \" + e.PackageInfo.Version + \"--\\x3e\", this.container._DVSL_ChartInstance = this.chart, this.domLayer.createDom(this), this.container.appendChild(this.domLayer.container), this.backgroundContainer = this.domLayer.backgroundContainer, this.interactiveContainer = this.domLayer.interactionContainer, this.menuContainer = this.domLayer.menuContainer, this.canvas = this.domLayer.canvas;\n            }, t.prototype.remove = function () {\n              this.mouseEvents.remove(), this.domLayer.remove(), p.unlistenResize(this.container), delete this.container._DVSL_ChartInstance, p.unlisten(window, \"resize\", this.containerResizeFunc), this.container.innerHTML = \"\";\n            }, t.prototype.updateSettings = function (t) {\n              t.area && this.updateSize(!0), this.domLayer.updateSettings(t);\n            }, t.prototype.notifyMouseEvent = function (t, e) {\n              this.chart.removed || (t.consumed = !1, this.events.onMouseEvent(t, e), t.cursor || (t.cursor = \"default\"), this.lastCursor !== t.cursor && (this.interactiveContainer.style.cursor = t.cursor, this.menuContainer.style.cursor = t.cursor, this.lastCursor = t.cursor));\n            }, t.prototype.requestPaint = function () {\n              var t = this;\n              null === this.paintRequested && (this.settings.advanced.useAnimationFrame ? this.paintRequested = s.Helpers.requestAnimationFrame(function (e, i) {\n                return t.paintScene(i ? e : null);\n              }) : this.paintRequested = window.setTimeout(function () {\n                return t.paintScene(null);\n              }, 5));\n            }, t.prototype.paintNow = function (t) {\n              return void 0 === t && (t = !1), this.paintNowInProgreess ? void this.chart.error(\"paintNow called from within paintNow call\") : (this.paintNowInProgreess = !0, (null !== this.paintRequested || t) && (this.settings.advanced.useAnimationFrame ? s.Helpers.cancelAnimationFrame(this.paintRequested) : window.clearTimeout(this.paintRequested), this.paintScene(null)), void (this.paintNowInProgreess = !1));\n            }, t.prototype.paintScene = function (t) {\n              if (!this.chart.removed) {\n                this.paintRequested = null;\n                var e = null !== t ? t : p.performanceNow(),\n                    i = new T();\n                i.timeStamp = e, i.isExport = !1, this.prevTime && this.animationInProgress ? (i.dtime = i.timeStamp - this.prevTime, i.dtime > 1e3 && (i.dtime = 1e3), i.dtime < 1 && (i.dtime = 1)) : i.dtime = 30, this.prevTime = e, this.chartWidth > 0 && this.chartHeight > 0 && (this.sizeChanged && (this.resizeCanvas(), this.sizeChanged = !1), this.innerAreaCache = null, this.events.animateFrame(i), i.animating ? (this.animationInProgress = !0, this.events.requestPaint()) : this.animationInProgress = !1, this.profiler.paintDone());\n              }\n            }, t.prototype.resizeCanvas = function () {\n              var t = this.chart.settings.advanced,\n                  e = 1,\n                  i = 1;\n\n              if (!0 === t.highDPI) {\n                var n = p.canvasScaling();\n                e = n.x, i = n.y;\n              } else t.highDPI > 0 && (e = i = t.highDPI);\n\n              var r,\n                  s,\n                  a = this.chartWidth,\n                  o = this.chartHeight,\n                  l = Math.max(100, t.maxCanvasWidth),\n                  h = Math.max(100, t.maxCanvasHeight),\n                  u = 0,\n                  c = 0;\n\n              do {\n                u++, r = Math.ceil(a * e / u);\n              } while (r > l);\n\n              do {\n                c++, s = Math.ceil(o * i / c);\n              } while (s > h);\n\n              a = r / (e /= u), o = s / (i /= c), this.scaleX = e, this.scaleY = i, this.canvas.width = r, this.canvas.height = s, this.canvas.style.width = a + \"px\", this.canvas.style.height = o + \"px\";\n            }, t.prototype.prepareContext = function (t) {\n              var e = this.scene,\n                  i = this.canvas,\n                  n = i.getContext(\"2d\");\n              n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, i.width, i.height), 534 === Mt && (i.style.display = \"none\", i.offsetHeight, i.style.display = \"inherit\"), this.areaStylesBefore(n, this.canvas);\n              var r = this.scaleX,\n                  s = this.scaleY;\n              n.setTransform(r, 0, 0, s, 0, 0), n.__scaleX = r, n.__scaleY = s, t.context = n, t.scaleX = r, t.scaleY = s, t.labelRenderer = this.labelRenderer, this.labelRenderer.startFrame(e.chartWidth, e.chartHeight, r, s);\n            }, t.prototype.areaStylesBefore = function (t, e) {\n              var i = this.settings.area.style.fillColor;\n              i && (t.fillStyle = i, t.fillRect(0, 0, e.width, e.height));\n            }, t.prototype.areaStylesAfter = function (t, e) {\n              var i = this.settings.area.style.overlayColor;\n              i && (t.fillStyle = i, t.setTransform(1, 0, 0, 1, 0, 0), t.fillRect(0, 0, e.width, e.height));\n            }, t.prototype.finalizeContext = function (t) {\n              this.areaStylesAfter(t.context, this.canvas), this.labelRenderer.finishFrame();\n            }, t.prototype.exportToImageGetDimensions = function () {\n              var t = new T();\n              t.isExport = !0, t.context = this.canvas.getContext(\"2d\"), t.labelRenderer = this.labelRenderer;\n              var e = this.events.updateLayout(t);\n              return t.isExport = !1, this.events.updateLayout(t), {\n                width: e.w(),\n                height: e.h()\n              };\n            }, t.prototype.exportToContext = function (t, e, i) {\n              var n = new j(this.settings, this.chart.assetsLoader, this.container);\n              n.allowCache = !1, n.startFrame(1, 1, i, i);\n              var r = new T();\n              r.isExport = !0, r.timeStamp = this.prevTime, r.dtime = 0, r.context = t, r.scaleX = i, r.scaleY = i, r.labelRenderer = n;\n              var s = this.events.updateLayout(r);\n              this.areaStylesBefore(t, e), t.save(), t.setTransform(i, 0, 0, i, -s.x0 * i, -s.y0 * i), this.events.doPaint(r), this.areaStylesAfter(t, e), r.isExport = !1, this.events.updateLayout(r), B.restore(t);\n            }, t.prototype.getChartInnerArea = function () {\n              if (this.innerAreaCache) return this.innerAreaCache;\n              var t = new s.AreaCollection();\n              t.addRect(new s.Rect(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height));\n\n              for (var e = this.menuContainer.getBoundingClientRect(), i = e.left, n = e.top, r = this.menuContainer.children, a = 0; a < r.length; a += 1) {\n                var o = r[a];\n\n                if (o.offsetHeight > 0 || o.offsetWidth > 0) {\n                  var l = o.getBoundingClientRect();\n                  t.subtractRect(new vt(l.left - i, l.top - n, l.right - i, l.bottom - n));\n                }\n              }\n\n              return this.innerAreaCache = t, t;\n            }, t;\n          }();\n\n          It.MouseEventConfig = [{\n            ev: L.EVENT_GLOBAL_DOWN,\n            name: \"GlobalPointerDown\"\n          }, {\n            ev: L.EVENT_DOWN,\n            name: \"PointerDown\",\n            captures: !0\n          }, {\n            ev: L.EVENT_UP,\n            name: \"PointerUp\",\n            needsCapture: !0,\n            releasesCapture: !0\n          }, {\n            ev: L.EVENT_DRAG,\n            name: \"PointerDrag\",\n            needsCapture: !0,\n            captures: !0\n          }, {\n            ev: L.EVENT_MOVE,\n            name: \"PointerMove\",\n            captures: !0\n          }, {\n            ev: L.EVENT_LEAVE,\n            name: \"PointerOut\"\n          }, {\n            ev: L.EVENT_CANCEL,\n            name: \"PointerCancel\",\n            needsCapture: !0,\n            releasesCapture: !0\n          }, {\n            ev: L.EVENT_CLICK,\n            name: \"Click\"\n          }, {\n            ev: L.EVENT_INSTACLICK,\n            name: \"InstantClick\"\n          }, {\n            ev: L.EVENT_LONGPRESS,\n            name: \"LongPress\"\n          }, {\n            ev: L.EVENT_RCLICK,\n            name: \"RightClick\"\n          }, {\n            ev: L.EVENT_DBLCLICK,\n            name: \"DoubleClick\"\n          }, {\n            ev: L.EVENT_TPLCLICK,\n            name: \"TripleClick\"\n          }, {\n            ev: L.EVENT_WHEEL,\n            name: \"Wheel\"\n          }], s.ChartOuterShell = It;\n\n          var Pt = function () {\n            function t(t, e) {\n              this.fullScreenMode = !1, this.chart = t, this.settings = t.settings, this.scene = t.scene, this.parentShell = e, this.buildDom(), this.events = new N(t, this), this.parentShell.events.addSubchart(this.chart), this.updateSize();\n            }\n\n            return t.prototype.getChartInnerArea = function () {\n              return this.parentShell.getChartInnerArea();\n            }, t.prototype.requestPaint = function () {\n              this.parentShell.requestPaint();\n            }, t.prototype.paintNow = function (t) {\n              this.parentShell.paintNow(t);\n            }, t.prototype.buildDom = function () {\n              this.container = this.parentShell.container, this.interactiveContainer = this.parentShell.interactiveContainer, this.backgroundContainer = this.parentShell.backgroundContainer, this.menuContainer = this.parentShell.menuContainer;\n            }, t.prototype.remove = function () {\n              this.parentShell.events.removeSubchart(this.chart);\n            }, t.prototype.updateSettings = function (t) {\n              t.area && this.updateSize();\n            }, t.prototype.updateSize = function (t) {\n              void 0 === t && (t = !1);\n              var e = this.settings.area;\n              this.events.setNewSize(new vt(e.left, e.top, e.left + e.width, e.top + e.height), !1, t);\n            }, t.prototype.prepareContext = function (t) {\n              var e = this.settings.area.style;\n\n              if (e.fillColor) {\n                var i = t.context,\n                    n = this.scene;\n                i.fillStyle = e.fillColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight);\n              }\n            }, t.prototype.finalizeContext = function (t) {\n              var e = this.settings.area.style;\n\n              if (e.overlayColor) {\n                var i = t.context,\n                    n = this.scene;\n                i.fillStyle = e.overlayColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight);\n              }\n            }, t.prototype.forceChromeRedraw = function () {\n              this.parentShell.forceChromeRedraw();\n            }, t.prototype.setFullscreen = function (t) {}, t;\n          }();\n\n          s.ChartInnerShell = Pt;\n\n          var Dt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 70, i.updateOrder = 200, i.scene = null, i.loadingTime = null, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.prototype.doAnimations = function (t) {\n              this.scene.loading && (t.animating = !0);\n            }, e.prototype.paintScene = function (t) {\n              var e = this.scene,\n                  i = e.getMessage(),\n                  n = e.settings.advanced.style,\n                  r = n.loadingArcStyle,\n                  s = e.loading && \"hidden\" !== r.location;\n\n              if (s || (this.loadingTime = null), i || s) {\n                null === this.loadingTime && (this.loadingTime = t.timeStamp);\n                var a,\n                    o,\n                    l = t.context,\n                    h = \"corner\" === r.location,\n                    u = r.r,\n                    c = r.lineWidth;\n                if (h) a = e.x0 + e.width - 1.2 * (u + c), o = e.y0 + 1.2 * (u + c), o += this.chart.shell.getChartInnerArea().findTopPosition(a, a);else a = e.x0 + e.width / 2, o = e.y0 + e.height / 2 + u;\n\n                if (i) {\n                  var d = n.messageTextStyle;\n                  l.textBaseline = \"top\", l.textAlign = \"left\";\n                  var p = B.getTextHeight(l, d.font),\n                      f = B.getTextWidth(l, d, i),\n                      g = void 0,\n                      m = void 0,\n                      v = void 0,\n                      y = n.messageBackgroundStyle,\n                      S = y.padding || 0;\n                  s && (h ? (g = (a -= S) - 1.2 * u - f, m = p > 2 * u ? 4 : o - p / 2, v = f + 2.2 * u) : (g = a - f / 2, m = (o -= p / 2) + 1.3 * p, v = f));\n                  var b = B.beginStrokeAndFill(l, y);\n                  b.rect(g - S, o - u - S, v + 2 * S, m - o + u + 2 * S + p), B.endStrokeAndFill(l, b, y), B.drawText(l, d, i, g, m), B.resetTextStyle(l);\n                }\n\n                if (s) {\n                  l.save(), l.lineCap = \"round\", l.lineWidth = c;\n                  var C = (t.timeStamp - this.loadingTime) / 700 * Math.PI,\n                      x = l.createLinearGradient(a + u * Math.cos(C + Math.PI), o + u * Math.sin(C + Math.PI), a + u * Math.cos(C), o + u * Math.sin(C));\n                  x.addColorStop(0, r.lineColor), x.addColorStop(1, \"transparent\"), l.strokeStyle = x, l.beginPath(), l.arc(a, o, u, C, C + Math.PI), l.stroke(), B.restore(l);\n                }\n              }\n            }, e;\n          }(A);\n\n          s.MessagesOverlay = Dt;\n\n          var Nt = \"undefined\" != typeof document ? document.currentScript : null,\n              Ft = null,\n              Ot = function Ot() {\n            if (Ft) return Ft;\n            if (\"undefined\" == typeof document) return \"\";\n            var t = e.PackageInfo.LibraryName;\n            \"<?\" === t.substr(0, 2) && (t = \"everything\");\n            var i = t.indexOf(\"-\");\n            i > -1 && (t = t.substr(0, i));\n\n            for (var n = new RegExp(\"^(.*?/\" + t + \"(-dev|.min|).js)\"), r = document.getElementsByTagName(\"script\"), a = 0; a < r.length; a++) {\n              var o = r[a].src;\n\n              if (o) {\n                var l = o.match(n);\n                if (l) return Ft = l[1] + \"/../assets/\";\n              }\n            }\n\n            return Nt && Nt.src ? (s.Helpers.warn(\"Cannot locate the ZoomCharts script path based on file name '\" + t + \".js'. The script path was detected using `document.currentScript` which is not supported on all browsers. Please specify 'assetsUrlBase' in settings when creating the chart for full browser compatibility.\"), Ft = Nt.src.match(/^([^?#]*)/)[1] + \"/../assets/\") : Ft = \"\";\n          },\n              Et = function () {\n            function t() {}\n\n            return t.hasPendingRequests = function () {\n              return p.hasProperties(this._imageLoading) || p.hasProperties(this.pendingHTMLAssets);\n            }, t.getAssetImage = function (t, e, i) {\n              var n = this;\n              if (this._imageCache.hasOwnProperty(t)) return this._imageCache[t];\n              if (this._imageLoading.hasOwnProperty(t)) return null;\n              if (!t) return null;\n\n              var r = function r(e) {\n                if (delete n._imageLoading[t], n._imageCache[t] = e, i) return i(e);\n              };\n\n              return this._imageLoading[t] = !0, p.buildImage(t, e, r, function () {\n                var t = l.ErrorImage,\n                    i = n._imageCache[t];\n                i ? r(i) : (n._imagesPendingForErrors.push(r), n._imageLoading.hasOwnProperty(t) || (p.buildImage(t, e, function (e) {\n                  delete n._imageLoading[t], n._imageCache[t] = e;\n\n                  for (var i = 0; i < n._imagesPendingForErrors.length; i++) {\n                    (0, n._imagesPendingForErrors[i])(e);\n                  }\n\n                  n._imagesPendingForErrors = null;\n                }, function () {\n                  p.error(\"Could not load '\" + t + \"'\");\n                }), n._imageCache.hasOwnProperty(t) || (n._imageLoading[t] = !0)));\n              }), this._imageCache.hasOwnProperty(t) ? this._imageCache[t] : null;\n            }, t.loadHtmlAssets = function (t, e) {\n              for (var i = this, n = !1, r = 0; r < t.length; r++) {\n                var s = t[r];\n                this.loadedHTMLAssets[s.url] || (this.pendingHTMLAssets[s.url] ? n = !0 : this.loadHTMLAsset(s, function (t) {\n                  return i.htmlAssetLoaded(t);\n                }) && (this.pendingHTMLAssets[s.url] = !0, n = !0));\n              }\n\n              return !!n && (this.callbacks.push(e), !0);\n            }, t.htmlAssetLoaded = function (t) {\n              if (delete this.pendingHTMLAssets[t], this.loadedHTMLAssets[t] = !0, !p.hasProperties(this.pendingHTMLAssets)) {\n                for (var e = 0; e < this.callbacks.length; e += 1) {\n                  this.callbacks[e](this.errors);\n                }\n\n                this.callbacks = [], this.errors = [];\n              }\n            }, t.loadHTMLAsset = function (t, e) {\n              var i,\n                  n = this,\n                  r = t.url,\n                  a = r.toUpperCase(),\n                  o = a.indexOf(\".CSS\"),\n                  l = a.indexOf(\".JS\"),\n                  h = !1,\n                  u = null,\n                  c = !1,\n                  d = function d() {\n                u && window.clearInterval(u), c || (c = !0, !h && t.required && t.required() && n.errors.push(\"The `required` delegate did not return `false` after loading \" + r), e(r));\n              },\n                  f = function f() {\n                u && window.clearInterval(u), c || (c = !0, n.errors.push(\"Failed to load asset: \" + r), e(r));\n              };\n\n              if (o > l) {\n                var g = document.createElement(\"link\");\n\n                if (g.rel = \"stylesheet\", g.href = r, g.type = \"text/css\", !t.required) {\n                  s.Helpers.warn(\"Asset url \" + r + \" does not define the `required` delegate which prevents the detection of asset load in older browsers.\");\n                  var m = 5;\n                  t.required = function () {\n                    return m-- > 0;\n                  }, h = !0;\n                }\n\n                var v = 100;\n                u = window.setInterval(function () {\n                  v-- < 0 ? f() : t.required() || d();\n                }, 100), i = g;\n              } else {\n                if (!(l > -1)) return this.errors.push(\"Assets: Do not know how to load \" + r + '. The URL should contain either \".css\" or \".js\" - it can be either in the path, the file name or the query string.'), !1;\n                var y = document.createElement(\"script\");\n                y.src = r, y.type = \"text/javascript\", y.async = !1, i = y;\n              }\n\n              return p.listen(i, \"load\", d), p.listen(i, \"error\", f), document.getElementsByTagName(\"head\")[0].appendChild(i), !0;\n            }, t;\n          }();\n\n          Et._imageCache = {}, Et._imageLoading = {}, Et._imagesPendingForErrors = [], Et.loadedHTMLAssets = {}, Et.pendingHTMLAssets = {}, Et.callbacks = [], Et.errors = [];\n\n          var Rt = function () {\n            function t(t) {\n              this.chart = t, this.settings = t.settings;\n              var e = this.settings.assetsUrlBase || Ot();\n              e.length > 0 && \"/\" !== e[e.length - 1] && (e += \"/\"), this.assetsUrlBase = e;\n            }\n\n            return t.prototype.getAssetUrl = function (t) {\n              return 0 === t.indexOf(\"builtin://\") ? this.settings.advanced.builtinAssets[t.slice(10)] : 0 === t.indexOf(\"assets://\") ? (this.assetsUrlBase || this.chart.error(\"Cannot locate the ZoomCharts script path based on file name '\" + e.PackageInfo.LibraryName + \".js'. Please specify 'assetsUrlBase' in settings when creating the chart.\"), this.assetsUrlBase + t.slice(9)) : t;\n            }, t.prototype.hasPendingRequests = function () {\n              return Et.hasPendingRequests();\n            }, t.prototype.getAssetImage = function (t, e) {\n              var i = this;\n              return Et.getAssetImage(this.getAssetUrl(t), this.settings.advanced.crossOriginHeader, function (t) {\n                i.chart.events.requestPaint(), e && e(t);\n              });\n            }, t.prototype.ensureAssetsList = function (t, e) {\n              for (var i = [], n = 0; n < t.length; n++) {\n                var r = t[n];\n                p.isString(r) ? i.push({\n                  url: r,\n                  required: null\n                }) : r.required && !r.required() || i.push(r);\n              }\n\n              this.loadAssetsList(i, function () {\n                e(!0);\n              }) || e(!1);\n            }, t.prototype.loadAssetsList = function (t, e) {\n              for (var i = this, n = 0; n < t.length; n++) {\n                var r = t[n];\n                r.url = this.getAssetUrl(r.url);\n              }\n\n              var s = Et.loadHtmlAssets(t, function (t) {\n                for (var n = 0; n < t.length; n += 1) {\n                  i.chart.error(t[n]);\n                }\n\n                i.chart.log(\"Assets loaded\"), e();\n              });\n              return s && this.chart.log(\"Loading assets\"), s;\n            }, t;\n          }();\n\n          s.AssetsLoader = Rt;\n\n          var Ht = function () {\n            function t(e, i, n, r, s) {\n              if (void 0 === r && (r = \"<>\"), void 0 === s && (s = null), this.t = 0, this.startSpeed = 0, this.duration = n, this.from = e, this.to = i, null == this.from && (this.from = this.to), this.startTime = s, this.x = this.from, this.t = this.startTime, this.formula = t.easingFormulas[r], !this.formula) throw new Error(\"Easing formula not defined: \" + r);\n            }\n\n            return t.prototype.jump = function (t) {\n              this.to = t, this.from = t, this.x = t, this.t = this.startTime = null;\n            }, t.prototype.reset = function (t, e, i) {\n              void 0 === i && (i = null), this.from = t, this.to = e, this.startTime = i, this.x = this.from, this.t = this.startTime;\n            }, t.prototype.retarget = function (t, e) {\n              return this.finished(this.t) ? this.startSpeed = 0 : (this.startSpeed = this._getSpeed(), e || (e = this.t)), e ? (this.from = this.get(e), this.startTime = e) : (this.startTime = null, this.from = this.x), this.to = t, this;\n            }, t.prototype.switchCoordinates = function (t, e) {\n              this.from = this.from * e + t, this.x = this.x * e + t, this.to = this.to * e + t, this.startSpeed = this.startSpeed * e;\n            }, t.prototype.updateAndGet = function (t, e) {\n              var i = this.x !== t;\n              return t !== this.to && this.retarget(t, e), {\n                value: this.get(e),\n                changes: i\n              };\n            }, t.prototype.updateAndGetFixed = function (t, e) {\n              var i = this.x !== t;\n              return t !== this.to && (this.startSpeed = 0, this.startTime = e, this.from = this.x, this.to = t), {\n                value: this.get(e),\n                changes: i\n              };\n            }, t.prototype.getClean = function (t) {\n              return this.duration <= 0 ? this.to : this.startTime ? this._calculate(t) : this.from;\n            }, t.prototype._calculate = function (t) {\n              var e = Math.min(1, Math.max(t - this.startTime, 0) / this.duration);\n              if (e >= 1) return this.to;\n              var i = this.formula(e),\n                  n = i * (this.to - this.from);\n              this.startSpeed && e < 1 && (n = n * i + this.startSpeed * e * this.duration * (1 - i));\n              return this.from + n;\n            }, t.prototype.get = function (t) {\n              if (this.duration <= 0) return this.t = t, this.x = this.to, this.to;\n              this.startTime || (this.startTime = t);\n\n              var e = this._calculate(t);\n\n              return this.t = t, this.x = e, e;\n            }, t.prototype.finished = function (t) {\n              return this.startTime || (this.startTime = t), t >= this.startTime + this.duration;\n            }, t.prototype._getSpeed = function () {\n              var t = this.t,\n                  e = this.duration / 1e3,\n                  i = this.getClean(t - e / 2),\n                  n = this.getClean(t + e / 2);\n              return this.t = t, (n - i) / e;\n            }, t;\n          }();\n\n          Ht.easingFormulas = {\n            \"=\": function _(t) {\n              return t;\n            },\n            \"<>\": function _(t) {\n              return t < .5 ? 2 * t * t : -.5 * ((2 * t - 1) * (2 * t - 3) - 1);\n            },\n            scroll: function scroll(t) {\n              return 1 - (1 - t) * (1 - t);\n            }\n          }, s.Animator = Ht;\n\n          var Bt = function () {\n            function t(t, e, i, n, r) {\n              void 0 === n && (n = \"<>\"), void 0 === r && (r = null), this._animator = new Ht(0, 1, i, n, r), this.reset(t, e, r);\n            }\n\n            return t.prototype.reset = function (t, e, i) {\n              return p.isString(t) || null == t ? this._fromColor = E.parse(t) : this._fromColor = t, p.isString(e) || null == e ? this._toColor = E.parse(e) : this._toColor = e, this._animator.reset(0, 1, i), this;\n            }, t.prototype.getColor = function (t) {\n              var e = Math.min(1, this._animator.get(t));\n              return this._lastValue = E.blend(this._fromColor, this._toColor, e);\n            }, t.prototype.get = function (t) {\n              return E.format(this.getColor(t));\n            }, t.prototype.updateAndGet = function (t, e) {\n              (p.isString(t) || null == t) && (t = E.parse(t));\n              var i = !E.areEqual(this._lastValue, t);\n              return E.areEqual(this._toColor, t) || this.reset(this._lastValue, t, e), {\n                value: this.get(e),\n                changes: i\n              };\n            }, t.prototype.finished = function (t) {\n              return this._animator.finished(t);\n            }, t;\n          }();\n\n          s.ColorAnimator = Bt;\n\n          var zt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 0, i.paintOrder = 1e4, i.touches = {}, i.fps = 0, i.prevFrame = null, i.frameCount = 0, i.chart = e, i.settings = e.settings.advanced, i.captureTouches = i.settings.showTouches, i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              this.captureTouches = this.settings.showTouches;\n            }, e.prototype.paintScene = function (t) {\n              var e = \"\";\n\n              if (this.settings.showTimestamp && (e += Math.round(t.timeStamp)), this.settings.showFPS) {\n                if (this.frameCount += 1, this.prevFrame) {\n                  var i = Math.max(t.timeStamp - this.prevFrame, 1) / 1e3,\n                      n = 1 / i,\n                      r = Math.min(1, 3 * i);\n                  this.fps = this.fps * (1 - r) + n * r;\n                }\n\n                this.prevFrame = t.timeStamp, e += \"FPS:\" + Math.round(this.fps);\n              }\n\n              var s = t.context;\n\n              if (this.captureTouches) {\n                var a = this.settings.showTouchTrail,\n                    o = 0;\n\n                for (var l in this.touches) {\n                  var h = this.touches[l];\n\n                  if (this.touches.hasOwnProperty(l)) {\n                    s.beginPath(), s.moveTo(h.dx, h.dy);\n\n                    for (var u = 0; u < h.trace.length; u++) {\n                      var c = h.trace[u];\n                      s.lineTo(c.x, c.y);\n                    }\n\n                    a && h.cancelled ? (s.strokeStyle = \"red\", s.fillStyle = \"red\", s.lineWidth = 1) : a && h.up ? (s.strokeStyle = \"gray\", s.fillStyle = \"gray\", s.lineWidth = 3) : (s.strokeStyle = \"rgba(180,180,180,0.4)\", s.fillStyle = \"rgba(180,180,180,0.3)\", s.lineWidth = 3), s.moveTo(h.x + 30, h.y), s.stroke(), s.lineWidth = 1.5, s.beginPath(), s.arc(h.x, h.y, h.animator.get(t.timeStamp), 0, 2 * Math.PI), s.stroke(), s.fill(), h.up || (o += 1), h.animator.finished(t.timeStamp) || (t.animating = !0);\n                  }\n                }\n\n                for (var l in s.beginPath(), s.fillStyle = \"black\", this.touches) {\n                  if (this.touches.hasOwnProperty(l)) for (h = this.touches[l], u = 0; u < h.trace.length; u++) {\n                    c = h.trace[u];\n                    s.rect(c.x - 1, c.y - 1, 2, 2);\n                  }\n                }\n\n                s.fill(), a && (e += \"\\ntouches:\" + o);\n              }\n\n              if (e.length > 0) {\n                var d = this.chart.shell.getChartInnerArea(),\n                    p = Math.max(30, d.findTopPosition(50, 200));\n                B.resetTextStyle(s), s.fillStyle = \"#000\", s.textAlign = \"start\", s.textBaseline = \"middle\", s.font = \"bold 11px Arial\", s.fillText(e, 50, p);\n              }\n            }, e.prototype.previewPointerDown = function (t) {\n              if (this.captureTouches) {\n                for (var e in this.touches) {\n                  var i = this.touches[e];\n                  this.touches.hasOwnProperty(e) && i.up && delete this.touches[e];\n                }\n\n                this.touches[t.identifier] = {\n                  dx: t.x,\n                  dy: t.y,\n                  x: t.x,\n                  y: t.y,\n                  up: !1,\n                  cancelled: !1,\n                  trace: [],\n                  animator: new s.Animator(10, 40, 200)\n                }, t.changes.requestPaint = !0;\n              }\n            }, e.prototype.previewPointerDrag = function (t) {\n              if (this.captureTouches) {\n                var e = this.touches[t.identifier];\n                e.x = t.x, e.y = t.y, this.settings.showTouchTrail && e.trace.push({\n                  x: e.x,\n                  y: e.y\n                }), t.changes.requestPaint = !0;\n              }\n            }, e.prototype.previewPointerUp = function (t) {\n              if (this.captureTouches) {\n                var e = this.touches[t.identifier];\n                e.up = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0;\n              }\n            }, e.prototype.previewPointerCancel = function (t) {\n              if (this.captureTouches) {\n                var e = this.touches[t.identifier];\n                e.up = !0, e.cancelled = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0;\n              }\n            }, e;\n          }(A);\n\n          s.TouchMarkers = zt;\n\n          var Ut = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n              Gt = function () {\n            function t() {}\n\n            return t.createImage = function (e, i, n, r) {\n              var a = t.getSizes(e, n),\n                  o = document.createElement(\"canvas\");\n              o.width = a.width, o.height = a.height;\n              var l = o.getContext(\"2d\");\n              r || (l.fillStyle = \"#fff\", l.fillRect(0, 0, a.width, a.height)), e.exportToContext(l, o, a.scale);\n\n              try {\n                return o.toDataURL(i);\n              } catch (t) {\n                throw s.Helpers.error(t), new Error(\"Browser security prevents exporting this chart. The canvas might be tainted. See `advanced.crossOriginHeader` setting in the documentation.\");\n              }\n            }, t.createPdf = function (e, i) {\n              var n,\n                  r,\n                  s,\n                  a,\n                  o = e.exportToImageGetDimensions(),\n                  l = [10, 10, 10, 10],\n                  h = e.settings.advanced.exportPdfSize,\n                  u = 0,\n                  c = 0,\n                  d = 0,\n                  p = 0;\n              o.width >= o.height ? (h = [h[1], h[0]], n = \"l\") : n = \"p\", r = h[0] / 25.4 * 72, s = h[1] / 25.4 * 72, a = Math.min(s / o.height, r / o.width), \"l\" === n ? (d = o.width * a / r * h[0] - l[1] - l[3], u = (h[0] - d - l[1] - l[3]) / 2, p = o.height / o.width * d, c = (h[1] - l[0] - l[2] - p) / 2) : (p = o.height * a / s * h[1] - l[0] - l[2], c = (h[1] - p - l[0] - l[2]) / 2, d = o.width / o.height * p, u = (h[0] - l[1] - l[3] - d) / 2);\n              var f = t.createImage(e, \"image/jpeg\", {\n                scaling: 3 * a\n              }, !1),\n                  g = new jsPDF(n, \"mm\", h);\n              return g.addImage(f, \"JPEG\", l[3] + u, l[0] + c, d, p), g.output(\"datauristring\");\n            }, t.createCsv = function (e) {\n              for (var i = /[^a-zA-Z0-9\\.]/, n = \"data:text/csv;charset=utf-8,\", r = encodeURIComponent(\"\\r\\n\"), s = 0; s < e.length; s++) {\n                for (var a = e[s], o = 0; o < a.length; o++) {\n                  o > 0 && (n += t._csvSeparator);\n                  var l = a[o];\n\n                  if (null != l) {\n                    var h = void 0;\n                    h = l instanceof Date ? l.toISOString() : \"\" + l, n += i.test(h) ? '\"' + encodeURIComponent(h.replace('\"', '\"\"')) + '\"' : h;\n                  }\n                }\n\n                n += r;\n              }\n\n              return n;\n            }, t.retrieveData = function (t, e) {\n              var i = t.exportVisibleData,\n                  n = t.settings.advanced.dataExportFunction;\n              if (!i && !n) throw new Error(\"This chart type does not support data export. Provide `advanced.dataExportFunction` delegate to enable it.\");\n              var r = i ? t.exportVisibleData() : null;\n              n ? n(r, e) : e(r);\n            }, t.createExcel = function (t) {\n              function e(t) {\n                return (t.getTime() + 22091616e5) / 864e5;\n              }\n\n              for (var i = Object.create(null), n = {\n                s: {\n                  c: 1 / 0,\n                  r: 1 / 0\n                },\n                e: {\n                  c: 0,\n                  r: 0\n                }\n              }, r = 0; r < t.length; r++) {\n                n.s.r > r && (n.s.r = r), n.e.r < r && (n.e.r = r);\n\n                for (var s = t[r], a = 0; a < s.length; a++) {\n                  n.s.c > a && (n.s.c = a), n.e.c < a && (n.e.c = a);\n                  var o = s[a];\n\n                  if (null != o) {\n                    var l = {\n                      t: \"s\",\n                      v: o\n                    };\n                    \"number\" == typeof o ? (l.t = \"n\", Math.round(o) === o && (l.z = \"0\")) : \"boolean\" == typeof o ? l.t = \"b\" : o instanceof Date && (l.t = \"n\", l.z = XLSX.SSF._table[14], l.v = e(l.v)), i[XLSX.utils.encode_cell({\n                      c: a,\n                      r: r\n                    })] = l;\n                  }\n                }\n              }\n\n              n.s.c < 1 / 0 && (i[\"!ref\"] = XLSX.utils.encode_range(n));\n              var h = {\n                SheetNames: [\"export\"],\n                Sheets: {\n                  export: i\n                }\n              },\n                  u = XLSX.write(h, {\n                bookType: \"xlsx\",\n                bookSST: !0,\n                type: \"binary\"\n              });\n              return \"data:\" + Ut + \";base64,\" + p.base64Encode(u);\n            }, t.export = function (e, i, n, r, a) {\n              void 0 === i && (i = \"png\"), void 0 === n && (n = {}), void 0 === r && (r = null);\n              var o = e.shell;\n              if (!(o instanceof It)) throw new Error(\"Export functionality is only available on the top level chart, not within nested charts.\");\n              var l = t._mimeMap[i];\n              if (\"xls\" === i) s.Helpers.warn(\"XLS format is not supported. XLSX will be used instead.\");else if (null == i) i = \"png\", l = t._mimeMap.png;else if (void 0 === l) throw new Error(\"Export image type `\" + i + \"` is not supported. Supported types: \" + Object.keys(t._mimeMap).join(\", \"));\n              if (l.transparent ? null == r && (r = !0) : r && (s.Helpers.warn(\"Only PNG images can be exported as transparent.\"), r = !1), l.csv) t.retrieveData(e, function (e) {\n                a(t.createCsv(e), l.mime, l.extension);\n              });else if (l.excel) e.assetsLoader.ensureAssetsList([{\n                url: \"assets://xlsx.core.min.js\",\n                required: function required() {\n                  return \"undefined\" == typeof XLSX;\n                }\n              }], function () {\n                t.retrieveData(e, function (e) {\n                  a(t.createExcel(e), l.mime, l.extension);\n                });\n              });else {\n                if (l.image) {\n                  var h = t.createImage(o, l.mime, t.getDimensions(e, n), r);\n                  return a(h, l.mime, l.extension), h;\n                }\n\n                if (!l.pdf) throw new Error(\"not implemented\");\n                e.assetsLoader.ensureAssetsList([{\n                  url: \"assets://jspdf.js\",\n                  required: function required() {\n                    return \"undefined\" == typeof jsPDF;\n                  }\n                }], function () {\n                  a(t.createPdf(o, n), l.mime, l.extension);\n                });\n              }\n            }, t.download = function (t, e, i, n) {\n              var r = this;\n              void 0 === i && (i = {}), this.export(t, e, i, n, function (e, i, n) {\n                r.launchDownload(t, i, n, e);\n              });\n            }, t.getSizes = function (t, e) {\n              var i = t.exportToImageGetDimensions(),\n                  n = i.width,\n                  r = i.height,\n                  s = p.tryParseFloat(e.width),\n                  a = p.tryParseFloat(e.height),\n                  o = 1;\n\n              if (\"mm\" === e.unit) {\n                var l = p.tryParseFloat(e.dpi, 300) / 25.4;\n                s > 0 && (s *= l), a > 0 && (a *= l);\n              }\n\n              s > 0 && a > 0 ? o = Math.min(s / n, a / r) : s > 0 ? a = r * (o = s / n) : a > 0 ? s = n * (o = a / r) : (s = n, a = r);\n              var h = p.tryParseFloat(e.scaling, 1);\n              return 1 !== h && (o *= h, s *= h, a *= h), {\n                width: s,\n                height: a,\n                scale: o,\n                chartWidth: n,\n                chartHeight: r\n              };\n            }, t.getDimensions = function (t, e) {\n              var i = t.shell;\n              if (!(i instanceof It)) throw new Error(\"Export functionality is only available on the top level chart, not within nested charts.\");\n              return this.getSizes(i, e || {});\n            }, t.dataUriToBlob = function (t, e) {\n              var i = e.indexOf(\",\"),\n                  n = i > 13 && \";base64\" === e.substr(i - 7, 7);\n              e = e.substr(i + 1), e = n ? window.atob(e) : decodeURIComponent(e);\n\n              for (var r = new ArrayBuffer(e.length), s = new Uint8Array(r), a = 0; a < e.length; a++) {\n                s[a] = e.charCodeAt(a);\n              }\n\n              return new Blob([r], {\n                type: t\n              });\n            }, t.launchDownload = function (e, i, n, r, s) {\n              var a = document.body;\n              -1 === n.indexOf(\".\") && (n = \"export.\" + n);\n              var o = p.createDom(\"a\", null, null, null);\n\n              if (navigator.msSaveOrOpenBlob && window.atob) {\n                if (navigator.msSaveOrOpenBlob(t.dataUriToBlob(i, r), n)) return;\n              } else if (C.detect().isChrome && r.length > 2097152) ;else if (void 0 !== o.download) return o.download = n, o.type = i, o.href = r, a.appendChild(o), o.click(), void a.removeChild(o);\n\n              var l = e.settings.advanced.exportProxyURL;\n\n              if (l) {\n                var h = function h() {\n                  var t = document.createElement(\"form\");\n                  t.action = l, t.target = \"_top\", t.method = \"POST\", t.style.display = \"none\";\n                  var e = document.createElement(\"input\");\n                  e.name = \"name\", e.value = n, t.appendChild(e);\n                  var i = document.createElement(\"textarea\");\n                  i.name = \"data\", i.value = r, t.appendChild(i), a.appendChild(t), t.submit(), a.removeChild(t);\n                };\n\n                s ? s(h, function () {}) : h();\n              } else alert(e.settings.localization.exportNotAvailable);\n            }, t;\n          }();\n\n          Gt._csvSeparator = \";\", Gt._mimeMap = {\n            png: {\n              mime: \"image/png\",\n              extension: \"png\",\n              image: !0,\n              transparent: !0\n            },\n            jpg: {\n              mime: \"image/jpeg\",\n              extension: \"jpg\",\n              image: !0\n            },\n            jpeg: {\n              mime: \"image/jpeg\",\n              extension: \"jpg\",\n              image: !0\n            },\n            csv: {\n              mime: \"text/csv\",\n              extension: \"csv\",\n              csv: !0\n            },\n            txt: {\n              mime: \"text/csv\",\n              extension: \"csv\",\n              csv: !0\n            },\n            xlsx: {\n              mime: Ut,\n              extension: \"xlsx\",\n              excel: !0\n            },\n            xls: {\n              mime: Ut,\n              extension: \"xlsx\",\n              excel: !0\n            },\n            pdf: {\n              mime: \"application/pdf\",\n              extension: \"pdf\",\n              pdf: !0\n            }\n          }, s.Export = Gt, function (t) {\n            var e = function (t) {\n              function e(e, i) {\n                var n = e.settings.localization.toolbar;\n\n                if (!i.dropDownItems) {\n                  var r = e.settings.toolbar.exportOptions,\n                      s = [];\n                  (!r || r.indexOf(\"jpg\") > -1) && s.push({\n                    label: n.exportJpeg,\n                    onClick: function onClick() {\n                      return Gt.download(e, \"jpg\", {\n                        scaling: 2\n                      });\n                    }\n                  }), (!r || r.indexOf(\"png\") > -1) && s.push({\n                    label: n.exportPNG,\n                    onClick: function onClick() {\n                      return Gt.download(e, \"png\", {\n                        scaling: 3\n                      });\n                    }\n                  }), (!r || r.indexOf(\"pdf\") > -1) && s.push({\n                    label: n.exportPDF,\n                    onClick: function onClick() {\n                      return Gt.download(e, \"pdf\");\n                    }\n                  }), (e.exportVisibleData || e.settings.advanced.dataExportFunction) && ((!r || r.indexOf(\"csv\") > -1) && s.push({\n                    label: n.exportCSV,\n                    onClick: function onClick() {\n                      return Gt.download(e, \"csv\");\n                    }\n                  }), (!r || r.indexOf(\"xlsx\") > -1) && s.push({\n                    label: n.exportXLS,\n                    onClick: function onClick() {\n                      return Gt.download(e, \"xlsx\");\n                    }\n                  })), i.dropDownItems = s;\n                }\n\n                return i.title = i.title || n.exportTitle, i.label = i.label || n.exportButton, i.cssClass = i.cssClass || \"DVSL-bar-btn-export\", t.call(this, e, i) || this;\n              }\n\n              return r(e, t), e;\n            }(t.Dropdown);\n\n            t.ExportDropdown = e, s.Bar.ToolbarItemNames.export = function (t, e) {\n              return new s.Bar.ExportDropdown(t, e);\n            };\n          }(h = s.Bar || (s.Bar = {}));\n\n          var jt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 0, i.chart = e, i;\n            }\n\n            return r(e, t), e.prototype.onKeyDown = function (t) {\n              this.chart.isFullscreen() && 27 === t.keyCode ? (this.chart.setFullscreen(!1), t.consumed = !0) : 8 === t.keyCode && this.chart.back(!0, \"user\") && (t.consumed = !0);\n            }, e;\n          }(A);\n\n          s.KeyShortcuts = jt;\n\n          var Wt = function () {\n            function t() {}\n\n            return t.verifySignature = function (t, e, i) {\n              var n = new Zt();\n              return n.setPublic(i || \"C314F39F62CBF2AEFA1D5BA41E38EFFD080E88849EE210BA17971BF63A55C44E159C9F9ED004F8D50856EC8ECE673690F60C29AAC124B7C46D549D20EB22CC2A387B2FB643700546312114F831133F242CFFD023A1788167025FF398F5F09D1003C47C9B3208860A547577F540D07FF66403097FE27E7BB6B8D76036AD31B62B04EAD1BB8B2C314F6DA7489346978286491D0DF7504E9EE85A4459805F4FFCEE664122FC27B80DAD6751A7A6C0D38E9C2ECD7C0AD1F2B774D6FF81C5A2CE14D608F08E13BEE45663450519774ADF87D34CE6150FC819558EBD336511D51405A42E7A38EBB786ED5050345CBC532ED7C0EECB05C5D6D4D00534249ED4585DFABD\", \"10001\"), n.verify(t, e);\n            }, t.hash = function (t) {\n              return Zt.hash(t);\n            }, t;\n          }();\n\n          s.RsaCrypto = Wt, Object.freeze(Wt);\n\n          var Vt,\n              Zt = function () {\n            function t(t, e) {\n              null != t && (null == e && \"string\" != typeof t ? this.fromString(t, 256) : this.fromString(t, e));\n            }\n\n            function e() {\n              return new t(null);\n            }\n\n            function i(t) {\n              return p.charAt(t);\n            }\n\n            function n(t, e) {\n              var i = f[t.charCodeAt(e)];\n              return null == i ? -1 : i;\n            }\n\n            function r(t) {\n              var i = e();\n              return i.fromInt(t), i;\n            }\n\n            function s(t) {\n              var e,\n                  i = 1;\n              return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i;\n            }\n\n            function a(t) {\n              this.m = t;\n            }\n\n            function o(t) {\n              this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t;\n            }\n\n            function l(e, i) {\n              return new t(e, i);\n            }\n\n            function h() {\n              this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;\n            }\n\n            var u;\n            \"undefined\" != typeof window && (window.crypto || window.msCrypto), \"undefined\" != typeof navigator && \"Microsoft Internet Explorer\" === navigator.appName ? (t.prototype.am = function (t, e, i, n, r, s) {\n              for (var a = 32767 & e, o = e >> 15; --s >= 0;) {\n                var l = 32767 & this[t],\n                    h = this[t++] >> 15,\n                    u = o * l + h * a;\n                r = ((l = a * l + ((32767 & u) << 15) + i[n] + (1073741823 & r)) >>> 30) + (u >>> 15) + o * h + (r >>> 30), i[n++] = 1073741823 & l;\n              }\n\n              return r;\n            }, u = 30) : \"undefined\" != typeof navigator && \"Netscape\" !== navigator.appName ? (t.prototype.am = function (t, e, i, n, r, s) {\n              for (; --s >= 0;) {\n                var a = e * this[t++] + i[n] + r;\n                r = Math.floor(a / 67108864), i[n++] = 67108863 & a;\n              }\n\n              return r;\n            }, u = 26) : (t.prototype.am = function (t, e, i, n, r, s) {\n              for (var a = 16383 & e, o = e >> 14; --s >= 0;) {\n                var l = 16383 & this[t],\n                    h = this[t++] >> 14,\n                    u = o * l + h * a;\n                r = ((l = a * l + ((16383 & u) << 14) + i[n] + r) >> 28) + (u >> 14) + o * h, i[n++] = 268435455 & l;\n              }\n\n              return r;\n            }, u = 28), t.prototype.DB = u, t.prototype.DM = (1 << u) - 1, t.prototype.DV = 1 << u;\n            t.prototype.FV = Math.pow(2, 52), t.prototype.F1 = 52 - u, t.prototype.F2 = 2 * u - 52;\n            var c,\n                d,\n                p = \"0123456789abcdefghijklmnopqrstuvwxyz\",\n                f = new Array();\n\n            for (c = \"0\".charCodeAt(0), d = 0; d <= 9; ++d) {\n              f[c++] = d;\n            }\n\n            for (c = \"a\".charCodeAt(0), d = 10; d < 36; ++d) {\n              f[c++] = d;\n            }\n\n            for (c = \"A\".charCodeAt(0), d = 10; d < 36; ++d) {\n              f[c++] = d;\n            }\n\n            a.prototype.convert = function (t) {\n              return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;\n            }, a.prototype.revert = function (t) {\n              return t;\n            }, a.prototype.reduce = function (t) {\n              t.divRemTo(this.m, null, t);\n            }, a.prototype.mulTo = function (t, e, i) {\n              t.multiplyTo(e, i), this.reduce(i);\n            }, a.prototype.sqrTo = function (t, e) {\n              t.squareTo(e), this.reduce(e);\n            }, o.prototype.convert = function (i) {\n              var n = e();\n              return i.abs().dlShiftTo(this.m.t, n), n.divRemTo(this.m, null, n), i.s < 0 && n.compareTo(t.ZERO) > 0 && this.m.subTo(n, n), n;\n            }, o.prototype.revert = function (t) {\n              var i = e();\n              return t.copyTo(i), this.reduce(i), i;\n            }, o.prototype.reduce = function (t) {\n              for (; t.t <= this.mt2;) {\n                t[t.t++] = 0;\n              }\n\n              for (var e = 0; e < this.m.t; ++e) {\n                var i = 32767 & t[e],\n                    n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;\n\n                for (t[i = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV;) {\n                  t[i] -= t.DV, t[++i]++;\n                }\n              }\n\n              t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);\n            }, o.prototype.mulTo = function (t, e, i) {\n              t.multiplyTo(e, i), this.reduce(i);\n            }, o.prototype.sqrTo = function (t, e) {\n              t.squareTo(e), this.reduce(e);\n            }, t.prototype.copyTo = function (t) {\n              for (var e = this.t - 1; e >= 0; --e) {\n                t[e] = this[e];\n              }\n\n              t.t = this.t, t.s = this.s;\n            }, t.prototype.fromInt = function (t) {\n              this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0;\n            }, t.prototype.fromString = function (e, i) {\n              var r;\n              if (16 == i) r = 4;else if (8 == i) r = 3;else if (256 == i) r = 8;else if (2 == i) r = 1;else if (32 == i) r = 5;else {\n                if (4 != i) return void this.fromRadix(e, i);\n                r = 2;\n              }\n              this.t = 0, this.s = 0;\n\n              for (var s = e.length, a = !1, o = 0; --s >= 0;) {\n                var l = 8 == r ? 255 & e[s] : n(e, s);\n                l < 0 ? \"-\" == e.charAt(s) && (a = !0) : (a = !1, 0 == o ? this[this.t++] = l : o + r > this.DB ? (this[this.t - 1] |= (l & (1 << this.DB - o) - 1) << o, this[this.t++] = l >> this.DB - o) : this[this.t - 1] |= l << o, (o += r) >= this.DB && (o -= this.DB));\n              }\n\n              8 == r && 0 != (128 & e[0]) && (this.s = -1, o > 0 && (this[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), a && t.ZERO.subTo(this, this);\n            }, t.prototype.clamp = function () {\n              for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) {\n                --this.t;\n              }\n            }, t.prototype.dlShiftTo = function (t, e) {\n              var i;\n\n              for (i = this.t - 1; i >= 0; --i) {\n                e[i + t] = this[i];\n              }\n\n              for (i = t - 1; i >= 0; --i) {\n                e[i] = 0;\n              }\n\n              e.t = this.t + t, e.s = this.s;\n            }, t.prototype.drShiftTo = function (t, e) {\n              for (var i = t; i < this.t; ++i) {\n                e[i - t] = this[i];\n              }\n\n              e.t = Math.max(this.t - t, 0), e.s = this.s;\n            }, t.prototype.lShiftTo = function (t, e) {\n              var i,\n                  n = t % this.DB,\n                  r = this.DB - n,\n                  s = (1 << r) - 1,\n                  a = Math.floor(t / this.DB),\n                  o = this.s << n & this.DM;\n\n              for (i = this.t - 1; i >= 0; --i) {\n                e[i + a + 1] = this[i] >> r | o, o = (this[i] & s) << n;\n              }\n\n              for (i = a - 1; i >= 0; --i) {\n                e[i] = 0;\n              }\n\n              e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp();\n            }, t.prototype.rShiftTo = function (t, e) {\n              e.s = this.s;\n              var i = Math.floor(t / this.DB);\n              if (i >= this.t) e.t = 0;else {\n                var n = t % this.DB,\n                    r = this.DB - n,\n                    s = (1 << n) - 1;\n                e[0] = this[i] >> n;\n\n                for (var a = i + 1; a < this.t; ++a) {\n                  e[a - i - 1] |= (this[a] & s) << r, e[a - i] = this[a] >> n;\n                }\n\n                n > 0 && (e[this.t - i - 1] |= (this.s & s) << r), e.t = this.t - i, e.clamp();\n              }\n            }, t.prototype.subTo = function (t, e) {\n              for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r;) {\n                n += this[i] - t[i], e[i++] = n & this.DM, n >>= this.DB;\n              }\n\n              if (t.t < this.t) {\n                for (n -= t.s; i < this.t;) {\n                  n += this[i], e[i++] = n & this.DM, n >>= this.DB;\n                }\n\n                n += this.s;\n              } else {\n                for (n += this.s; i < t.t;) {\n                  n -= t[i], e[i++] = n & this.DM, n >>= this.DB;\n                }\n\n                n -= t.s;\n              }\n\n              e.s = n < 0 ? -1 : 0, n < -1 ? e[i++] = this.DV + n : n > 0 && (e[i++] = n), e.t = i, e.clamp();\n            }, t.prototype.multiplyTo = function (e, i) {\n              var n = this.abs(),\n                  r = e.abs(),\n                  s = n.t;\n\n              for (i.t = s + r.t; --s >= 0;) {\n                i[s] = 0;\n              }\n\n              for (s = 0; s < r.t; ++s) {\n                i[s + n.t] = n.am(0, r[s], i, s, 0, n.t);\n              }\n\n              i.s = 0, i.clamp(), this.s != e.s && t.ZERO.subTo(i, i);\n            }, t.prototype.squareTo = function (t) {\n              for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0;) {\n                t[i] = 0;\n              }\n\n              for (i = 0; i < e.t - 1; ++i) {\n                var n = e.am(i, e[i], t, 2 * i, 0, 1);\n                (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1);\n              }\n\n              t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp();\n            }, t.prototype.divRemTo = function (i, n, r) {\n              var a = i.abs();\n\n              if (!(a.t <= 0)) {\n                var o = this.abs();\n                if (o.t < a.t) return null != n && n.fromInt(0), void (null != r && this.copyTo(r));\n                null == r && (r = e());\n                var l = e(),\n                    h = this.s,\n                    u = i.s,\n                    c = this.DB - s(a[a.t - 1]);\n                c > 0 ? (a.lShiftTo(c, l), o.lShiftTo(c, r)) : (a.copyTo(l), o.copyTo(r));\n                var d = l.t,\n                    p = l[d - 1];\n\n                if (0 != p) {\n                  var f = p * (1 << this.F1) + (d > 1 ? l[d - 2] >> this.F2 : 0),\n                      g = this.FV / f,\n                      m = (1 << this.F1) / f,\n                      v = 1 << this.F2,\n                      y = r.t,\n                      S = y - d,\n                      b = null == n ? e() : n;\n\n                  for (l.dlShiftTo(S, b), r.compareTo(b) >= 0 && (r[r.t++] = 1, r.subTo(b, r)), t.ONE.dlShiftTo(d, b), b.subTo(l, l); l.t < d;) {\n                    l[l.t++] = 0;\n                  }\n\n                  for (; --S >= 0;) {\n                    var C = r[--y] == p ? this.DM : Math.floor(r[y] * g + (r[y - 1] + v) * m);\n                    if ((r[y] += l.am(0, C, r, S, 0, d)) < C) for (l.dlShiftTo(S, b), r.subTo(b, r); r[y] < --C;) {\n                      r.subTo(b, r);\n                    }\n                  }\n\n                  null != n && (r.drShiftTo(d, n), h != u && t.ZERO.subTo(n, n)), r.t = d, r.clamp(), c > 0 && r.rShiftTo(c, r), h < 0 && t.ZERO.subTo(r, r);\n                }\n              }\n            }, t.prototype.invDigit = function () {\n              if (this.t < 1) return 0;\n              var t = this[0];\n              if (0 == (1 & t)) return 0;\n              var e = 3 & t;\n              return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e;\n            }, t.prototype.isEven = function () {\n              return 0 == (this.t > 0 ? 1 & this[0] : this.s);\n            }, t.prototype.exp = function (i, n) {\n              if (i > 4294967295 || i < 1) return t.ONE;\n              var r = e(),\n                  a = e(),\n                  o = n.convert(this),\n                  l = s(i) - 1;\n\n              for (o.copyTo(r); --l >= 0;) {\n                if (n.sqrTo(r, a), (i & 1 << l) > 0) n.mulTo(a, o, r);else {\n                  var h = r;\n                  r = a, a = h;\n                }\n              }\n\n              return n.revert(r);\n            }, t.prototype.toString = function (t) {\n              if (this.s < 0) return \"-\" + this.negate().toString(t);\n              var e;\n              if (16 == t) e = 4;else if (8 == t) e = 3;else if (2 == t) e = 1;else if (32 == t) e = 5;else {\n                if (4 != t) return this.toRadix(t);\n                e = 2;\n              }\n              var n,\n                  r = (1 << e) - 1,\n                  s = !1,\n                  a = \"\",\n                  o = this.t,\n                  l = this.DB - o * this.DB % e;\n              if (o-- > 0) for (l < this.DB && (n = this[o] >> l) > 0 && (s = !0, a = i(n)); o >= 0;) {\n                l < e ? (n = (this[o] & (1 << l) - 1) << e - l, n |= this[--o] >> (l += this.DB - e)) : (n = this[o] >> (l -= e) & r, l <= 0 && (l += this.DB, --o)), n > 0 && (s = !0), s && (a += i(n));\n              }\n              return s ? a : \"0\";\n            }, t.prototype.negate = function () {\n              var i = e();\n              return t.ZERO.subTo(this, i), i;\n            }, t.prototype.abs = function () {\n              return this.s < 0 ? this.negate() : this;\n            }, t.prototype.compareTo = function (t) {\n              var e = this.s - t.s;\n              if (0 != e) return e;\n              var i = this.t;\n              if (0 != (e = i - t.t)) return this.s < 0 ? -e : e;\n\n              for (; --i >= 0;) {\n                if (0 != (e = this[i] - t[i])) return e;\n              }\n\n              return 0;\n            }, t.prototype.bitLength = function () {\n              return this.t <= 0 ? 0 : this.DB * (this.t - 1) + s(this[this.t - 1] ^ this.s & this.DM);\n            }, t.prototype.mod = function (i) {\n              var n = e();\n              return this.abs().divRemTo(i, null, n), this.s < 0 && n.compareTo(t.ZERO) > 0 && i.subTo(n, n), n;\n            }, t.prototype.modPowInt = function (t, e) {\n              var i;\n              return i = t < 256 || e.isEven() ? new a(e) : new o(e), this.exp(t, i);\n            }, t.ZERO = r(0), t.ONE = r(1), h.prototype.doPublic = function (t) {\n              return t.modPowInt(this.e, this.n);\n            }, h.prototype.setPublic = function (t, e) {\n              null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = l(t, 16), this.e = parseInt(e, 16)) : alert(\"Invalid RSA public key\");\n            };\n            var g = {\n              utf8Encode: function utf8Encode(t) {\n                return window.unescape(encodeURIComponent(t));\n              },\n              hash: function hash(t) {\n                t = g.utf8Encode(t);\n\n                for (var e = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], i = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], n = (t += String.fromCharCode(128)).length / 4 + 2, r = Math.ceil(n / 16), s = new Array(r), a = 0; a < r; a++) {\n                  s[a] = new Array(16);\n\n                  for (var o = 0; o < 16; o++) {\n                    s[a][o] = t.charCodeAt(64 * a + 4 * o) << 24 | t.charCodeAt(64 * a + 4 * o + 1) << 16 | t.charCodeAt(64 * a + 4 * o + 2) << 8 | t.charCodeAt(64 * a + 4 * o + 3);\n                  }\n                }\n\n                s[r - 1][14] = 8 * (t.length - 1) / Math.pow(2, 32), s[r - 1][14] = Math.floor(s[r - 1][14]), s[r - 1][15] = 8 * (t.length - 1) & 4294967295;\n                var l,\n                    h,\n                    u,\n                    c,\n                    d,\n                    p,\n                    f,\n                    m,\n                    v = new Array(64);\n\n                for (a = 0; a < r; a++) {\n                  for (var y = 0; y < 16; y++) {\n                    v[y] = s[a][y];\n                  }\n\n                  for (y = 16; y < 64; y++) {\n                    v[y] = g.s1(v[y - 2]) + v[y - 7] + g.s0(v[y - 15]) + v[y - 16] & 4294967295;\n                  }\n\n                  l = i[0], h = i[1], u = i[2], c = i[3], d = i[4], p = i[5], f = i[6], m = i[7];\n\n                  for (y = 0; y < 64; y++) {\n                    var S = m + g.S1(d) + g.Ch(d, p, f) + e[y] + v[y],\n                        b = g.S0(l) + g.Maj(l, h, u);\n                    m = f, f = p, p = d, d = c + S & 4294967295, c = u, u = h, h = l, l = S + b & 4294967295;\n                  }\n\n                  i[0] = i[0] + l & 4294967295, i[1] = i[1] + h & 4294967295, i[2] = i[2] + u & 4294967295, i[3] = i[3] + c & 4294967295, i[4] = i[4] + d & 4294967295, i[5] = i[5] + p & 4294967295, i[6] = i[6] + f & 4294967295, i[7] = i[7] + m & 4294967295;\n                }\n\n                return g.toHexStr(i[0]) + g.toHexStr(i[1]) + g.toHexStr(i[2]) + g.toHexStr(i[3]) + g.toHexStr(i[4]) + g.toHexStr(i[5]) + g.toHexStr(i[6]) + g.toHexStr(i[7]);\n              },\n              ROTR: function ROTR(t, e) {\n                return e >>> t | e << 32 - t;\n              },\n              S0: function S0(t) {\n                return g.ROTR(2, t) ^ g.ROTR(13, t) ^ g.ROTR(22, t);\n              },\n              S1: function S1(t) {\n                return g.ROTR(6, t) ^ g.ROTR(11, t) ^ g.ROTR(25, t);\n              },\n              s0: function s0(t) {\n                return g.ROTR(7, t) ^ g.ROTR(18, t) ^ t >>> 3;\n              },\n              s1: function s1(t) {\n                return g.ROTR(17, t) ^ g.ROTR(19, t) ^ t >>> 10;\n              },\n              Ch: function Ch(t, e, i) {\n                return t & e ^ ~t & i;\n              },\n              Maj: function Maj(t, e, i) {\n                return t & e ^ t & i ^ e & i;\n              },\n              toHexStr: function toHexStr(t) {\n                for (var e = \"\", i = 7; i >= 0; i--) {\n                  e += (t >>> 4 * i & 15).toString(16);\n                }\n\n                return e;\n              }\n            },\n                m = {\n              crypto: {\n                Util: {\n                  DIGESTINFOHEAD: {\n                    sha256: \"3031300d060960864801650304020105000420\"\n                  }\n                }\n              }\n            },\n                v = new RegExp(\"[^0-9a-f]\", \"gi\");\n            return h.prototype.verify = function (t, e) {\n              var i = l(e = (e = e.replace(v, \"\")).replace(/[ \\n]+/g, \"\"), 16);\n              if (i.bitLength() > this.n.bitLength()) return !1;\n\n              var n = function (t) {\n                for (var e in m.crypto.Util.DIGESTINFOHEAD) {\n                  var i = m.crypto.Util.DIGESTINFOHEAD[e],\n                      n = i.length;\n                  if (t.substring(0, n) == i) return [e, t.substring(n)];\n                }\n\n                return [];\n              }(this.doPublic(i).toString(16).replace(/^1f+00/, \"\"));\n\n              return 0 !== n.length && n[1] === g.hash(t);\n            }, h.hash = g.hash, h;\n          }(),\n              Yt = function () {\n            function t(t, e, i) {\n              var n,\n                  r = this;\n\n              for (n in this.api = null, this.scene = null, this.settings = null, this.shell = null, this.events = null, this.removed = !0, this.assetsLoaded = !1, this.toolbar = null, this.data = {}, this.navigator = null, this.curState = null, this.goingBack = !1, this.chartUpdateOrigin = null, this.chartUpdateTimeout = null, this.scene = e, this.settings = t, this.api = i, i._impl = this, this.scene.settings = t, this.scene.assetsLoader = this.assetsLoader = new Rt(this), this.data = {}, this.settings.parentChart ? (this.shell = new Pt(this, this.settings.parentChart._impl.shell), this.events = this.shell.events) : (this.shell = new It(this, this.createDomLayer()), this.events = this.shell.events, this.events.addElement(new zt(this)), this.events.addElement(new nt(this)), this.events.addElement(new O(this, this.settings.credits))), window.setTimeout(function () {\n                return Qt.execute(r, !r.settings.parentChart);\n              }, 500), this.removed = !1, this.EVENT_NAMES = {}, t.events) {\n                if (0 === n.indexOf(\"on\")) {\n                  var s = n.charAt(2).toLowerCase() + n.slice(3);\n                  this.EVENT_NAMES[n] = s, this.EVENT_NAMES[s] = s;\n                }\n              }\n\n              this.eventListeners = {}, this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {\n                return r.notifyAssetsLoaded();\n              }), this.clearData(), this.events.addElement(new jt(this)), this.title = this.events.addElement(new U(this)), this.events.addElement(new Dt(this));\n            }\n\n            return t.prototype.createDomLayer = function () {\n              return new s.DomLayer(this);\n            }, t.prototype.updateFilters = function (t) {\n              this.events.notifySceneChanges({\n                filters: !0\n              });\n            }, t.prototype.updateStyle = function (t) {\n              this.events.notifySceneChanges({\n                style: !0\n              });\n            }, t.prototype.defaultDoubleClick = function (t, e) {}, t.prototype.defaultTripleClick = function (t, e) {}, t.prototype.defaultClick = function (t, e) {}, t.prototype.defaultRightClick = function (t, e) {}, t.prototype.finalInitialize = function () {\n              var t = {\n                settings: !0,\n                settingsChanges: this.scene.settings,\n                data: {}\n              };\n              this.processChangedSettings(t), this.events.notifySceneChanges(t), this.updateSize(), this.updateEvents(null, this.settings.events);\n            }, t.prototype.getRootChart = function () {\n              var t = this.settings.parentChart;\n              return t ? t._impl.getRootChart() : this;\n            }, t.prototype.processChangedSettings = function (t) {}, t.prototype.updateSettings = function (t, e) {\n              var i = this;\n\n              if (void 0 === e && (e = null), !this.removed) {\n                var n = p.clone(this.settings.events),\n                    r = this.settings.apply(t),\n                    s = {\n                  settings: !0,\n                  settingsChanges: r\n                };\n                this.processChangedSettings(s), r.events && this.updateEvents(n, this.settings.events), r.advanced && r.advanced.assets && r.advanced.assets.length > 0 && (this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {\n                  return i.notifyAssetsLoaded();\n                })), r.data && this.dataSettingsChanged(r.data), this.shell.updateSettings(r), this.onSettingsChanged(r), r.toolbar && this.assetsLoaded && this.createToolbar(), this.events.notifySceneChanges(s);\n                var a = r.area;\n\n                if (a && (a.width || a.height || a.maxWidth || a.minWidth || a.minHeight || a.maxHeight) && this.updateSize(!0), e) {\n                  var o = this.createEventArguments(null, e);\n                  o.changes = r, this.notifySettingsChanged(o);\n                }\n              }\n            }, t.prototype.getData = function (t) {\n              if (this.data[t]) return this.data[t];\n              var e = this.settings._computedDataMap[t];\n\n              if (e) {\n                var i = this.createDataObj(e);\n                return i.applyPreloadedData(), this.data[t] = i, i;\n              }\n\n              throw new Error(\"No data configured for source ID \" + t);\n            }, t.prototype.addData = function (t, e) {\n              this.removed || this.getData(e).addData(t);\n            }, t.prototype.reloadData = function (t, e) {\n              if (void 0 === t && (t = null), void 0 === e && (e = !1), !this.removed) {\n                this.log(\"Reload data\"), t ? this.data[t] && (this.data[t].remove(), delete this.data[t]) : this.clearData(), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n                var i = {};\n\n                for (var n in this.settings._computedDataMap) {\n                  i[n] = !0;\n                }\n\n                this.events.notifySceneChanges({\n                  data: i,\n                  dataDeep: e\n                }), this.navigator && this.navigator.onNewDataObject();\n              }\n            }, t.prototype.replaceData = function (t, e) {\n              if (void 0 === e && (e = \"default\"), null == e && (e = \"default\"), !this.removed) {\n                this.events.clearSceneChanges({\n                  dataArrived: null\n                }), this.data[e] && this.data[e].remove(), (this.data[e] = this.createDataObj(this.settings._computedDataMap[e])).addData(t), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n                var i = {};\n                i[e] = !0, this.events.notifySceneChanges({\n                  data: i\n                }), this.navigator && this.navigator.onNewDataObject();\n              }\n            }, t.prototype.clearData = function (t) {\n              for (var e in void 0 === t && (t = !1), this.data) {\n                this.data[e].remove();\n              }\n\n              this.events.clearSceneChanges({\n                dataArrived: null\n              }), this.data = {}, this.scene.mainData = null, !t && this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n            }, t.prototype.dataSettingsChanged = function (t) {\n              for (var e in this.data) {\n                !t[e] && this.settings._computedDataMap[e] || (this.data[e].remove(), delete this.data[e]);\n              }\n\n              this.events.clearSceneChanges({\n                dataArrived: null\n              }), this.events.notifySceneChanges({\n                data: t,\n                dataDeep: !0\n              }), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id)), this.navigator && this.navigator.onNewDataObject();\n            }, t.prototype.hasPendingRequests = function () {\n              if (!this.assetsLoaded) return !0;\n              if (this.assetsLoader.hasPendingRequests()) return !0;\n\n              for (var t in this.data) {\n                if (this.data[t].hasPendingRequests()) return !0;\n              }\n\n              return !1;\n            }, t.prototype.remove = function () {\n              return this.removed ? void s.Helpers.warn(\"Removing already removed chart\") : (this.cancelChartUpdateNotify(), this.removed = !0, this.toolbar && this.toolbar.remove(), this.shell.remove(), this.clearData(!0), this.shell = null, this.scene = null, void (this.events = null));\n            }, t.prototype.setFullscreen = function (t) {\n              this.shell.setFullscreen(t);\n            }, t.prototype.isFullscreen = function () {\n              return this.shell.fullScreenMode;\n            }, t.prototype.updateSize = function (t) {\n              void 0 === t && (t = !1), this.removed || this.shell.updateSize(t);\n            }, t.prototype.on = function (t, e) {\n              var i = this.EVENT_NAMES[t];\n              return i ? (this.eventListeners[i] || (this.eventListeners[i] = []), void this.eventListeners[i].push(e)) : void this.error(\"Unrecognized event name: \" + t);\n            }, t.prototype.off = function (t, e) {\n              var i = this.EVENT_NAMES[t];\n              return i ? this.eventListeners[i] ? p.removeFromArray(this.eventListeners[i], e) : void 0 : void this.error(\"Unrecognized event name: \" + t);\n            }, t.prototype.updateEvents = function (t, e) {\n              var i = t,\n                  n = e;\n\n              for (var r in this.EVENT_NAMES) {\n                var s = this.EVENT_NAMES[r];\n                t && i[r] && this.off(s, i[r]), n[r] && this.on(s, n[r]);\n              }\n            }, t.prototype.notifyHoverChanged = function (t, e) {\n              this.dispatchEvent(\"hoverChange\", t, e, null);\n            }, t.prototype.notifyDoubleClick = function (t, e) {\n              var i = this;\n              this.dispatchEvent(\"doubleClick\", t, e, function (t, e) {\n                return i.defaultDoubleClick(t, e);\n              });\n            }, t.prototype.notifyTripleClick = function (t, e) {\n              var i = this;\n              this.dispatchEvent(\"tripleClick\", t, e, function (t, e) {\n                return i.defaultTripleClick(t, e);\n              });\n            }, t.prototype.notifyRightClick = function (t, e) {\n              var i = this;\n              this.dispatchEvent(\"rightClick\", t, e, function (t, e) {\n                return i.defaultRightClick(t, e);\n              });\n            }, t.prototype.notifyClick = function (t, e) {\n              var i = this;\n              this.dispatchEvent(\"click\", t, e, function (t, e) {\n                return i.defaultClick(t, e);\n              });\n            }, t.prototype.notifySelectionChanged = function (t) {\n              return this.dispatchEventParams(\"selectionChange\", t, null);\n            }, t.prototype.notifySettingsChanged = function (t) {\n              return this.dispatchEventParams(\"settingsChange\", t, null);\n            }, t.prototype.notifyPositionChange = function (t) {\n              return this.dispatchEventParams(\"positionChange\", t, null);\n            }, t.prototype.notifyPointerDown = function (t, e) {\n              this.dispatchEvent(\"pointerDown\", t, e, null);\n            }, t.prototype.notifyPointerUp = function (t, e) {\n              this.dispatchEvent(\"pointerUp\", t, e, null);\n            }, t.prototype.notifyPointerDrag = function (t, e) {\n              this.dispatchEvent(\"pointerDrag\", t, e, null);\n            }, t.prototype.notifyPointerMove = function (t, e) {\n              this.dispatchEvent(\"pointerMove\", t, e, null);\n            }, t.prototype.notifyDataUpdated = function (t) {\n              return this.dispatchEventParams(\"dataUpdated\", t, null);\n            }, t.prototype.notifyChartUpdate = function (t, e) {\n              var i = this;\n              void 0 === e && (e = !1);\n              var n = p.performanceNow();\n              e && (this.chartUpdateForce = !0), t && (this.chartUpdateWasBack = this.goingBack, this.chartUpdateOrigin = t, this.chartUpdateTime = n), this.chartUpdateState = this.saveNavigation(), null === this.chartUpdateTimeout && (this.chartUpdateTimeout = setTimeout(function () {\n                return i.chartUpdateNotify();\n              }, this.chartUpdateTime + this.scene.settings.events.chartUpdateDelay - n));\n            }, t.prototype.cancelChartUpdateNotify = function () {\n              this.chartUpdateOrigin = null, this.chartUpdateTimeout && (clearTimeout(this.chartUpdateTimeout), this.chartUpdateTimeout = null);\n            }, t.prototype.chartUpdateNotify = function () {\n              this.chartUpdateTimeout = null;\n              var t = this.chartUpdateOrigin;\n\n              if (t) {\n                var e = this.chartUpdateState;\n                !e || this.curState && JSON.stringify(e) === JSON.stringify(this.curState) ? this.chartUpdateForce && (this.chartUpdateForce = !1, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t)) : (this.chartUpdateForce = !1, !this.chartUpdateWasBack && this.curState && (this.scene.pushBack(this.curState), this.events.notifySceneChanges({\n                  requestPaint: !0\n                })), this.curState = e, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t));\n              }\n            }, t.prototype.doChartUpdateNotify = function (t) {\n              var e = this.createEventArguments(null, t);\n              this.dispatchEventParams(\"chartUpdate\", e, null);\n            }, t.prototype.back = function (t, e) {\n              if (void 0 === t && (t = !0), void 0 === e && (e = \"api\"), 0 === this.scene.backStack.length) return !1;\n              var i = this.scene.backStack.pop();\n              return this.goingBack = !0, this.restoreNavigation(i, t, e), this.goingBack = !1, !0;\n            }, t.prototype.goHome = function (t, e) {\n              if (void 0 === t && (t = !0), void 0 === e && (e = \"api\"), 0 === this.scene.backStack.length) return !1;\n              var i = this.scene.backStack[0];\n              return this.restoreNavigation(i, t, e), !0;\n            }, t.prototype.clearHistory = function () {\n              return this.scene.backStack = [], !0;\n            }, t.prototype.dispatchEventParams = function (t, e, i) {\n              var n = new x(0, 0, p.performanceNow(), \"api\");\n              return i || this.eventListeners[t] && this.eventListeners[t].length ? (this.dispatchEvent(t, n, e, i), n) : n;\n            }, t.prototype.dispatchEvent = function (t, e, i, n) {\n              if (n || this.eventListeners[t] && this.eventListeners[t].length > 0) {\n                for (var r = Object.keys(i), s = 0; s < r.length; s++) {\n                  e[r[s]] = i[r[s]];\n                }\n\n                if (this.eventListeners[t]) for (var a = 0; a < this.eventListeners[t].length; a++) {\n                  var o = this.eventListeners[t][a];\n                  this.log(\"Call user event handler, \" + t, e, i), o.call(this.api, e, i);\n                }\n                !e.defaultPrevented && n && (this.log(\"Call default event handler, \" + t), n.call(this.api, e, i));\n              }\n            }, t.prototype.error = function (t, e) {\n              var i = this;\n              void 0 === e && (e = null);\n              var n = this.createEventArguments(null, \"api\");\n              n.message = t, n.arg = e, this.dispatchEventParams(\"error\", n, function (t, e) {\n                return i.defaultError(t, e);\n              });\n            }, t.prototype.log = function (t) {\n              for (var e = [], i = 1; i < arguments.length; i++) {\n                e[i - 1] = arguments[i];\n              }\n\n              this.settings.advanced.logging && p.log(t, e);\n            }, t.prototype.deprecated = function (t, e) {\n              var i = \"Deprecated: \" + t + \".\";\n              e && (i += \" Use \" + e + \" instead\"), s.Helpers.warn(i);\n            }, t.prototype.defaultError = function (t, e) {\n              e.arg ? p.error(e.message, e.arg) : p.error(e.message);\n            }, t.prototype.createToolbar = function () {\n              this.toolbar && this.toolbar.remove(), this.assetsLoaded && (this.toolbar = new tt(this, this.settings.toolbar));\n            }, t.prototype.notifyAssetsLoaded = function () {\n              this.removed || (this.assetsLoaded = !0, this.createToolbar(), this.updateSize(!0), this.events.notifySceneChanges({\n                assets: !0,\n                style: !0\n              }));\n            }, t;\n          }();\n\n          s.Impl = Yt, function (t) {\n            t[t.FacetChart = 1] = \"FacetChart\", t[t.GeoChart = 2] = \"GeoChart\", t[t.NetChart = 4] = \"NetChart\", t[t.PieChart = 8] = \"PieChart\", t[t.TimeChart = 16] = \"TimeChart\";\n          }(Vt || (Vt = {}));\n\n          var qt,\n              _t = !1,\n              Xt = {},\n              Qt = function () {\n            function t() {}\n\n            return t.checkChartType = function (t, e) {\n              var i = e.lastIndexOf(\"-\", e.indexOf(\":\"));\n              if (-1 === i || i === e.indexOf(\"-\")) return !0;\n              var n,\n                  r = 0;\n\n              for (i++; (n = e.charCodeAt(i)) > 47 && n < 58;) {\n                r = 10 * r + n - 48, i++;\n              }\n\n              var s = Vt[t];\n              return s > 0 && (r & s) === s;\n            }, t.execute = function (t, i) {\n              var n = this,\n                  r = window.ZoomChartsLicense,\n                  a = window.ZoomChartsLicenseKey,\n                  o = t.api.typeName,\n                  l = r + p.SeparatorChar + o,\n                  h = Xt[l];\n              if (h) h.result ? this.handleServerResponse([t], h.result) : h.charts.push(t);else {\n                Xt[l] = h = {\n                  charts: [t],\n                  result: null\n                };\n                var u = \"ZoomCharts \" + e.PackageInfo.Version;\n                r && a ? Wt.verifySignature(r, a) ? _t || (p.log(u + \" license verified: \" + r), _t = !0) : p.error(u + \" license key for license '\" + r + \"' is invalid. Please configure the correct key in order to use the charts.\") : (p.error(u + \" license key was not found on the page. Please make sure ZoomChartsLicense and ZoomChartsLicenseKey variables are correctly set before initializing the chart.\"), r = a = \"---:\");\n                var c = \". Please upgrade your license on https://zoomcharts.com\",\n                    d = r.charAt(2);\n\n                if (this.checkChartType(o, r) || (p.error(\"ZoomCharts license used on this page does not allow use of \" + o + c), d = \"-\", i)) {\n                  var f = /(\\d\\d\\d\\d-\\d\\d-\\d\\d)$/,\n                      g = \"builtin://logo-license-expired\",\n                      m = g;\n\n                  switch (d) {\n                    case \"F\":\n                    case \"O\":\n                      var v = r.match(f),\n                          y = e.PackageInfo.Built,\n                          S = r.substring(0, r.indexOf(\":\"));\n                      return [\"ZCF-f7zr14ipl-25\", \"ZCF-6sag05711-16\", \"ZCF-981cwt0sy-8\", \"ZCF-x33yuxzf8-1\", \"ZCF-8r2n87ra8-8\", \"ZCF-1flw35m2i-16\"].indexOf(S) >= 0 ? void (g = null) : void (v && v[1] < y ? (h.result = {\n                        status: 2,\n                        bannerImage: g,\n                        consoleMessages: [{\n                          level: \"error\",\n                          text: \"ZoomCharts license is not valid for this library version which was released on \" + y + c\n                        }]\n                      }, this.handleServerResponse(h.charts, h.result)) : (h.result = {\n                        status: 1\n                      }, h.charts = []));\n\n                    case \"B\":\n                      var b = r.match(f),\n                          C = \"https://zoomcharts.com/en/renew-licence/\";\n                      return void (b && b[1] < new Date().toISOString() ? (h.result = {\n                        status: 2,\n                        bannerImage: \"builtin://logo-license-expired\",\n                        consoleMessages: [{\n                          level: \"error\",\n                          text: \"ZoomCharts license has expired on \" + b[1] + \". Please renew the license at \" + C\n                        }],\n                        bannerTarget: C\n                      }, this.handleServerResponse(h.charts, h.result)) : (h.result = {\n                        status: 1\n                      }, h.charts = []));\n\n                    case \"-\":\n                    case \"S\":\n                      g = \"builtin://logo-development\";\n                      break;\n\n                    case \"X\":\n                      g = \"builtin://logo-supported-by\";\n                      break;\n\n                    default:\n                    case \"P\":\n                      g = null;\n                  }\n\n                  var x = JSON.stringify({\n                    protocol: 1,\n                    version: e.PackageInfo.Version,\n                    revision: e.PackageInfo.Revision,\n                    libraryName: e.PackageInfo.LibraryName,\n                    assetsDomain: this.parseUriDomain(t.assetsLoader.getAssetUrl(\"assets://\")),\n                    pageDomain: location.hostname,\n                    chartType: o,\n                    license: r.substring(0, r.indexOf(\":\")),\n                    licenseKeyHash: Wt.hash(a)\n                  }, null, \" \");\n                  s.Helpers.doPostRequest(t.assetsLoader.getAssetUrl(\"https://api.zoomcharts-cloud.com/lc/v1/\"), 3e4, x, function (e) {\n                    try {\n                      var i = JSON.parse(e);\n                      if (1 !== i.protocol) throw \"Server response contains invalid protocol.\";\n                      var r = Xt[l];\n                      r.result = i, n.handleServerResponse(r.charts, r.result);\n                    } catch (e) {\n                      n.handleServerError(t, \"Unable to parse licensing server response: \" + e), g && n.displayBanner(t, g), delete Xt[l];\n                    }\n                  }, function (e) {\n                    e = e || \"\", delete Xt[l], n.handleServerError(t, \"Unable to contact licensing server: \" + e), (2153644038 === e.result || e instanceof DOMException && e.code === DOMException.SECURITY_ERR || \"SecurityError\" === e.name) && (g = m), g && n.displayBanner(t, g);\n                  });\n                } else this.displayBanner(t, \"builtin://logo-license-expired\");\n              }\n            }, t.displayBanner = function (t, e, i) {\n              if (!t.removed) {\n                var n = new F();\n                i && (n.url = i), n.imageScaling = .5, n.image = e, n.enabled = !0, n.enabledOnExport = !0, n.location = \"inside\", t.events.addElement(new O(t, n)), t.events.notifySceneChanges({\n                  settings: !0,\n                  settingsChanges: {\n                    credits: {\n                      enabled: n.enabled\n                    }\n                  }\n                });\n              }\n            }, t.handleServerError = function (t, e) {\n              t.error(e);\n            }, t.handleServerResponse = function (t, e) {\n              if (null !== e) {\n                if (e.consoleMessages) for (var i = 0; i < e.consoleMessages.length; i++) {\n                  var n = e.consoleMessages[i];\n\n                  switch (n.level) {\n                    case \"error\":\n                      p.error(n.text);\n                      break;\n\n                    case \"warn\":\n                      p.warn(n.text);\n                      break;\n\n                    default:\n                    case \"info\":\n                      p.log(n.text);\n                  }\n                }\n\n                for (i = 0; i < t.length; i++) {\n                  var r = t[i];\n                  if (!r.removed) if (1 === e.status) ;else if (2 === e.status) this.displayBanner(r, e.bannerImage, e.bannerTarget);else {\n                    if (3 !== e.status) {\n                      p.warn(\"Licensing server returned unknown status code \" + e.status);\n                      break;\n                    }\n\n                    this.blockChart(r, '<a href=\"' + e.bannerTarget + '\"><img src=\"' + e.bannerImage + '\" title=\"Problem with the license\"/></a>');\n                  }\n                }\n\n                t.length = 0;\n              }\n            }, t.parseUriDomain = function (t) {\n              var e = document.createElement(\"a\");\n              return e.href = t, e.hostname || (e.href = e.href), e.hostname;\n            }, t.blockChart = function (t, e) {\n              var i = t.settings.container;\n              t.remove(), i.innerHTML = \"<strong>Unable to use ZoomCharts library because of a licensing issue:</strong><br/>\" + e;\n            }, t;\n          }();\n\n          !function (t) {\n            t[t.inside = 0] = \"inside\", t[t.outside = 1] = \"outside\";\n          }(qt = s.InfoPopupPosition || (s.InfoPopupPosition = {}));\n\n          var Jt = function () {\n            function t(t) {\n              this.chart = t, this.container = t.shell.interactiveContainer, this.events = t.events, this.popup = null, this.visible = !1, this.x0 = null, this.x1 = null, this.y = null, this.contentsChanged = !1;\n            }\n\n            return t.prototype.hide = function () {\n              return !(!this.visible || !this.popup || (this.visible = !1, this.popup.style.display = \"none\", 0));\n            }, t.prototype.remove = function () {\n              this.popup && this.popup.parentNode && (this.popup.parentNode.removeChild(this.popup), this.popup = null);\n            }, t.prototype.ensurePopup = function () {\n              this.popup || (this.popup = p.createDom(\"div\", \"DVSL-info-center\", null, this.container), p.createDom(\"em\", null, null, this.popup), this.popup.style.position = \"absolute\", this.popup.style.display = \"none\");\n            }, t.prototype.show = function (t, e, i, n, r) {\n              void 0 === r && (r = qt.inside), this.ensurePopup();\n              var s = this.popup;\n              n ? (-1 === n.indexOf(\"<\") && -1 === n.indexOf(\">\") && (n = \"<b>\" + n + \"</b>\"), this.visible = !0, s.style.display = \"block\", n !== s.innerHTML && (s.innerHTML = n, this.postProcessHtml(s), this.contentsChanged = !0), this.updateXY(t, e, i, r)) : s.style.display = \"none\";\n            }, t.prototype.postProcessHtml = function (t) {\n              if (t instanceof HTMLElement) {\n                var e = t.getAttribute(\"data-color\");\n                e && (t.style.color = e, null != t.getAttribute(\"data-selected\") && (t.style.borderColor = e));\n              }\n\n              for (var i = t.firstElementChild; i;) {\n                this.postProcessHtml(i), i = i.nextElementSibling;\n              }\n            }, t.prototype.updateContents = function (t) {\n              null === t ? this.hide() : this.show(this.x0, this.x1, this.y, t, this.position);\n            }, t.prototype.updateXY = function (t, e, i, n) {\n              if (void 0 === n && (n = qt.inside), this.visible && (this.contentsChanged || this.x0 !== t || this.x1 !== e || this.y !== i || this.position !== n)) {\n                this.ensurePopup(), this.contentsChanged && (this.contentsChanged = !1, this.popup.style.right = null, this.width = this.popup.offsetWidth, this.height = this.popup.offsetHeight), this.x0 = t, this.x1 = e, this.y = i, this.position = n;\n                var r,\n                    s = this.width,\n                    a = this.height,\n                    o = null,\n                    l = this.popup.style,\n                    h = this.chart.scene;\n                if (t > h.x0 + h.width || e < h.x0) return void (l.top = \"-10000px\");\n                var u = this.chart.getRootChart().scene;\n\n                switch (n) {\n                  default:\n                  case qt.inside:\n                    u.x0 <= t - s - 10 ? (o = t - s - 10, r = \"DVSL-info-left\") : u.x0 + u.width >= e + s + 10 ? (o = e + 10, r = \"DVSL-info-right\") : (o = (Math.max(t, u.x0) + Math.min(e, u.x0 + u.width) - s) / 2, r = \"DVSL-info-center\"), i = Math.min(Math.max(u.y0 + 12, i - a / 2), u.y0 + u.height - a), i = Math.max(this.chart.shell.getChartInnerArea().findTopPosition(o, o + s), i);\n                    break;\n\n                  case qt.outside:\n                    r = \"DVSL-info-center\", o = Math.min(u.x0 + u.width - s, Math.max(0, (t + e - s) / 2)), i = this.chart.shell.container.offsetTop > a ? u.y0 - a : u.y0 + u.height;\n                }\n\n                var c = null;\n                s >= u.chartWidth ? (c = 0, o = 0) : o + s > u.chartWidth - 20 && (o + s > u.chartWidth ? (c = 0, o = null) : (c = u.chartWidth - o - s, o = null)), l.right = null !== c ? c + \"px\" : null, l.left = null !== o ? o + \"px\" : null, l.top = i + \"px\", this.popupClass !== r && (this.popupClass = r, this.popup.className = r);\n              }\n            }, t;\n          }();\n\n          s.InfoPopup = Jt;\n\n          var Kt = function () {\n            function t(t, e, i) {\n              void 0 === i && (i = !1), this._direction = 1, this._endTime = 0, this._midTime = 0, this._startTime = 0, this._preventOvershoot = !1, this._setTargetPending = !1, this._settableTargetValue = 0, this._settableAcceleration = 0, this._acceleration = t, this._initialValue = this._targetValue = e, this._preventOvershoot = i;\n            }\n\n            return t.prototype.setTarget = function (t, e, i, n) {\n              if (null == e) return this._settableTargetValue = t, this._settableAcceleration = i, void (this._setTargetPending = !0);\n              this._settableAcceleration = null, this._setTargetPending = !1, null != i && this.setAcceleration(i, e);\n\n              var r = this._getDeltaT(e),\n                  s = this._getDistanceToV0(r),\n                  a = this._composeValue(e, s),\n                  o = Math.abs(t - a),\n                  l = t > a ? 1 : -1;\n\n              if (e < this._startTime && (this._direction *= -1), this._targetValue = t, e < this._endTime) {\n                if (s > o || this._direction !== l) {\n                  if (this._preventOvershoot) {\n                    if (this._direction === l) {\n                      var h = this._getCurrentVelocity(r);\n\n                      this._acceleration = h * h / (2 * o), this._startTime = e - h / this._acceleration, this._initialValue = a - o * this._direction;\n                    } else this._startTime = e, this._initialValue = a;\n                  } else this._startTime = e + r, this._initialValue = a + s * this._direction;\n                } else (e >= this._midTime || e <= this._startTime) && (this._startTime = e - r, this._initialValue = a - s * this._direction);\n              } else this._startTime = e, this._initialValue = a;\n              this._direction = this._targetValue > this._initialValue ? 1 : -1;\n              var u = Math.abs(this._targetValue - this._initialValue),\n                  c = Math.sqrt(u / this._acceleration);\n              this._midTime = this._startTime + c, this._endTime = this._startTime + 2 * c, null != n && this._endTime - this._startTime > n && (this._endTime = this._startTime + n, this._midTime = (this._startTime + this._endTime) / 2, c = this._endTime - this._midTime, this._acceleration = u / (c * c));\n            }, t.prototype.getValue = function (t) {\n              return this._setTargetPending && this.setTarget(this._settableTargetValue, t, this._settableAcceleration), this.finished(t) ? this._targetValue : this._composeValue(t, this._getDistanceToV0(this._getDeltaT(t)));\n            }, t.prototype.getTargetValue = function () {\n              return this._targetValue;\n            }, t.prototype.finished = function (t) {\n              return !this._setTargetPending && t >= this._endTime;\n            }, t.prototype.jump = function (t, e, i) {\n              if (this._initialValue = this._targetValue = t, this._startTime = this._midTime = this._endTime = 0, null != e && null != i && 0 !== e) {\n                var n = e > 0 ? 1 : -1,\n                    r = Math.abs(e / this._acceleration);\n                this._direction = n, this._midTime = i, this._endTime = i + r, this._targetValue = t + this._getDistanceToV0(r) * n;\n              }\n\n              return this._targetValue;\n            }, t.prototype.setAcceleration = function (t, e) {\n              if (t !== this._acceleration) if (e < this._endTime) {\n                var i = this._getDeltaT(e),\n                    n = this._getCurrentVelocity(i),\n                    r = this._composeValue(e, this._getDistanceToV0(i));\n\n                e < this._startTime && (n = -n), this._acceleration = t, this.jump(r, n * this._direction, e);\n              } else this._acceleration = t;\n            }, t.prototype._composeValue = function (t, e) {\n              return t < this._startTime ? this._initialValue + e * this._direction : t < this._midTime ? this._initialValue + e * this._direction : t < this._endTime ? this._targetValue - e * this._direction : this._targetValue;\n            }, t.prototype._getDistanceToV0 = function (t) {\n              return this._acceleration * t * t / 2;\n            }, t.prototype._getDeltaT = function (t) {\n              return t < this._startTime ? this._startTime - t : t < this._midTime ? t - this._startTime : t < this._endTime ? this._endTime - t : 0;\n            }, t.prototype._getCurrentVelocity = function (t) {\n              return t * this._acceleration;\n            }, t;\n          }();\n\n          s.Inertia = Kt;\n\n          var $t = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(s.ChartElement);\n\n          s.Navigator = $t;\n\n          var te = function () {\n            function t() {}\n\n            return t.prototype.customize = function (t) {\n              var e = this.constructor.themes;\n              if (!e.hasOwnProperty(t)) throw new Error(\"The chart does not contain a predefined theme named `\" + t + \"`.\");\n              return this.updateSettings(e[t]);\n            }, t.prototype.saveState = function () {\n              return this._impl.save();\n            }, t.prototype.restoreState = function (t, e) {\n              void 0 === e && (e = !1), null == e && (e = !1), this._impl.restore(t, e);\n            }, t.prototype.fullscreen = function (t) {\n              return !0 === t ? this._impl.setFullscreen(!0) : !1 === t && this._impl.setFullscreen(!1), this._impl.isFullscreen();\n            }, t.prototype.updateSettings = function (t) {\n              return t && this._impl.updateSettings(t, \"api\"), this;\n            }, t.prototype.replaceSettings = function (t) {\n              if (t) {\n                var e = n.Base.SettingsHelper;\n\n                try {\n                  e.replacingSettings = !0, this._impl.updateSettings(t, \"api\");\n                } finally {\n                  e.replacingSettings = !1;\n                }\n              }\n\n              return this;\n            }, t.prototype.updateFilters = function () {\n              this._impl.updateFilters(null);\n            }, t.prototype.updateStyle = function () {\n              this._impl.updateStyle(null);\n            }, t.prototype.on = function (t, e) {\n              this._impl.on(t, e);\n            }, t.prototype.off = function (t, e) {\n              return this._impl.off(t, e);\n            }, t.prototype.updateSize = function () {\n              return this._impl.updateSize(!0), this;\n            }, t.prototype.reloadData = function (t) {\n              return void 0 === t && (t = null), this._impl.reloadData(t);\n            }, t.prototype.remove = function () {\n              return this._impl.remove();\n            }, t.prototype.saveAsImage = function (t, e, i) {\n              return this._impl.deprecated(\"saveAsImage\", \"exportAsString\"), this.exportImageAsString(t, e, i);\n            }, t.prototype.exportGetDimensions = function (t) {\n              return this._impl.deprecated(\"exportGetDimensions\", \"exportImageGetDimensions\"), this.exportImageGetDimensions(t);\n            }, t.prototype.exportImageAsString = function (t, e, i) {\n              return this._impl.deprecated(\"exportImageAsString\", \"exportAsString\"), Gt.export(this._impl, t, e, i, function () {});\n            }, t.prototype.exportImageGetDimensions = function (t) {\n              return Gt.getDimensions(this._impl, t);\n            }, t.prototype.exportAsString = function (t, e, i, n) {\n              if (void 0 === n && (n = !1), !e) throw new Error(\"`callback` argument is mandatory.\");\n              Gt.export(this._impl, t, i, n, e);\n            }, t.prototype.export = function (t, e, i) {\n              void 0 === i && (i = !1), Gt.download(this._impl, t, e, i);\n            }, t.prototype.addSubchartContainer = function (t) {\n              this._impl.shell.interactiveContainer.appendChild(t);\n            }, t.prototype.suspendPaint = function () {\n              this._impl.events.suspendPaint();\n            }, t.prototype.resumePaint = function () {\n              this._impl.events.resumePaint();\n            }, t.prototype.paintNow = function (t) {\n              return void 0 === t && (t = !1), this._impl.events.paintNow(t), this;\n            }, t.prototype.back = function () {\n              return this._impl.back(), this;\n            }, t.prototype.home = function () {\n              return this._impl.goHome();\n            }, t.prototype.clearHistory = function () {\n              return this._impl.clearHistory(), this;\n            }, t.prototype.profiler = function () {\n              return this._impl.shell.profiler;\n            }, t.prototype.measureFps = function (t, e) {\n              this._impl.deprecated(\"measureFps\"), this.profiler().measureFps(t, e);\n            }, t;\n          }();\n\n          te.themes = {}, s.Api = te;\n\n          var ee = function () {\n            function t(t, e, i, n) {\n              void 0 === i && (i = 0), void 0 === n && (n = t.length), null == n && (n = t.length), null == i && (i = 0), this.n0 = i;\n              var r = [];\n              r.length = n - i;\n              var s = 0;\n              r[n - i - 1] = (e[n - 1] - e[n - 2]) / (t[n - 1] - t[n - 2]);\n              var a,\n                  o = (e[i + 1] - e[i]) / (t[i + 1] - t[i]);\n\n              for (a = i + 1; a < n - 1; a++) {\n                var l = (e[a + 1] - e[a]) / (t[a + 1] - t[a]),\n                    h = void 0;\n                if (0 === o) h = s = 0;else {\n                  var u = (s * s + (h = (o + l) / 2) * h) / (o * o);\n\n                  if (u > 9) {\n                    var c = 3 / Math.sqrt(u);\n                    s *= c, h *= c;\n                  }\n                }\n                r[a - i - 1] = s, s = h, o = l;\n              }\n\n              r[a - i - 1] = s, this.x = t, this.y = e, this.m = r;\n            }\n\n            return t.prototype.interpolate = function (t, e) {\n              var i = this.x[t + 1] - this.x[t],\n                  n = (e - this.x[t]) / i,\n                  r = n * n,\n                  s = r * n,\n                  a = s - 2 * r + n,\n                  o = -2 * s + 3 * r,\n                  l = s - r;\n              return (2 * s - 3 * r + 1) * this.y[t] + a * i * this.m[t - this.n0] + o * this.y[t + 1] + l * i * this.m[t - this.n0 + 1];\n            }, t.prototype.interpolateArray = function (t, e, i, n, r) {\n              for (var s = this.x[t], a = this.y[t], o = this.m[t - this.n0], l = this.y[t + 1], h = this.m[t - this.n0 + 1], u = this.x[t + 1] - s, c = 1 / u, d = i; d < n; d++) {\n                var p = (e[d] - s) * c,\n                    f = p * p,\n                    g = f * p,\n                    m = (2 * g - 3 * f + 1) * a + (g - 2 * f + p) * u * o + (-2 * g + 3 * f) * l + (g - f) * u * h;\n                r.push(m);\n              }\n            }, t.prototype.clear = function () {\n              this.m.length = 0;\n            }, t;\n          }();\n\n          s.MonotoneCurve = ee, function (t) {\n            var e = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.onSceneChange = function (e) {\n                t.prototype.onSceneChange.call(this, e);\n                var i = this.chart.zoomOutPossible(),\n                    n = this.options;\n                n.enabled !== i && (n.enabled = i, this.updateSettings());\n              }, e;\n            }(t.Button);\n\n            t.ToolbarItemNames.zoomOut = function (t, i) {\n              var n = t.settings.localization.toolbar;\n              i.label = i.label || n.zoomoutButton, i.title = i.title || n.zoomoutTitle, i.cssClass = i.cssClass || \"DVSL-bar-btn-zoomout\";\n              var r = i.onClick;\n              return i.onClick = function (e, i) {\n                t.zoomOut(!0, \"user\"), r && r(e, i);\n              }, new e(t, i);\n            };\n          }(h = s.Bar || (s.Bar = {}));\n        }(h = n.Base || (n.Base = {})), function (t) {\n          t.LicenseBannerBlank = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAxpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxQkU1RjhGREExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxQkU1RjhGQ0ExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjAzYTBmMDNkLTNiNTktNDRkNi05ZjhlLWZkMGI3MTQ3ZDk1YiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3YzdiOTZjNi0yYzYyLWM3NGEtOTEzYi00YTgzZTg1YmViODAiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5mb3ItY2hhcnRzLXpvb21jaGFydHMtYmxhbms8L3JkZjpsaT4gPC9yZGY6QWx0PiA8L2RjOnRpdGxlPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PtHwutkAABHoSURBVHja7J0J2ExlG8dvS1p9VCpF2SoqUlEptJK0UJKQ9oVEKNKVtIhLtIu0Ry6ilZK0XVEpok1RqGhBSUmS3fP59Xzne888c2bmnHlnmDH3/7qO18yc9Vnu577/93JKGJFFIlJOFApFoWNliS0CYcOW/5TWtlAoCh4bS275529tB4VCgSwoqW2gUCg8qEBQKBQqEBQKhQoEhUKhAkGhUKhAUCgUKhAUCoUKBIVCoQJBoVCoQFAoFCoQFApF9qBJTYr0sMMOIrvtJmKM/VyihMhff4ls2qRtoxqCouBw2mki33xTtH39tcjhh2u7qIawHWPXXUX23FOkbFm7+q1YIfK3Jof+C7SDvfeO/W6nnQpsOS1pNSO0JP5u3lykMalA2E7AKnfyySLNm4scdpjIf/5j1eMNG0T++Udk9myRN94Qeftt+/9CBe3hopDMhbp1RYYP3zKDtkyhjRtFypQRueMOkVdfVYGw3XRw794ibdtaae9i552tcKhY0arLrATPPy8ycKDI559r+xUa0ByPOy72u/33Vw5hu0DHjiIffCDSrl2wMAgC+7VpIzJtmkjnztqGqiGJrFunAiHvcf/9Io88Ym3iRB2/apXImjXBv++yi8iwYSJDh+okUeQ9CttkGDBApHv34N8wB95/X+STT0T++MMSZtWrizRsKHLGGSK1asXuf+21IqtXW7NDochXbLGEVxhrERfW1qqVCcTo0cbUrp382F13NaZ7d2NWr44//pJLCrf9jjmmcMZP48bxz3/FFfn+XCsK02QoV07k4Yfjv7/1VpELLxT56qvkx6MJPPCAyIkniixaFG+C7L578uPxWoTlKoKw44652a6JzKp8R1Bf/fln/HeYlmoypECDBiLnniuydm3658BOf/NNkbfeysw9odbvs0/sd7fdJnLnndHOM2uW9ThMny6yxx72O4TB9deL9O1rPRK4LhEchxxiWWieBRcVLjoEyy+/iEyZYt1VCxYUnbtUKZFq1USOPVakfn2RmjVF9trLejs8NyixEQQETZggMnWqyMqV0e5/v/3svZ1yisjBB1sehXtbv966WH/6SeTLL63pRPDR8uVJVE1jBVXlyiJNmth+P/BAK3z5nuflfjnf669bt21YEo625fkbNRI59FDbLsSIcF6uy70uXizy0Uci77yTntcHr0GVKtbbVLu2SNWqtv9obwjnsWNFzj7btg0bz+aiQweRgw6ybegBU/PHHy1PFeSWrVfPmqD0M3EdXM9zcc+bZ6/N+Fi4MPa4ffe17Yzbk/ZkHOWFydC7t8kIhgxJfa3SpY1p2tSYm24yZvhwY15+2ZhJk4x55RVjnnzSmBtvNOaCC4xZvDj23FOmFO8Z27WLPd+yZcY8/bQxS5eGf7716+0znniiMddea8x770Vrn3nzjGnbNtz97r67MYMHG7N8efjzL1pkTJcuiU2GzZuNmTXLmBUrwp1vxgxjmjdPfa+YYN99F60t6Pcw5kvFisZcfbUxTzxhny8RJk82pk+f9MfuTz8ZU6ZM7LUrVTJmzJhwx69bZ8yoUcbUrWuPPfpoO6YZL/37GzNunDFHHpkRkyH7AgFbOxMYNCjxNapVs78zKdJBgwbFf86pU01OIJXgZODMmZPeuT//PDUHExXduiW/3wkT0jsvAtYvwPxbhQp2Mi5ZEu5cY8ca07Nn+s84d26sQNhnH2O++Sb6efr1M6ZECWPuvtv284gRxvTta0zHjsbce2+80MlJDgEVORMIsptRGwcNshGDN95o1d6oQNVG5S8ucD3mArp2tVxIEFBzUS9Ru9NBptRSP+BiiP9IhKhmkJ+neeghkYsuiv8N84NronaHAWq83wyICsapB8KdR4+29xAVv/9uw+gxjz77TKR9e5EWLURGjLAh9TVq5AGHMGeOtYPCEC7YTdiHRx0V/xv2px9HH23tsqB9o+DddzPznDNmWFKNweM+0/z51o6EI6BTsUHZDzv1iCOsHZkM2JJsCD4GA53PAGVQNW4cHzHnhdAyaPwDcdy4eO4EfPGFFRTY99yfZ1MzwI45xtrV8B/Y1GHw/ff2eXnu336zNjF8BefBVnZBDAf8UBBHgQ1O3/PstDGE7w8/2LwScgeYIIyZk04SadlSpEKF2OMfe8wGj3FPHhKFWNN/kMS0MX3188/22nAS8D1cD94DPgyh2qVL7PG073vvxS5e9NPSpTa8GbRuLXLqqfHXnjjRhsTDFTA+ECIIcPqWMe5xGoynSpXseR980ArMCy6w7UBbb3duxyDVe+FCa+95+5x2mjGrViVXrxYsMObFF4159FHLJ6D2zZ4dv19YuzvVtuOOxnz5Zey5N2ywqnUYDmLt2vh7g/do1syYUqWSHz9gQPyxcBj+fTp3jt/nr7+MueiicJxDjx5WZfXU0iCTgWuefbZ1yyY611lnBZt2qORB+8MF1KoVrg+qVAkeP3AE/v0wEV0MHVpko4fZ6tSJP0ebNqmPg9Ny+YEOHZIfU7asNa1atrSfGbPwXqeeasz551sTsEWLPOEQomx0nAvIquOOK9qnSRNjNm0KFgKQedhW9erZQeyef7fdjDnkEEvE/PCDPYYGzdT9T5sWez9r1hhTvXq4Y7knFwi+sNeePj2eBGQg8dsOO8TzBhs3Rju/t3nCKUggVK0a7hzEeTAR/Jg5MzN9sMce8dwA46J8+eQCIWpbpBOHQNu5wnDixPSek3nAQsDWqFHG4hByRyB06hQ8ySFMvH0YcCtXBu+HMKlcOfz1GCDDhmVOQ6CzP/009p5Y9Y84Itzx++4bH+j0wAPhrx+kARx+uP2tYcP433j2TAcm1a8f/ng0Nj/++Se8QEm1DRwYf2+spskEQvv22RcILEjeQuQB7VUDkxxgIw0ZEv/9c8+JPPpo0ecnn7QZh67/m+SkK6+0Nl9YEFhCuPH48Zl5BmIEsPPSBXYmtqsfbr2BZHD91KB8efuXWAMXL7yQ+X4sGWE4ETPgEnfEamQCxGW4IOw8FwK34Af8gBQkZqNgApNSgQnO4IQV9gOC6+KLiz5fcYUNoHEBSfPSS+lfvzgBU35QRyFVhGLUSL8ozLZHWgVNUJe0XLJE5NNPt22/IwBdhCUtITyZ4BCVkGkE5zDRaD8IR353EUSmbm1AZhLg5Q9q4hkI/Bo1yi54EKdBfVkwAgFPASyx23BEfXmRbHT4LbfEH9uvX/GEQSZxySXFX13dFTbKihu0L6w4cPP0mYzpuvMyBdjyIFdhIpBMdtZZdkWF4UcQBAlMxkzQhCqO2zDT453niJmFW8b3ZZfZBZDIU6IiP/wwcx6wvBEIN90U7IOmcfzViBgErjqOK4lw41wArjR8wplGcctxeRPDTe3e1sIgkevPE2CuBnnXXSKXXx4uh4N9gvbLldJmr70mMniwjZtxQbg6YdP9+9vPM2dadyzuxWXLtsrtbTsOAf821YZcPPWUVZ/8oBCJi9tvz40OZvA9/rjkJLwJ5q68rh27LRAmuYu8CFbJa67J3YSudEAuDRpvqpJzxNrcfLPIxx/bfKDtVkOALAsitbBrIQj9YHVzuQMCRUiO2dYgcefFF0Xq1BFFhoFmQKJSUPQpATiMFdRqyFSC3jAJICYxJeBMMOGKk1GabVCLA/KTkn0EFsGJJDIRSbrCND7vvKybyNtGIIwcGW/XYlOidrv2H9FtbvQZmY/ZAvcVprry8cdbVY5MxFwFKmiQRpAPqy1agSsM6BfU6aeftv9PBAhETNFcf06iLtEU4MIYT5jGjCeiT4PwzDO2YA/E6XZjMvTpI3L66fHfI9EJzw0ik1xJDxObLRAOTKNjznjCiHwMVh5CRs8/32oFcBiuMIAQygV1/P/i/n/y3g379lK1cxX096WXxn6HFtC0qch99yUXBsANH891MGZIcSZt/oQTrHAg38EF4cxB3EPeagjUDvAIEz9YaRP5xV0XEnHxWZSQ/0ptViYITzYSeiB0WG28egZBoNAqWgXaT66B9vL7urHNMdu2ElGVlpaGO84PJgiCOqxmlM/vRyBGg42kOxK0/CBng/yOTLnLt5lAILOM5A8X2IGJ6hoC9+UfSNMolWmYyFRBwiZFmEDkuI2J7QYB9+yz1j4lwIlJA/CNJ/OPE+CEZEeNxTuSi3YrbDV2ql/IQuqSUJOL4P5cNyFJcmGBMChdOr6PM63FZBskfSHIGb8e8LYxl4IC0fJKIDBhvMg5v01IvEEqdcqV/lF8yggU3DxBwSoumCBk3IUZPPi78YbcfbfN6gOJKjdvS9UbBPmz8XnnqkDALYrw9i8GUSIN6QdXIGS6RHqQizQb5iLEql8gYA5lkRvZOhzCPfeINGsWr/rjSkkl6dyahQwSV51MtVqEef3at9/a6soQUngPPBD9RiAPGxwHfmQIL/zFV11VJAwSDZJcAIw8WoIfcCHpBFN5RGU2QZ+7kYznnJM8cMmPoBoIQfxUcYCW6gqZMKHmaKr++gip4BKMaKQuJ5RXAqFVK5Ebboj/nqIOFCehERNtTEy8D66/NupLRcNMVCYM+6FK+zuM2gJHHmnzLbxoOaLNECD5BIq/BvVBz56pSThyDAgOophJya2whtAPbj4C0ayTJqV28V53nUiPHvEaByttJkF9BZfc7NQpuOgKmpq3qlP/AjO5WzfrTkwGTFFXaGM6ZaNQzVYzGRK91QiCEe0gmfqDFoF54NprxCWgdWQSY8bYv64mQ7zDr79K3gN+BI4Dpt4PTB4GMiz33Ll28jDpMbGIuUf44nlhZYPUC3pjUTZABSomtl/1p6goZBtFSPA0eYVHEOAQwSRxBQkMAsfQ/jKtIXAPFGXxQHsRRARBTtEZxi0rPF4dLxQfjZM2RbjicqTNaVcKynBO2p5CrRwXlPQEaZ1FTTT7AiFRokYq6ZgMvIwVm9JfBac4oLIQ9jQrpT8qEtU1CpmV62BQopW5L5mhMlKY8lvJqi5nGnhGWEXd0nRMfl7EyxYGTLio1bTDgvJ9foEAIKNdkhzB5fELfrMHlzZuRrYwYHEikjeLyL7+lw33DzxCJv2xpEF72gxpzB4QElHcO646zeoWhY127fMo9nrQddzvcDOiIaQb5ennbsJcL+r9uu3HuzMI8013RSRjFhPPtbmLe+8e0FbCvKnLnztCKbZ0Fy0C97LMU2VfIIQlgqKCEGdX/U0H1FGgY1HTiBjz27G87rs4hBufoww013yK0nZBtn3Qd7hUaTeEYJTX2WP3+nNPgoRVlGcNuregc+Ih4vV5TzwRnCEZBALEevWy9QiDSOuw1w4D7o8UfN7RkUz4eQsjcS4QutRPDGuaYNYRf5CJmomp5PS/ZZNEymftCqj3+E6LY3syEChM6fIRFBQhbj2ZjY/tS+6Dm2LNOalQjArGSo5Q8EcekpuOsIgCbG0GIcKEQcAzU7w0VWSdN2jOPNNqKJ7LjUKfqPhhAJnFCz9QTb2XpqDhJGsb1G/IUlRWiEN4A45DK4LNxq5llWWwY575+/CAA6xgwS72Urcp7OoVaU0Foj7hgjwhwvEU401G1nJNMktpY1Rz6k8wkbHLMWeoNUBtAez3ZLEqqOqYHFwTwhrBG/QylKhaK/dFH9CWBLAxxhh7EKS0oast8xIfSGyIRp4HEp17QqNgbBMNS5vwwpytgz/z692Obs1CMH++rZOYrFQaxU79tQRHjjSmZs2i3ylY6QcvMPHX4NNNt8LYVuSXQDj00NjJ7eHnn4sq0ga9mJUXWvCmm65djalRo+g3ire6dRBB69Y6OHRTgZAXG+WmE2H8eFtMk1e6pSqhTYnzIPTqpQNDt4IVCNnnELIBSBnyIhKRWF69BEgz7DEelXBWSm/BaVB4Iij8GVIxV6owKRRbH3/mp0AApIgSMZiJ4iQIDQhLLzhJoShQgVAyb28dNxiuGHzVxYl1eOUVy7KrMFAoJH81BD9INCIsN+wLPHFRTZ5s3/mAW0ehUOS5yRAE/LjEszdqZItskCBFODK+coQA/lwy/6hkuz3kJygUKhAUCoVyCAqFIutQgaBQKFQgKBQKFQgKhUIFgkKhUIGgUChUICgUChUICoVCBYJCoVCBoFAoVCAoFIrsgVwGKmeW1qZQKAoeGxEEi7ds5bQtFIqCx8r/CjAAVYxYofEJKfkAAAAASUVORK5CYII=\", t.LicenseBannerExpired = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxRTNGMzgyRkExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxRTNGMzgyRUExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjNhMzUwODIzLTljMDYtNGFhOS1iOGEzLTNkOTE4ZGY3MzQ5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiZjFjMDMxMi02MTMwLWE4NDgtYWM1Zi1iMTljOTliOGVjMDIiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4BTPUAAAAjtklEQVR42uxdB5wURb7+JmxO7LLAElUUAyoSRJBwBkBQQRQRhTOhGJ4YTj15BvBUDlH0DlEBlVMQFT3E9O4ZT1Gf+QyYs+SFBZbNeXemXn1d3Ts9PT2zM7uzsCv9/X7NLD3d1VXVVf/w/f9V4xLARgBZcODAwb6OUpcUCPXyD6/TFw4c7PNocMt/Kpx+cODAAWWB2+kDBw4cGHAEggMHDhyB4MCBA0cgOHDgwBEIDhw4cASCAwcOHIHgwIEDRyA4cOCghXAyFB00D0lJQOfOQG0t4HJJ1SJ1S2EhUF/v9I0jEBzsczjxROCJJ4DqaiUQPB7g5JOBL790+sYRCL9T5OQAHTsCCQlAQwNQVKS0oAMgM1P1jRkpKfuYw+1WwlAI9TfHiCMQfmc48khg6lRg4EDg0EOBLl2AxERlCu/cCXz/vdKCTz0FfPPNvttPdq6Bz7fvtH/AAGDZsmCBcPvtwEsvOQLhd4FDDgFuugk46ywgNdXeZ+7ZUx1jxwJXXQW8+CJwxx3ATz85/bevITsbGDQo+BzHRns3epw3KzFzJvD118AFF9gLAzvwumnTgK++Aq6+2ulDx0JSfIojENo5Fi4EHnxQuQXhwBcdzhym5bBokSrDgQOHQ2jHuO8+4JprQs8zlPbss8D//i+wcSNQUqIERrduwODBimPo2zfUyqirA667zhlVDtovBFAsFC2ybx1nnils8fzzQhx1VOR7ExOFuPpqIUpLQ+8/77x9o/8mTQpt+zHH7DvjZ/jw0PZfdFF7b1fxvukydOoELF0aen72bGDSJMULRAItgfvvB4YMAX7+Ofg7ltu1q/19jNWTe8jKAtLTI7spduD1vK9DB/XpjvPro/vD+vGzObBzq1hnlhnvkKRRLg/2a2uAEQTjGVbYhZ9pScajTcnJ6tm/S5eBTOyYMYDf3wKmQw78jz4C3n03PnWim0ChYAZDRvPmxVbOjz8CEyequnGSEmlpwOWXA3/5i2Ki//AH4LDD1LHffiq3gS+dQqW0FFi/HvjsM+C114Affggun24J+48REN5Pl4Xxf04u8ho7digy9IMPgH/9C6ipia3+zDQ85RQVaj3iCFU3CgO6TMXFwObNKszK4513mi6fderRAzjpJODww4GDDlJhW7aXMfpdu4B164BPPgFeeCG2icJ+ZJnsiwMOUP3NcqnXOBHp2jEc/P77qj9jBSfh0UerOh94INC7N5CXB+TmqnH35JOqDhyLFRWqv6ygK0llwDFgHrsMVz/+uL3APOYY4Pjj1Xvu1UvdS8KS/f/ddyq0vXatGidm8F2NGydnsJzCL78M7N7dTlyGW28VccEjjzT9rOxsIUaOFGLOHCFWrRLirbeEePttIdauFWLNGlWXs84SYuvW4LJ5TUvaeMYZweUVFgqxerUQmzZF377KSiGWLhViwAAhZs0S4tNP1blo8fPPQlxySXT1TU8X4r77hMjPj638m24K7zL4/UJ8/bUQu3ZFV95XXwkxZUrTdb3iCiF+/DH6erIer70mxLBhTZfdo4cQ06cL8eKLqn3hwO9vv735Y7e4WIikpOBn5+WpMRrt/azDEUeoe489VohXXhHi0UeFWLBAiGeeEWLQoLi4DK0vEK65Jj4C4a67wj/j4IOFmDdPiPXrYy+XAygevu8774g2gYcfjlzP/v2F+Oab5pX92WeROYTm4LrrItf3hReaV25dnRImdmVyMq5YIUR5eXRlUZlcf33z2/jdd4p3Mp7ftasQ338fezmzZ6v777xTiOXLhXj5ZSHmzhXi8suVYEhNbQccAn3dePmMVtBkvOce4D//AW6+WZmSseL//k/d31K0lbDjpZcCt95q/x1dELoXduZuNIiXWWrG3/6mTO1woOkcjsehaxPOFWW6+eLFwHnnhX7HDFTmnEQ7NmmWm92AWEHXzMwJPPOMcgFjRWUlkJGh3sO//62yJUeOBP7xD6Cqqnnjf49zCPRxX3ml6TxvyicSNf37h2aAEfS3zSCh9/DDwFFHtax+b70Vn3ZSqNCHtpJnbDf9ZmYzbtum/F36iLyOawHYjqFDI5f9yy/Ahx8qP5n+KH1Y+vrduyv/87jjQvkQhky/+CJYoK5caU+Qffqp8kNZvkGWkf/gAKPPPnq04gKsaxfCYcsW1eZNm9R7o+/MgUx/ecSI0Os5cTlGrO+YIAHLsfHqq4ojYB15lJcrYcB+pM/PcUDBYuWGHnlE9d1vvwXOReJC6LOzv8mfsC84CclJ8B6Sl+x71ofPJFdkxpo1ih8xT34KEpZljP+zz1ZchBW8l/wH20ZBR2HFZxx8sOIKyB+xL1gP8gfkNshL8FqGuvmc7dt/h2HH994LNZV++02I3NzANaedpkzCcGhoEOKHH4R49VUhHntMiGXLlA9GU7miIvjac86JT71pEtKHNqO2VoiJE4PNRevh9ao61NeHtoNm7dChihuJ9Oy//jX03pUrQ31xK2pqVKgsUv14dOsmxMUXK1PVuNbOZXj8cSFGjBCic2f7ctxuIcaPt3ftbrjB/npyKn37RvcOundXvJEV9LXN17FPrbj3XvUc8ivRPOvAA0PL4Lhs6j76/tax2lSomi4OuQ5yVfz/tGlCvPuu4mB4L10S47s2zyHEcpA4tPMF+QKNa8aNCy8MduwQYv58FSMO94x+/RQ5tmFDfAUCj/ffD65PdbUQPXtGd+9ttzVvgBnHBx8E37t5c2BwcxJTQFqF1ahRsbfR5QovEA45JLoyeF1ZWfC9X3wRn3fQsaMaB2aQ6MzKiiwQTjkltueQvLaCQjPSPQkJQvzyS/A9L73UvHYef7wS0OTOIo33disQZsywn+SXXhq4Zv/9wxNBDz6oNFm0z6PFsXBh/ASCx6MGtVUDk8SLVrtZ27ZoUfTPt7MAjAQruyQaRjTinZg0eHD095MZN4OWG99vPN4FlYIVo0dHFgjUuq0tEDIzQyNPS5Y4iUm2sdglS0LPcwMO+oAGli8PJYLom114IXDllcpHjxb0D6+9FnjuufglO7WE1MnPD/UBrf5wJJh9ZLP/TZxwQuh3q1a1TiJPtKC/bAZ9YOYZxANPPx16jv743gb5CPr8ZjARbvjwNpOzt/fXMpAc48QnK2wGk3T+678C/58+XRFodskgJGSai3ht+UXm3khOau5kspJdsWQyUr7bJXQRVuKVgodk794Ek5Ts2PhowGXGTBqiwGOiFscOow6ccCRtWQ77wyygYhGurQWSq8xs7dMncI5k7dtvK8KXyo9k7F7chm7vCwRmgJFJNYMhlDPOUC+YIJPMzD8r/vu/WyYM4onLLmu5drVq2FhSk+20syEk9t8/1BqxY/T3tLa0CxWGgxEqZDYhN68h0x4OtBqtAqG56djxBlPeTz01tN0XX6wOCgRmJr7xhjr2MPauy3D99cDkyaHnufmIedMRpsIy7deMjz8GFixoGy+ZKyApwOINO60fC4xQlzXUyJBdW9CWVtjlFNAKYI4Hw7o33qhCoJGEgZE3YBWmLUmdjyc4ySONW+YWcF68/roKgbLNtIZ+9wKBsfd777WPST/2WPC5888PvY4d1RZAk5VWTmstsInHpLO6HrGueWgNRMM30Cr4/HO1tJx5DL8X0LJlIl1TG6rQDZ0/X1kNkZK32r3LwAQXZmtZwUQa6/4EJJuspAslZ7wWOrUErNvq1aEuT1uD1dLYSyvpYuaW/vlPezKwoECtSDWSiMrKAisFaT1wIjEByN2GF/NyonNBGl1NZhtGSrCjhUASmNxCK7vIe0cgUBhYXQD6tHQfrKYksxZJvJjBrLrWAlfrkaBiRmAk0I154IFQYWD1XfcmDKvFSlK1h92RqUX79Qs+x5Td225Tk4JCIZKgpgvHFYxtGd9+q9xjgtvaM9rGepMnsRNm3NiXgpBC8HfjMsyapfxAK5gGumFD6HkuR7WCZmRrgam6772nXJJhw5TG4cTi4GJdTj9daS76eFZhQN6jrfiqZoHAdFszWhIN2SOOrByW55wTfI4kJJdqk0+IJAwILkFuD1aQGSQS77pLjTmmNnPHLitoBbXy/p171kIgu3r33aHnec7OhSCsoShqO+va8HiCa9DJytOkI5iXT+uFTDDzycP5sjT9aLraxcD3tp/+669K+xhg2I6TJh65760BWo+01MxgDkq0i9CMNJv2CFrIXIDGg9yJddEc9xaha8RIXLsWCNS0VrKQ4GIQbn8eDlZCjOa8VeM15YtOmaI+I8V3OXkolZmwRHfBGJDG1uvhwB9v4eISLjRhWKwtgouCuEO0+V2QzW6rAoEWjDUEyc1oogWtNK/X3lqKt7CNxNW0FCTYjz0W+OMfg11autB21nS7EgjMCLRqe+74Q94gUkdaGXG+6FhiyvSXqV2iGRBccUfTNJpruSyXPh2XX3M1G8GIQ1uCMWi5VNaKSy5R7W2LYN9S8Js5AO5gFItAsQqEeG+Rbhc2bY1fbmLSklkgcDzHuvVem+MQ6BtZswyp5bn92Natke+luWvV+OH2LAynLYwJGwnMIKN1wIw2s1tAq4JWADPr6E4wqkB+gcu0SQiZy25L/IEZZOOtvAu5EPNAi1qF7AEdwjFBZWEGFUe0JKGVfzDebzzB8UuhFcm9tQPzKmKZ0LQQzGAOSSwWcpsTCMzVJmNsBScW05NpAkU67CYazd14g/4pn8MQp3m9BDde5eTnM+mHM5xFziMaIdOW/FIKZSuYP0HhFmmfAw5eptqSU7HbmLY1QE37/PPB57jfIKNLkd49Bfmf/gTccEPweUYn4rXvhQGa7NYNY7g5DetpBaMehhDg/pUU0Ew+skbazKDw4zUXXRTq/rWiq9f64p7EiB1IMFJLRTLPjRCe1V+jtWFHTrYEBqvLcKIZ3PyUxGJ7B0N13GSEv9BsBic6CVHjNygMl4mDmAOWacIUhGT+mSeyp37QlP4zJ7fZPWRojpu58PcTmaxD14IWHOtKwpdts1sgRe6KVl48QQKZSoRWrgEKTkaoKGhp5XDccmckclDkl2hRsP8YnWJS3ty5apEX20KLiH1PC4yWBjdFMRPBZiHempZoqy9/tm4IEQ9wU4nevaN7PpecNrXX4rp16tq0NCG2bw+c533WzTEjHTNnNn/5MzcDse51+Nxz0T977NjQdnHNvHWvAG6m0Vy88Ub8fpeB+w9YwSXw5mu4aWxLwT7NyGh6g5RYlz/zGDIkujpwyTM3wgn37Gjx5puB/Sja7fLn1sgWowZj6me8YCxMojVjzhun1rQuV42lrWTKY4mHt4QZt3uO9RxNXMbySVQ1B2Zuxe69xtJWu2utZfLXlWk2N5e9p+alBreu3Yjm2dGAETKre2IHWgbGu2yuhcW2MFLUyuHU1hcILdmcMhK4MowmZEtBtp2mH1NkyReYCUKarbHAGv3gIItlUlujFLFsUGu3UtCOAOQ+h+w3Cj+SpNGAeRjcV9DMIUT7vFjqa0e2/f3vavEYl8g3lZBkgNzUn/+s+CC7nBW7ejaXuafpT3LWvH+lHSdimPnkD0iQMvWebkdT4B4fXAzFtjSVPRsHuLRtk4DWS10bNUr5TC0J+5AU42akVj6C5ApZWA7ySJOMRIx18xK+DJJAzDrkxGMiiDlVloP/iitiqycX43DDU/q1FAa0LkiEReu/UpsxgsJQK7UxU1uj1eb0oZn2yoQVahEKYoZ6m5pETHQhacpkLPqunKjGD4XQDyZ5RoFp/cl78gunnaa0ryH4+OMrdr9oZAcSxnw272V9OUnZ1khpuewbYzxxg1luBGv0MycLiV5GU5j1FwmMJI0fr+rMyUoCj6sQW5rwNnasmrhULnx/7BtGNxj25UavVnAXbF7Pscn2cByyTryPbWFfkPexRlxaDyXt67cdP/nE3keMxCdwLz3zxqr8mxuQ9ukT4A3oG5uxe7cQXbrse7936Rz7+lHcvgRCuD0Vt21TJJfdPZzw3G+RG7heeWWw8CDpZkeyxWcHW+dwjnYnEFrfZYg3GKoM97uADK0tWqTM/0jkC1dQ0l2YMSOUTKLvyR8PadIVkgf3RKmGAwd7BtkMj8vj9dZzGdqfQCAmTFCTPxwRRAKMB/1e+pbkL/jDFkwK4bpzux/KIBi5MBY1NQXSGXNJuJGAdMaqg9aO1pF3kccseSxsPYHgbZedw40lmNjETSntdjrmenIe0YIkDpNg7BZfhQOXWDBRjUSx1RhJ0l8gI5ZMebeLxvFcov5ZqwsVl+X7BFMciOU0hHlWuPLr9HugP8ur/99Y48WyPPp3RpvsymmqHi69HuFQr99jV0+h1yvRpm0uvV9q9e+MNvj0thn3J+iHXz8vIvSN0Otjfi/mOvj057ksZQubNtksZ9DKCBe7M/e90RZzuT7T93bvIbn1LVJvu5WYb76p2HH+bBmjD5E26IwELlfmbyFa10w0K2Yj368clNWlLvj8LqQm+1XU0cZ74XVVpW7tMzXFrzwXoQ9qDpZMjfNFaZlbC5tnZvmVHVemDxp90FXJZ/nls6yhdb8sKzlRyG5RD6+tdKG23oXMNL9663oZfjlIqyrd2nhjPRqL8esDMF3+KQVfubyGdczoIL/I0uvhU2VobSl2a9V3WeYewXp4vcK2H3h/Q50L1eUuuC1toNfndgvZj0K7bnehR7umQ4YPrkR98uv9W77bjZpaF3Lkdx59Alv7hpG/JFmXxFyh7q3U+9GoQ5lLq2dKsl5Xeb6+xoWaskDd2K/8O62TXzW2LLjRbIfPF/w+hP5PkuV91De4Gu9l3bR3LA1ZFEVQJHAEQngwdMjfVlixQm3ZzjBWNKviGMZhHPihh5qfpGMHOYGqitw4e3YePvshGS//PR+DhtWqF2y5buc2L86R123b5cHaJfnofoCcmeW6VkuRbuIrqbj3qWx8/E0KEuQgHTW4CpeeUYoxo6saB7KQg3rq7K74cVOCNriqqt2NgmJnsQeP3bITF06XPo28Zd7DOVj6bAecObocD926U715OZl++i4RZ9+Sh6w0gTce2IqUDKE0ZIr6fs2adPxtVTa+/SUJaVJgjBlahavOKsExw2rUZJBtKS7w4PRZXVFc7kZZpQe1cmJqwobCscaNp+cVYPypFZqAC0Fn4OVnU3HZXV3QJbsBO4q9MCTL7hIPBh5ag3eW5iOlpx+PP5WJeY/mYPTQSjw1dwe8nLgZwD33Z2vnxx5bhRV3FCAlSU34c2/Lw7e/JWlR68oqN+pkF/fM8+Ey2Y+XTyuBO1W3imQZb/07BefKvjx1ZAVWLNih9RmF4T9XZ2CO7Lv0FIFdRR7Zz3Liyj6adlIZ/iTL6NTDp/pB9ledFAaXzOuCz35MlsJXtr3KrfVhgxQQZRUu3H/9Llx+eamm5Rcsy8bK1zNBMVpSJvtMvr/jBlbjxvOLcOxIWakKXWi7HIEQO7itFHdcYuyXO84wn4AxXsatyTMwrs4sPSbifP+92rG5NRaI6JNg2y4vduxM0DQyPPbXcZBu3enFlh1eOWB0TcVr5SB97IlMXHxHVww+shor7y5AZYkbc5Z2xJq30vHMnQU4+8xyNWAlNsv7f9mSiJunF2HggFolLDjOpcYbekRNo/DYXepBoRQST76agQkjKnHq6ZVaGazjpoIEZGf4Ne3X6MpILfvX+3MwZ0lnnDy8HCv/XoCCjR7MeSQXL76ThhcWbMfok6q0ieeTbf51awKqa9246cIiHHRQvTboWRy15YCDaxrrGwL+fqoUZDt2JqJ393osmbFTPb9O1S0n06cJRN5/wfgyLPufTKx+PQsTRlbi3KvKkf+hFw+u7iAtKS9mjC9FSiehJqjEVvbNpkTceOFuDB5cC5fs58efy8TM+XnyfAIW3rJL9bnsnyopuAqLE1Cw2xMw+eVnmZzUG7ck4/jBFbj9mt3ajPnog2Tc+Wgu3v8qBS/ctx05Wb7Ge7bKd//T+kTcetluHDWoVuOY2K8NcsIPOkwXolLo75ZC4NcNiZh6Shkmn14Bnzx/8wO5GDZ9P6yatw1Tp5QrBeF3BELzQS6AW5u9/vreeb6+Foua1JMoD7e9u2Bcly6vy0j1K3NUKC2z6acEzFnWET3y6vDc/G3oOaJBm6QpsrzJN/TEgieyMeWUcrjcAXOcrsnEP1Ri8KQaRREbJFSJrgFT1HXpctLTrF74dAecemKlpgH5bNYh3ewuSKG07j9JmLu8I/ofWo1/ysmfcZi/0fydOb8nFj6TjdHjqrS6sS2ae+L1Y+pJFbLO9Y2TUiuUdaoK41vLArUJL/84UAqESVMrlHVSrV9PLclcJ/lqOx7kw7xLd+PMWd2x/F9ZOPf8crzwdho25yfjojOKMObkKqVZRaBvkpL8GC8F4PCza7SyRh5WjS9/ScQTr2dgxsQyHH5UrXa918OX4lfuiQjULdGr/nPIfnWYdEGFNkEnDa/Az5sT8T/vpOPN91IxZVq5ei6fmaTacsZxFeg/RZZdYHofpbqLkajcB1437MgaTJpWoQnAfvvXYsRlvTBrcS6G9qvBARSslXueu3TQViA1xyffJmkWxrhhVejZRwqDjfJ8PjSX4frzC/HHseUQVaGmpOazGodXn1AVwW+4Vg66gYfW4cOvU7B8TabGSdBHtwO1X121CxP+UIGM7nIWrFcTk4Lniik7cZo0ra3+c2M93KZ6VJp89Sg4mKAD+iQy/Gn596SJFTh9VBnWfpaChX/rgMdfyUS3LrXS1C4OELmmuvCgdQT+yt8m6aJLl2Fk/xrp2rjx8xZvgFBtQtLT4jLKoMDq27tWa1RBkddWrQa9D48uEC3vg9+xHny/2CyFTv96TBlTjq3bEvDWf1IiE7WOhbBvhJYKOXhJNEqt38ikywnVIcuPe2/apSZHTYDhJmnplccqqfE+35CkfVchzdx+fWoxZmRVkMlZX+vB5FHl2K9LMuatyMF5E8uRlea3TdnQJpEUFknSMtGep0/I7l0bsPj2ner51YEIRYIcSQ1yjjzyQia6f9qgTcxyWY8RR1Vj6OAaVUaE1BCX1NCbt3vx8JIszV0hP0L3a9IJFcjr5lMTvUb59bOlW/LFT9Jsf6ojyitdmD+zEH3616mojw0xSYtNI0JJksqqr89PkJof6Jztt48U2AUPSAbq20YUfunBm5+mIiurHkMOrw7S4h5aSylCc80+3pCsfVctrbIjD6zDqKFV4ftAqChEr84qzFAkXQqHVHSAujq3NolJRDUOHiP8ZhMW9MhJS3OXfr14Wy0k27ozAZecXoIx9PGrg1Vw99wGTL6iEL3POACLn+qA808tC13851LWBIRL832DNLgRlrOESWn2V0qLghPBEDCbdyTgjssKMfS4mkDoMJwslG0gp3LX49kqAifbT27lmMNrkNfbFwgFSqE0aEgtThxUhaffyECPzg3440nlgUnlCtbSjIxsLkjA5p/r4ZYT7qEns/DhujRMOrEMxwzQuY3UyO8kNa1Bs5hGnNRTE9r5BR6UlHuwfM4ODDlelrErUIYRFXnu7XSItYZw9eLC8aUYNaIqsgCS9a/3qQa499Km0Y5AaGPwelU4ixM9JE6eobQITKt5GV0g+bZ41i6cPK5SmdgGSvT7TG+ZmueA4+oxWZqmc5fnoHfPOuRm+ZQACqqHYYGYZrFfj4KkK9IPpp28qAVprayeX4CjaRGYVxzvbrrdPikIBx1Wi9XztitNbhZ+paZ+kH3w47pEfP5DsjbZd0iTffXaDFx5cEmIRmXdGXG4eUkuau9zycmmLjl/Qgnu/FMhElJFUBvCwS/7hjzLEQfXagIhJ9WLd79MwUffJmPsCZVITQj0EfuxqNSNZ2Q7xpxapYRFo8/WtMuUoPc3w9aOQNjXISdcTqYfbq9ivRsTieQEKdrlwZOrMqSZ68OUE8vhtviXGilmJNEYk9dGG1VVu7Rr/jKjCG99lop7nsiW1oAbycn+IE2lMeecl7XuQGKONEDyN3ux6rUM9OlVj9NPrAjhBkLq4YueKXcZSVAJprqbk6CSVVm3PpKDb35LxFWTSvDvL9K0NowdUoU+/eqCQry0Muj73zJ9N4YfW4OGUuYw+HF43zrl6pREx23U1Hgx8JAyLH1Ud5W2AGdf1xX3rMhF/4NqMe288hDBEu37sLqMjFJQMGSm+fbKEHRIxdaa20INPs3vpBXMzywEMuDsIN3H/n3qNL/+g69TUFIgXw/3k+0OfP1LIq5ZkIcFT2YHMhxNijNN+q1aMlO6fnTQtbllMmoJUFJjH3FMLa6QE+q9dSla/kCCVwRpqoGaNhR4X2rChlJ5ohu0urz/VTJmLeqGh1/MUhaLyVcnMlJt6pEY2V0ImkTpuiXEz0z9MNoq/37t1TQ8+2YGBh5aiwVzCqW7UIbN+Um4e2V2wIIx1Ynh3aOl5TFkdA2Gy+Pwo+vUdSWxjH6hWUDgfsDrFak44BDlw2zZlRBK/gnL+8jQ+yHZ8j4EVFSjo+rb4i1uvPZRGtLSfTj2yOoAh+RYCO1cGPiVD7jupyQ0pKvBR22VJM3XPj3qGtdTMX4ftJu3tDD79q/FzRcU4YZFXTD5pm54YPZO1FVJLfdQrnbJhaeUwZ2BRiKLgoeZgt/8moisj32Nmoqma88uDcjp5GusEwewX6AxI/LKqSV4dm06NuQnonuX+qB6HDe8GteeU4KFT+Xiglu6YPa1RSjc6sHt/+ioqe3zx5WpCWUa4PT5P/8xCTV6dEF7jDR99+9aj8zM8ASeIUyKpTvz3eeJjXkIbANN/gN71MOTLlCV78LcFTmyUDcukj558v4CF5xWhuUvZ+LRlzIx+bhyjJtUpcKUev+y3cVlbmW6l4ZXhVodhCtku0JVN9N5PSWcZGajEBPBioDXfC3fR9pHfi3kKoRLq0v3zg3I7egLum7Tdi++ky6Qv8yFK+/shF83JmPBNTvQf2Bd+NwNRyC0N7i0vIGr7u2kCQK+eA7Kw3vX4uNHtyI9RzH7JOxIIjWy/A1qsP15RrEWz176fBYGTO6l5TP06VWHRTcU4OpzS4KIQpduas95uCMaFgdSYYuLPXj01h246GKVGWf4pJygRspt3iE+XDWlBFct6CLNYnewryvdg7uvLUQn6aIseykL/U/rpfm3fXvXYeXc7Zg6sVxNsCQ1acgfMB135oJAmzmJ6PqsuWs7TpsQJlPRpU8OOau+/DkRIy8L/ChOcYkH/Q+rwUf/2ApPmsC992fjwy9SccLQSpw3oVzT2D37NmD6hDLMWdwJtyzLRb8jtqFbjwZtMlGgkGPxC0Rm7BvrgGAuxaX3l9mnF6rN+3dVvszH3ySjdpsU9h1E47oWWgc3Lc6F737VDyyzvMKFB2ftxMyZ6n2Ql0iS1zE6tEIKNGZ3HiTdsOW3bcOFZ5dFXv/RmiO3Xa52bAu4WB43Inhxk742gJl/tXWuIPfAp+fR9+5WD3eCyp3fKLUDhQI1YAITVfwm4k6am2Wb3di4LUFjrqnts3r6lWVAwk3P4d+wTT2LQsEcPqS27t7Zh2w5oVlmgfRNC+UEy+uoaymfXob8ZJKNy6U0cdCailR1FK73IF/eT7eC2j61mwisqZBl+Opdsh5ebdIYefvGB+vEumdkhLEQpEoqLXFrEQaGLs0aukH+rVkI3eu1vv3+t0TUybYeIP+f1VEPhyao9Qa/5qt+OCBPficFLuvGvqGpH/H5UG0ol27Tpu0Jmu/eq1uDar9HCaV8WTeun+iRp5+Xz6yRwo/ZmQz5HiTfqVe6SgyVMnOUQtBteh9Ct9C65vqQk6Pex45dHhSVq7UZWiajPN1bPjetl7IqQtKW+Tfdttvl8VCrjeoSRyDEUyDoC2I0n9G6qMkI2RnpqB79OiODzbr6zqN8VU04CJ3Vr0boopdMm2cZJnGlfo9LaXytvCoEEoWMFYQZep2MpdzWeqQhQCzW6mX6TXyIx+Tr261YrNDr77InUjXfOsOGdHPrWrJMvy5T74+agMukPS9Zr6Nf719j8VembgNXIBC2tKcIVLkZej3LTG3RF3hp95cjEAI26lyvn/eZ3n2ChSswEpSs78PMKRirUysREj7dkwLBcRmai3T9BaVGR5g1wi7mHcUP/jQO2FiQqBOaZmTphx2So6xHrL9YF23GXUKYNqTaXJcRQxtyYqhrgj5Z7c6nhzmf2oL3Ee07pkDIC1MHh0NoA/hYHvPQZAaeAwdxoqWUIP7Q4RAcOHCwZ1Di5CE4cOAgyEKod1wHBw4cSDRQEHDxZZbTFw4c7PMo/X8BBgB5OBYtILpQMAAAAABJRU5ErkJggg==\", t.LicenseBannerDevelopment = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMDlCNDkzMEExRjQxMUU3OEEzQ0UxQUI2NDlFMzk5RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyMDlCNDkyRkExRjQxMUU3OEEzQ0UxQUI2NDlFMzk5RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOmNhMjU0YmI0LWZlMjEtNDM3NC05ZWE5LWNkZmFiY2RkZTA3ZiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiMGM4Y2MwNS0zN2M5LTY0NDEtYThmNC0zOTU0ZDM1MjY3ZTEiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7DNCRNAAAbLUlEQVR42uydCfxdwxXHT/5C1JaEqn3fGhKUWlpLba19J9Yi9qJKQ22xiyWaBrXFltKorQ1F06rUFhFViqKNpUQiqCIJUUvC9P81PX1z585977737vv/3/v/5/f5XPJ/9965c+fOnDnnd86Z6WFEJotIb4mIiOjumNmjXSDMbv9Hz9gWERHdHnPa2v8zK7ZDREQEsqAttkFERIQiCoSIiIgoECIiIqJAiIiIiAIhIiIiCoSIiIgoECIiIqJAiIiIiAIhIiIiCoSIiIgoECIiIhqHmNQUURtWWklkr71EZs0S6dGjvSe1d6XRo0X+9a/YNlEgRHQ7rLeeyNChyd8mTowCIQqELoh55xVZe22RddYRWWop+/enn4q89ZbIX/4i8uyzIh9/3L3baM6c9G+ff9593n+RRUQ23bTd6G63ur/4QmSuuWzfeP31KBC6DFZdVWT//UX22Udk+eWtGhwaCFOnWvX4lltE/vGP7tlWDAIfxnSf919jDZExY5K/HX64yLXXtvRrRVLxy1Zob4bzzxd5+mmR008XWXnlsDD4UoS2/77CCva6Z56x9809d2zD7gZ4kzy/RYHQYlhySZE//UnklFNE5puvunvnmcfeN26cyDLLxEHS3TWkLmAydW+TARPh4YdFFl88fB578O9/F3n3XZFevez1sOsLLpi8DlvyySft/198MQ6WiCgQWg7zz29twJAwuPtuawsy83/ySVIlXGUVkX33tfbiEkuUzn3tayK//rXIt78t8uGHsWdFRJOhpXD55ZYYcvHOOyI77CCy884i996bFAYA0uyll0TOOkvkG98Quemm5Pn+/UVuuCH2qu6Azz5L/zZ7dtQQKoucNkvEhWyuvMClA7tflI22ySYiBx2U/G3KFJHttxd5/vl8ZeBvP/BAkZkzRX74w9Lve+xhTYdHHin9BumIZoELs3dvka98xXYeNAk8Fn/7W/ln9e1rTZXFFhNZYAHrBkVY/fvf1kSZNq2+9kDTwRzq08fWlc7Oe+FmRQDmxfvvl/6N5gX5inuO+vLtOP/CC9YEqxWUufTSIgstZMtFSNOOb7xRnMeHdoATWnRRkYUXthPFhAkl0pC+yDf0QX2+HFU9k/2fvh9y07r9e801LZ9FuVxL+7/8sn2vDgTLsE+nCRr2hAMOEDnttPoEAo16zTUiw4fnux4b/6tftYMH25/BR0QdH5bO8/vfi2yzTVKyb7ihyF//Wlv9/PLGjhU55hj7G0IGrwXCgPr4IJ7hlVdEfvc7q7UwuOkU1Gfrra3w4l46S8ibgWBCiI0aJXLzzfnrTGfH9MHFutxyYdOJTkmHROjceac1od5+257bbTeR3/wmef2RR9oBtOuudtBSps+8U95zz4lceaXVwvLU83vfE9lpJ5F+/Ww7IGR88F0nTxYZP95qaU89lb8tENa09+abW60RwctzlWS+7z6R224T+clP7N/EpCCkl102WQ5tQx+DbHb7Lu23++5pDeLrXxc57jg7gay4ou2rvsbKhHHPPSJ33GH5LBU4TDx8NyYYyr/xxiJG6wxBIBgrZxtznHKKKQSXX17+OQstZMygQcaMHGnM888b8+mnyfs//9z+ftddxnzySfLcuefW945LLWXMrFnJMv3n58HbbxtzySXGPPVUbW10//3GrLZa5fruvbcxU6dWX/6995bK2G23+r/pmDHG9O1bvq7XXltb2ZddZsx882WX26+fMSecYMy4ccZ88UX5sm67zZghQ2p/zzffNKZXr+TzDznEmA8/zF8G/Xevvey9hx1mzGOPGXPllcYMHmzM7bfb8uofr9MbLxCOO64YgXDRReHyF1nEmLPOMua112or9513KnfKPMeIEaYpgFBZfvnsel54Ye1lP/hgsQIBTJhgzAILZNf3pptqL/uhh9IDkWPAAGNmzsxfzt13G3PSSbXX4+WXjZlnntLzGdi14Iwz7PucfbYVZu+9Z+vGJDB8uDFLLFG3QGg8h1Bt0A62JjZVyCvgAzXspz+1UYW1AvV++vT63xOVEvWvEj74wKqOqKMhO7RS27z5psh//mPVUlRWv61QdzEdUEN9zgWu46STwmVjt2K6KA+AHY0aq3axkqrVgjpwuGq0C7wyV1xh+ZgQfDPrtdesOxgTgXJpR+qJWebjO98R+eUvRQYOTHMycBCV8NFH1tREJed5mAq0PeYv7+O7nzmHCdjmcPXUD9Vf2w7zLyuaket4Pzgc+jvv5NaTshlP1Av+CJOOOtCnOMe18D5NTSpie0LYlSNVFNjPQ4ZYu9sH8QIu4BN+/OP660f8QBGAAMKeZ0C6Awi7G6GD3czH4mPSkfmwfEA4gqOOsvaxDzojvAYE5QMPWPubTkCHQRBgr2+2mciwYXYAu4OMAeZ6PCANEZ4+GFyXXmrtVDoZ9dOODA8DmYnXZccdbSfFfs36lhCdRG8++qjI44+LvPqqfQcGEMKPesEz4KHxeabLLkvb/fAPDMbf/taGiVM2hCRCyxVOtAPCkbKPOCJZxp572onD5TtCHgLalvL//GdL8jIwVQjMmGHfGy6Be3kfOAfczC7wPv3qV0mBgOCgTZU/4Fv7ggSi9dRTbV/k/VSAwmPAE1D/XXaxbUh78r7rrmt5FYQb3i7q/c9/1t+PG24yVHOssopVeX1cc03yutGjy9ta99xjVbw99zRm882N2XRTY3bayZovN99szEcfla7n96Lq/8QTybrAVaywQuX7UJmfey79LnntwnXWSXMYjzySvOaGG9Lljx1rTO/e+Z7Rp49tx7nnzjYZ9tmncjltbda+93Hjjelre/So/hscc0y67IkTk9dsuGH6GniVap6z5prpMtTGr6aPvPGGNXsr3QdHttJKJf4DbuWcc4w5/3xjRo0yZsUVW4RDyHssuKAxr76abuSnn07agRApWbj6amPWWKPys5ZbzpiLL7YDFoKmqHeA6PEFwlpr5bt3++3T5Nbhh+d/9nXXJe/FRl5ySXtuscXSNvOLLxoz77y1v2tIIOQhNPWYNCl575QpYXu/lmP8+GTZn31WGkxZAmHgwOqesckm1QtwSE6f66I/1/KOtNUuuxiz444lIV2AQGiewCRUQnzMvr2NqoTaBogd+MEP0veijn/rW1ZlRP2qBNTkE0+06nqlGIC8QJ1GxU45dnMmvGBa+GsJ8E558Yc/JP/GHFG32BZbpG3mESPSgVf1AhdYXmAGuMCdiC++CPguOMwzVOyyxnMHBe36/aHWHBjGxF13WVOvwICo5hAIJAiFeAMGv+aXQ8bQiX2wKMd3v2tt1mpB/jq2VxGgQ0Nu1Qo+8HvvJX+rJtkKbiErUAZ713+Wz8l0NCZNSgfn1EMOuyCmI/R9OhuQjvARLoiMveSS+vpOgej8XAZmL1KIfVx8sSVoFFzTp0+6UxG80wy5AwTPhLwj1QRf+cFb1Xhoymkifog2ATydnYTlDwz1bJQDpNo3vymy8cZ2AEGuoZnR7hBxMO0qVGlLl9yDfGsG3H+/yFprJX/70Y9EDj7YBh8R5Mah5G63EgiEzOIW8sFsr1FhAKaV9fsSbGi7xfP97zdPIhHscdHqZDVuvpBAUG+Ab8rA0tcTOVoEqjFXiHocNEjkkEPsv/MIXr/tmmWtArwpDH6EmQs8D/zOgbcNwYEXA+9SB67O1bkmw623plU53C64ilwQYuuHdeJCK8plWC/OPFNk9dWl6aBxCH68QzMI0dAADQlAeCMWrjnnHDsx5NXC6hGujQShyGi15daexDzmvQntxu2MBtHlBcIZZ9jgGR9ISD+hA2LRn13wnTcD+Lj4n5sROgja2sKCotmB1kWORoisBcQEEC8AkYwJBN/kJlg1K5jIMJX9OIYQyHeAYyCOogOIz84xGUjMOPvs9O/8BmvqAqLJZ5+xserN8CsCmCzXXde8HU9nSV8A9GyBZTDwChDB6IOZFTOTJCYiKzVyk3eCRCWykcVxb7+9uZe2I1EJTZjFfJkYiaakn/tBSwqSyeDU/KjLlhcIRPKRuejjoYfCMy0EjBs+C9zU4qKx/vqWhCP8NxTRpnUim/HQQ8Nqej3kYqFf93+fV922ilAYeLPh5JPTv0G6ER6OEAhpCwgGNAQIS40GbXYQHckBtwBRSlQoHrctt0xfiwAhk5To3y4hEBgovIzP+DLbZ0k+P8UUFBU7kKVmE/ILqfnYYzacFl6DUFI3TdbvbKQgc31ISHQWVDARI++CkFjeJ0vgdTaYJYkRcQGPkHd2ZPWqVlzwlFBvXOscW20lcvXVNnTcBSt1dRmBwIuGgm2IuyeOPgQ/2AX+oJGbgbDIBgMI240DTqMSyGMgrhyVjw/WbBwC9jUdTEEwDB2tWZeQZxLwVWdMgLwIeVBaTUAQqEZ8DaYRJKOrnbIehB+z0nICAXXHXVlIQVIHqx5XsoNdlTxPopQCm5JMREwV7svqGER7oa7R0HlnTsqDQyCDkKjK7bZrTg6BTnX00aXfMcEQEM0qEEImVzXfnPv97MqOEAhFu3IhTOFR3DgdtLuWFwjMtNdfn/6d0MsLLih/r+8iw/2YRbxkdQ4yAvNE/SEUYOR9F6cPTAjITxhwBluzz0JwLviyXffjscfaNNyiw5eLACYk9XW/WTVh3KQN+9+i6AFEX0EDc5/TCO9NyEXcQBdq492OdELUPX8QQyJCkFQCqbRuA0CUhXLfy6nNeUwM7H9meeIJ3Ig5gqRY7ovlzSC6iEgkfRdTwhUGDf5QdYG0a2I+/EFD/kjeNRk05bYjiDoGL/kpLtDe8mhg1I8Ueh+EuBcJzEpSkV34vEcIpKHvvXeaKA8B8tc3WRGWPifUUhoCASUDBoQ/OrkKoXUG3QGGvat75ynwBPgdvF4goACLaridHnXNd4W2IngPtqlz3434DgQuwo7IOD/+g7bHLcbGrvvtZwXrRht1TH1HjrSanavpQaYRf8IEA7Hsmnao0jDzmKWsu+ACQvKJJ4qtHzEPeDtWWy3JhVEvkquYXACRlfR/Jg8ECKYrgphYBLYBIJeGvUJdDQZBgEmHKeqvHUEOSihvpWUEAoM3BBZ94KgFzBQnnFCczUY5qP86EylQpxvp0ehI4LMn4g1txwU+e7wqzDqYQrgoUYPRHNAKGGgKFuDoKC0I3mfwYJu7oIAXIEsVcwfhxaDT1Yuwq7MSmHBnF11vzAMEE1v6udoJ7kP6pg5wCEHcoTopqguY99J304VvtO3xwmUlejU4IK/xAqERYbJIZXy1Rc3czJAMGOIPiCBT4HJs8d18E7jqKjvrk13qA1cdRzlUu9VdPWAAsyI0sfx+ijAcj++Oy8JFF9mNdxoBVu2ijr4Ji5fEdZezlL1yNSGTCy2CoxKOP772lcGbhkNoVCc677xiykED0EQqCE7XNAklXpWDz2zTcasJUvLNp2raLhR9GPoNrw7LjIWCeyrBdQ2HOnY17xqqm99+CGlMuFA6cx4bH8EXCnAK1bMWboRZHY2y0hocmpEJWKo9794frqbKuxDC3GA0XkNAzWRGrydjC5cTs4Q7QPD5I6FRK2sFtiXxA6hqxM2zbqCCFOFf/KL6AUPyCvXFW0EKK+pi3hkRNyADhfpAwhKokheoz5CHtDNl0VZZ2hmRonh44BTQtDbYIBy9SDnEWEC4QsqxNqSCaEDd5wI1l3rnfVcdTLwf7cRzuD+0gQuuN9YMwKbm+0Dq4rUKgfamnvjwCfPlW2Rdx7N1AyAEd60L7RKCjFlMNiYh+S7voW0IP6NuU8YDZhqaBe+EwAsF36lAJMEJToJoxg5A4zdqoaPpbjT12PjYW6F4hcMOK59PwEpBSHBfJSM0mSAiOvG22yY7O4BEc9djyAM6FrM89WWQYGdCJOV1RyEEKEM7KffmzYtnQGF7ci+dkBmPTl6p3akndi4H6ejch0uNwYkWgS0cIrG4judB7FEGA1tDhvPWl/flXurL/QiXSjEgfE82gKG+cBwMamZQhCFHnp2OuIdyeDbfirogUOuN3OQdiGZl5S88VbQHAhWhlsV3wX1ANMJ/UCfqwn0IM94ntG5E4zCjuRZZrXScfnp4LcWTT86+h0VEp02z17GOPYt5brFF6fx++6U3VWGt+1Zpk3jEo7hjemsJBI4HHggLhVtvzV5glZWX118/uZPPMsuEF2x9/fUiNryIRzyiQOiQg+WoH344LBTmzLHLrO+6qzELL2yX/A6tlsvqzNOnh4VBuV2P4hGPLi4QGs8hNALYWgR1hFJEFdjAEDiwurwqi2zgHgptaqoEDqQQQSIREd0TM1pTICgIOCFMtd71BwhKIs9eo8t86MIbEHwhb4nmV0BQ+kw7rjQEGGSbz2TjCQi5FrUciDuyPX3CCzIPAsvfwYh20NRyn7GHrKIsP8Yf0lGJK4gw1x3I75VIyazcEohJn4zUrex5F7+ttZ1cQGhWCihS0lrB9/GJ2FDZAG8ORCaTBO/ptxntRfl4U8q1g67oVO0295CifEfaqdxS6npdteV3eVIxdGy0kd3RuRawuxHmRaVnQDx+8IExRx0VPr/zzvb8aaclf2fnKHdjDjiL+ecvnT/1VHtf1sa27JTEeXb70XvmmsuYZ56xOwq7m6TSDmxqo2D3qmWXTe7uxMa2mFX+hi0uP+PuSPzCC3ZTk3Jtw85XoXdw68xx9NGlstk45Ygjkue33jpdzqOPGtO/f/nnn3de8r4ZM9Lfacstw3VkM1jOX3WVPY856e6mBRnNBjLldpHmWQo2Yc3TZ9mR6oorSve99JJ9/6ydxSHDqV+eXcC6HYeQday7rjFnnmkHRYgfADQqjf+zn1miMW/Zhx5q7z/xxPB53c2XnZXdDg6efNKYPfawW86DO+8sbVE2bJj9jV2kuEaP1Ve357faqlT3I48sbYVGR2WXJ/gUflt7bbuFHZ2X+91OSofimg02SNZHDwYL53v2tBwK0HNvvWX/3njj7LbZd197DVuSu+UizPzt1W65xZ7Trfh4f1eoqiDjGnZB0m/GzlOVtotnZ2Tu436AsNVrdtghWbYeKgC2286e//nP09/v+uvL9zlw6aV2MgB8s0r9iXYAeM2oh27jRz38aw88sPQtjz8+CoSqDwYbkpSt0QYNsjMRnYttr1Zd1Xb8ass86CD7QdgbMnR+993tefba8/fw0+3UONjHDyy+uP2bffnKbYGG0FIwONEO+P2VV+xsy/Z3/M12dGDIkKRWc8cddh9A/l5vPXsNM1PoWWxXjjZDua5WAcaNy24b9kQE+++f7fbFrTt1avJ3tA+3fXTQukL3ggvsb5zLev7IkfYavq3+NnmyFZh9+5a2yQNZGh7t+PHHVqDqb3xLsNlm2c9GuwTs87jyyvbf9LNyfUm3kYP81t/was2ebdvE759//KMx779v+87jjzdcIPTscrQIr0UgCEdnATucABUCS9wQYVbAIaBGbXYNViFtVm1I/k9wjWs7E3nHSjmEVhNm7duzZGryrHPPtTwAkYgEXnH4bUNUnLtLEKQrfAXnNKBKNz4hbp66kvGI7R9aO0HfgchRLZeyeG9sdNoBG37ChOR9BJmRas55t43cAB5dLctPM/bfCRDYQ84AYJdmgs5INSabUK8hV8V9d57LO8EjEIRGqjEBbLQ/gWlwB36KuwsW+yXfhahPvgm7MPPvctBNWsgyVfDtCGemnfl+yhXQV+gzQ4fab0IYNkFPDezbbRLRgFZtswPKX3CV0GQGtw4sjepjoRI8IhyEqPprFDB4SOsl048sODqqSw4SDUf4LNl3hHLrFupuaq6SaIQB67M4ttmm/LtA0PGsrFh/fQfqpmUSFqwdXwejP6iVvNQl4vU6VhdmABC3T3o8hG+1285p+2o7ah0JT3ff3U3l1r0mWTMTkhTBwYCvFHmJAGOQcg/pz5CQ7DHqZomG2ssnn1UQuv2FbwVYXIidzIC/Z0nRc1kcvQ3SUviwKhj8gcB5V1iQcKQLeMCS+zMxLPaFF9o1KVkngE7nlstzmNXY3YpZhLRyOhDrGDAwNSmJmZrsQTQJhb8QScjDQn2zWHZ9B4SahnrTuXV5Nh3wvpBTjcj3IrAyEoNSBwgLglSbuqzCS1ONtQ6jR5dW7qJM18WM0KFOZLvqO5ULXec7knRF+6KRoZEgCBAMw4bZzXdD64SqIPTbQwW8qyHp4FfvD3Xm21J+FAhNgCy3ZMjlpotn0EE0yYjBzIIXJOigimtHZRMOVXdDUNWZ9FddGGbKlNJ5hACdh9kVdZJdrdjliKXiEQqap8HzGKi6GExIs1FhBdBGiLVH7c5KTtOOTKJYqFySxIC/+zIJVe55LYcsVjbxASyIglsZrSpLS9D73AVGdAMgTQ7TdkboZr07rj8GMYvG8I34Zq5a7wMNAuGBFkH2KNeTXo4QYsk6fS8faHOu6aDuZzUF1FWLq1HXEnFTnjHN+LYNSsuPJkM16N/fZqrpofvzaad0d0hiFmamYS8BrmVrLmYRZgZfsLDgi1suSUZuufp/Fg1RTcKdSehI2J/MgNzPLItwCA04hJT7LM0cVA6BuAIGL+fUHnY1iqwBmbWZKrMk9/NcNBzKZdAjEJiB/fq5KrPa7+XWClDtgcFD2SxKClfAs3TpPL2GBDn33f11DMgqpO3RUPhu5bI3sfsRQiTGkeGoQpf24ztlAQ2NA20CzoJ68Cy0AMwujTchs5PJhJWuqA8HKdBobG5WbuHabVfzMjTiOOCAsBvz4IPt+YED7d94Ddz7Bg+27LXivvuMWXrp0vmhQ8PlqjsOlyAYNap0Dy5A8O67JS+DekJg8hUw7bi09Ly6HX3gsdBrnn02eW7mTBtLUa5t1O3oejhCx4gRybJx/fbqlXY7uq5IdbkNH55dLi6/rPbTY9ttw+8+cWLyOmJEeOe87kO+hRtnMmaMjeugTQcMyL5v0UWNGTs2XZ9jjy21yfjx9jfX5Uo8BHEkxKHE0OVOBNKbWUrTfBWo7UQfEgUHew/Z5y+AyYzDSkTMvr69rqsUUaZLEsL8M7vBFaBKEpHoMvFoKpQ3aVJSU6AeXK+agRspiGaCmsuz3HdgFlQ1llWIuE5naZ6ZtV+Ga86wVgX1rXQtz9eITn2mgt9RhSlDZ3bqQp2YNbNMKqIM4Vi0DXlnX10nQhLzx/9+qPn+mhNoDczCeRcxoW/w7RlOfF/+7tevtOZiOeBlge9AY4REZW0OzJAHH7RLrmG6sd6CC7wymBiNCbGfEQVCREQzAOHPYiksplIujLmxiAIhIiKiJBAiqRgREfF/RIEQERERBUJEREQacAgwGDFAKSIiYg6CYFr70Tu2RUREt8fM/wowALO9X+PzfEmSAAAAAElFTkSuQmCC\", t.LicenseBannerSupportedBy = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxM0JENjYxQkExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxM0JENjYxQUExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjgxYjI4YzQzLTQzNzctNGNlNC1hODk1LTZlNjE5ZjdkOWMxNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpjOGZmM2ZlNC0yZmRjLTgyNDAtYjlkZS02MDg1MjIwOGI0YTkiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5j1ZUXAAAYZklEQVR42uydB5gURROGixOzCCoYMGEWc845R8SAipgVzDlgxqyoPOYcwZxzwJww55wzZgUUFQXt/17b+rent3d3dnf2bveuv+cZ8WZnenp6uqurvqrq7mBEPhORzhIREdHeMaZDs0AY3/w/HWNbRES0e0xoav7P2NgOERERyIKm2AYRERGKKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiKgdYlJTRGWYay6RrbYSGTtWpEOH5p7U3JWuuUbku+9i20SBENHusPTSIiedlDz37LNRIESB0AYx2WQiiy0mssQSIjPPbP/+80+Rb74RefFFkddfF/njj/bdRhMm5J/7++/28/7TTSeyyirNRnez1f3PPyITTWT7xuefR4HQZjDvvCLbbivSt69Ijx5WDQ4NhC+/tOrx9deLvPtu+2wrBoEPY9rP+y+4oMhttyXPDRggcumlDf1akVT8txWam+Hkk0VefVXk6KNF5p47LAz+FaHN5+eYw1732mv2voknjm3Y3gBvkuZcFAgNhu7dRR55ROTww0WmmKK8eyeZxN738MMis84aB0l715DagMnUvk0GTIQnnhCZccbw79iD77wj8uOPIpNOaq+HXe/UKXkdtuRLL9l/338/DpaIKBAaDlNOaW3AkDC46y5rCzLzjxuXVAnnmUdkm22svTjTTLnfpp9e5JZbRFZYQeTXX2PPiogmQ0PhvPMsMeTi++9FNtpIZJNNRO65JykMAKTZBx+IHHusyOKLiwwblvx9oYVErrgi9qr2gL/+yj83fnzUEEqLnCZLxIVsrrTApQO7n5WNtvLKIjvumDz3xRciG24o8tZb6crA377DDiJjxojss0/u/BZbWNPhySdz5yAd0SxwYXbuLDL55LbzoEngsXjjjeLPmmYaa6rMMIPIVFNZNyjC6ocfrIkycmR17YGmgznUpYutK52d98LNigBMi59/zv0/mhfkK+456su34/e337YmWKWgzFlmEZl6alsuQpp2/Oqr7Dw+tAOcULduItNOayeKESNypCF9kW/og/r8O6o6Jvs/fT/kpnX79yKLWD6LcrmW9v/wQ/teLQiWYR9FE9TsCdtvL3LkkdUJBBr1kktEhgxJdz02fteudvBg+zP4iKjjw9J57r9fZL31kpJ9ueVEXnmlsvr55d13n8jee9tzCBm8FggD6uODeIaPPhK5916rtTC46RTUZ911rfDiXjpLyJuBYEKIXXmlyLXXpq8znR3TBxfr7LOHTSc6JR0SoXP77daE+vZb+9tmm4ncemvy+t13twNo003toKVMn3mnvDffFLngAquFpannOuuI9Ool0rOnbQeEjA++62efiTz1lNXSXn45fVsgrGnv1Ve3WiOCl+cqyTx8uMiNN4oceqj9m5gUhPRssyXLoW3oY5DNbt+l/TbfPF+DmH9+kf33txPInHPavuprrEwYd98tcvPNls9SgcPEw3djgqH8oUOzGK2jBYFgrJytzXH44SYTnHde8edMPbUxO+1kzMUXG/PWW8b8+Wfy/r//tufvuMOYceOSv51wQnXvOPPMxowdmyzTf34afPutMWedZczLL1fWRg89ZMx885Wu79ZbG/Pll+WXf889uTI226z6b3rbbcZMM03xul56aWVln3OOMVNMUbjcnj2NOfhgYx5+2Jh//ile1o03GnPUUZW/59dfGzPppMnn77KLMb/+mr4M+u9WW9l7+/c35plnjLngAmMOOsiYm26y5VU/XkfVXiDsv382AmHw4HD5001nzLHHGvPpp5WV+/33pTtlmuPMM01dAKHSo0fhep56auVlP/ZYtgIBjBhhzFRTFa7vsGGVl/344/kDkWPhhY0ZMyZ9OXfdZczAgZXX48MPjZlkktzzGdiV4Jhj7Pscd5wVZj/9ZOvGJDBkiDEzzVS1QKg9h1Bu0A62JjZVyCvgAzXsjDNsVGGlQL0fNar690SlRP0rhV9+saoj6mjIDi3VNl9/LfL771YtRWX12wp1F9MBNdTnXOA6Bg4Ml43diumiPAB2NGqs2sVKqpYL6sDhqtEu8Mqcf77lY0LwzaxPP7XuYEwEyqUdqSdmmY9VVxW5+mqRLbfM52TgIErht9+sqYlKzvMwFWh7zF/ex3c/8xsmYJPD1VM/VH9tO8y/QtGMXMf7weHQ33knt56UzXiiXvBHmHTUgT7Fb1wL71PXpCK2J4RdMVJFgf181FHW7vZBvIAL+IQDD6y+fsQPZAEIIOx5BqQ7gLC7ETrYzXwsPiYdmQ/LB4Qj2HNPax/7oDPCa0BQPvqotb/pBHQYBAH2+mqriZx2mh3A7iBjgLkeD0hDhKcPBtfZZ1s7lU5G/bQjw8NAZuJ12Xhj20mxXwt9S4hOojefflrkuedEPvnEvgMDCOFHveAZ8ND4PNM55+Tb/fAPDMY777Rh4pQNIYnQcoUT7YBwpOzddkuW0aePnThcviPkIaBtKf/55y3Jy8BUITB6tH1vuATu5X3gHHAzu8D7dN11SYGA4KBNlT/gW/uCBKL1iCNsX+T9VIDCY8ATUP/evW0b0p6875JLWl4F4Ya3i3p//HH1/bjmJkM5xzzzWJXXxyWXJK+75prittbdd1sVr08fY1Zf3ZhVVjGmVy9rvlx7rTG//Za7nvNZ1f+FF5J1gauYY47S96Eyv/lm/ruktQuXWCKfw3jyyeQ1V1yRX/599xnTuXO6Z3TpYttx4okLmwx9+5Yup6nJ2vc+hg7Nv7ZDh/K/wd5755f97LPJa5ZbLv8aeJVynrPIIvllqI1fTh/56itr9pa6D45srrly/AfcyvHHG3PyycZceaUxc87ZIBxC2qNTJ2M++SS/kV99NWkHQqQUwkUXGbPggqWfNfvsxpx+uh2wEDRZvQNEjy8QFl003b0bbphPbg0YkP7Zl12WvBcbuXt3+9sMM+TbzO+/b8xkk1X+riGBkIbQ1OO995L3fvFF2N6v5HjqqWTZf/2VG0yFBMKWW5b3jJVXLl+AQ3L6XBf9uZJ3pK169zZm441zQjoDgVA/gUmohPiYfXsbVQm1DRA7sMce+feiji+/vFUZUb9KATX5kEOsul4qBiAtUKdRsfMcuykTXjAt/LUEeKe0eOCB5N+YI+oWW2ONfJv5zDPzA6+qBS6wtMAMcIE7EV98FvBdcJhnqNhFjecWCtr1+0OlOTCMiTvusKZehgFR9SEQSBAK8QYMfs0vh4yhE/tgUY6117Y2a7kgfx3bKwvQoSG3KgUf+KefkufKSbaCWygUKIO96z/L52RaGu+9lx+cUw057IKYjtD3aW1AOsJHuCAy9qyzqus7GaL1cxmYvUgh9nH66ZagUXBNly75nYrgnXrIHSB4JuQdKSf4yg/eKsdDU0wT8UO0CeBp7SQsf2CoZ6MYINWWWkpkpZXsAIJcQzOj3SHiYNpVqNKWLrkH+VYPeOghkUUXTZ7bbz+RnXe2wUcEuXEouduuBAIhs7iFfDDba1QYgGll/b4EG9ps8Wy3Xf0kEsEeZ61OluPmCwkE9Qb4pgwsfTWRo1mgHHOFqMeddhLZZRf7/2kEr9929bJWAd4UBj/CzAWeB85z4G1DcODFwLvUgqtzta7JcMMN+aocbhdcRS4IsfXDOnGhZeUyrBaDBokssIDUHTQOwY93qAchGhqgIQEIb8TCNccfbyeGtFpYNcK1liAUGa222NqTmMe8N6HduJ3RINq8QDjmGBs84wMJ6Sd0QCz6swu+83oAHxf/cz1CB0FTU1hQ1DvQusjRCJG1gJgA4gUgkjGB4JvcBKt6BRMZprIfxxAC+Q5wDMRRtADx2TomA4kZxx2Xf55zsKYuIJp89hkbq9oMvyyAyXLZZfXb8XSW9AVAxwZYBgOvABGMPphZMTNJYiKyUiM3eSdIVCIbWRz3ppvqe2k7EpXQhFnMl4mRaEr6uR+0pCCZDE7Nj7pseIFAJB+Ziz4efzw800LAuOGzwE0tzhrLLGNJOMJ/QxFtWieyGXfdNaymV0MuZvp1//u86rZVhMLA6w2HHZZ/DtKN8HCEQEhbQDCgIUBYajRovYPoSA64BYhSokLxuK25Zv61CBAySYn+bRMCgYHCy/iML7N9Icnnp5iCrGIHCqnZhPxCaj7zjA2nhdcglNRNk/U7GynIXB8SEq0FFUzEyLsgJJb3KSTwWhvMksSIuIBHSDs7snpVIy54Sqg3rnWOtdYSuegiGzrugpW62oxA4EVDwTbE3RNHH4If7AJ/UMvNQFhkgwGE7cYBp1EK5DEQV47KxwerNw4B+5oOpiAYho5Wr0vIMwn4qjMmQFqEPCiNJiAIVCO+BtMIktHVTlkPwo9ZaTiBgLrjriykIKmDVY9L2cGuSp4mUUqBTUkmIqYK9xXqGER7oa7R0GlnTsqDQyCDkKjKDTaoTw6BTrXXXrnzmGAIiHoVCCGTq5xvzv1+dmVLCISsXbkQpvAobpwO2l3DCwRm2ssvzz9P6OUppxS/13eR4X4sRLwU6hxkBKaJ+kMowMj7Lk4fmBCQnzDgDLZ6n4XgXPBlu+7Hffe1abhZhy9nAUxI6ut+s3LCuEkb9r9F1gOIvoIG5j6nFt6bkIu4hi7U2rsd6YSoe/4ghkSEICkFUmndBoAoC+W+F1Ob05gY2P/M8sQTuBFzBEmx3BfLm0F0EZFI+i6mhCsMavyhqgJp18R8+IOG/JG0azJoym1LEHUMXvJTXKC9pdHAqB8p9D4Icc8SmJWkIrvweY8QSEPfeut8ojwEyF/fZEVY+pxQQ2kIBJQsvHD4o5OrEFpn0B1g2Lu6d54CT4DfwasFAgqwqIbb6VHXfFdoI4L3YJs6992I70DgIuyIjPPjP2h73GJs7NqvnxWsK67YMvW9+GKr2bmaHmQa8SdMMBDLrmmHKg0zj1nKugsuICRfeCHb+hHzgLdjvvmSXBj1IrmKyQUQWUn/Z/JAgGC6IoiJRWAbAHJp2CvU1WAQBJh0mKL+2hHkoITyVhpGIDB4Q2DRB45KwExx8MHZ2WyUg/qvM5ECdbqWHo2WBD57It7Qdlzgs8erwqyDKYSLEjUYzQGtgIGmYAGOltKC4H0OOsjmLijgBchSxdxBeDHodPUi7OpCCUy4s7OuN+YBgokt/VztBPchfVMHOIQg7lCdFNUFzHvpu+nCN9r2eOEKJXrVOCCv9gKhFmGySGV8tVnN3MyQDBjiD4ggU+BybPDdfBO48EI765Nd6gNXHUcxlLvVXTVgALMiNLH8foowHI/vjiuEwYPtxju1AKt2UUffhMVL4rrLWcpeuZqQyYUWwVEKBxxQ+crgdcMh1KoTnXhiNuWgAWgiFQSna5qEEq+KwWe26bjlBCn55lM5bReKPgydw6vDMmOh4J5ScF3DoY5dzruG6ua3H0IaEy6UzpzGxkfwhQKcQvWshBthVkejLLUGh2ZkApZqT7v3h6up8i6EMNcYtdcQUDOZ0avJ2MLlxCzhDhB8/kho1MpKgW1J/ACqGnHzrBuoIEX4qqvKHzAkr1BfvBWksKIupp0RcQMyUKgPJCyBKmmB+gx5SDtTFm1VSDsjUhQPD5wCmtayy4ajFymHGAsIV0g51oZUEA2o+1yg5lLvtO+qg4n3o514DveHNnDB9caaAdjUfB9IXbxWIdDe1BMfPmG+fItC1/Fs3QAIwV3pQruEIGMWk41JSL7Le2gbws+o25TxgJmGZsE7IfBCwXcqEElwgpMgmrEFUPuNWuhouhtNNTY+9lYoXqF//+L5BKwUhAT3VTJCkwkiohOvv36yswNINHc9hjSgYzHLU18GCXYmRFJadxRCgDK0k3Jv2rx4BhS2J/fSCZnx6OSl2p16YudykI7OfbjUGJxoEdjCIRKL63gexB5lMLA1ZDhtfXlf7qW+3I9wKRUDwvdkAxjqC8fBoGYGRRhypNnpiHsoh2fzragLArXayE3egWhWVv7CU0V7IFARaoX4LrgPiEb4D+pEXbgPYcb7hNaNqB1G19ciq6WOo48Or6V42GGF72ER0ZEj7XWsY89inmuskfu9X7/8TVVY675R2iQe8cjuGNVYAoHj0UfDQuGGGwovsMrKy8ssk9zJZ9ZZwwu2fv55FhtexCMeDSkQam8yZA3UKrwLobUUUFdxV5Fnjr8WdctX1QgewRxgBSZ/yS72j8Cmgz+IKAzMBQ2sCfEUqM7KSWDyuN8A8xG1GPXczcLken/dBv8a1zQLbfySxqOlAXJ+vdy6w7/4kY6h66lDsahW+qPyKm6bhbgaylfTyedzeG7LLKk2uvE0BF2jnj35iuGHH4x57jm7l+Ptt9ulub/5pvh2W2mXTG+vB/sk7LFHcl/IBx80Zuml8/e6pP3Z03DeeZO/XXWV/e2QQ3Ln2OaMb8V5F999FzYHjzjCXvv77/l7O8w9d7juCyxg92h0l6FnL1D/OjRH+oJfl9dft0ueu9dSN3c/EO5x9/x48cXctdtsY3//5ZfwdoLTTmuvo73Ym8R9Psvzn3RS7ppoMhQ42NNxwoTq9xdkExOETBz0xQ/dIIe9MnbYIbffIR127bWT+14ofDPugQfseTYYcfcYQHjopr6UzfHKK+FNXNhTA7zxRu7a006z59iwZv75k9cvu6zdmwGwWQ/Xv/22/fvEE5PXsrGOgj0UuXbffXPCZ7vtctfybvp8Nq5VQaPn1lsvd+1uu+UGv/6ux+ab5/Z+pEwF7cvvl19u//74Y2NmmSUKhKLHiitaLaASsLvRppvGgZ7mmG0222bjxxvTrVv+LPnuu8lZVjdIYZchtxwdOIMGJQXCBx/Y8662Qef/4w97np2S9DyDGLA5jVu2agAIB/c8OzeBXXfNnWODX90lbLXVksJMN8xx35N7wUsv2d2n/PZB29CdokPtt/POuc1ti7Uz7aUah7sBiwqFUrugt5mNWirFiBE2Jh+3JCGq+GsLuWqwMXEDsS4DEYnwEDVcbKJNQe157H8WiFGwXD6h5G56dTXApajAhaih4/juSwVyaQCTG+5MvAqL2hCf4bqRcclquLofQq9cgeuq1ghBojmbmsLuw6wD8dz4hHPPtf+SGFVOtm/dBSa1FAgz5iCZijhwshb5eBA/+OLxpxNEQkBKNTER7RVE2DHoSTqCuKVjkgNB4AxrXGYFTQrSGAkdFBC+PnzCkUxC4Iaba04Afn0/1VuDkfwBpoSiG5lJIBEglbya/sPK0f4O3CQ7hd7PBUvD8VwED/EfNVo5u2Ob67goPgSCcERkC9a0QCMjuYil4khfR8ASRq6zbbVgUGuEIYlDaAxESobW0WRw6I5HCy0kcuSRuXoqdPCiIfieA/VU+FuhMdhYqYsJBs0I7wArP5MTwfLo1YCAqlNPTZ4jE7OUQNBQb7SXGu6p0TH28oiywG5ZhHmTZsxemiSGoSkw2Nzt510BHfrbzyfQ8/4CvLiYSZMPzcqEXbtbAGIOsrw/Kd3+QGLw+3VRQeDnVWjd0CiJ0sREILW6Z0+bCl7N2goIGdekSQt9f+rS1BQFQkQrA1scWxuOBt4FHzvLezFgSAI78ECb++GuXYGQ8Aey/u3Pcjp7M8ujEahKz1oBhfDYY9ZE1PLYq9PPmSH8V/kAhIJrNujiML4poXEAvK/u84BmgBZExih8RqWzdKVp2BqmTZu4ZlUUCBGtAmL0mX1ZscclYtU0Q8XWQQ1fw4FKj6pNko5COQF/RSR3kKedgQkg04VtCoEENp5PijKJUW4qtO4QRjKUCxVq2PsqEHRTYHgpgpEqTdYrh39wV0ZCONG+vG8N8xuaYk+PSAW2m8fWxQYm+45Zkk1XMRkAyWKa2IQNrvY8hBm7W3E96bsw/ngO/O3rVatwF2Qp2Gv/67bFVttyByB7OQAyPFH9qQuCAeIZzwMrF4Xq4nIOuvo35kVoltc6FVLntSxmep7vHvAf/jMpB08Yv6N9sSwc7VrrXcIaPg4hHi13dO1qzNlnGzNuXC6Wg8g8YhFcn7keAwYkoxo1dqB79+R1xCGQQwJ69y5dj8GD7bXENKSte69eNtpQQYzEkCE2+tK9rkeP3DVLLpmMw9D3dpPj/HiM4cPDz+/fv3A8zOjRuShEIipDINZm8cVjLkNEHYI0aVRnuhCuObXTQ8ClRzowMx/p3KwHEJo9UelRxXEZlnKpkS6MJgF/UWjNg6CB3NFqBTwPdTxUb3IO8HRwDaaGyy+wShO8A6nhuGFdYBrhEaHuoVW2cBXq/go+oYong1WV0LBoA101Gi2BfyE/IThrj9FRIERERPxfIEQOISIiIpKKERERUSBEREREgRAREZEGkIrEb8YApYiIiAkIgpHNR+fYFhER7R5j/ifAAAu+3z0PC2TkAAAAAElFTkSuQmCC\", t.LicenseBannerUnlicensed = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAZAAA/+EECGh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InV1aWQ6NTgwNmJkZDgtY2Q5YS00NjcxLTllODUtNzA5YWVkODQwNjhjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI5RUZFREM2RTU5MzExRTc4MDU1QTE1NTdFRTNGMkY2IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI5RUZFREM1RTU5MzExRTc4MDU1QTE1NTdFRTNGMkY2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIElsbHVzdHJhdG9yIENDIDIwMTcgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTNCRDY2MUFBMUY0MTFFNzgwM0JCNjkyOENBMjM2RUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTNCRDY2MUJBMUY0MTFFNzgwM0JCNjkyOENBMjM2RUEiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7QBIUGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAA8cAVoAAxslRxwCAAACAAIAOEJJTQQlAAAAAAAQ/OEfici3yXgvNGI0B1h36//uAA5BZG9iZQBkwAAAAAH/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgMDAwMDAwMDAwMBAQEBAQEBAgEBAgICAQICAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA//AABEIAEgBBAMBEQACEQEDEQH/xADUAAEAAwEAAwEBAQAAAAAAAAAACAkKBwQFBgILAwEBAAIDAAMBAQAAAAAAAAAAAAcIBQYJAwQKAgEQAAAGAgEDAgIHAwkECwAAAAECAwQFBgcIABESCRMUFQohItUWllcZMRc5QTJCI7Z3tzh4UXWXGHMktNQ1VbVW1ogaEQACAQIFAwAFBwULBwURAAABAgMEBQAREgYHIRMIMUEiFAlRYTIj05RWcRUWGBmBQlJysyR0tHY3OKKyM3W1NhexQ1OTlZHRYoKS0nODNFSE1CU1hnc5/9oADAMBAAIRAxEAPwCmHnKfH3+YcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYlBrzpZtTtas5Jr9g+75HZMnHs31hYM2sRTmD7tIp7B/d7K7hagxkPTOB/QVfEW7B7u3t+nmzbf2ZundTEWCinqUU5FwAsYPyGRysYPzFs/mxBvL/AJLcD8CRo3Lm6LXZqmVNaU8jtNWSJmR3I6KmSarePMEa1gKZ9M8+mJF5Q8PvkexFXnNpter9tkIRk3M6er0Kfo+Tn7RFIgqOFF4HHdos9hIi2TATKK+0FIhQEwm6AIhsVz4i5FtNOaqqtkrQKMyYmimI+XNYnd+nrOnL58Q5sb4ifhnyHd0sNg3zb4bpK4VFroK22I5JyULPcKWmpyWPRV7usnIacyAa11UlUFVEVk1EVkVDpKpKkMmqkqmYSKJqJnADEUIYBAQEAEBDkcEFTpboRi6aOkqCWIho2AIIOYIPUEEdCCOoI9OPxz+Y/WHGGHGGHGGHGGHGGO66xYV/5jthMPYH+8v3N/exfYCj/er4N94fgHxx4Rp8U+B/FYP4r7Xu7vQ9427/ANnqF/bzObZsv6Rbgo7F3Oz73OkevTr06jlq06l1ZfJqGfy4ivnDkz/g1xDuPlX3L85fmC0z1vuve937/YQv2u/2p+1qyy19mTT6dB9GJUeTDx+/p2Zfo2Kf3t/vh++eNm2Qvj33C/d98N9xZ7JW/hHwv753f3nZ93vW9x7lLr63Z6YdncbaOSdg/wDD27wWr3v3zvUwl1drtZZu6adPckz+hnnmPTll0zMEeE3lx+uJx3dN+/o/+jv5tvTW/se/e/8Ac001NUd3u+50WjP3jR2+230NWv2tK1xcjvFy8OMMOMMOMMOMMOMMfZY8x/b8r3uoYzx/DHsV4vtiianUoJN3Hx6kvYJx4lHxUcR9LO2EY0M7eLkICjhdJEnXqY5Q6jz3LfQVd1robbQJ3K2eRY41zA1OxyUZsQozJ9JIHynGt7w3dt3YO1bjvbd1SKPa9po5aqrnKSSCGngQySyFIkklcIik6Y0Zzlkqk9Mdc2R1I2G1EsVeqexOOXON7BaoVWxQEc5sNRsJpCGRfLRqr0rioT9gaNyletzp9iqiag9OoF7eg8y249p7g2lUR0m4ac01RKmtQXjfNQcs843cDqMupBxH3DHkFw/5C2esv/Dt5S9WigqRTzyLT1dOI5igkCFauCnds0YNmisvXLPPpiOPNdxMuHGGHGGHGGHGGHGGHGGHGGHGGLoKn4E/INc6tWrhCV3FikLbICGssQdzk2NbuDxc7HNpSPOu3MyEyCxmjogmIIiJTdQ/k5MlLwTv+spY6yCOl7MsauucwB0sAwzGXQ5HHNa//Ff8RNtX2t25dKy/C5W+rmppgttkZRLBI0UgVtftDWpyPrHXHv8A/wDPd5Gv/beJf+KcX/3Hnn/4Acif9HSf9ev/AHsYn9rz4bf++7g/7Ll/8/FZ+1Gq2WtOMrL4ZzUzgmN2b1+GsqiFdm0Z+O+FzpXJo84SCCSSYrGBqfvJ06l+j/byNt0bWu2z7qbNeQi1ojV8kYMNLZ5dR6+mLs8D888f+R2wl5J4zkqpdsPVzUwaohMEndg09wdtiTp9oZHPrj3uENGtvdkI8k1hPXnJ98rypzpI2tlXV4ynOFkzimqg2uE8aKrDhwgcOiiZHZjp/wBIA557Jsjdu44+9ZbfUz059DhCsZ+YSNpQkesBumMVyf5R+PHDFWbbybvCx2q8KATSvULLWKCMwzUkAlqVVh9FmiAb1E4sb058Iu1WQNmaFTdosNXTFOFGpXlryDZ1XsK5QlIKCFscKbDzldl5Vo1n7W/dINC/1pF27Mzh0mUwtxKMibP4V3TX7lgo9z0c1LZRm8r5qQyrl9WrIzAO5IX05hdTDPTim3kb8TvgbaPCV23JwZuS2X/kyQpS2+mCTK0U8+oe+TQVEUTtBSxq8p9kxySiGByomzFonkS8yMRpDODpfodj/HsO8xEyQqlotbqGI5pmPZFukB1qVRqowXZMJSwQ51Q+Jvnx10EnwrIHbruAVVJJ3IXMMOyZ/wBDdi09Oj0ihHcrnHER/wA3EgIDOv79mzAbNSrNmRRfw7+HDcfJ+1/rK+Vl3vFTT7hkaqpaVZitZcI2OQrK2qkV5IqeYD+bQQBHaARyrNFEY0atrCXzDe9VDuLGRy+6oudKOo7SCbrEhTq7Q5okcJwFcKzZKNFRCUdJFIH9Wo/ZSaP7QMkIiBixzZfILfFDWLJdzBXURPtIY0ibL16HiVcj8hZXHzYujyd8H/xY3VtyWj47S67W3QsZ7FTHWVFdCZMvZ95pq6WYyR5/SWCamf1hx6DYJ5EdC6N5McL4o378e9MQmckZKeR7XIFLZK12pObi0fO3EPKStmLJykfX4zJGOrQ1MymFzOQTfNPUWMuqVsidbfuQtiUPJNmpd+cfwh7jUkCWMaIzICSrM+pgizQuNMhzyZcyWOlSajeHnldunwl5Kv8A4meXtyem2ZZY5GoKxxUVa0boizRRUxjikqJbdcKZhNSII9UMuiNYozNKsdf1e+XO8gc1GEfyUrr5UnR0gUNCWHI9jcyaZxABFA6tUoFmhhVAR6dSuzE6h/O/Z10Gn8eN/TRdyR7fE+X0Xmct+T2InX/Kyxbe7/GQ8RrbXGkoqfd9wgDZd6nt1OsRH8ICqr6abL8sQPzYjhb/AAneSSqZCYY8b6+PLgtKorOY24VC1VR7j1Zs3Ommuo/t0pLw7CtrFMp9RvKgwdrlATJJKFDrzXavhfkaluC29beZmcZiSN0MWQ9OcjMoT8j6WPqBxM23via+F9/2hLvCbd8dujp2CyUlXS1SXAMwJUR0kUM0lQCB1kpe/EhIEjoTliSUN8uX5ApOLLIPZnXmuuxTA4wczkazryhTD0/qTLV/Hk7C+oHX9oPBJ9H87mxw+O+/pYu472+N8votM5b/ACImX/KxC9y+Ml4j0NcaSlpt4VlPqy78NupliI+XKouEE2X5Yc/mxWztpoRtJpNKxbLP+NnNfhp9dVrWrvCv2VlothcopmWUZsLHEqrN2koVEhlPYvStHwpEFQEfTDv5HO69ibn2XKqX+mMcMhySRSHicj1B1zAb16W0tl1yy64ul4/+WHBXk3QT1PEt6SruVIgapopo3pq6nVjkHenlCs8WZC9+EywaiE7mv2cckwLrpm3Z++tMZ4Gx1YMkXJyiZ2rHQqTdJnFRxFE0VJawzkkuygq3DpLKkTM7fuW7cFDkJ395ylHEWLbt63NXi22KnkqawjPJcslH8J2JCoufTUxAzIGeZGJB5X5j4x4O2pJvbla80ll24jaBJMWLyyEEiKngjV56iYgFhFBHJJpVm06VYi3xh8uf5BHkQSScSevsU9Ol6hq+/wAkWFSXSP2gb0DrRdCkoAVev1epXxidf6XT6eS5H48b/eHuM1vV8voGZ9X5M1iK/wCVl8+Od9X8ZDxGp7iaKGDd09MGy94jt1OISM/pBZa+OfL19YA2Xqz6Y5trxpDshpL5LdG6zsNR21VWuGcqs9p8rGWSvWaFs7KDnYtCVcxruCkXqzf2KsmgCiTxJq4D1Sj6faIDzG7e2TuPZXJFkptwQCIzVyGNldHVwrKGIKk5ZahmGCnqOmN15h8n+GPJzwp5RvfD90evjt21qpKuKSnqKaameeCVolkSeNA2sRyFXhaWM6WGvMEYuZ8zHjP2u3p2oxXZ8F1esnpVZwZG1edulwuMPXYZhYS369SxooGJTv7Q9WJGySCxlG8csgUqgAJwN9Xkx8xcbbq3xuilqbHFF7lFQhGkkkVFD92VtOXVz0IOYQjr6c8c2/huebPAfizwPfrHylXVw3NXbpkqoKOko5qiZ6f3Chi7uvKOlQGSN0CyVCOSpIUr1xTzlXwA+Q3GdXf2iNrmM8sljGyjx3A4qvDuTtAtkUxVXFhC2yu01aZcpkKPa2ZGcu1jfVSSUMIFGIbpwJyDbaVqqOOmqwozKwSEvl68lkSPUfmXNj6ACcdFth/Fs8P97XyKx1tbe9vtO4RJ7pRJHTaicl7k1JUVghUn0yTCOJB7UjooJFLD5i+i3zyMk2bqOko504YyEe+brNHzF80WO3ds3jRwRNdq6arpmIomcpTkOUQEAEBDkMujxOYpQVkUkEEZEEdCCD1BB6EH0Y6XUtVS11LHW0Ukc1FNGrxyIwdHRwGR0dSVZWUhlZSQwIIJBxc7ifwF+QvKVdi7O6rWMMZx80waSkYjkTIzUsg4j36Cbpm5UY0SMvSzIV26pT+k49JcnXochTAIcmS1cD8gXSnWpaOlpo3UMvdmGZBGYOUQlyzHqORHrAxzY398WXxA2LeJ7HBW3y91lNK8Upt9ubtrIjFXUPXSUIfSwI1R60b0qzDrj4XYfwk7+66VKUvkrjyvZOqUC0XkLBKYcshre7hY9sQyriQdVl/GV+3umLZEhlFlmke4TbpFFRUSEATB6O4eFt+7epGrpaeOppIwS7U79wqB6SUISQgDqSqEAdTkMbVw/wDE48S+Y9wQbVoLxWWPcFXIsdPFeKb3RJpGICxrUxyVFIrsxCoktRG0jEJGGYgGrqmUi55GssXTMfVKy3m3zixm8NVqhBydksUsuRI6yiUdDQ7V5IvVE0UzHMCaZu0hRMPQAEeRhR0VZcalaO3xST1bnJUjVndj6eiqCT069Bi9G5Nz7b2bZZ9ybuuFFa9u0q6pqqrnipqeJSQoMk0zJGgLEKNTDMkAdSMWwYt8EfkfyYybSb3E9dxdHuylUbq5SvlfhXpkzFA3c5r8CtZ7PGmAR6Cm6ZIKgP8AR6fTyVbXwZyLckEj0kdLGfR35UU/uoutx+RlB+bFBN9fFU8Mtk1L0VNf6y+1cZyYWyhqJkzz9C1E4pqaQevVFM65fvsSu0n8Me52MtxsVZFmG+LZWm687HUBTIMxBXtRX6lZUp94mBgo+VhIiUkvbw04iUvcgj6i4HKXqUAMbatl8Obytm8KW4zClajt9xi7rLL/AAO3I2kMqsclYeoZnMD5cQH5NfEm8bN7+OV+2dbnvsG494bMrxQQz0IHWpFXRQ9+SKaWKPVNA5OTvpQqzZElRZR5qPGbtHvJmTD92wLFUuQgqXjJ9VpxSz3BpW3Kcs4tMlLJkbN3DdYzhAWbkgicBAAN1Dkj8zca7n3veKOtsSQtBDTFG1yBDqLlugI6jI+nFK/hoebXBfi5xxuLbPK9Rcobpcr2lVAKakeoUxLSxxEsysNLa1Ps/J1xlMvelmxFF2ikNOBo6twz8wkYKLCn0R0nZCPHVgqcTdmh2smkDdmDFpXJhNy8dLGSbMkyKnWORNI5wqzXbM3DQ7nbZ/YM1+VlXtxHXmXjWQZHoMgjAsxyCgEkgAnHe3avktw9urguHyOF0W3cSywzy+91ymmKLT1UtE4aM6n1vUQtHDEgeSZmRY1Z3VTZjDfLr+QqUgk5d8pgiuSB24LGq0zkuTXnUlBL3e0UcV6nT1ZFwA/V6lkTJdf6fT6eSTD49cgSwd5/cY5MvoNMS35M0jZM/wDx8vnxSW5fGJ8QaG6m30o3VWUgfL3qG2xrARn9MLUVkFTp9eRpw2X73PpiBmR/G3uPijM8Vge74jdR18nYN3aYMWc7X5qvy9VZSLaHWn2M9DST5kqgeXfN2aTURCSXfum7RNsd24RQU0W48c7wtV5WxVtIVrpELrkyMjICF1hlJGWohQv0yzKgUuyqbXbN80fHHf3G0/K22NwpNtWlqkpZ9cFRDURVTxtMIHgmjRwwiSSZpetMkEU1Q8y08MsqReyria94WtzqkZDhhhZ5qmosCZHLZ61coIv30S5UbOmiiqQrR8zFu2D1ufsdR8kzcsnaSDtuugnrF0tNdZqs0VwTROPnBBGZU5EfIysrA5MjqyOFdWUTnsPkDavJe3o9z7PqfebU5AzKsjKxjSVQyuAcpIZYp4ZF1RVFPNDU07y080Ur835jsbnhxhhxhhxhhxhiyOA8vXkdrEFC1qB2htMdB16JjoKGj06pjZVNjFRLNFhHM01HFKWXUI2ZtyEAxzmOIF6iIj1HkjQct8i00CU0FzlWCNAqjRD0VRkB1jz6AZdcUvu3w8vDS+XSpvd12NQTXSsqJJ5pDVXEF5ZXMkjkLWhQWdixCgAZ9AB0xrp0Pu+yWCtN7btx5Ls+WF8eWriF8b1OzwtWgy4toCCIng2bmOr1fg38jke+uXqPSOVMqskdVmyTSTeGcEG2exa3cdj2fLuzkmvkYvGJRG6ovYiH0QQiKTNKSPYOZGaIAHLDHz2eVe2OF+VPI+3+PnhRtOjiWnrWoWq6aaqn/OdexyndZKionSO3UCo+dQoVGCVNS7vTrCwgBpvrfB+UvPuTPKVuJVIiNwPGyrmuYDxJYBaI1mQquNQXajaMjvlhSZztZqhkFiuiLHFnJTJXvrlTYNCNV9C2ftyDlC/VPJ+74kWxKxSlgfLQUhzGuYnoyJkdWfsvJr1ZRoFa23kdzNdPBPiayeCnjnX1E/Ks0C1F9u1PrNTHVXLS3u1uRc3gqarUhiKDu09GabtF6udp4vg9vfmL06VY32NNHMX0qXqdVOMC1ynkRjLDX5ZCOAGSf3Bx7X39ZVj4BsRAAZOnzvqsl06sEilDv9DdvkMKKoa27IpYXpIvZE8obQwHT6qJCmSDL2WZuo/5sD07X48fBwfc1mi3r5RXy509/rx32tdveL3iJpPbPv8AcKiOpEk7FvrooIvYbP8AncjE6Y7YS+ZR2Zr1mYkz3iXFeSKOs5SLKGojOcoN3YtlDlIs5jHj2eslbkDNUhE5GqzFAVzB2C6RA3eXXrL5H7lp6lRfqSlqaIn2u0GikA9ZUlnQ5enSVGfo1D04mHk74LHCV3skrcT7gv1l3QqExe/PBX0TsBmFkRIKepj1H2TKk76AdQgkI0nPVke2L37Id9vTpw8durpdLRbHLuRAgSDpexzj6YWcPgTWcEB4so8EyvRRQO8R6GN+0a/3GravuE9cxJaaZ5CT6SXYtmfT1OfXqeuOvmzNvxbT2fadrQJHHBbLbS0ipHn21WngSEKmYU6FCZLmqnSB0Hox8Zz08bLjcv8ALgRtsZaHW93PFdEgZjYq9P6QDoD9isKhTsdRUo5jzG+r8NNaY5+l0L9AOkVx/aI9bu+OsdWmxZnnz7D3GUx5/wAERwqxHzaww/jBsfLf8ZqtsFV5WW6ntRjN2ptnUMdbpyzEzVlwliWTLr3BSyQNmevaeL1AYzR3by++SOZtcq+W2svbAzaWeFbs4CKpdbikU0HKqSKIRMDWI6OVRTTKAdFEj9/TqbuHqPK3VvLnI01UztdZ1yc5BVjReh6DSqAf90flx2v2x8O/wwttggpYthWqUPTpqeeWsqJSWUEt3Z6mSQEnrmrDL0LkOmNWPio3azlt54/cpZJyHMRj7NuKJrJlBZ3c0HGNW9ifwmP4K6VKzTcBFoxsKLxqvaCNnKLdFui4IyA4gB1Tjy0vFu9L5u3YNVcbg6teqV5ohJpUBysSyRuyqAuYLhWAAB05+knHBTz08ZOLfHny4sWy9n008XGV/prbXvRd+Vmp0mr56OrpoZ5TJNoZaZpY3keR4zMVBKooxk3tXl78kNvmzzz/AGtyDGODLeskwqres1GEQKBu5NAkJW4GMjVUUwAC/wBamoY4B9cTCIiNVKrlvkarn78l1qFbP0IEjUfNpRVGX5Qfnzx38sPw8fDHb1sFqpNg2ieILkZKpqmrmbp1YzVM8sgY+n2GUA/RCgADSjh7Kk95L/CLnmZ2JTjrRkKnU3M8evawi46OUkbxh2vfvBoF1Iyj2rVjFyqfqsEXotCIkcARwAFIRc6YWPtF0n5J4Vr5tw6ZbhDDUAvpAzlp07sUmQACt9ENpAB9r0BiMcWORdh2rwn+J3tS28Omah2hcblZ5Fpe7JII6K71HuFfRF5GZ5YjlO8PdZ2jzhJLNEr49LpIFW8Yfhem9uGVWiZjKuRKcxyxJLSJDFCxT98sban4SgH66B0ZJSqQUdYY5yu1SVIIC4fqpGTMuY4eDZXuvGfDb7sSJHulRCJzn+/aVxHTISOuhQ6EqCPTIRkWzxk/Jz8++cPxKaXx7qq+op9hWe4vaoxGQfd4KGnarvU8asDGKqeSnqI0ldCMo6SNw6xBTm9t/ls8i9ztLq2PNrMmwjpw7O5Rh6g+ZVKrMU/UE6LNrWYJkyhztG5OhA9dJZRQodVTqGExhrpV8sch1lUat7rUoxOemMiNB8wRQFyHzgk+sk47Obd+H34cbbsMe36bYVkqoEjCmarR6uqc5ZF2qZ3eYOx6nQyKpPsKigASL1l3j2O3J308drHYi4ML5I4kzjEsaxZQrkJAT7plbZutKP206eus4uLlBamraHore1I5HuUFZRUTAJdi21vfcW8N97eTcMyzyUlcoR9CqxEjJmG0BVbLQMjpB9OZOIb5t8XeGvG/xR5iquHrdLaqPcG15Xqab3iaeBXpIKkRtAKh5ZYtXvL607rR9EEaRgEG23zueQ7bbVTNmLsRa+5PDGlXteH214sDuLrFVk7E/mHN0t8CKac5YoeZdRbJJlBICUrP26neJxMcwG7QljnPkHdm1r1S2mwVXu1LLRiRyqIzljJIv0nVioyUfRyOefXHPv4Vfh94+89cZX3kLl2x/nu+0G4moqdJamqip44Vo6SfMwU80KyuXnfMzdxdOnJQRmYUeKzy8bjT232I8LZzyrIZgxlmOzkoz1pbYyDPO16cnGrpGuTdfsMfGMJVIU54GyThs4VcNFGiinamRbsVJpfFvLe8J93UlmvlU1ZbayXtESKupGYEIyOAG+lkCCSpUnIA5EWa88vh5+OVq8eNw8l8W2GHbu99uUJrkeklnEFRBAytUQVFPJJJEc4O40ckaxyrKqanaPUjcq+YdwhWMWbyRd3qka2ikM54shb9Z2zRAjZuveo6dsFTnpMiKRSolVl42Fj3Lk4AB13qq6ynU6hjGxXkFZKa173WtpVCrXUqyuAMgZQzxs3ye0FRj8rFiepzxvnwfeT75vvxdn2xf5nnl2tfpqCmZ2LMtDJBT1UERJzOUMk1RHGD0SFYo0yVAo4jV9yPMltOVBLEF52luERAt2kMghgCmzMBXIJpHtU2zNi+f4vrsWyRFFskUvqP3B1lB6Cc5jj1HC0u8OYd0ZC0T3SaKMBQKWNlRQBkATCigdPWxzPrJOJPvvjh8ODggvJyJa9iW64VbvMzX6shnqJ2kYs7pHc6iVzmxJ0wRhFHRVVRkL0/Ehl3yuweby4f3YxvnqwYct1YnXMHkXKlLkTvaFb4NiEyxLI34zH3K0NZI9quzFvJrqj78zYG50jCqmtOHE925Ugvf5o3pTV8lnmiYrNPGc4pFGoZy5Z6XAK5OT7WnSR1DcsfiDceeA104wPIvjLetp0nI1vroFnt9rrIwldSTv2XMdBr0iamkaObuUyIOwJu8rgRvFwbGWCKpr98x+2rNFjG0HULdXL7k+Hg2SBGzGIXveB7VJ2NkwbpFTbto773FkFGyKRSJN0FCIkACphzBW2xUtg8ihTUKhKSaOWZVAyCmWldnAHoA7msgDoAQB6MSvvflW/8ufBle97pneq3Db6ygtk07sWeVaG+0sVO8jElmk9093WR2JaSRWkYkucc980nkm3VwJuRbMF4YzfLY3xtC0ygyzWKrddpyUoeRsFeQkpJ0vaXleeWcfUcKj2pkeESIXp0L1+nmP5l5H3nYd4S2OzVr01uSGJgqJHqzdASS5Qv6fUGA+bG3/DU8LfGflfxwt/KfJO16e9b0qblXxNLU1FYYhHT1DRxqtKlQlN0UDNmhZifS2XTEBfH55AN0LNunrpSp/ZDJ0vVcpbH42LkODfTZV2VuLOTtcr8sWZKdv3uQfQkei2P9YOqSRSh06c0PYO/t5VO87dRVFxqXpaq4w91S2Yk1MiNq6dc1AU/MMWy8ufEnxqsnjRvHc1p2ZY6e/WLZlxNvnSHS9J2IKioi7JDZLomkeReh9tifXi1vz9bi7Qa2Z3wZXMEZtvWLoOw4kkZubjKpJEYtZKWSuMqxTfuiHQVE7gjNEqYD1D6pQ5KnPW79zbcvtDT2KtnpYJKQsyocgW7jDM9PTl0xQf4S3jnwbzTxVum88q7YtV9ulHuGOGGWqjLtHEaOJyikMMlLktl8px8T8vBdXOdtntwM3Zptbm/7DPMeYvZRtqsy6Ly0SFUWdyMLbXSaokIcUmKdVq7JRQhQ7EvSII9DfT6Xj5WtfNzXe9XmU1G4DTwgO5BcpmVkP7miFSfkyHrxs/xhNsw8V8Hcd8Y8aUCWniCO8XN5KWmUpTR1QSOakUjMjNzVXOZVJObdxgPZ6Rx8kOdvNFhPP8Ak+12u2Z2xvh5pdbCpjecxUiujhZvQiSrsKgmrOVVmtDneqQRUTrpTygShle8V0wHqAa7yNfOZbLf6qqqpa6mtAmfstBn7uItR7ftINOenLMSnXnnqGJm8MeK/hq8m8S2OwWG37VvXIslspxcYLoVN5auMSe9kQVTiYIJy4RqFfdQukROR1Nd8j5SNqbtkKjZFzBaWuSbBR6NK45ZznwqDqFqUrUlaq9d2rlCbrsMjHt7RXrXVY96wkVY9yIqN+12m7SOomePZOT901twguN3lFTUQQNCG0rG+gukgIZFyDo6IyuUPUZOHBINwaPwV4G2xtC6bO47oJLLaLpdIri8Hdnq6UVMdLUUTK0NRMZGpailqp4Z6daiMaZNVO9PIqOsU9gM5TuwF9PdpuMZQ/pNpFoxYNDJLLiM1a7NfLDLTD9BnHISU/ZrtcpWUfLItWbX3L05GzZs2Ii3T1a/3ue/1/vs6qmQIAHU+07yuzEAAu8kjuxCqubEKqqAonviPi618SbUG2LZPLU6njd5HzVfqaWmoaeKFGeRo4Kaio6WlgR5Zpe3CrTTTTNJK/D+YTEoYcYYcYYcYYcYY0XeCzxllz5dmm3ecIAqmEcZTYmxtX5lsHsMn5FhFwOaWcoOC+m/pFCeJAZbqHt30sQrcRUTbPURsNwfxr+fq0btvcf/ANEpn+pRh0mmU/SIPpjiPp9TPkvUK6444/FN83DxPtiTx54vqyOT73S5XGohb6y2W+Zcu0rKc0ra9DkmX1kFKWmAR56aQc4823k0Ntpk4+v2HJ4Vtc8Rzq4O5WNcCLLLWRY/1mTu0Cskb0nlRrYnVawoF7knJjLPu5QqzYEMdzVyV+ldz/MFnkz27SOc2B6TzDMF/njTqsfqPV+oK6dy+GN4SDx/2OOXOR6TTzJuGlXRFIvt2m3yaXSmyPVKupyWWsJyaMCOlyRo5zLbd5G7A81V8GmFsZY5UNDo3+mYBw1LyMab0Flo60Utze7+7FREQJ1u61beoPunUqyUmsXp0P8ARLHIlQ+1uEaK2W46FqIaWnYjp0eMyyn/ANZoYN8odvlxz68NbRT89fFH3NvfeSioltFyv14hjk9oCSmrFoaBMj1/mQqYXg9aNTRH97jFVymWPphxNuq+N3e28VKs3un6tZbslQuUFEWerz8RXReMJuvz0ehKQ8uxOkuJzspGPcpqpnEodSHD/bzdKXjnfNdSRV1Ja6uSkmRXRlTMMjAMrDr6CCCMVjv3mf4rbX3BXbV3Fvvb1FuK21UtNVQS1GiSGogkaKaJwVyDxyKyMMzkQcd21h8TGw+es7W/WvIDSR1vy1E4Ke53qUblWryZI2z19jf67QBRfKxqykpCsXsjNrCk+Savg9RgokKI9wHLnds8U7hvt8m23XhrddkoTVRidDk6CVIuuR1KCWOTBW6qRp9YivnD4gHD3FHFdu5p2jJDvPj+o3Uljq5LXVRmSmqHoKivzQSKIpnSOFNcDSwezOjiUZaWsbw98tXmNKzpyezWf8SVHGEOcZCfUxQ8s9ksj+JZdV36SUleKfSICrJqtkzf9fXLIFbB1OZscA7RkS0eOF4FSJdy19JDbE6v2C7uVHU9ZY41Tp++OvL0lTimvIvxqeOJLI1DwjtLcNx3xUDtwC6pTU1NHK/soTHRVdbPVEMR9QhpzIfZWdc88aTNJcwao2usWrA2nzqNk8W6smrONxlq2YHlOcysiykZR0hXrAZZVS3rpqonXkZcBUSfv3SipVlzCdQbG7Ku+1aqmlsW0CrWu16IdSdYyxBYhHz+sPTN5OoZmJDN1OOLnk5x1z5Yb5QcreRUc0G+t9ipuPaqfYrFijeOJWqKfSBSKQQlPSHS8EESI0UQCoP5rs//AOOzX+9pL/ti3OcU/wDp3/jn/lx9ptp/+1U39Hj/AMwY2N/L3/w6dqf75smf4GY25b/gD+7y6f0yb+rQ4+cn4vH+MbYf9m7b/tu44xncp3j6RsbJfEL/AATttv8A7Yf4IQXLg8Sf3L3b/wCO/qy4+cH4hv8A/TXj7/8AFf8AbU+Pp9jW6+YvlyaE/pKRpT7pa/a6OJBuwAVTChiK20it3xU5UwMHbAhXX7pz16AQrRQR+kvTntbiVrv47wSUQ1dqgpCQPkgkjSX/AMnQzH5NJxg+GpouOfjKXak3Mwg/OG7twrG0nT2rtSVtTQgZ+uf3iCKPL6RlQDocYs+U0x9LWJ1+MX+IRp5/f3QP/V0ubxxn/eBaP6fF/nYqx5wf4Q+Rf7J1/wDInFp/zMH+b7B3+m6M/wAT8kclHyS/3uof9XD+WmxRD4Jv+HjdH9tJP9mW7FUvjS/iBac/6hsY/wBpmPIs43/3+s/+sIf88Yvv5rf4R+R/7H3P+rPjTT5N9dahtX5dPHvhDIAqHo1lxdc5q2MUXKrRWagqG7vl+fV0rhuok7QTsZKz7FVRA5F0kHB1EzFMUDBZTkvb1Junlnb9kr//AGGSlkaQZ5aliMspTMdRr0aSRkQCSCCMcRvCHmLcXAvw9uXuT9o5DdFFfaOGlcqHEM9clDQJUaWBRjTmp76K4ZGeNUdWViD4XlK8tN28e2Qq3qJqfiHGdWSrGPa9Lu56wV5wNbrsfO+++DV/H1Krz6uw7VONZsyqKu3JnLc6qxkQagKQqn/HJ/K9bx/cI9pbVpKaIRU6MWdDoQNnpSKNCijIDMscxmSNPTM+z4KfD+2x5e7QrfIXn7cV7r5K68VEKQU9QvvFRJBo71RcK2oSomYyO5VYoxHIFRZDOQ4RY/8Air8vW6+1O7WMMF5is1Jncf3KOyK7mW8Xj6FgpJqatY7tVnijspOJK3VbkLLxTch/UBQDpiJf2m68wHFvLe9N071pbHeJYZKCZZiwWJVI0RO65MuWXtKPTnmOmJc88vh5eM3A3jHfOU+OaG50u7rbNb0haWvmnjb3m4UtNKHil1Bj2pZCNJXJsm9AyxJO5nIb5k3EpSmKYyevckRQCiAiQ44ayYoBTgH80wpqFN0H+QQH+XmyVhB8jqTL1W8/1ebELbbVl+C3uAsCA274yPnH54tozH7oI/KDilnz/wD8SbIn93mJv7HM+Qzz3/ePUf0eD+TGOlvwk/8ABbZ/9cXX+uPiFXjf/wA/mm3+pHEP9tYjmmcdf7+2f/WNP/KLizHmb/hL5I/sXdv6lLi4j5mn/Mlrn/chK/28muS95K/7x27+hN/KtjnR8Ef+5feX9qIv6jDigHBeect615JgsuYSu0rQr7XhWIymYz266Tlk6ApXsTMRb9B3FTkJIEIALs3iKzdXtKIk7ilEIEsd9u227kl2sszwV8foZcjmD6VZSCrKfWrAg/J0GOtfKXFHH3NWy6rj3k62QXbadZkXhl1KVdeqSwyxsksE0ZJKTQuki5kBsmYHSLrP8ylak5CIrG3eFK9NV92ojHy2RsQneRUtHtFOiKsjKY8sLyXjbCJim7nBWclGgBAMKTc49qQ2M215H1QkSm3bRRvTno01PmrAejNonLB/n0unzKfRjjBzb8FewvSVF78etzVlNd4wZIrddgksUjjqI4rhTpFJT+jKMzU1QScu5Kozcem8/wDpJgmjUTEu6uBa9X6a1yXcI6lXmIqMehD1e2rWypzl2p9/j4Rqg0ZxUo5Y1t4lInSSTB8Zw3VUIC5VlFvDz3sqx0NDSbzsUccK1MwjlWMBUk7kbSRyhQAFYhGDkAas1JGrMnJfCT8nOVN0bq3B4z8r1lXcp7JbpK2hmq5GmqaQUlVBRVdBJMzO8sSvUwtThmbsCOaNGMRjSPLryseO6GHGGHGGHGGHGGHGGN/lf8gfiUHXKD12ebEY+gMZmxhGY6k6bV3mUKYZvXzwaEdKwredp8fDWJgLwhlU3Kzd6mu49RQVFD+ocTX1p9/cUfo6m3nuFPHbfdViaNDNHkmkBlDRhXGfUMQwJzOZOZx8lF38RviBjmWq5ip9n3er3sL5LcIqyqS2VgaoE7SRTNBVyTU8mg6WjSSFkj0poRdCgQR/dh8sf/5njz/i7t1/815o35s8af4VP/19f9pi1P6cfG9/6C8f9k7T/wDksT42bxjgTyY+N28Yi02vlZvzHGKFbj8RqxsvKu0Iq74jioxxBUmWf2wxJsjydprk0WR7IqGMPxEjlVY4FOYd83LbLDyVxzPadnzxTpTBBBkzELJAqlY2L+1m0Z0anP78MSeuKncIb35Y8JfM+18h+SFqrbTVXxqmS7CSKJGlortLKs9bFHSgwlIKxRUmGnUD+btBHGpKgYErFXZ+oz0zVrVDSlcstdk3sLPQE0xcRkvDS8a4UaSEbJx7tNJ0yfM3KRk1ElClOQ5RAQ68obUU89JO9LVI0dTGxVlYEMrA5EEHqCD0IOPrNs94tO4bTTX2w1MFZZayBJoJ4XWSGaKRQ8ckciEq6OpDKykgggg4/pAalZVxvhXxs6mZIyxda7j+jVzU3AjuYstmkUI2ObELimsGTbpGVN6z6RdmJ2Nmjcirp0qIJopnUMUo9FdqXS3WXji03G6zR09DHaqUs7kAD6hOnzk+gKM2Y9ACemPjJ8gdhbz5M80uQNmbAtlZd901vIF9SGmpo2kkYm6VILHLokaZ6pJZCsUSZvI6oCwhNhPMiaL/AHJ8yea4WTouKnuKIzGGrlWtSQw9qmcE0Z8vNRsw5ZuO87N7nrKD1qeGbG7RKZUBAVUFUHCml2W8ASXjmG9I0FralWGiR/ZdqaIlgxB9BqpipjHz+tSrGzfJvHDyUnG/w4OM6mC679jv8tz3PVUp71LDfK1FhkhV1yDpYrYkorJBmCEIIjlSWFMX+Vdrdl83lkWuWc+5kyDDyT9zIHrdvydd7HWGqjh0o7BCPgJqdfxbJm1VU6IJJpgRIoABQAADlN7purcl7DLda+sqIWYnRJNI6DM55BGYqAPUAOnqx9KWwuBOE+MGhn4/2ltu0XGGJYxU0lsoqepYKoTVJPDBHK7sB7bsxLkktmTi/jwGbpauas4t2EhNgcyVrGErbL/T5Wusp1vNrKysfH12QaPHTcYqKkUypoOVSkHvEo9R+gB5PPA+89sbXtdwgv8AWR00stRGyBg3tAIQSNKn0HHJf4snjTzpztvraFz4j23W3ygt9pq4qh4GhAikkqI3RW7ssZzZQSMgR09OMzMysk4l5VwicFEV5J8skoHXodJV0qdM4dQAehimAeVrmIaZ2X0Fj/y47bW2N4bdBDKMpFhQEfIQoBH7hxp58LW7Oq+uekWw+Nc2ZmrOPbzbco32brlcmW84q9lYqUxHRIGPetzxsS+bFSdTEW4QKB1Cm70h6gAdBGzHDW9Nr7d2VcLbeqyKnrpaqVkRg2bK0ESgjJSOrKR6fVjh58Szxl545k8ntn704y21XXja1vsVDDUVELQBIpYrtXTyIwklRs1hljc5KRkwyOeYxl05WPHdDGoHxpbq6tYb8U2yODMnZlrNQyzcP+Yz7tUmSbzikpL/AHvxPEQVb9soyiXTAvxaXbnQT71i9Dl+t2h9PLNcb7z2vZ+LLjY7nWRQ3Wb3vRGQ2pu5AqplkpHtMMh1xw281/Gfnbkfz22XylsjbddcdgW79Hvea2NoBFF7pdZp6nUHlWT6qJg7ZIeh6ZnpjhXiJ8t9F1YpM5qrtXEvZ7XWyvpl1XbG3hRtZKH96iHTt9as1SBJy4sOO7GdZV0om0QcOm7pdx1bOk3Q+3wfEvLFDteifa26UaTb0jMUcLr7Wv8A0iPH1LxP1YhQWDFvZYN7Mp/EL+Hzunnfc1LzzwLURUnMdFFCtRTtN7qa73Ug0lTTVearT3CnAWJWleOKSJIfroHgHenhOawfLmXqSc5CY50p1RjJJY0mtUIPNllrUaQy4mcLJNqhYUVrdEoqG69GiHoEQ6gmkmmUCkDep9s+PFdIbgldDFEx1dtal0HXr0jf6xf4oyy9AA6DFVLXzj8ZHatEm0Kra1yuFdCvaFXPZaapkIX2QWq6ciklI6fWvrL/AE5HclmMKcsZc8WWL95PHo+0ud16rYpwplB5PZ2yKnC5C9s5BedpqsU+lLTfGq9ut6cO1iX5wMkC7NuDgQb/AEKGANLut24vtm99vvs0xxWqiqi1TNplyObR6SzygySaQrejNRn7PpOLM7A4+87t8+LnL9L5Kx1lfv3c1jSCx28zW/UumCsEqRUtCy0lIZmlgBDaJpO2O91RTjj/AJ5Nl8FbQ7L4luWAskQmTKxA4LYVmXmIJGTRbMZ5K/3qVUjVSyrCPWFcsfJoK9SkMXtVD6evUAxHOu5LHufclJWWGpSppo6EIzLqyDd2VsvaAOeTA/u4kT4UvCfKnBnCe4Nt8s2Wqsl8q90yVMMM5iLPAaChiEg7Uki6TJFIvUg5qemWRxXXofe6ji/c3WHIl+nGlZpVLzXQbHabA+K4OzhoOKnmjqQkXJGqLhyZFq3TExgIQ5ugfQA8j3YtdSWzeNsuFe4iooa2J3c55KqsCScszkB8gxcXyr2ruHfPjZvjZ206WSt3Nc9s19PS06FQ808sDrHGpYqupmIA1MB8pxc75W/IxjRbenUDaLUPJdcyi6wZT1VJFWNJMtYtdytbJsZmoSx38fHPCM7PVJRdm4MiUTFbujCUwHAOkx8qch2074tG59pVMdU1DD1y1BSe42qNswDk6MVOXqY5dcc2fAjw33tH4s8icF+Q1krbFBum4gRiQwtKqilh7NXEI5JEL01VEk0YcgGSIagVzxO6/bOeEbylQlSt+yk8liTLtfhEIcTXSUsWNbrX2B1VHq0AW8RKa1CulcQlHThRn7hVwqh6h1AQaGXUIbea/cvCvKEEVXuSQUl2jQL9YzwyIPSV7i/VSIGJK5kkZk6ULEGqu0+EPideCd0uG3uFaRtwce1lU038zip7lRVEgARZ/cpSK6jqGiWNZu2savpVDLULEjL/AKYtzL4LPGJ94MnYQvrXKGV3sK8hmTmpzNgzDfX8csZNdxAwUkYrPHlRRfqtiAs5UXjjLkACHWUL0T5/bXeOD+M+5c7JOKq6shUGNnqJSPSVU9Io88upJTMdCSOmPxvrjf4pvnD7nsfk+0vYtgxVKTOtVDT2ihjkAKrPPGC9wqzGGOiNUqAjHUsaNm+KkNQfIJWsieYdluxslZYnFdMnSZIQFWQVfyEPSa5+6afpVArALMGCrl2q3akZtlXBGyYOniii5iJ+oYAifaO/6a4cvLvTcciUtHJ3h1zKxp2GjiTMDM5DSCQBqYlshnjoN5D+I172f8OiXxl4Xoqi/blpTbmyjEcc1bUfnWCtr6nTJIFQMxmkWNpGMUKpEGfQCeAeZfOOKNh96rtk7C11i8gUOSpOOI1jZYdN+kxcPoesNWUk3ISRaMXQHaOiCQ3VMA6h9AiHMBzFe7VuHfE1zs0y1FA0MIDrnkSqAEdQD0PzYlv4bnF+/uHvFi2bH5Ltk9o3XDc7jI9NMULqk1SzxsTG7rk6kEZNnl6csV34jyVPYayrjTLtXKgeyYuvtRyFApOwMLRaXp0+wsMe3eFIIGOzcOY8pFSh/OTMYP5eR9ablPZ7rTXaly95pZ45Vz9BaNg4B+YkZH5sXB5C2VauSNhXvjy+lxZb7aau3zlMtaxVkElPIyE9A6rIWQ+pgDjYrk7Y/wALflVpWPrZsfkZtirIdHinCZYq3WmXxhdaoWWBs7m6wE8dqanXmFO+alUbqNzOzkHqZMGyiyyQ2+ue4+GuUqKnq9xVApbhAp9mR2hkTVkWTVl25VzGYI1fNpJYY+czZHDPxK/Azc132/wzZnv2z7pOpMtJSxXOiqjFqSGp7AYVlDMEYrIsgiB6BzOkcTioTElj8RWLPIRshSsgRMffNF7RjasUbFVocxN7u7aFuSMTi6SsdqJPN/TyfDLL2ONn0PikQmJw9wYiAFYqFEIktNRxLa+QLjRV6LPseWmSKByssgWQLAXfUPrlJcSjXGPXkuSHHQ/kGzfEK334h7M3NtGomtXlLQ3qprrpTLLQ0TTUbS3OOnpTA2dsmVaeSgf3arbI9sNLqqkINjsJrD8uTASjTIps5VCah2K6cqjSJvNtskotT25gcJNndUSTSvUggBigBmq6inrAHYoQ4CYoyJDtnx3glFx9+heFTq7bVMhXp1yKf6Uj/wAEk5+gg+jFNLnzj8ZO7UMmzhta401xlUxGthstJHKNXslkqiTQxt6cpUVdH0kZSAwr080flDxvuZ+77Aeujd6pgbFc2a1ObS+h3NcRu1xbxD2twJ63XHqDORh6pVa9JvEm5naDZw5VfKALdFNBMy0f8y8nW7ePu9h26G/MVK+suVKdyQKUXQhAKoiMwGoAksfZAUE2++Gp4M708bfzvyzzG8Q5Wv1KKVaVJlqDRUbSpUTipqEZ45qqqqIoXkETyRxrAh70jyusdCHIIx1hw4ww4ww4ww4ww4ww4ww4wxPPQHyC5h8fuVV7xj4qNnpVnIyj8m4tmHq7SAu8SyVVO0XSdIpuDQVphgcrDHSZEVjNxVUIoksgqqipvWwt/wB32DdDW2/KWilyE0DEhZFHoOfXS65nQ4ByzIIZSVNUfLXxF468uNhLtfdxah3NQl5LbdIUV56KVwA6lSVE9LNpQVFMzoJNCMjxSpHKmj+2bF+CzybtGNvz+eJw1mVRi1bycpdFJnEl9aCgim3Ii/yHXTK4+vLFsVP0mgyLp6qigUv9Q26gQLF1e4eD+S0Wrv2ijvBUBmk1QSjLp1lT6qUD0LrZiB+9X0Y4zWDhz4pvhDUS7d4lFRuTjcSs0UVGIbtQvqJYmO31AFfQuxOqUU8UKPIT9bNlqPpHpvAfq8nAW+2ZqkNrZbHrFq3xvS7Fka3bJMYRGLRSSjoSs06L9HFDBq2bNiJt05cEmKJUygUxBAvPA54I2wI6urrWustOoEMbzSVgUKOipGv1AAAAAkyUZDqMZOmX4sXOb1e3tv7Zh2Db7vKzXGsp7dSbceZpWJkmqayXO6yMzMzSNSF53LMSrZnFKvk18ruR9/ZaOpUDCuMW65U+SCQq2OSPE3EtYpRskq0ZWq/O2fYxcSTZoqcrKPbALKMIqcpTuFBFwaGeSuVLjv2VaKBDS7dhbNIc82dh0DykdCQM9KD2UzPVj7WOmHhH4DbM8SrfNua61KX3mS4w9uquJQrFTxMQ70tAj5usbOFM1RJlNUlFJWFMoRUlyJ8dBMOMMOMMOMMOMMOMMaU/H1rHr5kTUnFtwvWHqFa7RLLXsJKem6+zfSb0GGRbZGsgcOlSCooDVgzSRJ1/mpplD+TnK/yT5Y5K2xzPd7Jt+93GjtEK0miGKZkjTXRU7tpUHIanZmPykk44r+XXN/LuzvIK+7d2tuO7UFip1oe3BDUOkady30sj6VByGqR2c/KzE+vH5hJfx6T2G9oM3s9W2SdU1MyNlfGORo9zj6kksM1PYej4mSszulNErUtGyMQ+QmUgYKPncasqcpgVSRAAE2YuW2PKG18h7J40qN4Z33flntdyt8i1tYYIYLtJLHTJWMaUSRyo0LGdYIqhFBXtvISQKcQeZ/NE9nul7TdW5hSWmpnhmBqDrZ6cKXMY7uRUhhpLMhPXMLj5zKuRPGhhfFesOZsg64xEPQtqSUpxTpT931NUNSo+8ViJtrKVyUQ1nTTiI+IiJcgvzxp5YyJ01PTKqUoGNl9i8deXPI2+d68dbT3S9RunYxrFq4vfase+SUVTLSvFbj7sTLJLLEwgFQKUMGXUUYlR69182uX7LarZebhu3cqUF17Zjb3g/ViVFkDTfWeyFVhq0dzLI5ZjrjsqdM0OV2mJqOlrTWFMiqYSLntOwJ0eqHoalNPbAp5GJJUs4M6ewnkh9UEgjfai3+t7ju+pyO3q/I9ODzz4+66kbQG5fzGYDV1IrRVil97LmLs9kQCP2dXvHd7nTtafaxmR5ec3HdP6JDdm4zcTRe9a/eW7Xb7nby1dzVrz65aNOX77Ppjy9dqBorszC5InaHrPWIlpi/MV6wjPp26jVdg5eWvH5owszIQ5IaZnknFecjKp+1VWO3cn7Td6CfQOvg5cufkVwxcbPa90bsqZ6i97eorzAaWrqHVKWu7nZjlM0MBWde03cVBJGMxplfrl+tu+XXOG5oameg3ZuNEpayWmfuVLAl4tOorpds0OoaScieuajCHoGi03sxb9VWus9YTyFS8WwuW5SZcUarkpjitzs0jBNGUfIpzKs2rNpu1wMompHJIAn1EqxjfV4uF08irbwxb+c592VJ2lcr5NaooVq6g1a1EEJmd5IzCIRCVUhWWoZy3QxgdcIfLnnCfcs21U3ZuP84Q0qzsxqW7ZRm0gA69WrM9QUAy9eIlXfY/xe0q7XCvl1Lt9xx9je0BS8m7FULXgtm17x3aU3hY5/D2i+ISCL1NeLkFUkVTtI50ioddP0DrFN3BPW2uB/Mbcm27fdTvW127dl4ovfLdYK6++7X6vpincSWmoWjKFZIwzqJZ4nUI3dWMjI6nW+dnLVFWzU/6U7tmt9NL25quJ5XpIXzyKvKHzzU5AlUYEkaScdd2cnNB9YpTB8E800nM3zmwrW5vcZQmu2IqnkiYmGlGjKxNSzlOLcWqvPnyDiHtaLpuZgm8AzZBdRT0yEKJ9B4W2r5Kc1UO5rnT79ods2zaT0iXGa/3Opt8UT1slTDEpkWlnRGWWleKQTtCRI8SLrZiFy+5vNDmzbMtDA+5t1109wEhhWkmaZmESozHSZUJBVww0hugYnIDr4H3j0gjdaMqbRXzQHKOIqjiWTQjpqj5cwDW6DlGeQcrVlqjN1OtTNtTjJSBO7tCaIOVZBsAqtXJAATJgB/a/RDyDrOZrHwltbk/b9/v9/haSGstV7nrrbAyipYw1VRDSmSOcLTM5jWCQhZIWJyc6fH+ujznHtqq3RX3/AHlSUlIwDRVDtFOwOgao0aXSy5uBmXHVWHq6+we2nxspU/U++RGvFdtNZ3Gvlaxzi+Qr1Bqa3wayWRUWgpXtKRsEYeHSgJRNZnJFZhIrt3TdUhUlO3qPqU2zPLOTcG/Nr1+5p6G9ceWuouFyjnrKkd6npxrzojHBIJTPGVmpzL2EkikRi6Z5DyP5p8wijtNfFu7cktNeJ0hgKVLHS79Prc5F06GzV9OshgRkcsem2HvPj117yS4xAGmttzjkmJqLe/W+p684DZ5Hf0KlOlVEW9muiysrAsYeMOYhRMIKqqJEWROoUhFkzGyHEmwfKDlnZycgHftr2zs6ouDUNLVX69Nb0rqxQC1NRgRTvNIATkNKqxSRUZmjcDw7h81+aNv3I2j9Jt211ySESyR0kkkxijPQPJ7ahV/dJAIJABGfn3u6+NOm6q1TcOJ12h8l4nukrAwdfaY6xpX390eTU7NuqyESNeskzV0iSUVYWK7J2h7n1CuEhKmCodoj6u19ieW+4uc67x8r9zyWbfltgnmnevr50o0hghWo7vfp4akmOWndJon7ekowLlOoHkrvNbmCj2rFvCHd25am0zOqoIahzIWZimnQ7p1VwVYZ55jpnjy8Mr6hZeSyG6kfG3nPCEfjmlSN4fyuwGtMTjWLsLKMKdR1DVN8vZ5NCWsQIJmUBucUCemAmFQADng5FsfNnH8lpgo+W9qbmq7xco6JIrFuCS4yQPIQFmqkWmjaKn1EL3BrOo5BCcfqzeZfPd3FQ8l73tQx00BlLVRkhVwvpWMmRgz5dcunT1447g/Y3xm5ps2Na6902vWFGOaHhonDl5zngKFqON8pTpTikEBSrxCWS1QcnKKL9qKYGUSSUcKpoEUMsoRM0hcl8E+XfHFlvN3pt+2fclTtyPu3aist6lqrhbIMs+/WUU1PSzRxBc2YhWZY1eRlEaM4w9k86+Xr1U01O+5t30SVp008tS7xwzt/AjlWR1Zs+g6gEkKDqIGOweQ/WfX/ABxqhkC3UPEFDqdnjpOkJMZ2DgGbCSapvrpBMXhEHKJAUIVyzcHTOAftIYQ5E3jNytyRujmO22XcV7uNZaZYqovFLMzoxSlldSVJyOlgGHyEA4vV4e828t7z59tG3t17iutwsk0FaXgnnd42KUc7oWUnI6XVWHyEA4zc86k47P4cYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYY1j+Mf/ACTYd/6fI3+KV15xt8sP7+75/Fov9n0uOAnm/wD4m9x/xLd/suixTHZs607XfDPlR01ypGXuG2Dz9slsRcsG0mPx/cZ02V65m5hW4WmytSlYmGdRCrXtiDOlxcrtzCgoUiBVnAHQL0ysvGG4eXOReDfIjY81rqOJ9q7OsNJeqx66kh/NlRZnqJquKqilmWUN9aI07aSDWpaQxwlZTytqr7R7es26dm3RZ03BX3KrkpoxFI3fSpCLG0bKpXL2dRzI6HJdTZqJHbR4NaS+I/DJrnmaugqgrL4zxJkmtODEFRu6a4Ci6tZGCa4FP7d/HPkFfRXJ9dFdMqhBAxSiEP8ACPJtRb9/eRfL3HVXlKtPcbpb6hc8mVr5JU07lempJEZdaHo6MyMCpIxse6LGk1p2bt28x5qXhgmQ+oilVHGfqIIORHUEAjqMc30Jr2YcdeV2cwbmhwrNTGvelVgw/Sbw4KuDjImJYnL9ZsuMLY5FUBR92Sp2pvGLESOqVFaNMkdQ65FTDuHlNduPd3+CdNybxyi01v3byRBdayiXTpoLpLaqmnuVKuXXSaqlepQsFLpUK6qsbRjGN2HT3i3crPY7yS81vsr08cpzzmgWoR4ZD6s+24Q5Z5FCCSwOPrtAd+NTNcnOz+G8zZX+5uSLRvnn6Zgq59xclWH30bY52uwEK5+L1WnTkC295LRThLsWdJqJ+n3KFKQxTDgfKzxY555fh2TyHx1Yvzjs+h4tscM9R77boNElPDUTzL2qmrhnbRFKjZpGytq0qWYED29gb92ntxrnZ7zV9m5S36qZU7Uz5h2RFOpI2UZspHVgRlmchkcTCoH8ZbPv+iXHX+Ikfyvm6/8A+du1f/2TcP6hJjcLf/fHcP8AUkP8qMQP1m2iw/ppr1kzSPZfFV2yPsMyy/khs010c4ln7ersLBXC1g8hbFXV3lcm6VYa5NswUWTUeuDe5TaCZIqpRII2i5n4S5B8ieWrL5KcM3222fiWTb9vZr+t0gpBYZ6Sl0TU9QqVENZT1EL6UZYYx22lAkMZDAaJtndFn2bt6p2TuWknqdwrWTAUhgeT3tZJM1dCUaN0YZkFj7QXMA9MfYeVV/jSrZe8WjvKt3yBqNjaKgtjkJ6y4LkX8HecONgxzh9nGVulP6LVbE5ZIM5Q7eEU+HxSiIsFVClImiImJr3gzS7zvmwOcINjWy07/wB4z1W32gp71Gk1Fdm/OF2eSorEramnV2eISVi9+pVxOqMWeQBW9zlSS20t32s91nqLRbUjrAz0xKy047NOFSMxI5ADZRnQhGgkZAdR7/OGRME37w77Uo6/7F5i2gqlScNIKWyZnaQuMxkMbC7vePLEtAvpe60uiyT+Pi42bbe1FJmZBJJQEwUMYpwLiuNNo8obV+IRsaTlbaG3tk32vRp4rdZY6SKg7C0VfTidIqOsrY0kkkhk7uqYOzLrKBWUn2L3cbFX8P3UWC41l0pIiFaaqMjS6zLE5UtJHESFDLpyXIA5Z5g4h/kjD961r2n8e+MYRiK2seW9qMCbEYsFMi5WuOMjTI12Jy5jhkUCizaxEnJPms0wapggi2QWFNEhxKuYtgtncg7Y5k4P5Z3rcpdPNVg2NfLBc8yuq4W+H3iW1XB/37SxxpLRzyNreR0DyMoMQbT7lZ67be6dv2yFc9s1d1pauD05QzNoWohHqCsSsiKMgoOQB9rKWPkKtuAMfbU2a73bJGyujGZY/FkGzoGzuNoiw23Fuf2INVHiFBs1RrsHLNpqSq8sB0jt3y7BNRNmQy6wEIzEII8TLDyruzg2i21tuz7N5O47mvkz123LhLBS3KxPqCNXU9VUTRNDHUxZMskKTsrSssUZZqgHbOQauwW/dUtbW1Nysd5WlURVsKvJBVDLMRPGisGKN0IYoCFBY5BMfCbR3PIV28MWHbpnypnwxcpXK+MHtvTrFWTx69aRLbJ8shH3+NqsXHlGuzE9V2zeXAiLMgGcresggVI6SYbPwjtzaW2/iL7h25xZXjce3YLFckpDU1Jr0eVrbE0lDJVSyfziGCpaSlzeUkRp25ZWdXc+huituFbw1R1t+i9yrHq4TJoTtEKJmAlCKPYZkAk6L9I5qoBAxKHUnK2qNlxptXT9fN2Nntup5XD81ZZ5tsnP5Is69JiIuAs8WkvT312xhj5nHJTTybKV8kidyquLdAwlKVIRGE+e9i862beexdwcscbbK2Ba13BDTwNt6C30y1kss9NIRVpR3KveQwpCTCzrGqCSUAsXyG0bSuu1Km23Wj2/e7nd5zRs7CseZzGqo65xmSGIDUW9oAknJfRliuHGmXqZtXpfoDpDgRCw5Az1Rcy41ueTVGFOtTGu4MrdJsNulZe4WS5y8Iyr5TnjZkE2osHDoFiisl3guZBBxcDeXH+4uDPIzlbyW5TaktPFl027caS3B6umeovVRWQUsUVJT0kUzz5CSHVJ30iKERyaTEJJYo5tt3o91bMsGyLCJKi/QVkMk2UbhKZI3kZpHkZQnobJdJbP2hnq0q13/lE/yXZN/wB7Y9/t9XOctfEj+/a0/wDoaz+pz460eDH+JWyf0e4f1CoxlH52Jx3xw4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4wxaHrj5ObXrrhyp4fjMUV6zMqoewHRm39lko908+P2WYsigKtG8a4SS9srLmSL0OPcUgCPQR6cqTyh4nWfk7fFbvarvNTST1ghBiSBHVezBFAMmLqTqEYY9OhOXqxRnmXwgsHMXI1w5Err/WUNTXinBhSmjkVOxTQ0wydpFJ1CEMcwMixHqx2/9aa9fkVUvxjMfY3NA/UR29+Ia37tF9riL/2aW1fxVcPucP22H6016/IqpfjGY+xuP1EdvfiGt+7Rfa4fs0tq/iq4fc4ftsP1pr1+RVS/GMx9jcfqI7e/ENb92i+1w/ZpbV/FVw+5w/bYfrTXr8iql+MZj7G4/UR29+Ia37tF9rh+zS2r+Krh9zh+2w/WmvX5FVL8YzH2Nx+ojt78Q1v3aL7XD9mltX8VXD7nD9th+tNevyKqX4xmPsbj9RHb34hrfu0X2uH7NLav4quH3OH7bD9aa9fkVUvxjMfY3H6iO3vxDW/dovtcP2aW1fxVcPucP22H6016/IqpfjGY+xuP1EdvfiGt+7Rfa4fs0tq/iq4fc4ftsP1pr1+RVS/GMx9jcfqI7e/ENb92i+1w/ZpbV/FVw+5w/bYfrTXr8iql+MZj7G4/UR29+Ia37tF9rh+zS2r+Krh9zh+2w/WmvX5FVL8YzH2Nx+ojt78Q1v3aL7XD9mltX8VXD7nD9th+tNevyKqX4xmPsbj9RHb34hrfu0X2uH7NLav4quH3OH7bD9aa9fkVUvxjMfY3H6iO3vxDW/dovtcP2aW1fxVcPucP22OE7J+TK1bH4gseI5TFVfq7KxOoF0rNMLJJSLpsMFOR82mRNo4jW6SgOFGAJmETh2gYRDqIdOSHxZ4pWfi7e1LvSkvFTVz0qTKIngRFbuxPESWV2I0h8x06kZYlXhbwksPDPIlHyFQ36srqmjjnUQyU0cat34JICS6yMRpEhYdOpGWKw+WyxeHDjDDjDH//2Q==\", t.ErrorImage = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQIHWP4zwAAAgEBAMVfG14AAAAASUVORK5CYII=\", t.PiechartBack = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAMAAADmtEJjAAAAYFBMVEVMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgUIAAAAH3RSTlMACbeu3XUBgH/vy+gqMRghOfqXYUpWwkDGihCfgmebkGEUkgAAAQVJREFUeNqV0ttugzAURNEx2BADBMItTXqZ///Lyi0qrXOkZvajtcbyg2F1gtSJIqfIKXKKnCKnyClyipwip8gpcmo8FaNvitewdtV/PB8WYRD4V83sBJ5q50rgqW2QOBlHiZOXUeJkewZQ8/kKiIOrOCigDS5ncbBCG9ygDUqYgxhpt8EcALh3Syjb3L/AHAB7/a3N7jcHOHIhZu83BvjduTj8BHOAP1XTjw8wB8gG5fGBzAGynN//g4M5QN7y7Rs8VJu+8ky9wR7gocBUD2tg+TFxD7Pa8C75GnbWeSQ54Pk8WULzV8VHNgp35Kr4nk2l+JkLlD42SPle4t0Eqfe75jvsfQLbYGzTrP2yIAAAAABJRU5ErkJggg==\";\n        }(l = n.Resources || (n.Resources = {})), function (t) {\n          var e = function () {\n            function t() {\n              this._dict = new Object(null), this._count = 0;\n            }\n\n            return t.prototype.add = function (t) {\n              var e = this._dict[t.id];\n              e ? e.push(t) : this._dict[t.id] = [t], this._count++;\n            }, t.prototype.remove = function (t) {\n              var e = this._dict[t.id];\n              e && h.Helpers.removeFromArrayHasty(e, t), this._count--;\n            }, t.prototype.contains = function (t) {\n              var e = this._dict[t.id];\n              return e && e.indexOf(t) >= 0;\n            }, t.prototype.clone = function () {\n              var e = new t();\n\n              for (var i in this._dict) {\n                e._dict[i] = this._dict[i].slice();\n              }\n\n              return e._count = this._count, e;\n            }, t.prototype.count = function () {\n              return this._count;\n            }, t;\n          }(),\n              i = function (t) {\n            function i() {\n              var i = t.apply(this, arguments) || this;\n              return i.centerX = 0, i.centerY = 0, i.zoom = 1, i.hoverNode = null, i.hoverLink = null, i.hoverItem = null, i.lastClickedNode = null, i.selection = [], i.selectionSet = new e(), i.notifyChanges = !0, i.lastNotifiedSelectionSet = new e(), i.autoZoomMode = !1, i.layoutActive = !1, i;\n            }\n\n            return r(i, t), i.prototype.xyInChart = function (t, e) {\n              return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height;\n            }, i.prototype.toDisplay = function (t, e) {\n              return {\n                x: (t - this.centerX) * this.zoom + this.x0 + .5 * this.width,\n                y: (e - this.centerY) * this.zoom + this.y0 + .5 * this.height\n              };\n            }, i.prototype.fromDisplay = function (t, e) {\n              return {\n                x: (t - this.x0 - .5 * this.width) / this.zoom + this.centerX,\n                y: (e - this.y0 - .5 * this.height) / this.zoom + this.centerY\n              };\n            }, i.prototype.toDisplayTransform = function () {\n              return {\n                xm: this.zoom,\n                xa: this.x0 + .5 * this.width - this.centerX * this.zoom,\n                ym: this.zoom,\n                ya: this.y0 + .5 * this.height - this.centerY * this.zoom\n              };\n            }, i.prototype.objectRemoved = function (t) {\n              h.Helpers.removeFromArray(this.selection, t) && (t.selected = !1), this.hoverNode !== t && this.hoverLink !== t || this.setActiveObject(null, null);\n            }, i.prototype.addToSelection = function (t) {\n              return !this.selectionSet.contains(t) && (this.selectionSet.add(t), this.selection.push(t), t.layer.touchNodeOrLink(t), t.selected = !0, !0);\n            }, i.prototype.removeFromSelection = function (t) {\n              return !!this.selectionSet.contains(t) && (this.selectionSet.remove(t), h.Helpers.removeFromArray(this.selection, t), t.selected = !1, t.layer.touchNodeOrLink(t), !0);\n            }, i.prototype.setSelection = function (t) {\n              for (var i = this.selectionSet, n = this.selection, r = new e(), s = [], a = !1, o = 0; o < t.length; o++) {\n                var l = t[o];\n                r.contains(l) || (r.add(l), s.push(l)), i.contains(l) || (i.add(l), l.selected = !0, a = !0, l.layer.touchNodeOrLink(l));\n              }\n\n              for (o = 0; o < n.length; o++) {\n                l = n[o];\n                r.contains(l) || (l.selected = !1, l.layer.touchNodeOrLink(l), a = !0);\n              }\n\n              return this.selectionSet = r, this.selection = s, a;\n            }, i.prototype.setActiveObject = function (t, e) {\n              if (this.hoverNode) {\n                this.hoverNode.layer.touchNode(this.hoverNode);\n\n                for (var i = 0; i < this.hoverNode.links.length; i++) {\n                  (n = this.hoverNode.links[i]).layer.touchLink(n);\n                }\n\n                this.hoverNode.hovered = !1, this.hoverNode.locks--;\n              }\n\n              if (this.hoverLink && (this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to), this.hoverLink.hovered = !1), this.hoverNode = null, this.hoverLink = null, this.hoverItem = e, t instanceof u) {\n                this.hoverNode = t, t.hovered = !0, t.locks++, this.hoverNode.layer.touchNode(this.hoverNode);\n\n                for (i = 0; i < this.hoverNode.links.length; i++) {\n                  var n;\n                  (n = this.hoverNode.links[i]).layer.touchLink(n);\n                }\n              } else if (t instanceof c) this.hoverLink = t, t.hovered = !0, this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to);else if (null !== t) throw \"scene.setActiveObject invalid active object type \" + t;\n            }, i.prototype.getVisibleBounds = function () {\n              var t = this.fromDisplay(this.x0, this.y0),\n                  e = t.x,\n                  i = t.y,\n                  n = (t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height)).x,\n                  r = t.y;\n              return new h.Rect(e, i, n, r);\n            }, i.prototype.disableSelectionChangeNotification = function () {\n              this.notifyChanges = !1;\n            }, i.prototype.enableSelectionChangeNotification = function () {\n              this.notifyChanges = !0;\n            }, i.prototype.notifySelectionChangesIfNeeded = function (t, e) {\n              if (this.notifyChanges) {\n                for (var i = !1, n = 0; n < this.selection.length; n++) {\n                  if (!this.lastNotifiedSelectionSet.contains(this.selection[n])) {\n                    i = !0;\n                    break;\n                  }\n                }\n\n                (i || this.selection.length !== this.lastNotifiedSelectionSet.count()) && (t.events.notifySceneChanges({\n                  selection: !0\n                }), t.notifySelectionChanged(t.createEventArguments(null, e)), this.lastNotifiedSelectionSet = this.selectionSet.clone());\n              }\n            }, i;\n          }(h.Scene);\n\n          t.Scene = i;\n\n          var n = 2 * Math.PI,\n              s = function () {\n            function t(t, e) {\n              this.node = t, this.nodesLayer = e;\n            }\n\n            return t.prototype.postProcess = function (t, e, i) {\n              var n = this.node;\n              n.targetHWidth = n.targetHHeight, n.bounds = new h.Rect(-n.targetHHeight, -n.targetHHeight, n.targetHHeight, n.targetHHeight), this.sizeScale = n.targetHHeight / t.nodeLabelScaleBase, this.postProcessLabel(e, i);\n            }, t.prototype.postProcessLabel = function (t, e) {\n              var i,\n                  n,\n                  r,\n                  s = this.node;\n\n              if (null != s.label && this.nodesLayer.chart.assetsLoaded) {\n                var a = s.label.toString();\n                if (0 === a.length) this.currentLabel = null;else {\n                  var o = this.currentLabel;\n                  null == o ? o = this.currentLabel = new h.Label(s.labelStyle, !0) : o.style = s.labelStyle, o.text = a, e.measure(t, o), r = o.style.scaleWithSize ? this.sizeScale : (o.style.scaleWithZoom, 1), i = 0, n = s.targetHHeight + o.hheight * r * .8, s.outerBounds.addBounds(i - o.hwidth * r, n - o.hheight * r, i + o.hwidth * r, n + o.hheight * r);\n                }\n              }\n            }, t.prototype.getAnchor = function () {\n              return {\n                x: 0,\n                y: 0\n              };\n            }, t.prototype.adaptToViewport = function (t, e, i, n, r) {\n              var s = this.node;\n              this.x = s.x * t + e, this.y = s.y * i + n, this.hWidth = s.hHeight * r, this.hHeight = s.hWidth * r, this.zoom = r;\n            }, t.prototype.isInViewport = function (t, e, i, n, r) {\n              var s = this.node.outerBounds;\n              return this.x + s.x0 * r < e && this.x + s.x1 * r > t && this.y + s.y0 * r < n && this.y + s.y1 * r > i;\n            }, t.prototype.paintSelection = function (t, e, i) {\n              var n = this.hWidth * (1 + e) + i;\n              t.moveTo(this.x, this.y), t.arc(this.x, this.y, n, 0, 2 * Math.PI), t.closePath();\n            }, t.prototype.paint = function (t, e, i) {\n              this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !0), this.paintDetails(t, e));\n            }, t.prototype.paintBasicShape = function (t) {\n              var e = h.Graphics.beginStrokeAndFill(t, this.node);\n\n              if (this.hWidth !== this.hHeight) {\n                var i = this.x + this.hHeight - this.hWidth;\n                e.moveTo(i, this.y - this.hWidth), e.arc(i, this.y, this.hWidth, -Math.PI / 2, Math.PI / 2, !1), i = this.x - this.hHeight + this.hWidth, e.lineTo(i, this.y + this.hWidth), e.arc(i, this.y, this.hWidth, .5 * Math.PI, 1.5 * Math.PI, !1), e.closePath();\n              } else e.moveTo(this.x + this.hWidth, this.y), e.arc(this.x, this.y, this.hWidth, 0, n, !1);\n\n              h.Graphics.endStrokeAndFill(t, e, this.node);\n            }, t.prototype.paintDetails = function (t, e) {\n              this.image && this.basicPaintImage(t), this.paintLabel(t, e);\n            }, t.prototype.basicPaintImage = function (t, e) {\n              if (void 0 === e && (e = 1), this.image) {\n                var i,\n                    n,\n                    r = 0,\n                    s = 0;\n\n                if (this.node.imageSlicing) {\n                  var a = this.node.imageSlicing;\n                  r = a[0], s = a[1], i = a[2], n = a[3];\n                } else i = this.image.width, n = this.image.height;\n\n                h.Graphics.drawImageInSquare(t, this.image, r, s, i, n, this.x - this.hHeight + this.hWidth, this.y, this.hWidth * e);\n              }\n            }, t.prototype.paintLabel = function (t, e) {\n              var i = this.nodesLayer.style.nodeLabelScaleBase;\n\n              if (this.node.hovered && (i = h.Helpers.toleranceMin(i, this.hWidth, .9)), this.currentLabel) {\n                var n = this.hWidth / i,\n                    r = this.currentLabel,\n                    s = 1;\n\n                if (this.node.labelStyle.scaleWithSize ? s = n : this.node.labelStyle.scaleWithZoom && (s = this.zoom), e.measure(t, r), r.hheight > 1.5) {\n                  var a = this.getLabelPosition(r, s);\n                  e.paint(t, a.x, a.y, s, r);\n                }\n              }\n            }, t.prototype.getLabelPosition = function (t, e) {\n              return {\n                x: this.x,\n                y: this.y + this.hWidth + t.hheight * e * .8 + (t.style.margin || 0) * this.zoom\n              };\n            }, t.prototype.distanceToEdge = function (t, e, i, n) {\n              return t;\n            }, t.prototype.hitTest = function (t, e, i, n) {\n              var r,\n                  s = this.node,\n                  a = s.renderHheight * i,\n                  o = s.renderHwidth * i,\n                  l = s.x,\n                  u = s.y;\n\n              if (a < o) {\n                var c = o - a;\n                r = h.Geometry.distanceToSegmentSq(l - c, u, l + c, u, t, e);\n              } else r = (t - l) * (t - l) + (e - u) * (e - u);\n\n              return r < (a + n) * (a + n) ? r < a * a ? 0 : Math.sqrt(r) - a : n;\n            }, t;\n          }();\n\n          t.Shape = s;\n\n          var a,\n              o = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e, i) || this;\n              return n.validate(), n;\n            }\n\n            return r(e, t), e.prototype.postProcess = function (t, e) {\n              var i = this.node.customShape.onUpdate.call(this.node, e, this.node.radius),\n                  n = new h.Rect(i.bounds[0], i.bounds[1], i.bounds[2], i.bounds[3]);\n              this.node.targetHWidth = i.HWidth, this.node.targetHHeight = i.HHeight, this.node.bounds = n, this.node.outerBounds = n.clone(), i.anchor && (this.node.shapeAnchorX = i.anchor[0], this.node.shapeAnchorY = i.anchor[1]);\n            }, e.prototype.paint = function (t, e, i) {\n              var n = this.nodesLayer.getNodeImage(this.node, !0);\n              this.node.customShape.paint.call(this.node, t, this.x, this.y, this.hWidth, this.hHeight, n, i);\n            }, e.prototype.paintSelection = function (e, i, n) {\n              this.node.customShape.paintSelection ? this.node.customShape.paintSelection.call(this.node, e, this.x, this.y, this.hWidth, this.hHeight) : t.prototype.paintSelection.call(this, e, i, n);\n            }, e.prototype.distanceToEdge = function (e, i, n, r) {\n              return \"function\" == typeof this.node.customShape.distanceToEdge ? this.node.customShape.distanceToEdge.call(this.node, e, i, n, r) : t.prototype.distanceToEdge.call(this, e, i, n, r);\n            }, e.prototype.hitTest = function (e, i, n, r) {\n              return \"function\" == typeof this.node.customShape.hitTest ? this.node.customShape.hitTest.call(this.node, e, i, n, r) : t.prototype.hitTest.call(this, e, i, n, r);\n            }, e.prototype.validate = function () {\n              var t = this.node;\n              \"object\" != typeof t.customShape ? h.Helpers.error('If the display of an object is \"customShape\", it\\'s mandatory to supply the rendering methods for the custom shape') : (\"function\" != typeof t.customShape.onUpdate && h.Helpers.error(\"onUpdate function was not supplied for the custom shape\"), \"function\" != typeof t.customShape.paint && h.Helpers.error(\"paint function was not supplied for the custom shape\"));\n            }, e;\n          }(t.Shape);\n\n          t.CustomShape = o, function (t) {\n            t[t.Floating = 0] = \"Floating\", t[t.Scene = 1] = \"Scene\", t[t.Fixed = 2] = \"Fixed\";\n          }(a = t.NodeAnchorMode || (t.NodeAnchorMode = {}));\n\n          var l = function () {\n            function t() {\n              this.id = null, this.data = null, this.added = !1, this.removed = !1, this.visibility = 1, this.selected = !1, this.hovered = !1, this.dragging = !1, this.selectionLock = !1, this.cursor = null, this.invisible = !1, this.items = [], this.currentItems = null, this.label = null, this._labelStyle = null;\n            }\n\n            return Object.defineProperty(t.prototype, \"labelStyle\", {\n              get: function get() {\n                return this._labelStyle;\n              },\n              set: function set(t) {\n                null !== this._labelStyle ? (h.Helpers.warn(\"For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object.\"), h.SettingsHelper.updateRecursive(this._labelStyle, t, h.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {})) : this._labelStyle = t;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), t;\n          }();\n\n          t.ItemsLayerObject = l;\n\n          var u = function (t) {\n            function e(e, i, n) {\n              void 0 === n && (n = !1);\n              var r = t.call(this) || this;\n              return r.parentNode = null, r.data = null, r.links = [], r.dataLinks = [], r.isNode = !0, r.isLink = !1, r.aura = null, r.x = null, r.y = null, r.anchorX = null, r.anchorY = null, r.shapeAnchorX = 0, r.shapeAnchorY = 0, r.targetHHeight = null, r.targetHWidth = null, r.hHeight = 0, r.hWidth = 0, r.renderHheight = 0, r.renderHwidth = 0, r.anchorMode = a.Floating, r.coordinates = null, r.coordinatesCache = null, r.coordinatesCachePrecision = 1 / 0, r.expanded = !1, r.focused = !1, r.background = !1, r.loading = !1, r.userLock = !1, r.relevance = 1, r.display = \"image\", r.image = null, r.imageCropping = null, r.imageSlicing = null, r.tintImage = !1, r._anchorStyle = null, r.zindex = 0, r.opacity = 1, r.aspectRatio = 1, r.locks = 0, r.locked = null, r.fillColor = null, r.lineColor = null, r.lineWidth = 1, r.draggable = !0, r.layer = i, r.id = e, r;\n            }\n\n            return r(e, t), Object.defineProperty(e.prototype, \"anchorStyle\", {\n              get: function get() {\n                return this._anchorStyle;\n              },\n              set: function set(t) {\n                null !== this._anchorStyle ? (h.Helpers.warn(\"For performance reasons it is not recommended to set `anchorStyle` to a custom object. Instead modify properties on the existing object.\"), h.SettingsHelper.updateRecursive(this._anchorStyle, t, h.SettingsMapping.ItemsChartSettingsNodeAnchorStyle, {})) : this._anchorStyle = t;\n              },\n              enumerable: !0,\n              configurable: !0\n            }), e;\n          }(l);\n\n          t.Node = u;\n\n          var c = function (t) {\n            function e(e, i) {\n              var n = t.call(this) || this;\n              return n.data = null, n.from = null, n.to = null, n.isNode = !1, n.isLink = !0, n.multiId = null, n.radius = 1, n.fillColor = null, n.lineColor = null, n.length = 1, n.strength = 1, n.dashed = !1, n.currentRadius = 0, n.background = null, n._angle = null, n.targetRadius = null, n.targetStrength = null, n.targetLength = null, n.direction = null, n.fromDecoration = null, n.toDecoration = null, n.relevance = 1, n.toPieValue = 0, n.toPieColor = null, n.toPie0 = null, n.toPie1 = null, n.currentCenterOffset = 0, n.layer = i, n.id = e, n;\n            }\n\n            return r(e, t), e.prototype.otherEnd = function (t) {\n              return t === this.from ? this.to : t === this.to ? this.from : null;\n            }, e.prototype.commonNode = function (t) {\n              return this.from === t.from || this.from === t.to ? this.from : this.to === t.from || this.to === t.to ? this.to : null;\n            }, e;\n          }(l);\n\n          t.Link = c;\n\n          var d = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e) || this;\n              return n.parentId = null, n.scaleNodesWithZoom = !0, n.scaleLinksWithZoom = !0, n._nodes = [], n._links = [], n._nodesDel = null, n._linksDel = null, n.idToNode = {}, n.idToLink = {}, n.lastClickedNode = null, n.newNodes = {}, n.newLinks = {}, n.modifiedNodes = {}, n.modifiedLinks = {}, n.deletedNodes = {}, n.deletedLinks = {}, n.drilldownId = null, n.layerSettings = i, n.scene = e, n.clearModified(), n.styleUpdater = n.createStyleUpdater(n.layerSettings.style), n;\n            }\n\n            return r(e, t), e.prototype.onSettingsChanged = function (t) {\n              if (t.style) {\n                this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);\n\n                for (var e = 0, i = this.nodes(); e < i.length; e++) {\n                  var n = i[e];\n                  this.touchNode(n);\n                }\n\n                for (var r = 0, s = this.links(); r < s.length; r++) {\n                  var a = s[r];\n                  this.touchLink(a);\n                }\n              }\n            }, e.prototype.updateStyle = function (t) {\n              this.styleUpdater.updateLayer(t, !0);\n            }, e.prototype.postprocessStyle = function (t) {\n              this.styleUpdater.postprocessLayer(t);\n            }, e.prototype.createStyleUpdater = function (t) {\n              return null;\n            }, e.prototype.paintPrepare = function (t) {}, e.prototype.paintBackground = function (t) {}, e.prototype.findObjectById = function (t) {\n              return this.idToNode.hasOwnProperty(t) ? this.idToNode[t] : this.idToLink.hasOwnProperty(t) ? this.idToLink[t] : null;\n            }, e.prototype.paint = function (t) {\n              this.paintPrepare(t), this.clearModified(), this.paintBackground(t);\n              var e = this.scene.selection;\n\n              if (e.length > 0) {\n                for (var i = [], n = [], r = 0; r < e.length; r++) {\n                  var s = e[r];\n                  s.layer === this && s instanceof u && i.push(s), s.layer === this && s instanceof c && n.push(s);\n                }\n\n                (i.length > 0 || n.length > 0) && this.paintSelection(t, i, n);\n              }\n\n              var a = this.links(),\n                  o = this._makeHoveredLast(a, this.scene.hoverLink);\n\n              this.paintLinks(t, a), this._restoreHovered(a, o);\n\n              var l = this.nodes(),\n                  h = this._makeHoveredLast(l, this.scene.hoverNode);\n\n              this.paintNodes(t, l), this._restoreHovered(l, h);\n            }, e.prototype.clearObjects = function () {\n              for (var t = 0, e = this.nodes(); t < e.length; t++) {\n                var i = e[t];\n                this.removeNode(i);\n              }\n\n              for (var n = 0, r = this.links(); n < r.length; n++) {\n                var s = r[n];\n                this.removeLink(s);\n              }\n            }, e.prototype.nodes = function () {\n              if (null === this._nodesDel) return this._nodes;\n\n              for (var t = [], e = 0; e < this._nodes.length; e++) {\n                var i = this._nodes[e];\n                this._nodesDel[i.id] || t.push(i);\n              }\n\n              return this._nodes = t, this._nodesDel = null, t;\n            }, e.prototype.links = function () {\n              if (null === this._linksDel) return this._links;\n\n              for (var t = [], e = 0; e < this._links.length; e++) {\n                var i = this._links[e];\n                this._linksDel[i.id] || t.push(i);\n              }\n\n              return this._links = t, this._linksDel = null, t;\n            }, e.prototype.addNode = function (t) {\n              var e;\n              return this.nodes(), this.idToNode.hasOwnProperty(t) ? ((e = this.idToNode[t]).removed = !1, e.added || (e.added = !0)) : this.deletedNodes.hasOwnProperty(t) ? ((e = this.deletedNodes[t]).removed = !1, e.added || (e.added = !0), this.idToNode[t] = e, this._nodes.push(e), delete this.deletedNodes[t]) : ((e = new u(t, this)).added = !0, this.idToNode[t] = e, this._nodes.push(e), this.newNodes[t] = e), this.modifiedNodes[t] = e, e;\n            }, e.prototype.touchNodeOrLink = function (t) {\n              t instanceof u ? this.modifiedNodes[t.id] = t : t instanceof c && (this.modifiedLinks[t.id] = t);\n            }, e.prototype.touchNode = function (t) {\n              this.modifiedNodes[t.id] = t;\n            }, e.prototype.removeNode = function (t) {\n              var e = t.id;\n              this.idToNode.hasOwnProperty(e) && (t === this.lastClickedNode && (this.lastClickedNode = null), this.scene.objectRemoved(t), this.newNodes.hasOwnProperty(t.id) ? this.deleteNode(t) : (t.removed || (t.removed = !0), t.added = !1, this.modifiedNodes[e] = t));\n            }, e.prototype.deleteNode = function (t) {\n              null === this._nodesDel && (this._nodesDel = {}), this._nodesDel[t.id] = !0, this.scene.objectRemoved(t), delete this.newNodes[t.id], delete this.modifiedNodes[t.id], delete this.idToNode[t.id], this.deletedNodes[t.id] = t;\n            }, e.prototype.addLink = function (t, e, i) {\n              var n = this.idToNode[e],\n                  r = this.idToNode[i];\n              if (!n || !r) throw new Error(\"Cannot add link - missing nodes\");\n              var s = null;\n              return this.links(), this.idToLink.hasOwnProperty(t) ? ((s = this.idToLink[t]).removed = !1, s.added || (s.added = !0)) : this.deletedLinks.hasOwnProperty(t) ? (s = this.deletedLinks[t], delete this.deletedLinks[t], this.idToLink[t] = s, this._links.push(s), s.removed = !1, s.added || (s.added = !0)) : ((s = new c(t, this)).added = !0, this._links.push(s), this.idToLink[t] = s, this.newLinks[t] = s), s.from && s.from !== n && (h.Helpers.removeFromArrayHasty(s.from.links, s), s.from = null), s.from || (s.from = n, s.from.links.push(s), this.touchNode(s.from)), s.to && s.to !== r && (h.Helpers.removeFromArrayHasty(s.to.links, s), s.to = null), s.to || (s.to = r, s.to !== s.from && (s.to.links.push(s), this.touchNode(s.to))), s.multiId = e < i ? e + h.Helpers.SeparatorChar + i : i + h.Helpers.SeparatorChar + e, this.modifiedLinks[t] = s, s;\n            }, e.prototype.removeLink = function (t) {\n              var e = t.id;\n              this.idToLink.hasOwnProperty(e) && (this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(e) ? this.deleteLink(t) : (t.added = !1, t.removed || (t.removed = !0), this.modifiedLinks[e] = t));\n            }, e.prototype.deleteLink = function (t) {\n              null === this._linksDel && (this._linksDel = {}), this._linksDel[t.id] = !0, this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(t.id) ? delete this.newLinks[t.id] : this.deletedLinks[t.id] = t, delete this.modifiedLinks[t.id], delete this.idToLink[t.id], h.Helpers.removeFromArrayHasty(t.from.links, t), h.Helpers.removeFromArrayHasty(t.to.links, t);\n            }, e.prototype.touchLink = function (t) {\n              this.modifiedLinks[t.id] = t;\n            }, e.prototype.getModified = function () {\n              return {\n                this_newNodes: this.newNodes,\n                this_newLinks: this.newLinks,\n                this_modifiedNodes: this.modifiedNodes,\n                this_modifiedLinks: this.modifiedLinks,\n                this_deletedNodes: this.deletedNodes,\n                this_deletedLinks: this.deletedLinks\n              };\n            }, e.prototype.hasTopologyChanges = function () {\n              return h.Helpers.hasProperties(this.newNodes) || h.Helpers.hasProperties(this.newLinks) || h.Helpers.hasProperties(this.deletedNodes) || h.Helpers.hasProperties(this.deletedLinks);\n            }, e.prototype.hasStyleChanges = function () {\n              return this.hasTopologyChanges() || h.Helpers.hasProperties(this.modifiedLinks) || h.Helpers.hasProperties(this.modifiedNodes);\n            }, e.prototype.clearModified = function () {\n              this.newNodes = {}, this.newLinks = {}, this.modifiedNodes = {}, this.modifiedLinks = {}, this.deletedNodes = {}, this.deletedLinks = {};\n            }, e.prototype.paintNodeDetails = function (t, e, i, n, r, s, a, o, l) {\n              var u,\n                  c,\n                  d,\n                  p = o.labelRenderer,\n                  f = o.context;\n              if (t.hovered ? (c = h.Helpers.toleranceMax(s, 1, .9), d = h.Helpers.toleranceMin(a, r, .9)) : (c = s, d = a), t.currentItems) for (var g = 0; g < t.currentItems.length; g++) {\n                var m = t.currentItems[g];\n\n                if (l) {\n                  if (m.style.zIndex >= 0) break;\n                } else if (m.style.zIndex < 0) continue;\n\n                var v = m.style.x || 0,\n                    y = m.style.y || 0,\n                    S = e + n * (m.style.px || 0) + v,\n                    b = i + r * (m.style.py || 0) + y;\n                u = m.style.scaleWithSize ? r / (m.style.hoverEffect ? d : a) : m.style.scaleWithZoom ? m.style.hoverEffect ? c : s : 1, p.measure(f, m), m.hheight > 1.5 && p.paint(f, S, b, u, m);\n              }\n            }, e.prototype.getNodesSceneZoom = function () {\n              return this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;\n            }, e.prototype.getGeometry = function () {\n              var t = this.scene.toDisplayTransform(),\n                  e = t.xm,\n                  i = t.xa,\n                  n = t.ym,\n                  r = t.ya,\n                  s = this.bounds.x0,\n                  a = this.bounds.x1,\n                  o = this.bounds.y0,\n                  l = this.bounds.y1,\n                  h = (s - i) / e,\n                  u = (a - i) / e,\n                  c = (o - r) / n,\n                  d = (l - r) / n;\n              return {\n                txm: e,\n                txa: i,\n                tym: n,\n                tya: r,\n                zoom: this.scaleNodesWithZoom ? this.scene.zoom : 1,\n                linkZoom: this.scaleLinksWithZoom ? this.scene.zoom : 1,\n                x0s: s,\n                x1s: a,\n                y0s: o,\n                y1s: l,\n                x0w: h,\n                y0w: c,\n                x1w: u,\n                y1w: d\n              };\n            }, e.prototype._makeHoveredLast = function (t, e) {\n              var i = t.length;\n              if (i < 2 || !e || e === t[i - 1]) return i - 1;\n\n              for (var n = 0; n < t.length; n++) {\n                if (t[n] === e) {\n                  var r = t[i - 1];\n                  return t[i - 1] = e, t[n] = r, n;\n                }\n              }\n\n              return i - 1;\n            }, e.prototype._restoreHovered = function (t, e) {\n              var i = t.length;\n\n              if (e !== i - 1) {\n                var n = t[e];\n                t[e] = t[i - 1], t[i - 1] = n;\n              }\n            }, e;\n          }(h.Layer);\n\n          t.ItemsLayer = d;\n\n          var p = function () {\n            return function () {\n              this.nameLegend = null, this.showInLegend = !0, this.legendGroupId = null;\n            };\n          }();\n\n          t.SettingsItemClass = p;\n\n          var f = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(p);\n\n          t.SettingsNodeClass = f;\n\n          var g = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(p);\n\n          t.SettingsLinkClass = g;\n\n          var m = function () {\n            return function () {\n              this.allObjectsStyleFunction = null, this.linkStyleFunction = null, this.nodeStyleFunction = null, this.nodeRules = {}, this.linkRules = {}, this.nodeClasses = [], this.linkClasses = [], this.node = {\n                fillColor: \"#c7dae0\",\n                lineColor: null,\n                lineWidth: null,\n                radius: 30,\n                aspectRatio: 1,\n                shadowColor: null,\n                lineDash: null\n              }, this.nodeAnchor = {\n                lineColor: \"blue\",\n                lineWidth: 1\n              }, this.link = {\n                fillColor: \"#333\",\n                shadowColor: null,\n                fromDecoration: null,\n                toDecoration: null,\n                label: null,\n                radius: 1,\n                length: 1,\n                strength: 1,\n                lineDash: null,\n                toPieValue: 0,\n                toPieColor: null\n              }, this.item = {\n                align: \"center\",\n                aspectRatio: 4,\n                borderRadius: 1e3,\n                textStyle: {\n                  fillColor: \"black\",\n                  font: \"12px Arial\"\n                },\n                backgroundStyle: {\n                  fillColor: \"rgba(255,255,255,0.7)\"\n                },\n                hoverEffect: !0,\n                zIndex: 0\n              }, this.linkLabel = {\n                padding: .6,\n                margin: 0,\n                align: \"center\",\n                aspectRatio: 4,\n                borderRadius: 1e3,\n                lineSpacing: .2,\n                textStyle: {\n                  fillColor: \"black\",\n                  font: \"12px Arial\"\n                },\n                backgroundStyle: {\n                  fillColor: \"#FFF\",\n                  lineColor: \"gray\"\n                },\n                scaleWithZoom: !0,\n                scaleWithSize: !1,\n                rotateWithLink: !1\n              }, this.nodeLabel = {\n                padding: 0,\n                margin: 0,\n                align: \"center\",\n                aspectRatio: 4,\n                borderRadius: 1e3,\n                lineSpacing: .2,\n                textStyle: {\n                  fillColor: \"black\",\n                  font: \"12px Arial\"\n                },\n                backgroundStyle: {\n                  fillColor: \"rgba(255,255,255,0.7)\"\n                },\n                scaleWithZoom: !1,\n                scaleWithSize: !0\n              }, this.nodeLocked = {}, this.nodeExpanded = {}, this.nodeFocused = {\n                fillColor: \"#09c\"\n              }, this.nodeNotLoaded = {\n                fillColor: \"#fff\"\n              }, this.nodeHovered = {\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n                shadowBlur: 6,\n                shadowColor: \"rgba(0,0,0,.6)\"\n              }, this.linkHovered = {\n                shadowOffsetX: 0,\n                shadowOffsetY: 0,\n                shadowBlur: 2,\n                shadowColor: \"blue\"\n              }, this.nodeSelected = {}, this.linkSelected = {}, this.selection = {\n                enabled: !0,\n                fillColor: null,\n                lineColor: \"rgba(0,0,0,0)\",\n                lineWidth: 1,\n                sizeConstant: .5,\n                sizeProportional: 0,\n                shadowBlur: 8,\n                shadowOffsetX: 1,\n                shadowOffsetY: 3,\n                shadowColor: \"rgba(0,0,0,0.8)\"\n              }, this.removedColor = \"#EEE\", this.nodeBackground = {}, this.nodeDetailMinZoom = .2, this.nodeDetailMinSize = 5, this.linkDetailMinZoom = .5, this.linkDetailMinSize = 12, this.linkDecorationScale = 4, this.linkDecorationMinSize = 4, this.nodeLabelScaleBase = 30, this.linkLabelScaleBase = 1, this.scaleObjectsWithZoom = !0, this.scaleLinksWithZoom = null;\n            };\n          }();\n\n          t.SettingsItemsLayerStyle = m;\n\n          var v = function () {\n            function t(t, e) {\n              this.layer = e, this.styleSettings = t, this.nodeClasses = h.Helpers.arrayToMap(this.styleSettings.nodeClasses, \"className\"), this.linkClasses = h.Helpers.arrayToMap(this.styleSettings.linkClasses, \"className\"), this.nodeRules = this.sortRules(this.styleSettings.nodeRules), this.styleSettings.nodeStyleFunction && this.nodeRules.unshift(this.styleSettings.nodeStyleFunction), this.linkRules = this.sortRules(this.styleSettings.linkRules), this.styleSettings.linkStyleFunction && this.linkRules.unshift(this.styleSettings.linkStyleFunction);\n            }\n\n            return t.getClasses = function (t) {\n              return t ? t.trim().split(/\\s+/g) : [];\n            }, t.prototype.updateLayer = function (t, e) {\n              void 0 === e && (e = !1), null == e && (e = !1), this.isIncremental = e;\n              var i = this.styleSettings;\n\n              if (t.changes.style || t.changes.zoom && !(!this.nodeRules.length && !this.linkRules.length)) {\n                this.isIncremental = !1;\n\n                for (var n = 0, r = this.layer.nodes(); n < r.length; n++) {\n                  this.layer.touchNode(r[n]);\n                }\n\n                for (var s = 0, a = this.layer.links(); s < a.length; s++) {\n                  this.layer.touchLink(a[s]);\n                }\n              }\n\n              var o = this.layer.modifiedNodes;\n\n              for (var l in o) {\n                var h = o[l];\n                if (this.updateNode(h), e) for (s = 0; s < h.links.length; s++) {\n                  this.layer.touchLink(h.links[s]);\n                }\n              }\n\n              var u = this.layer.modifiedLinks;\n\n              for (var l in u) {\n                var c = u[l];\n                this.updateLink(c);\n              }\n\n              if (i.allObjectsStyleFunction && (t.changes.zoom || this.layer.hasStyleChanges())) {\n                var d = this.layer.nodes(),\n                    p = this.layer.links(),\n                    f = i.allObjectsStyleFunction(d, p),\n                    g = p,\n                    m = d;\n                f && (g = f.modifiedLinks, m = f.modifiedNodes);\n\n                for (var v = 0; v < m.length; v += 1) {\n                  this.layer.touchNode(m[v]);\n                }\n\n                for (v = 0; v < g.length; v += 1) {\n                  this.layer.touchLink(g[v]);\n                }\n              }\n\n              if (this.nodeRules.length > 0) for (var l in o = this.layer.modifiedNodes) {\n                h = o[l];\n                this.applyStyleRules(h, this.nodeRules);\n              }\n              if (this.linkRules.length > 0) for (var l in u = this.layer.modifiedLinks) {\n                c = u[l];\n                this.applyStyleRules(c, this.linkRules);\n              }\n            }, t.prototype.postprocessLayer = function (t) {\n              var e = this.layer.modifiedNodes;\n\n              for (var i in e) {\n                var n = e[i];\n                this.postprocessNode(n);\n              }\n\n              var r = this.layer.modifiedLinks;\n\n              for (var i in r) {\n                var s = r[i];\n                this.postprocessLink(s);\n              }\n            }, t.prototype.postprocessItems = function (t) {\n              for (var e = t.currentItems, i = t instanceof u ? h.SettingsMapping.ItemsChartSettingsNodeItem : h.SettingsMapping.ItemsChartSettingsLinkItem, n = this.styleSettings.item, r = 0; r < t.items.length; r++) {\n                var s = t.items[r],\n                    a = new h.Label(n);\n                h.SettingsHelper.updateRecursive(a.style, s, i, {}, \"items[\" + r + \"]\"), e.push(a);\n              }\n            }, t.prototype.sortRules = function (t) {\n              var e = [];\n\n              for (var i in t) {\n                e.push(i);\n              }\n\n              e.sort();\n\n              for (var n = [], r = 0; r < e.length; r++) {\n                i = e[r];\n                n.push(t[i]);\n              }\n\n              return n;\n            }, t.prototype.updateNode = function (t) {\n              var e = this.styleSettings,\n                  i = t.hovered;\n              if (t.radius || (t.radius = 10), t.label = null, h.Helpers.extendStyleTo(e.node, t), t._labelStyle = h.Helpers.realClone(e.nodeLabel), t._anchorStyle = h.Helpers.realClone(e.nodeAnchor), t.userLock && h.Helpers.extendStyleTo(e.nodeLocked, t), t.expanded && h.Helpers.extendStyleTo(e.nodeExpanded, t), t.focused && h.Helpers.extendStyleTo(e.nodeFocused, t), t.background && h.Helpers.extendStyleTo(e.nodeBackground, t), t.data.loaded || h.Helpers.extendStyleTo(e.nodeNotLoaded, t), t.data && (t.data.error && (t.label = t.data.error, t.fillColor = \"red\"), t.data.style && h.Helpers.extendStyleTo(t.data.style, t), t.data.className)) for (var n = this.getClassSequence(t.data.className, this.nodeClasses), r = 0; r < n.length; r++) {\n                var s = n[r];\n                h.Helpers.extendStyleTo(this.styleSettings.nodeClasses[s].style, t);\n              }\n              t.removed && (t.fillColor = e.removedColor), t.selected && h.Helpers.extendStyleTo(e.nodeSelected, t), i && h.Helpers.extendStyleTo(e.nodeHovered, t);\n            }, t.prototype.updateLink = function (t) {\n              var e = this.styleSettings;\n              t.label = null, t._labelStyle = h.Helpers.realClone(e.linkLabel), t.radius = 1, h.Helpers.extendStyleTo(e.link, t);\n              var i = t.hovered || t.from.hovered || t.to.hovered;\n              if (t.data.style && h.Helpers.extendStyleTo(t.data.style, t), t.data.className) for (var n = this.getClassSequence(t.data.className, this.linkClasses), r = 0; r < n.length; r++) {\n                var s = n[r];\n                h.Helpers.extendStyleTo(e.linkClasses[s].style, t);\n              }\n              t.selected && h.Helpers.extendStyleTo(e.linkSelected, t), i && (h.Helpers.extendStyleTo(e.linkHovered, t), t.from.hovered && (t.toPieColor = t.fillColor)), t.removed && (t.fillColor = e.removedColor);\n            }, t.prototype.applyStyleRules = function (t, e) {\n              for (var i = 0; i < e.length; i++) {\n                (0, e[i])(t);\n              }\n            }, t.prototype.getClassSequence = function (e, i) {\n              for (var n = t.getClasses(e), r = [], s = 0; s < n.length; s++) {\n                var a = n[s],\n                    o = i[a];\n                o ? r.push(o.index) : h.Helpers.error(\"Unable to apply item style: class `\" + a + \"` undefined\");\n              }\n\n              return r.sort(function (t, e) {\n                return t - e;\n              });\n            }, t;\n          }();\n\n          t.ItemsStyle = v;\n\n          var y = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = [], e.info = {\n                enabled: !1,\n                nodeContentsFunction: null,\n                linkContentsFunction: null\n              }, e.interaction = new b(), e.nodeMenu = new z(), e.linkMenu = new U(), e.advanced = new w(), e.style = {}, e;\n            }\n\n            return r(e, t), e.prototype.apply = function (e) {\n              return this.applyCompatibility(e, [{\n                from: \"style.makeImagesCircular\",\n                to: \"style.node.imageCropping\"\n              }, {\n                from: \"style.nodeDecorationMinSize\",\n                alternative: \"style.nodeDetailMinSize\"\n              }, {\n                from: \"style.nodeLabelMinSize\",\n                to: \"style.nodeDetailMinSize\"\n              }, {\n                from: \"style.nodeRules\",\n                alternative: \"style.nodeStyleFunction\",\n                alternativeAsWarning: !0\n              }, {\n                from: \"style.linkRules\",\n                alternative: \"style.linkStyleFunction\",\n                alternativeAsWarning: !0\n              }]), t.prototype.apply.call(this, e);\n            }, e;\n          }(h.Settings);\n\n          t.Settings = y;\n\n          var S = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.cacheSize = 1e4, e.random = null, e.randomGridLinkProbability = .6, e.randomNodes = 0, e.randomLinks = 0, e.randomTreeDensity = 3, e.requestMaxUnits = 2, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsData);\n\n          t.SettingsData = S;\n\n          var b = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.nodesMovable = !0, e.zooming = new x(), e.panning = {\n                enabled: !0\n              }, e.selection = new C(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsInteraction);\n\n          t.SettingsInteraction = b;\n\n          var C = function () {\n            return function () {\n              this.enabled = !0, this.nodesSelectable = !0, this.linksSelectable = !0, this.lockNodesOnMove = !0, this.allowMoveNodesOffscreen = !0, this.tolerance = 10;\n            };\n          }();\n\n          t.SettingsInteractionSelection = C;\n\n          var x = function () {\n            return function () {\n              this.zoomInOnDoubleClick = !0, this.autoZoomAfterClick = !1, this.doubleClickZoom = 1.5, this.sensitivity = 1, this.wheel = !0, this.fingers = !0;\n            };\n          }();\n\n          t.SettingsInteractionZooming = x;\n\n          var w = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.perNodeLoadingIndicator = !0, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsAdvanced);\n\n          t.SettingsAdvanced = w;\n\n          var L = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(s);\n\n          t.ImageShape = L;\n\n          var T = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.leftOffset = 0, e;\n            }\n\n            return r(e, t), e.prototype.postProcessLabel = function (t, e) {\n              if (this.nodesLayer.chart.assetsLoaded) {\n                var i = this.node.targetHHeight,\n                    n = this.currentLabel;\n                null == n ? n = this.currentLabel = new h.Label(this.node.labelStyle, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.backgroundStyle = null, n.style.image = null, e.measure(t, n);\n                var r = n.hwidth / n.hheight * i;\n                this.node.image && (r += i), this.node.targetHWidth = Math.max(r, i), this.node.bounds.x0 = -this.node.targetHWidth, this.node.bounds.x1 = this.node.targetHWidth;\n              }\n            }, e.prototype.distanceToEdge = function (t, e, i, n) {\n              return h.Geometry.distanceToBalloon(t, e, i, n);\n            }, e.prototype.paintSelection = function (t, e, i) {\n              var n = this.node.renderHheight * (1 + e) + i,\n                  r = this.node.renderHwidth - this.node.renderHheight + n,\n                  s = this.x,\n                  a = this.y,\n                  o = s + r - n;\n              t.moveTo(o, a - n), t.arc(o, a, n, -Math.PI / 2, Math.PI / 2, !1), o = s - r + n, t.lineTo(o, a + n), t.arc(o, a, n, Math.PI / 2, -Math.PI / 2, !1), t.closePath();\n            }, e.prototype.paintDetails = function (t, e) {\n              var i = this.currentLabel;\n\n              if (i) {\n                if (this.hWidth > 2) {\n                  if (e.measure(t, i), this._computeScale(), this.image) {\n                    var n = this.image,\n                        r = this.x - this.hHeight,\n                        s = this.y - this.imSize / 2;\n\n                    if (this.node.imageSlicing) {\n                      var a = this.node.imageSlicing;\n                      h.Graphics.drawImageHighQuality(t, n, a[0], a[1], a[2], a[3], r, s, this.imSize, this.imSize);\n                    } else h.Graphics.drawImageHighQuality(t, n, 0, 0, n.width, n.height, r, s, this.imSize, this.imSize);\n                  }\n\n                  e.paint(t, this.x + this.leftOffset, this.y, this.scale, i), h.Graphics.clearShadow(t);\n                }\n              } else this.basicPaintImage(t);\n            }, e.prototype._computeScale = function () {\n              this.scale = this.hWidth / this.currentLabel.hheight, this.image && (this.leftOffset = this.hWidth, this.imSize = 2 * this.hWidth);\n            }, e;\n          }(s);\n\n          t.TextShape = T;\n\n          var k = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e.prototype.postProcessLabel = function (t, e) {\n              if (this.nodesLayer.chart.assetsLoaded) {\n                var i = this.node.labelStyle;\n                i.backgroundStyle.fillColor = \"transparent\";\n                var n = this.currentLabel;\n                null == n ? n = this.currentLabel = new h.Label(i, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.aspectRatio = 1, n.style.image = null;\n              }\n            }, e.prototype.distanceToEdge = function (t, e, i, n) {\n              return s.prototype.distanceToEdge.call(this, t, e, i, n);\n            }, e.prototype._computeScale = function () {\n              var t = Math.sqrt(this.currentLabel.hwidth * this.currentLabel.hwidth + this.currentLabel.hheight * this.currentLabel.hheight);\n\n              if (this.image) {\n                var e = this.currentLabel.lineHeight + 2 * this.currentLabel.hwidth,\n                    i = (e * e + this.currentLabel.hheight * this.currentLabel.hheight) / 2 / e;\n                i > t && (this.leftOffset = i - t, t = i);\n              }\n\n              this.scale = this.hWidth / t, this.image && (this.imSize = this.currentLabel.lineHeight * this.scale);\n            }, e;\n          }(T);\n\n          t.RoundTextShape = k;\n\n          var A = 1.878652526641458,\n              M = .6170212765957447,\n              I = [0, -1, .556548642145067, -1, 1, -.5534547954623581, 1, 0, 1, .808869027157099, 0, 1.2870402200068753, 0, A],\n              P = h.Helpers.reversePolyline(h.Geometry.transformPolyline(I, -1, 0, 1, 0)),\n              D = [0, -1, .7095605708093294, -.7046444467621514, 1, 0, 1, 0, .4313896533498214, .9021657092700437, 1, 0],\n              N = h.Helpers.reversePolyline(h.Geometry.transformPolyline(D, -1, 0, 1, 0)),\n              F = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e.prototype.postProcess = function (e, i, n) {\n              t.prototype.postProcess.call(this, e, i, n), this.node.bounds.addBounds(0, 0, 0, this.node.targetHHeight * A), this.node.shapeAnchorX = 0, this.node.shapeAnchorY = this.node.radius * A;\n            }, e.prototype.getAnchor = function () {\n              return {\n                x: 0,\n                y: this.hWidth * A\n              };\n            }, e.prototype.adaptToViewport = function (e, i, n, r, s) {\n              t.prototype.adaptToViewport.call(this, e, i, n, r, s), this.controlPoints = h.Geometry.transformPolyline(I, this.hWidth, this.x, this.hHeight, this.y), this.reverseControlPoints = h.Geometry.transformPolyline(P, this.hWidth, this.x, this.hHeight, this.y);\n            }, e.prototype.paintSelection = function (t, e, i) {\n              var n = this.hWidth * e + i,\n                  r = h.Geometry.outlinePolylineByVectors(this.controlPoints, D, n),\n                  s = h.Geometry.outlinePolylineByVectors(this.reverseControlPoints, N, n);\n              t.moveTo.apply(t, r.slice(0, 2)), t.bezierCurveTo.apply(t, r.slice(2, 8)), t.bezierCurveTo.apply(t, r.slice(8, 14)), t.arc(this.controlPoints[12], this.controlPoints[13], n, 0, Math.PI, !1), t.bezierCurveTo.apply(t, s.slice(2, 8)), t.bezierCurveTo.apply(t, s.slice(8, 14)), t.closePath();\n            }, e.prototype.paintBasicShape = function (t) {\n              var e = h.Graphics.beginStrokeAndFill(t, this.node);\n              e.beginPath(), e.moveTo.apply(e, this.controlPoints.slice(0, 2)), e.bezierCurveTo.apply(e, this.controlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.controlPoints.slice(8, 14)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(8, 14)), e.closePath(), h.Graphics.endStrokeAndFill(t, e, this.node);\n            }, e.prototype.paintDetails = function (t, e) {\n              this.image && this.basicPaintImage(t, M), this.paintLabel(t, e);\n            }, e.prototype.getLabelPosition = function (t, e) {\n              return {\n                x: this.x,\n                y: this.y - this.hWidth - t.hheight * e * 1.1\n              };\n            }, e.prototype.distanceToEdge = function (t, e, i, n) {\n              var r = e,\n                  s = t * A,\n                  a = h.Geometry.rayIntersectsSegment(0, 0, i, n, 0, s, r, 0),\n                  o = h.Geometry.rayIntersectsSegment(0, 0, i, n, -r, 0, 0, s),\n                  l = Math.min(a, o);\n              return l < 1 / 0 ? l : t;\n            }, e;\n          }(s);\n\n          t.DropletShape = F;\n\n          var O = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e.prototype.calcHalf = function (t, e) {\n              return this.node.aspectRatio > 1 ? {\n                hWidth: t,\n                hHeight: t / this.node.aspectRatio\n              } : {\n                hWidth: e * this.node.aspectRatio,\n                hHeight: e\n              };\n            }, e.prototype.render = function (t, e, i) {\n              var n = this.calcHalf(this.hWidth, this.hHeight),\n                  r = n.hHeight,\n                  s = n.hWidth;\n              r = r * (1 + e) + i, s = s * (1 + e) + i, t.moveTo(this.x, this.y), t.moveTo(this.x - s, this.y - r), t.lineTo(this.x + s, this.y - r), t.lineTo(this.x + s, this.y + r), t.lineTo(this.x - s, this.y + r), t.lineTo(this.x - s, this.y - r);\n            }, e.prototype.paint = function (t, e, i) {\n              this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !1), this.paintDetails(t, e));\n            }, e.prototype.paintBasicShape = function (t) {\n              var e = h.Graphics.beginStrokeAndFill(t, this.node);\n              this.render(e, 0, 0), h.Graphics.endStrokeAndFill(t, e, this.node);\n            }, e.prototype.basicPaintImage = function (t, e) {\n              if (void 0 === e && (e = 1), this.image) {\n                var i, n, r, s, a, o, l, u;\n\n                if (this.node.imageSlicing) {\n                  var c = this.node.imageSlicing;\n                  i = c[0], n = c[1], r = c[2], s = c[3];\n                } else i = 0, n = 0, r = this.image.width, s = this.image.height;\n\n                var d = this.calcHalf(this.hWidth, this.hHeight),\n                    p = d.hHeight,\n                    f = d.hWidth;\n\n                switch (this.node.imageCropping) {\n                  case !0:\n                    a = this.x - f, o = this.y - p, l = 2 * f, u = 2 * p;\n                    break;\n\n                  case \"crop\":\n                    if (a = this.x - f, o = this.y - p, l = 2 * f, u = 2 * p, s * this.node.aspectRatio <= r) {\n                      var g = s * this.node.aspectRatio;\n                      i += (r - g) / 2, r = g;\n                    } else {\n                      var m = r / this.node.aspectRatio;\n                      n += (s - m) / 2, s = m;\n                    }\n\n                    break;\n\n                  case \"letterbox\":\n                  case \"fit\":\n                    var v = Math.min(2 * p / s, 2 * f / r);\n                    u = s * v, l = r * v, a = this.x - l / 2, o = this.y - u / 2;\n                    break;\n\n                  default:\n                    var y = 2 * Math.max(f, p),\n                        S = Math.min(y / s, y / r);\n                    u = s * S, l = r * S, a = this.x - l / 2, o = this.y - u / 2;\n                }\n\n                h.Graphics.drawImageHighQuality(t, this.image, i, n, r, s, a, o, l, u);\n              }\n            }, e.prototype.paintSelection = function (t, e, i) {\n              this.render(t, e, i), t.closePath();\n            }, e.prototype.distanceToEdge = function (t, e, i, n) {\n              var r = this.calcHalf(t, e);\n              return Math.min(r.hHeight / Math.abs(n), r.hWidth / Math.abs(i));\n            }, e.prototype.hitTest = function (t, e, i, n) {\n              var r = this.node,\n                  s = this.calcHalf(r.renderHwidth * i, r.renderHheight * i),\n                  a = Math.max(Math.abs(t - r.x) - s.hWidth, Math.abs(e - r.y) - s.hHeight);\n              return a < 0 ? 0 : Math.min(a, n);\n            }, e;\n          }(s);\n\n          t.RectangleShape = O;\n\n          var E = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.multilinkSpacing = 10, e.nodeRadiusExtent = [10, 150], e.linkRadiusExtent = [.6, 30], e.linkStrengthExtent = [.1, 1], e.linkLengthExtent = [.3, 150], e.nodeAutoScaling = null, e.linkAutoScaling = null, e.linkStrengthAutoScaling = null, e.linkLengthAutoScaling = null, e.hiddenLinks = {\n                lineColor: \"rgba(100,100,100,0.3)\",\n                lineWidth: 1,\n                size: 7\n              }, e.fadeTime = 600, e.selfLinkHeightFactor = 1, e.selfLinkWidthFactor = 1, e.selfLinkShape = \"quadratic\", e.selfLinkAngle = 60, e;\n            }\n\n            return r(e, t), e;\n          }(m);\n\n          t.SettingsNodesLayerStyle = E;\n\n          var R = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e, i) || this;\n              return r.g = null, r.fadeout = n, r.styleSettings = e, r;\n            }\n\n            return r(e, t), e.prototype.updateLayer = function (e, i) {\n              void 0 === i && (i = !1), this.nodeRadiusChanged = h.Helpers.hasProperties(this.layer.newNodes) || h.Helpers.hasProperties(this.layer.deletedNodes) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.nodeRules.length > 0, this.linkRadiusChanged = h.Helpers.hasProperties(this.layer.newLinks) || h.Helpers.hasProperties(this.layer.deletedLinks) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.linkRules.length > 0, t.prototype.updateLayer.call(this, e, i);\n            }, e.prototype.setItemRenderer = function (t) {\n              this.itemRenderer = t;\n            }, e.prototype.setContext = function (t) {\n              this.g = t;\n            }, e.prototype.postprocessLayer = function (t) {\n              this.g = t.context;\n              var e = this.layer,\n                  i = this.styleSettings.removedColor;\n\n              for (var n in this.setItemRenderer(t.labelRenderer), e.modifiedLinks) {\n                var r = e.modifiedLinks[n];\n                this.fadeout && r.relevance < 1 && (r.fillColor && (r.fillColor = h.Colors.blend(i, r.fillColor, r.relevance)), r.lineColor && (r.lineColor = h.Colors.blend(i, r.lineColor, r.relevance)), r.length = .2 + (r.length - .2) * r.relevance), this.postprocessLink(r);\n              }\n\n              for (var s in e.modifiedNodes) {\n                var a = e.modifiedNodes[s];\n                this.fadeout && a.relevance < 1 && (a.fillColor && (a.fillColor = h.Colors.blend(i, a.fillColor, a.relevance)), a.lineColor && (a.lineColor = h.Colors.blend(i, a.lineColor, a.relevance)));\n              }\n\n              var o = this.layer.nodes();\n\n              if (this.nodeRadiusChanged || this.fadeout && t.changes.navigation) {\n                this.computeNodeSize(o, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);\n\n                for (var l = 0; l < o.length; l++) {\n                  var u = o[l];\n                  this.postprocessNode(u);\n                }\n              } else for (var c in e.modifiedNodes) {\n                var d = e.modifiedNodes[c];\n                this.postprocessNode(d);\n              }\n\n              if (this.linkRadiusChanged || t.changes.navigation) {\n                var p = e.links();\n                this.computeRadii(p, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent), this.computeStrengths(p, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent), this.computeLengths(p, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent), h.Helpers.sort(p, function (t, e) {\n                  return t.targetRadius === e.targetRadius ? 0 : t.targetRadius > e.targetRadius ? 1 : -1;\n                });\n              }\n\n              h.Helpers.sort(o, function (t, e) {\n                return t.zindex - e.zindex;\n              });\n            }, e.prototype.updateLink = function (e) {\n              var i = e.radius;\n              t.prototype.updateLink.call(this, e), i !== e.radius && (this.linkRadiusChanged = !0);\n            }, e.prototype.updateNode = function (e) {\n              var i = e.radius;\n              t.prototype.updateNode.call(this, e), i !== e.radius && (this.nodeRadiusChanged = !0), null == e.label && e.data && (e.label = e.data.id);\n            }, e.prototype.computeNodeSize = function (t, e, i) {\n              var n = i[0],\n                  r = i[1];\n\n              if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n                for (var s = 1 / 0, a = -1 / 0, o = 0; o < t.length; o++) {\n                  if (!(c = t[o]).removed && !c.invisible) {\n                    var l = c.radius;\n                    h.Helpers.isNumber(l) ? (s = Math.min(s, l), a = Math.max(a, l)) : c.targetHHeight = n;\n                  }\n                }\n\n                if (s >= a) for (o = 0; o < t.length; o++) {\n                  (c = t[o]).removed || (c.targetHHeight = r);\n                } else if (\"linear\" === e) {\n                  var u = r / a;\n\n                  for (o = 0; o < t.length; o++) {\n                    if (!(c = t[o]).removed) {\n                      l = c.radius;\n                      h.Helpers.isNumber(l) && (c.targetHHeight = Math.max(n, l * u));\n                    }\n                  }\n                } else if (\"square\" === e) for (u = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n                  if (!(c = t[o]).removed) {\n                    l = c.radius;\n                    h.Helpers.isNumber(l) && (c.targetHHeight = Math.max(n, Math.sqrt(l) * u));\n                  }\n                } else {\n                  s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n                  for (u = r / Math.log(a), o = 0; o < t.length; o++) {\n                    !(c = t[o]).removed && h.Helpers.isNumber(c.radius) && (c.targetHHeight = Math.max(n, Math.log(Math.max(1e-4, c.radius)) * u));\n                  }\n                }\n              } else for (o = 0; o < t.length; o++) {\n                (c = t[o]).removed || (h.Helpers.isNumber(c.radius) ? c.targetHHeight = Math.min(Math.max(1e-6, c.radius), 1e30) : c.targetHHeight = n);\n              }\n\n              if (this.fadeout) for (o = 0; o < t.length; o++) {\n                var c;\n                (c = t[o]).relevance < 1 && (c.targetHHeight = c.targetHHeight * c.relevance);\n              }\n            }, e.prototype.computeRadii = function (t, e, i) {\n              var n = i[0],\n                  r = i[1];\n\n              if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n                for (var s = 1 / 0, a = -1 / 0, o = 0; o < t.length; o++) {\n                  if (!(c = t[o]).removed) {\n                    var l = c.radius;\n                    h.Helpers.isNumber(l) ? (s = Math.min(s, l), a = Math.max(a, l)) : c.targetRadius = n;\n                  }\n                }\n\n                if (s >= a) for (o = 0; o < t.length; o++) {\n                  (c = t[o]).removed || (c.targetRadius = n);\n                } else if (\"linear\" === e) {\n                  var u = r / a;\n\n                  for (o = 0; o < t.length; o++) {\n                    if (!(c = t[o]).removed) {\n                      l = c.radius;\n                      h.Helpers.isNumber(l) && (c.targetRadius = Math.max(n, l * u));\n                    }\n                  }\n                } else if (\"square\" === e) for (u = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n                  if (!(c = t[o]).removed) {\n                    l = c.radius;\n                    h.Helpers.isNumber(l) && (c.targetRadius = Math.max(n, Math.sqrt(l) * u));\n                  }\n                } else {\n                  s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n                  for (u = r / Math.log(a), o = 0; o < t.length; o++) {\n                    !(c = t[o]).removed && h.Helpers.isNumber(c.radius) && (c.targetRadius = Math.max(n, Math.log(Math.max(1e-4, c.radius)) * u));\n                  }\n                }\n              } else for (o = 0; o < t.length; o++) {\n                (c = t[o]).removed || (h.Helpers.isNumber(c.radius) ? c.targetRadius = Math.min(Math.max(1e-6, c.radius), 1e30) : c.targetRadius = n);\n              }\n\n              if (this.fadeout) for (o = 0; o < t.length; o++) {\n                var c;\n                (c = t[o]).relevance < 1 && (c.targetRadius = c.targetRadius * c.relevance);\n              }\n            }, e.prototype.computeStrengths = function (t, e, i) {\n              var n = i[0],\n                  r = i[1];\n\n              if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n                for (var s = 1 / 0, a = -1 / 0, o = 0; o < t.length; o++) {\n                  (c = t[o]).removed || (s = Math.min(s, c.strength), a = Math.max(a, c.strength));\n                }\n\n                if (s >= a) for (o = 0; o < t.length; o++) {\n                  (c = t[o]).removed || (c.targetStrength = n);\n                } else if (\"linear\" === e) {\n                  var l = r / a;\n\n                  for (o = 0; o < t.length; o++) {\n                    (c = t[o]).removed || (c.targetStrength = Math.min(n, c.strength * l));\n                  }\n                } else if (\"square\" === e) for (l = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n                  if (!(c = t[o]).removed) {\n                    var u = c.strength;\n                    h.Helpers.isNumber(u) && (c.targetStrength = Math.max(n, Math.sqrt(u) * l));\n                  }\n                } else {\n                  s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n                  for (l = r / Math.log(a), o = 0; o < t.length; o++) {\n                    (c = t[o]).removed || (c.targetStrength = Math.max(n, Math.log(Math.max(1e-4, c.strength)) * l));\n                  }\n                }\n              } else for (o = 0; o < t.length; o++) {\n                var c;\n                (c = t[o]).removed || (c.targetStrength = Math.min(Math.max(n, c.strength), r));\n              }\n            }, e.prototype.computeLengths = function (t, e, i) {\n              var n = i[0],\n                  r = i[1];\n\n              if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n                for (var s = 1 / 0, a = -1 / 0, o = 0; o < t.length; o++) {\n                  (d = t[o]).removed || (s = Math.min(s, d.length), a = Math.max(a, d.length));\n                }\n\n                if (s >= a) for (o = 0; o < t.length; o++) {\n                  (d = t[o]).removed || (d.targetLength = n);\n                } else if (\"linear\" === e) {\n                  var l = r - a * (u = (r - n) / (a - s));\n\n                  for (o = 0; o < t.length; o++) {\n                    (d = t[o]).removed || (d.targetLength = d.length * u + l);\n                  }\n                } else if (\"square\" === e) {\n                  var u = r / Math.sqrt(a);\n\n                  for (o = 0; o < t.length; o++) {\n                    if (!(d = t[o]).removed) {\n                      var c = d.length;\n                      h.Helpers.isNumber(c) && (d.targetLength = Math.max(n, Math.sqrt(c) * u));\n                    }\n                  }\n                } else {\n                  s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n                  for (l = r - (u = (r - n) / Math.log(a / s)) * Math.log(a), o = 0; o < t.length; o++) {\n                    (d = t[o]).removed || (d.targetLength = Math.log(Math.max(1e-4, d.length)) * u + l);\n                  }\n                }\n              } else for (o = 0; o < t.length; o++) {\n                var d;\n                (d = t[o]).removed || (d.targetLength = Math.min(Math.max(n, d.length), r));\n              }\n            }, e.prototype.postprocessNode = function (t) {\n              var e;\n\n              switch (t.display) {\n                case \"customShape\":\n                  e = o;\n                  break;\n\n                case \"roundtext\":\n                  e = k;\n                  break;\n\n                case \"text\":\n                  e = T;\n                  break;\n\n                case \"droplet\":\n                  e = F;\n                  break;\n\n                case \"rectangle\":\n                  e = O;\n                  break;\n\n                default:\n                  e = L;\n              }\n\n              t.shape && t.shape.constructor === e || (t.shape && (t.shape.node = null), t.shape = new e(t, this.layer));\n              var i = t.outerBounds = h.Rect.createEmpty();\n              t.shape.postProcess(this.styleSettings, this.g, this.itemRenderer), i.addRect(t.bounds), t.currentItems = [], this.postprocessItems(t);\n\n              for (var n = t.targetHWidth, r = t.targetHHeight, s = 0; s < t.currentItems.length; s++) {\n                var a = t.currentItems[s];\n                this.measureCustomItem(n, r, t.shape.sizeScale, a, i);\n              }\n            }, e.prototype.measureCustomItem = function (t, e, i, n, r) {\n              this.itemRenderer.measure(this.g, n);\n              var s = 1;\n              n.style.scaleWithSize && (s = i);\n              var a = n.style.x || 0,\n                  o = n.style.y || 0,\n                  l = t * (n.style.px || 0) + a,\n                  h = e * (n.style.py || 0) + o;\n              r.addBounds(l - n.hwidth * s, h - n.hheight * s, l + n.hwidth * s, h + n.hheight * s);\n            }, e.prototype.postprocessLink = function (t) {\n              var e = [];\n\n              if (t.label) {\n                var i = void 0;\n                t.currentItems && t.currentItems.length ? (i = t.currentItems[0]).style = t.labelStyle : i = new h.Label(t.labelStyle), i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i);\n              }\n\n              t.currentItems = e, this.postprocessItems(t);\n            }, e;\n          }(v);\n\n          t.NodesStyle = R;\n\n          var H = function () {\n            return function () {\n              this.className = null, this.text = null, this.title = null, this.onInit = null, this.onRefresh = null, this.onClick = null;\n            };\n          }();\n\n          t.SettingsMenuButton = H;\n\n          var B = function () {\n            return function () {\n              this.enabled = !0, this.showData = !1, this.contentsFunction = null, this.buttons = [];\n            };\n          }();\n\n          t.SettingsMenu = B;\n\n          var z = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.contentsFunction = null, e.buttons = [], e;\n            }\n\n            return r(e, t), e;\n          }(B);\n\n          t.SettingsNodeMenu = z;\n\n          var U = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.contentsFunction = null, e;\n            }\n\n            return r(e, t), e;\n          }(B);\n\n          t.SettingsLinkMenu = U;\n\n          var G = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 600, i.paintOrder = 40, i.updateOrder = 2e3, i.node = null, i.link = null, i.contents = null, i.x = 0, i.y = 0, i.chart = e, i.container = e.shell.menuContainer, i.scene = e.scene, i.events = e.events, i.buttons = [], i.popup = h.Helpers.createDom(\"div\", \"DVSL-Menu\", null, i.container), i.closeButton = h.Helpers.createDom(\"a\", \"DVSL-Menu-close\", null, i.popup), i.popupValue = h.Helpers.createDom(\"div\", \"DVSL-Menu-title\", null, i.popup), i.detailsDiv = h.Helpers.createDom(\"div\", \"DVSL-Menu-details\", null, i.popup), i.popupActions = h.Helpers.createDom(\"nav\", null, null, i.popup), i.buildDetailsPanel(i.detailsDiv), i.buildCloseButton(i.closeButton), i.popup.style.position = \"absolute\", i.popup.style.display = \"none\", i;\n            }\n\n            return r(e, t), e.prototype.remove = function () {\n              this.popup.parentNode && this.popup.parentNode.removeChild(this.popup);\n            }, e.prototype.doAnimations = function (t) {\n              this.node && (this.node.removed || this.link && this.link.removed ? this.hideMenu() : this.node.layer.modifiedNodes.hasOwnProperty(this.node.id) && this.updateMenu());\n            }, e.prototype.previewPointerDown = function (t) {\n              this.hideMenu();\n            }, e.prototype.previewWheel = function (t) {\n              this.hideMenu();\n            }, e.prototype.toggleNodeMenu = function (t) {\n              this.node === t ? this.hideMenu() : this.showNodeMenu(t);\n            }, e.prototype.toggleLinkMenu = function (t, e, i) {\n              this.link === i ? this.hideMenu() : this.showLinkMenu(t, e, i);\n            }, e.prototype.showNodeMenu = function (t) {\n              this.scene.settings.nodeMenu.enabled && (this.node === t ? this.updateMenu() : (this.hideMenu(), this.showPopup(t, null)));\n            }, e.prototype.showLinkMenu = function (t, e, i) {\n              this.scene.settings.linkMenu.enabled && (this.x = t, this.y = e, this.link === i ? this.updateMenu() : (this.hideMenu(), this.showPopup(null, i)));\n            }, e.prototype.showPopup = function (t, e) {\n              this.node = t, this.link = e, this.node && (this.node.locks += 1), this.buildButtons(), this.contents = null, this.popupValue.innerHTML = \"\", this.popup.style.display = \"block\", this.updateMenu(), this.updateXY();\n            }, e.prototype.hideMenu = function () {\n              (this.node || this.link) && (this.node && (this.node.locks -= 1), this.node = null, this.link = null, this.popup.style.display = \"none\");\n            }, e.prototype.updateMenu = function () {\n              var t,\n                  e,\n                  i = this;\n              this.closeButton.title = this.scene.settings.localization.closeButton, this.node ? (t = this.scene.settings.nodeMenu, e = this.node) : (t = this.scene.settings.linkMenu, e = this.link);\n\n              var n = null,\n                  r = this.node,\n                  s = this.link,\n                  a = function a(t) {\n                if (i.node === r && i.link === s && t !== i.contents) {\n                  if (null == t) i.popupValue.innerHTML = \"\";else if (h.Helpers.isString(t)) i.popupValue.innerHTML = t;else {\n                    if (!h.Helpers.isDomObject(t)) return void h.Helpers.error(\"Invalid value for menu text. Must be either a string or a DOM element.\");\n                    i.popupValue.innerHTML = \"\", i.popupValue.appendChild(t);\n                  }\n                  i.contents = t;\n                }\n              };\n\n              if (t.contentsFunction) {\n                var o = t.contentsFunction.call(this.chart.api, e.data, e, a);\n                n = h.Helpers.isString(o) || h.Helpers.isDomObject(o) ? o : null == this.contents ? \"<small>\" + this.scene.settings.localization.loadingLabel + \"</small>\" : this.contents;\n              } else n = e.label;\n\n              a(n), this.updateButtons(), t.showData ? (this.details.innerHTML = JSON.stringify(e.data, null, \"  \"), this.detailsDiv.style.display = \"block\") : (this.detailsDiv.style.display = \"none\", null == n && 0 === this.buttons.length && this.hideMenu());\n            }, e.prototype.updateXY = function () {\n              var t,\n                  e,\n                  i,\n                  n,\n                  r,\n                  s = 12;\n\n              if (this.node) {\n                var a = this.scene.toDisplay(this.node.x, this.node.y);\n                n = a.x, (r = a.y) - this.node.renderHheight - s, i = r + this.node.renderHheight + s, t = n - this.node.renderHheight - s, e = n + this.node.renderHheight + s;\n              } else i = r = this.y, t = this.x - s, e = this.x + s;\n\n              var o = this.chart.getRootChart().scene,\n                  l = o.x0,\n                  h = o.x0 + o.width,\n                  u = this.popup.offsetWidth,\n                  c = this.popup.offsetHeight;\n              r = Math.max(Math.min(r, o.y0 + o.height - c), o.y0), e + u <= h ? n = e : t - u >= l ? n = t - u : (n = Math.max(t - u / 2, l), r = i), this.popup.style.left = n + \"px\", this.popup.style.top = r + \"px\";\n            }, e.prototype.buildDefaultButton = function (t, e) {\n              this.chart.error(\"The menu does not support any named buttons.\");\n            }, e.prototype.buildButton = function (t, e, i, n, r, s, a) {\n              var o = this,\n                  l = h.Helpers.createDom(\"a\", e, i, this.popupActions);\n              l.title = n, l.onclick = function (e) {\n                s && s.call(o.chart.api, t, l), o.hideMenu(), e.preventDefault();\n              }, l.href = \"#\", r && r.call(this.chart.api, t, l), this.buttons.push({\n                e: l,\n                t: t,\n                a: a\n              });\n            }, e.prototype.buildButtons = function () {\n              var t, e;\n              this.popupActions.innerHTML = \"\", this.buttons = [], this.node ? (t = this.scene.settings.nodeMenu, e = this.node) : (t = this.scene.settings.linkMenu, e = this.link);\n              var i = t.buttons;\n              if (i) for (var n = 0; n < i.length; n++) {\n                var r = i[n];\n                h.Helpers.isString(r) ? this.buildDefaultButton(e, r) : this.buildButton(e, r.className, r.text, null == r.title ? r.text : r.title, r.onInit, r.onClick, r.onRefresh);\n              }\n            }, e.prototype.updateButtons = function () {\n              for (var t = 0; t < this.buttons.length; t++) {\n                var e = this.buttons[t];\n                e.a && e.a.call(this.chart.api, e.t, e.e);\n              }\n            }, e.prototype.buildCloseButton = function (t) {\n              var e = this;\n\n              t.onclick = function (t) {\n                e.hideMenu(), t.preventDefault();\n              };\n            }, e.prototype.buildDetailsPanel = function (t) {\n              var e = h.Helpers.createDom(\"small\", null, \"Technical data\", t),\n                  i = this.details = h.Helpers.createDom(\"pre\", null, \"\", t);\n              i.style.display = \"none\", e.onclick = function () {\n                \"none\" === i.style.display ? i.style.display = \"block\" : i.style.display = \"none\";\n              };\n            }, e;\n          }(h.ChartElement);\n\n          t.Menu = G;\n\n          var j = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 800, i.paintOrder = 45, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.item = null, i.x = null, i.y = null, i.popup = new h.InfoPopup(e), i;\n            }\n\n            return r(e, t), e.prototype.previewPointerMove = function (t) {\n              this.onMove(t.x, t.y);\n            }, e.prototype.doAnimations = function (t) {\n              null !== this.x && null !== this.y && this.onMove(this.x, this.y);\n            }, e.prototype.previewPointerDown = function (t) {\n              this.x = this.y = null, this.setCurrentObject(0, 0, null);\n            }, e.prototype.previewPointerDrag = function (t) {\n              this.x = this.y = null, this.setCurrentObject(0, 0, null);\n            }, e.prototype.onPointerOut = function (t) {\n              this.x = this.y = null, this.setCurrentObject(0, 0, null);\n            }, e.prototype.onMove = function (t, e) {\n              if (this.y = e, this.x = t, this.options.info.enabled) {\n                var i = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;\n                this.setCurrentObject(t, e, i);\n              }\n            }, e.prototype.setCurrentObject = function (t, e, i) {\n              if (i) {\n                if (i !== this.item) {\n                  var n = this.buildContents(i);\n                  this.popup.show(t, t, e, n);\n                } else this.popup.updateXY(t, t, e);\n\n                this.item = i;\n              } else this.item = null, this.popup.hide();\n            }, e.prototype.buildContents = function (t) {\n              var e = this,\n                  i = null;\n\n              if (t instanceof u ? i = this.options.info.nodeContentsFunction : t instanceof c && (i = this.options.info.linkContentsFunction), i) {\n                return i.call(this.chart.api, t.data, t, function (i) {\n                  t === e.item && e.popup.updateContents(i);\n                });\n              }\n\n              return t.label;\n            }, e.prototype.remove = function () {\n              this.popup.remove();\n            }, e;\n          }(h.ChartElement);\n\n          t.InfoPopup = j;\n\n          var W = \"undefined\" != typeof Float32Array,\n              V = function () {\n            return function () {\n              this._calculatedStyles = {}, this._defaultStyles = {}, this.enabled = !0, this.drawLimit = .8, this.cellSize = 3, this.intensity = 6, this.style = {}, this.defaultStyle = null, this.defaultColors = [\"rgba(47,195,47,0.3)\", \"rgba(176,220,11,0.3)\", \"rgba(234,180,4,0.3)\", \"rgba(222,103,44,0.3)\", \"rgba(236,46,46,0.3)\", \"rgba(213,66,155,0.3)\", \"rgba(111,82,184,0.3)\", \"rgba(28,124,213,0.3)\", \"rgba(86,185,247,0.3)\", \"rgba(10,232,235,0.3)\"], this.overlap = !1;\n            };\n          }();\n\n          t.SettingsNodesLayerAuras = V;\n\n          var Z = function () {\n            function t(t, e, i) {\n              this._marginCells = 1, this._polygons = [], this._autoAuraCounter = 0, this._overlapWarning = !0, this._auraCounter = 0, this._settings = i, this._scene = t, this._events = e;\n            }\n\n            return t.prototype.recalculateStyles = function (t) {\n              var e = this._settings,\n                  i = Object.keys(e.style);\n              e._calculatedStyles = {};\n\n              for (var n = 0; n < i.length; n++) {\n                var r = i[n],\n                    s = h.Helpers.realClone(this._settings._defaultStyles[r]);\n                e.defaultStyle && h.Helpers.extendStyleTo(e.defaultStyle, s), e.style[r] && h.Helpers.extendStyleTo(e.style[r], s), e._calculatedStyles[r] = s, s.__auraCounter = this._auraCounter++;\n              }\n\n              (i = Object.keys(t).filter(function (t) {\n                return e._calculatedStyles[t].enabled;\n              })).sort(function (t, i) {\n                var n = e._calculatedStyles[t].zIndex - e._calculatedStyles[i].zIndex;\n                return 0 === n ? t.localeCompare(i) : n;\n              }), this._auras = new Array(i.length + 1), this._aurasMap = Object.create(null), this._aurasMap[\"\"] = 0;\n\n              for (n = 0; n < i.length; n++) {\n                var a = i[n];\n                this._aurasMap[a] = n + 1, this._auras[n + 1] = e._calculatedStyles[a];\n              }\n\n              this._events.notifySceneChanges({\n                auras: !0\n              });\n            }, t.prototype.recalculateGrid = function () {\n              var t = this._scene,\n                  e = this._settings;\n              this._overlapWarning = e.overlap;\n\n              for (var i = t.width, n = t.height, r = this._marginCells, s = e.cellSize, a = this._widthCells = Math.ceil(i / s) + 2 * r, o = this._heightCells = Math.ceil(n / s) + 2 * r, l = this._cellLength = this._auras.length, h = a * o * l, u = this._cells = W ? new Float32Array(h) : new Array(h), c = this._cellEdges = W ? new Int8Array(h) : new Array(h), d = a * l, p = 0; p < h; p++) {\n                c[p] = -1;\n              }\n\n              if (!W) for (var f = 0; f < u.length; f++) {\n                u[f] = 0;\n              }\n              var g = [-d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l, -d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l];\n              this._edgeFinderDeltas = W ? new Int16Array(g) : g;\n            }, t.prototype.doAnimations = function (t, e) {\n              if (this._settings.enabled && t) {\n                for (var i = !1, n = {}, r = 0; r < t.length; r++) {\n                  var s = t[r].aura;\n\n                  if (s) {\n                    Array.isArray(s) ? !this._overlapWarning && s.length > 1 && (h.Helpers.warn(\"One or more nodes defined more than one aura. It is recommended to set `overlap: true` in the chart configuration to better handle this scenario.\"), this._overlapWarning = !0) : s = [s];\n\n                    for (var a = 0; a < s.length; a++) {\n                      var o = \"\" + (s[a] || \"\");\n                      \"\" !== o && (i = !0, n[o] = !0, this.ensureAura(o));\n                    }\n                  }\n                }\n\n                for (var r in this._settings.style) {\n                  h.Helpers.hasProperty(this._settings.style, r) && this.ensureAura(r);\n                }\n\n                var l,\n                    u = e.changes,\n                    c = u.settingsChanges,\n                    d = !1;\n                if (!this._auras || c && c.auras) l = !0;else if (i) {\n                  var p = Object.keys(n),\n                      f = 0,\n                      g = this._settings._calculatedStyles;\n\n                  for (r = 0; r < p.length; r++) {\n                    var m = p[r];\n\n                    if (null == g[m]) {\n                      l = !0;\n                      break;\n                    }\n\n                    g[m].enabled && f++;\n                  }\n\n                  l = l || this._auras.length - 1 !== f;\n                }\n                if (l ? (this.recalculateStyles(n), d = !0) : u.bounds && (d = !0), !i || this._auras.length < 2) return void (this._polygons.length > 0 && (this._polygons = []));\n                d && this.recalculateGrid(), this.reset(), this.stage1(t), this.stage2(), this.stage3();\n              }\n            }, t.prototype.ensureAura = function (t) {\n              if (this._settings.style[t] || (this._settings.style[t] = {}), !this._settings._defaultStyles[t]) {\n                var e = this._settings.defaultColors;\n                e && e.length || (e = [\"rgba(47,195,47,0.3)\"]), this._autoAuraCounter = (this._autoAuraCounter + 1) % e.length, this._settings._defaultStyles[t] = {\n                  lineWidth: 1,\n                  showInLegend: !0,\n                  enabled: !0,\n                  zIndex: 0,\n                  fillColor: e[this._autoAuraCounter]\n                };\n              }\n            }, t.prototype.reset = function () {\n              for (var t = this._cellEdges, e = 0; e < t.length; e++) {\n                t[e] = -1;\n              }\n\n              var i = this._cells;\n\n              for (e = 0; e < i.length; e++) {\n                i[e] = 0;\n              }\n\n              this._polygons = new Array(this._auras.length);\n\n              for (e = 0; e < this._polygons.length; e++) {\n                this._polygons[e] = [];\n              }\n            }, t.prototype.stage1 = function (t) {\n              for (var e = this._scene, i = e.zoom, n = this._settings, r = n.cellSize, s = this._marginCells, a = this._widthCells, o = this._heightCells, l = this._cells, h = this._cellLength, u = this._aurasMap, c = n.intensity, d = e.centerX * e.zoom % r, p = e.centerY * e.zoom % r, f = 0; f < t.length; f++) {\n                var g = t[f],\n                    m = e.toDisplay(g.x, g.y),\n                    v = (m.x + d) / r + s,\n                    y = (m.y + p) / r + s,\n                    S = 0 | v,\n                    b = 0 | y,\n                    C = v - S,\n                    x = y - b,\n                    w = t[f].aura;\n\n                if (w) {\n                  Array.isArray(w) || (w = [w]);\n\n                  for (var L = 0; L < w.length; L++) {\n                    var T = u[\"\" + (w[L] || \"\")];\n\n                    if (void 0 !== T && this._auras[T].enabled) {\n                      var k = Math.min((g.hHeight * i + 5) / r, a, o),\n                          A = k * c + 1,\n                          M = 2 * A;\n\n                      if (v > -M && v < a + M && y > -M && y < o + M) {\n                        var I = k / 2,\n                            P = Math.ceil(A);\n                        A -= I;\n\n                        for (var D = -P; D < P; D++) {\n                          if (!(v + D < s || v + D >= a - s)) for (var N = C - D, F = -P; F < P; F++) {\n                            if (!(y + F < s || y + F >= o - s)) {\n                              var O = x - F,\n                                  E = Math.sqrt(N * N + O * O) - I;\n\n                              if (E < A) {\n                                E = E <= 0 ? 1 : 1 - E / A;\n                                var R = T + (b + F) * a * h + (S + D) * h;\n                                l[R] = l[R] + E - l[R] * E;\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }, t.prototype.stage2 = function () {\n              var t = this._cellLength;\n              if (1 !== t && !this._settings.overlap) for (var e = this._cells, i = 0; i < e.length; i += t) {\n                for (var n = i, r = e[i], s = 1; s < t; s++) {\n                  var a = e[i + s];\n                  a > r ? (r = a, e[n] = 0, n = i + s) : a > 0 && (e[i + s] = 0);\n                }\n              }\n            }, t.prototype.stage3FindEdge = function (t, e) {\n              var i = this._cells,\n                  n = this._cellEdges,\n                  r = this._settings,\n                  s = r.drawLimit,\n                  a = this._edgeFinderDeltas,\n                  o = [e],\n                  l = e,\n                  u = 2,\n                  c = 0,\n                  d = 0,\n                  p = r.overlap,\n                  f = 0,\n                  g = 0;\n\n              do {\n                for (var m = n[l], v = void 0, y = (u + 5) % 8, S = y, b = !1; S < y + 8; S++) {\n                  if (m !== S && i[v = l + a[S]] >= s) {\n                    b = !0;\n                    break;\n                  }\n                }\n\n                if (!b) {\n                  l !== e && h.Helpers.error(\"Edge finder stuck\");\n                  break;\n                }\n\n                if ((u !== (S %= 8) || ++f > 5) && (0 === c && (c = 7 === S ? 7 : 1, d = 7 === S ? 6 : 2), (!p || u !== (S + c) % 8 && u !== (S + d) % 8) && o.push(l), f = 0), -1 === m && (n[l] = S), u = S, l = v, ++g > 1e4) {\n                  h.Helpers.error(\"Edge finder run into a loop\");\n                  break;\n                }\n              } while (l !== e);\n\n              o[o.length - 1] !== e && o.push(e), t.push(o);\n            }, t.prototype.stage3 = function () {\n              for (var t = this._cellLength, e = this._widthCells * t, i = this._cells, n = this._cellEdges, r = this._settings.drawLimit, s = e - t, a = this._polygons, o = 0, l = i.length - t, u = 0; u < l; u++) {\n                var c = i[u];\n\n                if (u % e >= s || c < r) {\n                  var d = u + t;\n\n                  if (i[d] >= r && n[d] < 0 && (this.stage3FindEdge(a[d % t], d), ++o > 1e4)) {\n                    h.Helpers.error(\"Edge finder found too many polygons\");\n                    break;\n                  }\n                }\n              }\n            }, t.prototype.paintPolygons = function (t) {\n              if (this._settings.enabled) {\n                var e = t.context;\n                e.save();\n\n                for (var i = this._settings.cellSize, n = this._marginCells * i - i / 2, r = this._cellLength, s = this._widthCells, a = this._auras, o = this._polygons, l = this._scene, u = -l.centerX * l.zoom % i, c = -l.centerY * l.zoom % i, d = 1; d < o.length; d++) {\n                  for (var p = o[d], f = a[d], g = h.Graphics.beginStrokeAndFill(e, f), m = 0; m < p.length; m++) {\n                    var v = p[m],\n                        y = v[0] / r | 0,\n                        S = y % s * i - n + u,\n                        b = (y / s | 0) * i - n + c,\n                        C = v[1] / r | 0,\n                        x = C % s * i - n + u,\n                        w = (C / s | 0) * i - n + c;\n                    g.moveTo((S + x) / 2, (w + b) / 2);\n\n                    for (var L = 2; L < v.length; L++) {\n                      var T = (C = v[L] / r | 0) % s * i - n + u,\n                          k = (C / s | 0) * i - n + c;\n                      g.quadraticCurveTo(x, w, (T + x) / 2, (k + w) / 2), x = T, w = k;\n                    }\n\n                    var A = (C = v[1] / r | 0) % s * i - n + u,\n                        M = (C / s | 0) * i - n + c;\n                    g.quadraticCurveTo(x, w, (A + x) / 2, (M + w) / 2), g.closePath();\n                  }\n\n                  h.Graphics.endStrokeAndFill(e, g, f);\n                }\n\n                h.Graphics.restore(e);\n              }\n            }, t;\n          }();\n\n          t.NodesLayerAuras = Z;\n\n          var Y = function (e) {\n            function i(t, i, n) {\n              var r = e.call(this, t.scene, i) || this;\n              r.chart = t, r.imageCache = {}, r.imageLoading = {}, r.multilinks = {}, r.useFadeout = n, r.styleUpdater = r.createStyleUpdater(i.style), r.events = t.events, r.layerSettings = i;\n              var s = i.style;\n              return r.style = s, r.scaleNodesWithZoom = s.scaleObjectsWithZoom, r.scaleLinksWithZoom = null == s.scaleLinksWithZoom ? s.scaleObjectsWithZoom : s.scaleLinksWithZoom, r._auras = new Z(t.scene, t.events, i.auras), r;\n            }\n\n            return r(i, e), i.prototype.createStyleUpdater = function (t) {\n              return null == this.useFadeout ? null : new R(t, this, this.useFadeout);\n            }, i.prototype.updateStyle = function (t) {\n              var e = !t.changes.newGraph;\n              this.styleUpdater.updateLayer(t, e);\n            }, i.prototype.postprocessStyle = function (t) {\n              e.prototype.postprocessStyle.call(this, t), this.animateSize(t);\n            }, i.prototype.animateSize = function (t) {\n              var e = t.timeStamp,\n                  i = t.changes.newGraph,\n                  n = t.dtime,\n                  r = !1,\n                  s = !1,\n                  a = this.style.fadeTime,\n                  o = [],\n                  l = [];\n\n              if (i = i || !(a > 0) || n > a) {\n                for (var h = 0, u = this.nodes(); h < u.length; h++) {\n                  (f = u[h]).removed ? (f.visibility = 0, o.push(f)) : f.targetHWidth !== f.hWidth && (f.added = !1, f.visibility = 1, f.hHeight = f.targetHHeight, f.hWidth = f.targetHWidth);\n                }\n\n                for (var c = 0, d = this.links(); c < d.length; c++) {\n                  (S = d[c]).removed ? (S.visibility = 0, l.push(S)) : S.targetRadius !== S.currentRadius && (S.added = !1, S.visibility = 1, S.currentRadius = S.targetRadius);\n                }\n              } else {\n                var p = a > 0 ? Math.max(0, Math.pow(.2, n / a)) : 0;\n\n                for (h = 0, u = this.nodes(); h < u.length; h++) {\n                  var f;\n                  if (!0 === (f = u[h]).added && (f.added = e), f.added + a < e && (f.added = !1), !0 === f.removed && (f.removed = e), f.removed) r = !0, f.visibility = p, f.hHeight = f.hHeight * p, f.hWidth = f.hWidth * p, e - f.removed < a ? f.visibility = 1 - (e - f.removed) / a : o.push(f);else {\n                    e - f.added < a ? (f.visibility = (e - f.added) / a, r = !0) : f.visibility = 1;\n                    var g = f.targetHHeight,\n                        m = f.hHeight,\n                        v = f.targetHWidth,\n                        y = f.hWidth;\n                    g === m && v === y || (s || (Math.abs(g - m) / Math.max(g, m) >= .5 || Math.abs(v - y) / Math.max(v, y) >= .5) && (s = !0), r = !0, f.hHeight = m * p + g * (1 - p), f.hWidth = y * p + v * (1 - p), Math.abs(f.hHeight - g) < .01 * g && (f.hHeight = g, f.hWidth = v));\n                  }\n                }\n\n                for (c = 0, d = this.links(); c < d.length; c++) {\n                  var S;\n                  !0 === (S = d[c]).added && (S.added = e), S.added + a < e && (S.added = !1), !0 === S.removed && (S.removed = e), S.removed ? (r = !0, S.currentRadius = S.currentRadius * p, e - S.removed < a ? S.visibility = 1 - (e - S.removed) / a : l.push(S)) : (e - S.added < a && !S.invisible ? (S.visibility = (e - S.added) / a, r = !0) : S.visibility = 1, S.targetRadius !== S.currentRadius && (r = !0, S.currentRadius = S.currentRadius * p + S.targetRadius * (1 - p), Math.abs(S.currentRadius - S.targetRadius) < .01 * S.targetRadius && (S.currentRadius = S.targetRadius)));\n                }\n              }\n\n              for (var b = 0; b < l.length; b++) {\n                var C = l[b];\n                this.deleteLink(C);\n              }\n\n              for (var x = 0; x < o.length; x++) {\n                var w = o[x];\n                this.deleteNode(w);\n              }\n\n              if (r) {\n                var L = {\n                  position: !0\n                };\n                s && (L.dynamicLayout = !0), this.events.notifySceneChanges(L), t.animating = !0;\n              }\n            }, i.prototype.paintPrepare = function (t) {\n              this.computeNodeRenderRadii(), this.multilinks = this.updateMultilinks(), (t.changes.position || this.hasTopologyChanges()) && this.placePies();\n            }, i.prototype.paintBackground = function (t) {\n              this._auras.doAnimations(this.nodes(), t), this._auras.paintPolygons(t);\n            }, i.prototype.paintSelection = function (t, e, i) {\n              var n = this.style.selection;\n\n              if (n.enabled) {\n                null === n.fillColor && ((n = h.Helpers.clone(n)).fillColor = this.chart.settings.area.style.fillColor, n.fillColor && \"transparent\" !== n.fillColor || (n.fillColor = \"white\"));\n                var r = this.getGeometry(),\n                    s = r.txm,\n                    a = r.txa,\n                    o = r.tym,\n                    l = r.tya,\n                    u = r.zoom,\n                    c = t.context,\n                    d = n.sizeProportional,\n                    p = n.sizeConstant;\n                c.beginPath();\n\n                for (var f = 0; f < e.length; f++) {\n                  var g = e[f];\n                  g.invisible || (g.shape.adaptToViewport(s, a, o, l, u), g.shape.paintSelection(c, d, p * u));\n                }\n\n                for (f = 0; f < i.length; f++) {\n                  var m = i[f];\n\n                  if (!m.invisible) {\n                    var v = (m.currentRadius / 2 * (1 + d) + .9 * p) * u,\n                        y = m.from,\n                        S = m.to,\n                        b = y.x * s + a,\n                        C = y.y * o + l,\n                        x = S.x * s + a,\n                        w = S.y * o + l,\n                        L = b - x,\n                        T = C - w,\n                        k = 1 / Math.sqrt(L * L + T * T),\n                        A = L * k,\n                        M = T * k;\n\n                    if (0 !== m.currentCenterOffset) {\n                      var I = M * m.currentCenterOffset * u,\n                          P = -A * m.currentCenterOffset * u;\n                      b += I, C += P, x += I, w += P;\n                    }\n\n                    A *= v, M *= v, c.moveTo(b + M, C - A), c.lineTo(b - M, C + A), c.lineTo(x - M, w + A), c.lineTo(x + M, w - A), c.closePath();\n                  }\n                }\n\n                return h.Graphics.paint(c, n);\n              }\n            }, i.prototype.paintLinks = function (t, e) {\n              var i = this.getGeometry();\n              this.paintLinksImpl(t, e, this.multilinks, {\n                geometry: i,\n                paintDetails: i.zoom > this.style.linkDetailMinZoom\n              });\n            }, i.prototype.paintNodes = function (t, e) {\n              var i = this.getGeometry();\n              t.animating = this.paintNodesImpl(t, e, {\n                geometry: i,\n                paintDetails: i.zoom > this.style.nodeDetailMinZoom\n              }, t.timeStamp) || t.animating;\n            }, i.prototype.updateMultilinks = function () {\n              if (!this.hasTopologyChanges()) return this.multilinks;\n\n              for (var t = this.links(), e = {}, i = [], n = 0; n < t.length; n++) {\n                var r = t[n],\n                    s = r.multiId;\n\n                if (e.hasOwnProperty(s)) {\n                  var a = e[s];\n                  if (a instanceof Array) a.push(r);else {\n                    var o = [a, r];\n                    i.push(o), e[s] = o;\n                  }\n                } else e[s] = r;\n              }\n\n              for (var l = 0; l < i.length; l++) {\n                i[l].sort(function (t, e) {\n                  return (\"\" + (t.id || \"\")).localeCompare(\"\" + (e.id || \"\"));\n                });\n              }\n\n              return e;\n            }, i.prototype.getNodeImage = function (t, e, i) {\n              if (void 0 === i && (i = !1), !t.image) return null;\n              var n = t.tintImage && t.fillColor,\n                  r = !!e && t.imageCropping,\n                  s = t.image,\n                  a = s;\n              if (n && (s += \"##\" + t.fillColor), s += \"##\" + r, this.imageCache.hasOwnProperty(s)) return this.imageCache[s];\n              if (this.imageLoading[s]) return null;\n              var o = this.scene.assetsLoader.getAssetImage(a);\n              return i ? o : o ? (r && (o = h.Graphics.cropImageToCircle(o, r)), n && (o = h.Graphics.applyColorToImage(o, t.fillColor, !1)), this.imageCache[s] = o, delete this.imageLoading[s], this.events.notifySceneChanges({\n                layout: !0\n              }), o) : null;\n            }, i.prototype.computeNodeRenderRadii = function () {\n              for (var t = this.getGeometry().zoom, e = 0, i = this.nodes(); e < i.length; e++) {\n                var n = i[e],\n                    r = n.hHeight * t,\n                    s = n.hWidth * t;\n                n.lineWidth && (r += n.lineWidth / 2, s += n.lineWidth / 2), n.renderHheight = r, n.renderHwidth = s;\n              }\n            }, i.prototype.paintLinksImpl = function (t, e, i, n) {\n              var r = t.context,\n                  s = n.geometry.txm,\n                  a = n.geometry.txa,\n                  o = n.geometry.tym,\n                  l = n.geometry.tya,\n                  u = n.geometry.linkZoom,\n                  c = n.geometry.x0w,\n                  d = n.geometry.y0w,\n                  p = n.geometry.x1w,\n                  f = n.geometry.y1w,\n                  g = 1 / u,\n                  m = this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;\n              r.textAlign = \"center\", r.textBaseline = \"middle\";\n\n              for (var v = this.style, y = v.linkDetailMinSize * v.linkDetailMinSize, S = n.paintDetails && this.chart.assetsLoaded, b = v.multilinkSpacing * u, C = v.linkDecorationScale, x = v.linkDecorationMinSize, w = v.linkLabelScaleBase, L = 0; L < e.length; L++) {\n                var T = e[L];\n\n                if (!T.invisible && T.from !== T.to) {\n                  var k = T.from.x,\n                      A = T.from.y,\n                      M = T.to.x,\n                      I = T.to.y,\n                      P = T.currentItems,\n                      D = P && P.length && P[0].style.rotateWithLink,\n                      N = void 0,\n                      F = T.from.renderHheight,\n                      O = T.to.renderHheight,\n                      E = T.from.renderHwidth,\n                      R = T.to.renderHwidth,\n                      H = h.Geometry.clipSegmentToBounds(k, A, M, I, (F + E) * m, (O + R) * m, c, d, p, f);\n\n                  if (H) {\n                    k = H[0], A = H[1], M = H[2], I = H[3];\n                    var B = (M = M * s + a) - (k = k * s + a),\n                        z = (I = I * o + l) - (A = A * o + l),\n                        U = B * B + z * z,\n                        G = Math.max(.25, T.currentRadius * u * .5),\n                        j = T.hovered || T.from.hovered || T.to.hovered,\n                        W = j || S && U > y;\n\n                    if (U > 25) {\n                      var V = Math.sqrt(U);\n\n                      if (D && (N = Math.atan2(z, B) * (180 / Math.PI), k >= M && (N -= 180), T.currentItems[0].style.angle = N), T.toPieValue > 0) {\n                        var Z = O + 2,\n                            Y = Z + 5 + .1 * O;\n                        this.paintLinkPie(r, M, I, Z, Y, T.toPie0, T.toPie1, T.toPieColor), O = Y;\n                      }\n\n                      if (V < F + O) continue;\n\n                      var q = B * (Tt = 1 / V),\n                          _ = z * Tt,\n                          X = void 0,\n                          Q = void 0;\n\n                      if (V <= (X = T.from.shape.distanceToEdge(F, E, q, _)) + (Q = T.to.shape.distanceToEdge(O, R, -q, -_))) continue;\n                      var J = Math.min((V - X - Q) / 4, Math.max(x, G * C));\n                      T.fromDecoration && (X += J), T.toDecoration && (Q += J), B = (M -= q * Q) - (k += q * X), z = (I -= _ * Q) - (A += _ * X), Tt = 1 / (V = V - X - Q);\n                      var K = i[T.multiId];\n\n                      if (K instanceof Array) {\n                        var $ = K.length,\n                            tt = Math.min(b * ($ - 1), 1.5 * F, 1.5 * O) * (K.indexOf(T) - ($ - 1) / 2) / ($ - 1);\n                        T.from.id > T.to.id && (tt = -tt), T.currentCenterOffset = tt * g, k -= _ * tt, M -= _ * tt, A += q * tt, I += q * tt;\n                      } else T.currentCenterOffset = 0;\n\n                      if (T.renderPointsX ? (T.renderPointsX[0] = k, T.renderPointsX[1] = M) : T.renderPointsX = [k, M], T.renderPointsY ? (T.renderPointsY[0] = A, T.renderPointsY[1] = I) : T.renderPointsY = [A, I], T.renderBounds ? (T.renderBounds.x0 = Math.min(k, M), T.renderBounds.x1 = Math.max(k, M), T.renderBounds.y0 = Math.min(A, I), T.renderBounds.y1 = Math.max(A, I)) : T.renderBounds = new h.Rect(k, A, M, I), W && T.currentItems && !T.removed && (T.currentItems.sort(function (t, e) {\n                        return t.style.zIndex - e.style.zIndex;\n                      }), this.paintLinkItems(r, t.labelRenderer, u, G / w, k, A, q, _, V, G, T.currentItems, T.renderBounds, j, !0)), T.lineDash && T.lineDashBackgroundFillColor && (r.beginPath(), r.moveTo(k + _ * G, A - q * G), r.lineTo(k - _ * G, A + q * G), r.lineTo(M - _ * G, I + q * G), r.lineTo(M + _ * G, I - q * G), r.closePath(), h.Graphics.fill(r, {\n                        fillColor: T.lineDashBackgroundFillColor\n                      })), r.beginPath(), T.fromDecoration && this.paintLinkDecoration(r, k, A, q, _, J, T.fromDecoration, T.fillColor), T.toDecoration && this.paintLinkDecoration(r, M, I, -q, -_, J, T.toDecoration, T.fillColor), T.lineDash) {\n                        var et = k + _ * G,\n                            it = A - q * G,\n                            nt = k - _ * G,\n                            rt = A + q * G;\n                        if (T.lineDash.length > 0) for (var st = T.lineDash, at = st.length, ot = st.reduce(function (t, e) {\n                          return t + e;\n                        }) * u, lt = 0, ht = 0; ht <= V / ot; ht++) {\n                          for (var ut = 0; ut <= at - 1; ut += 2) {\n                            if ((wt = ht * ot + lt) > V - G) break;\n                            var ct = wt + st[ut] * u,\n                                dt = [et + wt * q, it + wt * _],\n                                pt = [nt + wt * q, rt + wt * _],\n                                ft = [nt + (Lt = ct >= V - G ? V - G : ct) * q, rt + Lt * _],\n                                gt = [et + Lt * q, it + Lt * _];\n\n                            if (T.lineDashShape && \"rectangle\" != T.lineDashShape) {\n                              if (\"triangle\" == T.lineDashShape) {\n                                var mt = [(dt[0] + pt[0]) / 2, (dt[1] + pt[1]) / 2];\n                                r.moveTo(mt[0], mt[1]), r.lineTo(ft[0], ft[1]), r.lineTo(gt[0], gt[1]);\n                              } else if (\"inverseTriangle\" == T.lineDashShape) {\n                                var vt = [(ft[0] + gt[0]) / 2, (ft[1] + gt[1]) / 2];\n                                r.moveTo(vt[0], vt[1]), r.lineTo(dt[0], dt[1]), r.lineTo(pt[0], pt[1]);\n                              } else if (\"diamond\" == T.lineDashShape) {\n                                mt = [(dt[0] + pt[0]) / 2, (dt[1] + pt[1]) / 2];\n                                var yt = [(pt[0] + ft[0]) / 2, (pt[1] + ft[1]) / 2],\n                                    St = (vt = [(ft[0] + gt[0]) / 2, (ft[1] + gt[1]) / 2], [(gt[0] + dt[0]) / 2, (gt[1] + dt[1]) / 2]);\n                                r.moveTo(mt[0], mt[1]), r.lineTo(yt[0], yt[1]), r.lineTo(vt[0], vt[1]), r.lineTo(St[0], St[1]);\n                              } else if (\"hexagon\" == T.lineDashShape) {\n                                mt = [(dt[0] + pt[0]) / 2, (dt[1] + pt[1]) / 2];\n                                var bt = [((yt = [(pt[0] + ft[0]) / 2, (pt[1] + ft[1]) / 2])[0] + (St = [(dt[0] + gt[0]) / 2, (dt[1] + gt[1]) / 2])[0]) / 2, (yt[1] + St[1]) / 2];\n                                r.moveTo(mt[0], mt[1]), r.lineTo(yt[0], yt[1]), r.lineTo(ft[0], ft[1]), r.lineTo(bt[0], bt[1]), r.lineTo(gt[0], gt[1]), r.lineTo(St[0], St[1]);\n                              } else if (\"inverseHexagon\" == T.lineDashShape) {\n                                var Ct = [(dt[0] + ft[0]) / 2, (dt[1] + ft[1]) / 2];\n                                yt = [(pt[0] + ft[0]) / 2, (pt[1] + ft[1]) / 2], vt = [(ft[0] + gt[0]) / 2, (ft[1] + gt[1]) / 2], St = [(dt[0] + gt[0]) / 2, (dt[1] + gt[1]) / 2];\n                                r.moveTo(dt[0], dt[1]), r.lineTo(Ct[0], Ct[1]), r.lineTo(pt[0], pt[1]), r.lineTo(yt[0], yt[1]), r.lineTo(vt[0], vt[1]), r.lineTo(St[0], St[1]);\n                              }\n                            } else r.moveTo(dt[0], dt[1]), r.lineTo(pt[0], pt[1]), r.lineTo(ft[0], ft[1]), r.lineTo(gt[0], gt[1]);\n\n                            r.closePath(), lt += u * (st[ut] + st[ut + 1]);\n                          }\n\n                          lt = 0;\n                        } else {\n                          var xt = Math.max(5, 3 * G);\n\n                          for (ht = 0; ht <= V / xt; ht += 2) {\n                            var wt = ht * xt,\n                                Lt = Math.min((ht + 1) * xt, V);\n                            r.moveTo(et + wt * q, it + wt * _), r.lineTo(nt + wt * q, rt + wt * _), r.lineTo(nt + Lt * q, rt + Lt * _), r.lineTo(et + Lt * q, it + Lt * _), r.closePath();\n                          }\n                        }\n                      } else r.moveTo(k + _ * G, A - q * G), r.lineTo(k - _ * G, A + q * G), r.lineTo(M - _ * G, I + q * G), r.lineTo(M + _ * G, I - q * G), r.closePath();\n\n                      h.Graphics.fill(r, T), W && T.currentItems && !T.removed && this.paintLinkItems(r, t.labelRenderer, u, G / w, k, A, q, _, V, G, T.currentItems, T.renderBounds, j, !1);\n                    } else if (T.fillColor) {\n                      if (r.beginPath(), r.lineWidth = Math.max(.1, 2 * G), r.strokeStyle = T.fillColor, T.dashed) {\n                        var Tt;\n\n                        for (q = B * (Tt = 1 / (V = Math.sqrt(U))), _ = z * Tt, xt = Math.max(5, 3 * G), ht = 0; ht <= V / xt; ht += 2) {\n                          wt = ht * xt, Lt = Math.min((ht + 1) * xt, V);\n                          r.moveTo(k + wt * q, A + wt * _), r.lineTo(k + Lt * q, A + Lt * _);\n                        }\n                      } else r.moveTo(k, A), r.lineTo(M, I);\n\n                      r.stroke(), T.renderPointsX ? (T.renderPointsX[0] = k, T.renderPointsX[1] = M) : T.renderPointsX = [k, M], T.renderPointsY ? (T.renderPointsY[0] = A, T.renderPointsY[1] = I) : T.renderPointsY = [A, I], T.renderBounds ? (T.renderBounds.x0 = Math.min(k, M), T.renderBounds.x1 = Math.max(k, M), T.renderBounds.y0 = Math.min(A, I), T.renderBounds.y1 = Math.max(A, I)) : T.renderBounds = new h.Rect(k, A, M, I);\n                    }\n                  }\n                }\n              }\n            }, i.prototype.paintNodesImpl = function (e, i, n, r) {\n              var s = !1,\n                  a = e.context,\n                  o = n.geometry.txm,\n                  l = n.geometry.txa,\n                  u = n.geometry.tym,\n                  c = n.geometry.tya,\n                  d = n.geometry.zoom,\n                  p = n.geometry.x0s,\n                  f = n.geometry.x1s,\n                  g = n.geometry.y0s,\n                  m = n.geometry.y1s,\n                  v = 1 / o,\n                  y = n.paintDetails,\n                  S = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * v * v,\n                  b = this.style.hiddenLinks,\n                  C = this.style.nodeLabelScaleBase;\n              a.textAlign = \"center\", a.textBaseline = \"middle\";\n\n              for (var x = this.style.removedColor, w = 0; w < i.length; w++) {\n                (j = i[w]).data && !j.invisible && this.paintSelfLinks(e, j, n);\n              }\n\n              for (w = 0; w < i.length; w++) {\n                if ((j = i[w]).data && !j.invisible) if ((N = j.shape).adaptToViewport(o, l, u, c, d), null != j.anchorX && null != j.anchorY && j.anchorMode === t.NodeAnchorMode.Floating) {\n                  var L = j.anchorX * o + l,\n                      T = j.anchorY * u + c,\n                      k = N.getAnchor(),\n                      A = N.x + k.x,\n                      M = N.y + k.y,\n                      I = A - L,\n                      P = M - T,\n                      D = M;\n                  P < 0 && (D = Math.max(D, T - P * Math.min(.3, Math.abs(I) / P))), a.beginPath(), a.moveTo(A, M), a.lineTo(A, D), a.lineTo(L, T), h.Graphics.stroke(a, j.anchorStyle);\n                }\n              }\n\n              for (w = 0; w < i.length; w++) {\n                var N = (j = i[w]).shape;\n\n                if (j.data && !j.invisible && N.isInViewport(p, f, g, m, d)) {\n                  var F = j.opacity,\n                      O = j.outerBounds.w(),\n                      E = j.outerBounds.h(),\n                      R = y && O * E > S || j.hovered;\n\n                  if (F < 1 && (a.globalAlpha = F), R && !j.removed) {\n                    var H = j.dataLinks.length - j.links.length;\n                    if (H > 0) if (this.useFadeout && j.relevance < 1) {\n                      var B = b.lineColor;\n                      b.lineColor = h.Colors.blend(x, B, j.relevance), this.paintHiddenLinks(a, j, N.x, N.y, N.hWidth, N.hHeight, H, b, b.size * d), b.lineColor = B;\n                    } else this.paintHiddenLinks(a, j, N.x, N.y, N.hWidth, N.hHeight, H, b, b.size * d);\n                    j.items.sort(function (t, e) {\n                      return t.zIndex - e.zIndex;\n                    }), this.paintNodeDetails(j, N.x, N.y, N.hHeight, N.hWidth, d, C, e, !0);\n                  }\n\n                  N.paint(a, e.labelRenderer, R), R && !j.removed && this.paintNodeDetails(j, N.x, N.y, N.hHeight, N.hWidth, d, C, e, !1), F < 1 && (a.globalAlpha = 1);\n                }\n              }\n\n              if (this.scene.settings.advanced.perNodeLoadingIndicator) {\n                var z = this.scene.settings.advanced.style.loadingArcStyle;\n                a.save(), a.lineCap = \"round\", a.lineWidth = z.lineWidth, a.strokeStyle = z.lineColor;\n                var U = r / 1400,\n                    G = (U = (U - Math.floor(U)) * (2 * Math.PI)) + Math.PI / 2;\n\n                for (w = 0; w < i.length; w++) {\n                  var j;\n\n                  if (!(j = i[w]).invisible) {\n                    N = j.shape;\n\n                    if (j.loading || j.image && null === this.getNodeImage(j, !1, !0)) {\n                      if (!N.isInViewport(p, f, g, m, d)) continue;\n                      s = !0, a.beginPath(), a.arc(N.x, N.y, N.hWidth, U, G), a.stroke();\n                    }\n                  }\n                }\n\n                h.Graphics.restore(a);\n              }\n\n              return s;\n            }, i.prototype.paintLinkDecoration = function (t, e, i, n, r, s, a, o) {\n              t.fillStyle = o, \"circle\" === a ? (t.moveTo(e + s, i), t.arc(e, i, s, 0, 2 * Math.PI, !0)) : \"arrow\" === a ? (t.moveTo(e - n * s, i - r * s), t.lineTo(e + n * s - r * s, i + r * s + n * s), t.lineTo(e + n * s + r * s, i + r * s - n * s)) : h.Helpers.error(\"Unrecognized link decoration value. Valid values are 'circle' and 'arrow'.\");\n            }, i.prototype.paintLinkPie = function (t, e, i, n, r, s, a, o) {\n              var l = (n + r) / 2,\n                  u = r - n;\n              t.beginPath(), t.arc(e, i, l, s, a), h.Graphics.paint(t, {\n                lineColor: o,\n                lineWidth: u\n              });\n            }, i.prototype.paintLinkItems = function (t, e, i, n, r, s, a, o, l, u, c, d, p, f) {\n              var g, m;\n              p ? (g = h.Helpers.toleranceMax(i, 1, .9), m = h.Helpers.toleranceMax(n, 1, .9)) : (g = i, m = n);\n\n              for (var v = 0; v < c.length; v++) {\n                var y = c[v];\n\n                if (f) {\n                  if (y.style.zIndex >= 0) break;\n                } else if (y.style.zIndex < 0) continue;\n\n                var S,\n                    b = y.x || 0,\n                    C = y.y || 0,\n                    x = y.style.px || 0,\n                    w = y.style.py || 0,\n                    L = y.style.lx || 0,\n                    T = y.style.ly || 0,\n                    k = r + a * (x = l * (x + 1) * .5 + L) - o * (w = w * u + T) + b,\n                    A = s + o * x + a * w + C;\n                S = y.style.scaleWithSize ? y.style.hoverEffect ? m : n : y.style.scaleWithZoom ? y.style.hoverEffect ? g : i : 1, e.paint(t, k, A, S, y);\n              }\n            }, i.prototype.paintBezierLinkItems = function (t, e, i, n, r, s, a, o, l, u, c) {\n              var d, p;\n              u ? (d = h.Helpers.toleranceMax(i, 1, .9), p = h.Helpers.toleranceMax(n, 1, .9)) : (d = i, p = n);\n\n              for (var f = 0; f < o.length; f++) {\n                var g = o[f];\n\n                if (c) {\n                  if (g.style.zIndex >= 0) break;\n                } else if (g.style.zIndex < 0) continue;\n\n                var m = g.x || 0,\n                    v = g.y || 0,\n                    y = g.style.px || 0,\n                    S = g.style.py || 0,\n                    b = g.style.lx || 0,\n                    C = g.style.ly || 0,\n                    x = 0;\n                y <= 0 ? y = 1 + y : x = 2;\n                var w,\n                    L = 1 - y,\n                    T = r[x] * L + r[x + 1] * y,\n                    k = s[x] * L + s[x + 1] * y,\n                    A = r[x + 1] * L + r[x + 2] * y,\n                    M = s[x + 1] * L + s[x + 2] * y,\n                    I = A - T,\n                    P = M - k,\n                    D = Math.sqrt(I * I + P * P),\n                    N = I / D,\n                    F = P / D,\n                    O = T * L + A * y + N * b - F * (S * a + C) + m,\n                    E = k * L + M * y + F * b + N * (S * a + C) + v;\n                w = g.style.scaleWithSize ? g.style.hoverEffect ? p : n : g.style.scaleWithZoom ? g.style.hoverEffect ? d : i : 1, g.style.rotateWithLink && (g.style.angle = 180 * Math.atan2(F, N) / Math.PI), e.paint(t, O, E, w, g), l.addRect(g.currentBounds);\n              }\n            }, i.prototype.paintSelfLinks = function (t, e, i) {\n              var n = this.multilinks[e.id + h.Helpers.SeparatorChar + e.id];\n\n              if (null != n) {\n                n instanceof c && (n = [n]);\n                var r = (n = n.filter(function (t) {\n                  return !t.invisible;\n                })).length;\n\n                if (!(r < 1)) {\n                  for (var s, a, o, l = e.dataLinks.length > e.links.length, u = 0, d = 0, p = 0, f = 0; f < e.links.length; f++) {\n                    if ((et = e.links[f]).from !== et.to) {\n                      var g = et.otherEnd(e);\n                      u += g.x, d += g.y, p++;\n                    }\n                  }\n\n                  if (0 === p) s = -1, a = 0, o = l ? 4 * Math.PI / 3 : 2 * Math.PI;else {\n                    var m = (u = e.x - u / p) * u + (d = e.y - d / p) * d,\n                        v = 1 / Math.sqrt(0 === m ? 1e-4 : m);\n\n                    if (a = d * v, (s = u * v) || a || (s = 1), l) {\n                      o = Math.PI / 2;\n                      var y = Math.SQRT2 / 2,\n                          S = y * (s - a);\n                      a = y * (a + s), s = S;\n                    } else o = Math.PI;\n                  }\n                  var b,\n                      C,\n                      x,\n                      w,\n                      L = this.style.selfLinkAngle;\n                  L <= 0 ? L = 60 : L > 90 && (L = 90);\n                  var T = Math.PI * L / 180,\n                      k = Math.cos(T),\n                      A = Math.sin(T),\n                      M = Math.cos(T / 2),\n                      I = Math.sin(T / 2);\n\n                  if (o >= T * r) {\n                    var P = -((o /= r) * (r - 1) + T) / 2;\n                    b = s * (x = Math.cos(P)) - a * (w = Math.sin(P)), C = s * w + a * x, x = Math.cos(o), w = Math.sin(o);\n                  } else {\n                    P = -o / 2;\n                    b = s * (x = Math.cos(P)) - a * (w = Math.sin(P)), C = s * w + a * x;\n                    var D = (o - T) / (r - 1);\n                    x = Math.cos(D), w = Math.sin(D);\n                  }\n\n                  var N = t.context,\n                      F = i.geometry.txm,\n                      O = i.geometry.txa,\n                      E = i.geometry.tym,\n                      R = i.geometry.tya,\n                      H = i.geometry.linkZoom;\n                  N.textAlign = \"center\", N.textBaseline = \"middle\";\n\n                  for (var B = this.style, z = B.linkDetailMinSize * B.linkDetailMinSize, U = i.paintDetails && this.chart.assetsLoaded, G = B.linkDecorationScale, j = B.linkDecorationMinSize, W = B.linkLabelScaleBase, V = e.x * F + O, Z = e.y * E + R, Y = 1 + (this.style.selfLinkHeightFactor <= 0 ? 1 : this.style.selfLinkHeightFactor), q = Math.max(this.style.selfLinkWidthFactor, 0), _ = [0, 0, 0, 0, 0], X = [0, 0, 0, 0, 0], Q = [0, 0, 0, 0, 0], J = [0, 0, 0, 0, 0], K = [0, 0, 0, 0, 0], $ = [0, 0, 0, 0, 0], tt = 0; tt < r; tt++) {\n                    var et;\n\n                    if (!(et = n[tt]).invisible) {\n                      var it = Math.max(e.renderHheight, e.renderHwidth);\n                      it *= it;\n                      var nt = e.renderHheight;\n\n                      if (it > 25 && et.toPieValue > 0) {\n                        var rt = nt + 2,\n                            st = rt + 5 + .1 * nt;\n                        this.paintLinkPie(N, V, Z, rt, st, et.toPie0, et.toPie1, et.toPieColor), nt = st;\n                      }\n\n                      var at = b * k - C * A,\n                          ot = b * A + C * k,\n                          lt = b * M - C * I,\n                          ht = b * I + C * M,\n                          ut = e.shape.distanceToEdge(nt, e.renderHwidth, b, C),\n                          ct = e.shape.distanceToEdge(nt, e.renderHwidth, at, ot),\n                          dt = Math.max(ut, ct) * Y,\n                          pt = Math.max(.25, et.currentRadius * H * .5),\n                          ft = Math.min((dt - Math.max(ut, ct) - pt) / 2, Math.max(j, pt * G));\n                      et.fromDecoration && (ut += ft), et.toDecoration && (ct += ft), Q[0] = V + b * ut, J[0] = Z + C * ut, Q[2] = V + lt * dt, J[2] = Z + ht * dt, Q[4] = V + at * ct, J[4] = Z + ot * ct, _[2] = V + lt * (dt - pt), X[2] = Z + ht * (dt - pt), K[2] = V + lt * (dt + pt), $[2] = Z + ht * (dt + pt);\n                      var gt = void 0,\n                          mt = void 0,\n                          vt = void 0,\n                          yt = void 0;\n\n                      if (\"parabolic\" === this.style.selfLinkShape) {\n                        gt = b, mt = C, vt = at, yt = ot, _[0] = Q[0] - C * pt, X[0] = J[0] + b * pt, _[4] = Q[4] + ot * pt, X[4] = J[4] - at * pt;\n                        var St = ((dt - pt) * I - pt) / M * q;\n                        _[1] = _[2] + ht * St, X[1] = X[2] - lt * St, _[3] = _[2] - ht * St, X[3] = X[2] + lt * St, K[0] = Q[0] + C * pt, $[0] = J[0] - b * pt, K[4] = Q[4] - ot * pt, $[4] = J[4] + at * pt, St = ((dt + pt) * I + pt) / M * q, K[1] = K[2] + ht * St, $[1] = $[2] - lt * St, K[3] = K[2] - ht * St, $[3] = $[2] + lt * St, St = dt * I / M * q, Q[1] = Q[2] + ht * St, J[1] = J[2] - lt * St, Q[3] = Q[2] - ht * St, J[3] = J[2] + lt * St;\n                      } else {\n                        gt = lt, mt = ht, vt = lt, yt = ht, _[0] = Q[0] - ht * pt, X[0] = J[0] + lt * pt, _[4] = Q[4] + ht * pt, X[4] = J[4] - lt * pt;\n                        var bt = (_[4] - _[0]) * q / 2,\n                            Ct = (X[4] - X[0]) * q / 2;\n                        _[1] = _[2] - bt, X[1] = X[2] - Ct, _[3] = _[2] + bt, X[3] = X[2] + Ct, K[0] = Q[0] + ht * pt, $[0] = J[0] - lt * pt, K[4] = Q[4] - ht * pt, $[4] = J[4] + lt * pt, bt = (K[4] - K[0]) * q / 2, Ct = ($[4] - $[0]) * q / 2, K[1] = K[2] - bt, $[1] = $[2] - Ct, K[3] = K[2] + bt, $[3] = $[2] + Ct, bt = (Q[4] - Q[0]) * q / 2, Ct = (J[4] - J[0]) * q / 2, Q[1] = Q[2] - bt, J[1] = J[2] - Ct, Q[3] = Q[2] + bt, J[3] = J[2] + Ct;\n                      }\n\n                      et.renderBounds || (et.renderBounds = new h.Rect(0, 0, 0, 0)), et.renderBounds.x0 = Math.min.apply(Math, K), et.renderBounds.y0 = Math.min.apply(Math, $), et.renderBounds.x1 = Math.max.apply(Math, K), et.renderBounds.y1 = Math.max.apply(Math, $), et.renderPointsX || (et.renderPointsX = new Array(10), et.renderPointsY = new Array(10));\n\n                      for (var xt = 0; xt < 5; xt++) {\n                        var wt = xt / 4,\n                            Lt = 1 - wt;\n                        et.renderPointsX[xt] = Lt * Lt * Q[0] + 2 * Lt * wt * Q[1] + wt * wt * Q[2], et.renderPointsY[xt] = Lt * Lt * J[0] + 2 * Lt * wt * J[1] + wt * wt * J[2], et.renderPointsX[xt + 5] = Lt * Lt * Q[2] + 2 * Lt * wt * Q[3] + wt * wt * Q[4], et.renderPointsY[xt + 5] = Lt * Lt * J[2] + 2 * Lt * wt * J[3] + wt * wt * J[4];\n                      }\n\n                      if (it > 25) {\n                        var Tt = et.hovered || et.from.hovered || et.to.hovered,\n                            kt = Tt || U && it > z;\n                        kt && et.currentItems && !et.removed && (et.currentItems.sort(function (t, e) {\n                          return t.style.zIndex - e.style.zIndex;\n                        }), this.paintBezierLinkItems(N, t.labelRenderer, H, pt / W, Q, J, pt, et.currentItems, et.renderBounds, Tt, !0)), N.beginPath(), et.fromDecoration && this.paintLinkDecoration(N, Q[0], J[0], gt, mt, ft, et.fromDecoration, et.fillColor), et.toDecoration && this.paintLinkDecoration(N, Q[4], J[4], vt, yt, ft, et.toDecoration, et.fillColor), N.moveTo(_[0], X[0]), N.quadraticCurveTo(_[1], X[1], _[2], X[2]), N.quadraticCurveTo(_[3], X[3], _[4], X[4]), N.lineTo(K[4], $[4]), N.quadraticCurveTo(K[3], $[3], K[2], $[2]), N.quadraticCurveTo(K[1], $[1], K[0], $[0]), N.closePath(), h.Graphics.fill(N, et), kt && et.currentItems && !et.removed && (et.currentItems.sort(function (t, e) {\n                          return t.style.zIndex - e.style.zIndex;\n                        }), this.paintBezierLinkItems(N, t.labelRenderer, H, pt / W, Q, J, pt, et.currentItems, et.renderBounds, Tt, !1));\n                      } else et.fillColor && (N.beginPath(), N.lineWidth = Math.max(.1, 2 * pt), N.strokeStyle = et.fillColor, N.moveTo(Q[0], J[0]), N.quadraticCurveTo(Q[1], J[1], Q[2], J[2]), N.quadraticCurveTo(Q[3], J[3], Q[4], J[4]), N.stroke());\n\n                      S = b * x - C * w;\n                      C = b * w + C * x, b = S;\n                    }\n                  }\n                }\n              }\n            }, i.prototype.paintHiddenLinks = function (t, e, i, n, r, s, a, o, l) {\n              for (var h, u, c, d = 0, p = 0, f = 0, g = !1, m = 0; m < e.links.length; m++) {\n                var v = e.links[m];\n                if (v.from === v.to) g = !0;else {\n                  var y = v.otherEnd(e);\n                  d += y.x, p += y.y, f++;\n                }\n              }\n\n              if (0 === f) h = 1, u = 0, c = 2 * Math.PI / a / 3;else {\n                d = e.x - d / e.links.length, p = e.y - p / e.links.length;\n                var S = 1 / Math.sqrt(d * d + p * p);\n\n                if (h = d * S, u = p * S, g) {\n                  c = Math.PI / a / 2;\n                  var b = Math.SQRT2 / 2,\n                      C = b * (h + u);\n                  u = b * (u - h), h = C;\n                } else c = 2 * Math.PI / a / 3;\n              }\n              var x = Math.cos(-c * (a - 1) / 2),\n                  w = Math.sin(-c * (a - 1) / 2),\n                  L = h * x - u * w,\n                  T = h * w + u * x,\n                  k = L;\n              x = Math.cos(c), w = Math.sin(c), t.beginPath();\n\n              for (var A = 1; A <= a; A++) {\n                var M = e.shape.distanceToEdge(r, s, k, T);\n                t.moveTo(i + k * M, n + T * M), t.lineTo(i + k * (M + l), n + T * (M + l)), L = k * x - T * w, T = k * w + T * x, k = L;\n              }\n\n              t.strokeStyle = o.lineColor, t.lineWidth = o.lineWidth, t.stroke();\n            }, i.prototype.findObjectAt = function (t, e, i) {\n              var n = this.scene,\n                  r = n.fromDisplay(t, e),\n                  s = r.x,\n                  a = r.y,\n                  o = 1 / n.zoom,\n                  l = this.scaleLinksWithZoom ? o : 1,\n                  u = null,\n                  c = [],\n                  d = null,\n                  p = i,\n                  f = n.hoverNode;\n              if (f && f.layer === this && !f.invisible && (y = f.shape.hitTest(s, a, o, p * o)) / o < p && (p = y / o, u = f, (k = this.findItem(t, e, u, i)) && (d = k.item, p = Math.min(p, k.distance)), p <= 0)) return {\n                object: u,\n                details: d\n              };\n\n              for (var g = this.nodes(), m = g.length - 1; m >= 0; m--) {\n                var v = g[m];\n\n                if (!v.removed && !v.invisible && h.Geometry.distanceToRect(s - v.x, a - v.y, v.outerBounds) < p * o) {\n                  var y;\n\n                  if ((y = v.shape.hitTest(s, a, o, p * o)) <= 0) {\n                    p = 0, u = v;\n                    break;\n                  }\n\n                  y / o < p && (p = y / o, u = v), c.push(v);\n                }\n              }\n\n              if (p > 0) {\n                var S = n.hoverLink;\n\n                if (S && S.layer === this && !S.invisible) {\n                  var b = S.targetRadius / 2 * l;\n\n                  for (m = 1; m < S.renderPointsX.length; m++) {\n                    if ((T = h.Geometry.distanceToSegmentSq(S.renderPointsX[m - 1], S.renderPointsY[m - 1], S.renderPointsX[m], S.renderPointsY[m], t, e)) <= (p + b) * (p + b)) {\n                      if (p = 0, u = S, (k = this.findItem(t, e, u, i)) && (d = k.item, p = Math.min(p, k.distance)), p <= 0) return {\n                        object: u,\n                        details: d\n                      };\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (p > 0) for (var C = 0, x = this.links(); C < x.length; C++) {\n                var w = x[C];\n\n                if (!w.removed && !w.invisible && w.renderPointsX && h.Geometry.distanceToRect(t, e, w.renderBounds) < p) {\n                  b = w.targetRadius / l * 2;\n                  var L = Math.min(p * p, b * b);\n\n                  for (m = 1; m < w.renderPointsX.length; m++) {\n                    var T;\n\n                    if ((T = h.Geometry.distanceToSegmentSq(w.renderPointsX[m - 1], w.renderPointsY[m - 1], w.renderPointsX[m], w.renderPointsY[m], t, e)) < L) {\n                      p = Math.sqrt(T), u = w;\n                      break;\n                    }\n                  }\n\n                  c.push(w);\n                }\n              }\n              if (0 === p) return {\n                object: u,\n                details: (k = this.findItem(t, e, u, i)) ? k.item : null\n              };\n\n              for (m = 0; m < c.length; m++) {\n                var k,\n                    A = c[m];\n                (k = this.findItem(t, e, A, i)) && k.distance < p && (p = k.distance, u = A, d = k.item);\n              }\n\n              return p > i && (u = null, d = null), {\n                object: u,\n                details: d\n              };\n            }, i.prototype.findItem = function (t, e, i, n) {\n              if (!i) return null;\n              var r = n * n,\n                  s = this.scene.hoverItem;\n              if (s && s.hwidth && i.currentItems.indexOf(s) > -1 && (d = h.Geometry.distanceToRect(t, e, s.currentBounds, !0)) <= r) return {\n                item: s,\n                distance: Math.sqrt(d)\n              };\n              var a = null,\n                  o = n * n;\n\n              if (i instanceof u) {\n                var l = i.shape.currentLabel;\n                if (l && l.currentBounds) (d = h.Geometry.distanceToRect(t, e, l.currentBounds, !0)) < o && (a = l, o = d);\n              }\n\n              for (var c = 0; c < i.currentItems.length; c++) {\n                var d,\n                    p = i.currentItems[c];\n                if (p.hwidth) (d = h.Geometry.distanceToRect(t, e, p.currentBounds, !0)) <= o && (a = p, o = d);\n              }\n\n              return o > r || !a ? null : {\n                item: a,\n                distance: Math.sqrt(o)\n              };\n            }, i.prototype.getGraphBounds = function (t) {\n              if (void 0 === t && (t = this.nodes()), !t || !t.length) return new h.Rect(0, 0, 0, 0);\n\n              for (var e = h.Rect.createEmpty(), i = 0; i < t.length; i++) {\n                var n = t[i];\n\n                if (!n.removed) {\n                  var r = n.x,\n                      s = n.y,\n                      a = n.outerBounds;\n                  e.addBounds(a.x0 + r, a.y0 + s, a.x1 + r, a.y1 + s);\n                }\n              }\n\n              return e;\n            }, i.prototype.getNodeNeighborsBounds = function (t) {\n              if (!t || 0 === this.nodes().length) return new h.Rect(0, 0, 0, 0);\n\n              for (var e = t.outerBounds.clone().moveBy(t.x, t.y), i = t, n = 0; n < t.links.length; n++) {\n                if (!(i = t.links[n].otherEnd(t)).removed) {\n                  var r = i.outerBounds,\n                      s = i.x,\n                      a = i.y;\n                  e.addBounds(r.x0 + s, r.y0 + a, r.x1 + s, r.y1 + a);\n                }\n              }\n\n              return e;\n            }, i.prototype.placePies = function () {\n              for (var t = 2 * Math.PI, e = [], i = 0, n = this.nodes(); i < n.length; i++) {\n                for (var r = n[i], s = 0, a = 0; a < r.links.length; a++) {\n                  var o = r.links[a];\n                  o.to === r && o.toPieValue > 0 && (s += o.toPieValue, e.push(o), o._angle = Math.atan2(o.to.y - o.from.y, o.to.x - o.from.x));\n                }\n\n                if (s > 0) {\n                  e.sort(function (t, e) {\n                    return t._angle - e._angle;\n                  });\n\n                  for (var l = t / s, h = 0, u = 0, c = 0; c < e.length; c++) {\n                    var d = e[c];\n                    d.toPie0 = h, h += d.toPieValue * l, d.toPie1 = h;\n                    var p = d._angle - (d.toPie0 + d.toPie1) / 2;\n                    p < 0 && (p += 2 * Math.PI), u += p;\n                  }\n\n                  u /= e.length, u -= Math.PI;\n\n                  for (var f = 0; f < e.length; f++) {\n                    var g = e[f];\n                    g.toPie0 += u, g.toPie1 += u;\n                  }\n\n                  e = [];\n                }\n              }\n            }, i;\n          }(d);\n\n          t.NodesLayer = Y;\n\n          var q = function (t) {\n            function e(e, i, n) {\n              return t.call(this, e, i, n) || this;\n            }\n\n            return r(e, t), e.prototype.zoomOut = function () {}, e.prototype.zoomOutPossible = function () {\n              return !1;\n            }, e.prototype.setSelection = function (t) {\n              for (var e, i = [], n = 0; n < t.length; n++) {\n                var r = t[n];\n                r instanceof u || r instanceof c ? i.push(r) : h.Helpers.isString(r) && (e = this.getNode(r) || this.getLink(r)) ? i.push(e) : this.error(\"setSelection: Could not find a chart object with the ID `\" + r + \"`.\");\n              }\n\n              this.scene.setSelection(i) && (this.events.notifySceneChanges({\n                selection: !0\n              }), this.notifySelectionChanged(this.createEventArguments(null, \"api\")));\n            }, e.prototype.createEventArguments = function (t, e) {\n              var i = null,\n                  n = null;\n\n              if (t && (t.x || t.y)) {\n                var r = this.scene.fromDisplay(t.x, t.y);\n                i = r.x, n = r.y;\n              }\n\n              return {\n                chart: this.api,\n                origin: e,\n                chartX: i,\n                chartY: n,\n                hoverLink: this.scene.hoverLink,\n                hoverNode: this.scene.hoverNode,\n                hoverItem: this.scene.hoverItem,\n                selection: this.scene.selection.slice()\n              };\n            }, e;\n          }(h.Impl);\n\n          t.Impl = q;\n        }(o = n.ItemsChart || (n.ItemsChart = {})), function (t) {\n          var e = t.Gestures || (t.Gestures = {}),\n              i = t.Layouts || (t.Layouts = {}),\n              n = t.Bar || (t.Bar = {});\n          !function (t) {\n            t[t.NodeClass = 0] = \"NodeClass\", t[t.LinkClass = 1] = \"LinkClass\", t[t.Aura = 2] = \"Aura\";\n          }(t.LegendItemType || (t.LegendItemType = {}));\n\n          var s = function (t) {\n            function e(e, i, n, r, s, a, o, l, h) {\n              var u = t.call(this, i, n, r, s) || this;\n              return u.itemId = e, u.enabled = a, u.node = o, u.link = l, u.aura = h, u;\n            }\n\n            return r(e, t), e;\n          }(h.LegendEntry),\n              a = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e, null) || this;\n              return n.halfSize = i, n;\n            }\n\n            return r(e, t), e.prototype.distanceToEdge = function () {\n              return this.halfSize;\n            }, e;\n          }(o.Shape),\n              l = function (t) {\n            function e(e, i) {\n              var n = t.call(this, null, null, !0) || this;\n              return n.data = {\n                id: null,\n                loaded: !0\n              }, n.hHeight = e, n.hWidth = e, n.renderHheight = e, n.renderHwidth = e, n.x = i ? 2 * -e : e + e / 2, n.y = 0, n.shape = new a(n, e), n;\n            }\n\n            return r(e, t), e;\n          }(o.Node),\n              u = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.textColorDisabled = \"rgba(64,62,62,0.3)\", e.showItemsWithClasses = \"any\", e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegendAdvanced);\n\n          t.SettingsLegendAdvanced = u;\n\n          var c = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.panel = new h.SettingsLegendPanel(\"bottom\", \"left\"), e.advanced = new u(), e.marker.size = 30, e.padding = 15, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegend);\n\n          t.SettingsLegend = c;\n\n          var d = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.paintOrder = 51, e.updateOrder = 100, e.linkClassState = Object.create(null), e.nodeClassState = Object.create(null), e.allNodeClassesEnabled = !0, e.allLinkClassesEnabled = !0, e;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (e) {\n              t.prototype.onSceneChange.call(this, e);\n              var i = e.changes.settingsChanges;\n              (e.changes.auras || i && (i.style && (i.style.nodeClasses || i.style.linkClasses) || i.legend && i.legend.text)) && (this.rebuildItems(e), e.changes.bounds = !0, e.changes.filters = !0);\n            }, e.prototype.doAnimations = function () {\n              return 1;\n            }, e.prototype.paintMarker = function (t, e, i, n, r) {\n              if (r.node) {\n                var s = {\n                  geometry: this.getGeometry(e, i, .6),\n                  paintDetails: !1\n                };\n                this.chart.renderer.paintNodes(t, [r.node], s, 0);\n              } else if (r.link) {\n                s = {\n                  geometry: this.getGeometry(e, i, 1),\n                  paintDetails: !0\n                };\n                this.chart.renderer.paintLinks(t, [r.link], {}, s);\n              } else this.paintAuraMarker(t.context, e, i, n, r.aura);\n            }, e.prototype.paintAuraMarker = function (t, e, i, n, r) {\n              var s = n / 527,\n                  a = e - n,\n                  o = i - n,\n                  l = h.Graphics.beginStrokeAndFill(t, r);\n              l.moveTo(878.4 * s + a, 413.8 * s + o), l.bezierCurveTo(856.4 * s + a, 404.2 * s + o, 817.1 * s + a, 388.9 * s + o, 769.7 * s + a, 378.2 * s + o), l.bezierCurveTo(696.1 * s + a, 361.5 * s + o, 679.5 * s + a, 324.1 * s + o, 676.7 * s + a, 308.7 * s + o), l.bezierCurveTo(674.4 * s + a, 296.1 * s + o, 652.9 * s + a, 188.3 * s + o, 589.9 * s + a, 107 * s + o), l.bezierCurveTo(543 * s + a, 42.5 * s + o, 466.9 * s + a, .6 * s + o, 381 * s + a, .6 * s + o), l.bezierCurveTo(238.4 * s + a, .6 * s + o, 122.8 * s + a, 116.2 * s + o, 122.8 * s + a, 258.8 * s + o), l.bezierCurveTo(122.8 * s + a, 264.7 * s + o, 123 * s + a, 270.5 * s + o, 123.4 * s + a, 276.3 * s + o), l.lineTo(122.8 * s + a, 276.9 * s + o), l.bezierCurveTo(122.8 * s + a, 276.9 * s + o, 127 * s + a, 333.8 * s + o, 136.7 * s + a, 389.3 * s + o), l.bezierCurveTo(146.4 * s + a, 444.8 * s + o, 138.1 * s + a, 500.4 * s + o, 106.2 * s + a, 543.4 * s + o), l.bezierCurveTo(74.3 * s + a, 586.4 * s + o, 2.1 * s + a, 689.2 * s + o, 4.9 * s + a, 754.4 * s + o), l.bezierCurveTo(5 * s + a, 755.9 * s + o, 5.2 * s + a, 757.3 * s + o, 5.4 * s + a, 758.8 * s + o), l.bezierCurveTo(4.1 * s + a, 769.2 * s + o, 3.5 * s + a, 779.8 * s + o, 3.5 * s + a, 790.5 * s + o), l.bezierCurveTo(3.5 * s + a, 933.1 * s + o, 119.1 * s + a, 1048.7 * s + o, 261.7 * s + a, 1048.7 * s + o), l.bezierCurveTo(349.6 * s + a, 1048.7 * s + o, 427.2 * s + a, 1004.7 * s + o, 473.9 * s + a, 937.6 * s + o), l.lineTo(474.1 * s + a, 937.6 * s + o), l.bezierCurveTo(474.1 * s + a, 937.6 * s + o, 510.2 * s + a, 891.8 * s + o, 518.5 * s + a, 884.8 * s + o), l.bezierCurveTo(526.8 * s + a, 877.9 * s + o, 568.5 * s + a, 854.3 * s + o, 608.7 * s + a, 869.5 * s + o), l.bezierCurveTo(631.7 * s + a, 878.2 * s + o, 675.6 * s + a, 894.2 * s + o, 719.1 * s + a, 905 * s + o), l.bezierCurveTo(743.4 * s + a, 912.6 * s + o, 769.3 * s + a, 916.7 * s + o, 796.1 * s + a, 916.7 * s + o), l.bezierCurveTo(938.7 * s + a, 916.7 * s + o, 1054.3 * s + a, 801.1 * s + o, 1054.3 * s + a, 658.5 * s + o), l.bezierCurveTo(1054.3 * s + a, 544.8 * s + o, 980.6 * s + a, 448.1 * s + o, 878.4 * s + a, 413.8 * s + o), l.closePath(), h.Graphics.endStrokeAndFill(t, l, r), (l = h.Graphics.beginStrokeAndFill(t, {\n                fillColor: \"white\"\n              })).moveTo(796.1 * s + a, 825.2 * s + o), l.bezierCurveTo(718.8 * s + a, 825.2 * s + o, 653.8 * s + a, 772.6 * s + o, 635 * s + a, 701.2 * s + o), l.lineTo(423.3 * s + a, 750 * s + o), l.bezierCurveTo(426.5 * s + a, 763 * s + o, 428.3 * s + a, 776.5 * s + o, 428.3 * s + a, 790.5 * s + o), l.bezierCurveTo(428.3 * s + a, 882.5 * s + o, 353.7 * s + a, 957.1 * s + o, 261.7 * s + a, 957.1 * s + o), l.bezierCurveTo(169.7 * s + a, 957.1 * s + o, 95.1 * s + a, 882.5 * s + o, 95.1 * s + a, 790.5 * s + o), l.bezierCurveTo(95.1 * s + a, 698.5 * s + o, 169.7 * s + a, 623.9 * s + o, 261.7 * s + a, 623.9 * s + o), l.bezierCurveTo(270.7 * s + a, 623.9 * s + o, 279.4 * s + a, 624.6 * s + o, 288 * s + a, 626 * s + o), l.lineTo(331.2 * s + a, 417.8 * s + o), l.bezierCurveTo(263.6 * s + a, 396.6 * s + o, 214.5 * s + a, 333.4 * s + o, 214.5 * s + a, 258.8 * s + o), l.bezierCurveTo(214.5 * s + a, 166.8 * s + o, 289.1 * s + a, 92.2 * s + o, 381.1 * s + a, 92.2 * s + o), l.bezierCurveTo(473.1 * s + a, 92.2 * s + o, 547.7 * s + a, 166.8 * s + o, 547.7 * s + a, 258.8 * s + o), l.bezierCurveTo(547.7 * s + a, 298.1 * s + o, 534.1 * s + a, 334.1 * s + o, 511.4 * s + a, 362.6 * s + o), l.lineTo(684 * s + a, 535.3 * s + o), l.bezierCurveTo(713.6 * s + a, 508.4 * s + o, 752.9 * s + a, 492 * s + o, 796.1 * s + a, 492 * s + o), l.bezierCurveTo(888.1 * s + a, 492 * s + o, 962.7 * s + a, 566.6 * s + o, 962.7 * s + a, 658.6 * s + o), l.bezierCurveTo(962.7 * s + a, 750.6 * s + o, 888.1 * s + a, 825.2 * s + o, 796.1 * s + a, 825.2 * s + o), l.closePath(), l.moveTo(381 * s + a, 425.4 * s + o), l.bezierCurveTo(374.2 * s + a, 425.4 * s + o, 367.6 * s + a, 425 * s + o, 361 * s + a, 424.2 * s + o), l.lineTo(317.5 * s + a, 633.5 * s + o), l.bezierCurveTo(359.9 * s + a, 648.6 * s + o, 394.3 * s + a, 680.4 * s + o, 413 * s + a, 721 * s + o), l.lineTo(630 * s + a, 671 * s + o), l.bezierCurveTo(629.7 * s + a, 666.9 * s + o, 629.5 * s + a, 662.8 * s + o, 629.5 * s + a, 658.6 * s + o), l.bezierCurveTo(629.5 * s + a, 620.8 * s + o, 642.1 * s + a, 585.9 * s + o, 663.4 * s + a, 557.9 * s + o), l.lineTo(490.2 * s + a, 384.6 * s + o), l.bezierCurveTo(460.9 * s + a, 410 * s + o, 422.8 * s + a, 425.4 * s + o, 381 * s + a, 425.4 * s + o), l.closePath(), h.Graphics.endStrokeAndFill(t, l, {\n                fillColor: \"white\"\n              });\n            }, e.prototype.rebuildItems = function (t) {\n              var e = this.chart.scene.settings.style,\n                  i = [],\n                  n = this.settings.marker.size / 2,\n                  r = this.settings.text.fillColor,\n                  a = this.settings.advanced.textColorDisabled,\n                  u = this.nodeClassState,\n                  c = this.linkClassState;\n              this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0, this.chart.layer.styleUpdater.setItemRenderer(t.labelRenderer), this.chart.layer.styleUpdater.setContext(t.context);\n\n              for (var d = 0; d < e.nodeClasses.length; d++) {\n                var p = e.nodeClasses[d];\n\n                if (p.showInLegend && null != p.style) {\n                  var f = h.Helpers.clone(e.node);\n                  h.Helpers.extendStyleTo(p.style, f);\n                  var g = new l(n, !1);\n                  h.Helpers.extendStyleTo(f, g), this.chart.layer.styleUpdater.postprocessNode(g);\n                  var m = !h.Helpers.hasProperty(u, p.className) || u[p.className];\n                  this.nodeClassState[p.className] = m, m || (this.allNodeClassesEnabled = !1), i.push(new s(p.className, p.nameLegend || p.className, r, a, p.legendGroupId, m, g, null, null));\n                }\n              }\n\n              for (var v = 0; v < e.linkClasses.length; v++) {\n                var y = e.linkClasses[v];\n\n                if (y.showInLegend && null != y.style) {\n                  f = h.Helpers.clone(e.link);\n                  h.Helpers.extendStyleTo(y.style, f);\n                  var S = new o.Link(null, null);\n                  h.Helpers.extendStyleTo(f, S), S.currentRadius = S.radius, S.from = new l(n, !0), S.to = new l(n, !1);\n                  m = !h.Helpers.hasProperty(c, y.className) || c[y.className];\n                  this.linkClassState[y.className] = m, this.allLinkClassesEnabled = this.allLinkClassesEnabled && m, i.push(new s(y.className, y.nameLegend || y.className, r, a, y.legendGroupId, m, null, S, null));\n                }\n              }\n\n              for (var b = this.chart.settings.auras._calculatedStyles, C = Object.keys(b), x = 0; x < C.length; x++) {\n                var w = C[x],\n                    L = b[w];\n                L.enabled || (this.allNodeClassesEnabled = !1), (L.showInLegend || null == L.showInLegend) && i.push(new s(w, L.nameLegend || w, r, a, L.legendGroupId, L.enabled, null, null, L));\n              }\n\n              this.resetEntries(i);\n            }, e.prototype.getGeometry = function (t, e, i) {\n              var n = this.settings.marker.size;\n              return {\n                txm: i,\n                txa: t,\n                tym: i,\n                tya: e,\n                zoom: i,\n                x0s: t - n,\n                x1s: t + n,\n                y0s: e - n,\n                y1s: e + n,\n                x0w: -n,\n                y0w: -n,\n                x1w: n,\n                y1w: n,\n                linkZoom: i\n              };\n            }, e.prototype.itemClicked = function (e, i) {\n              t.prototype.itemClicked.call(this, e, i), this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0;\n\n              for (var n = 0; n < this.entries.length; n++) {\n                var r = this.entries[n];\n                if (r.node) this.nodeClassState[r.itemId] = r.enabled, r.enabled || (this.allNodeClassesEnabled = !1);else if (r.link) this.linkClassState[r.itemId] = r.enabled, r.enabled || (this.allLinkClassesEnabled = !1);else {\n                  var s = this.chart.settings.auras;\n                  s._calculatedStyles[r.itemId].enabled = r.enabled, s.style[r.itemId].enabled = r.enabled, s._defaultStyles[r.itemId].enabled = r.enabled, this.chart.events.notifySceneChanges({\n                    settingsChanges: {\n                      auras: {}\n                    }\n                  }), r.enabled || (this.allNodeClassesEnabled = !1);\n                }\n              }\n\n              this.chart.events.notifySceneChanges({\n                filters: !0\n              });\n            }, e.prototype.isNodeVisible = function (t) {\n              if (this.allNodeClassesEnabled) return !0;\n              var e = t.className,\n                  i = t.style ? t.style.aura : null;\n              if (!e && !i) return !0;\n              var n = o.ItemsStyle.getClasses(e),\n                  r = Array.isArray(i) ? i : [i],\n                  s = this.chart.settings.auras._calculatedStyles;\n\n              if (\"any\" === this.settings.advanced.showItemsWithClasses) {\n                for (var a = !1, l = !1, u = 0; u < n.length; u++) {\n                  if (h.Helpers.hasProperty(this.nodeClassState, n[u])) {\n                    if (this.nodeClassState[n[u]]) {\n                      l = !0;\n                      break;\n                    }\n\n                    a = !0;\n                  }\n                }\n\n                for (u = 0; u < r.length; u++) {\n                  if (h.Helpers.hasProperty(s, r[u])) {\n                    if (s[r[u]].enabled) {\n                      l = !0;\n                      break;\n                    }\n\n                    a = !0;\n                  }\n                }\n\n                return l || !a;\n              }\n\n              for (u = 0; u < n.length; u++) {\n                if (h.Helpers.hasProperty(this.nodeClassState, n[u]) && !this.nodeClassState[n[u]]) return !1;\n              }\n\n              for (u = 0; u < r.length; u++) {\n                if (h.Helpers.hasProperty(s, r[u]) && !s[r[u]].enabled) return !1;\n              }\n\n              return !0;\n            }, e.prototype.isLinkVisible = function (t) {\n              if (this.allLinkClassesEnabled) return !0;\n              var e = t.className;\n              if (!e) return !0;\n              var i = o.ItemsStyle.getClasses(e);\n\n              if (\"any\" === this.settings.advanced.showItemsWithClasses) {\n                for (var n = !1, r = !1, s = 0; s < i.length; s++) {\n                  if (h.Helpers.hasProperty(this.linkClassState, i[s])) {\n                    if (this.linkClassState[i[s]]) {\n                      r = !0;\n                      break;\n                    }\n\n                    n = !0;\n                  }\n                }\n\n                return r || !n;\n              }\n\n              for (s = 0; s < i.length; s++) {\n                if (h.Helpers.hasProperty(this.linkClassState, i[s]) && !this.linkClassState[i[s]]) return !1;\n              }\n\n              return !0;\n            }, e;\n          }(h.Legend);\n\n          t.Legend = d, function (e) {\n            var i = function (t) {\n              function e(e, i) {\n                var n = t.call(this, e, i) || this;\n                n.scene = e.scene, n.events = e.events;\n                var r = h.Helpers.createDom(\"li\", null, null, null),\n                    s = h.Helpers.createDom(\"span\", \"DVSL-NC-zoom\", null, r);\n                return n.handle = h.Helpers.createDom(\"em\", null, null, s), n.mouse = new h.MouseEvents(r, n.scene.settings.advanced.pointer), n.mouse.listen(\"drag\", function (t) {\n                  return n.zoomMove(t);\n                }), n.mouse.listen(\"down\", function (t) {\n                  return n.zoomDown(t);\n                }), n.domElement = r, n;\n              }\n\n              return r(e, t), e.prototype.zoomDown = function (t) {\n                t.y < 100 && this.zoomMove(t);\n              }, e.prototype.zoomMove = function (t) {\n                var e = t.y - 10;\n                e = Math.max(0, Math.min(80, e)), this.handle.style.top = e + \"px\";\n                var i = this.getZoomValue(e / 80);\n                this.chart.autoZoom.manualZoom(i / this.scene.zoom), this.events.notifySceneChanges({\n                  position: !0\n                }), t.consumed = !0;\n              }, e.prototype.getSliderPosition = function () {\n                var t = this.scene.settings.interaction.zooming.zoomExtent,\n                    e = Math.min(t[0], this.chart.autoZoom.minimumAutoZoom),\n                    i = t[1];\n                return 1 - (Math.log(Math.max(e, Math.min(i, this.scene.zoom))) - (e = Math.log(e))) / ((i = Math.log(i)) - e);\n              }, e.prototype.getZoomValue = function (t) {\n                var e = this.scene.settings.interaction.zooming.zoomExtent,\n                    i = Math.min(e[0], this.chart.autoZoom.minimumAutoZoom),\n                    n = e[1];\n                i = Math.log(i);\n                var r = (1 - t) * ((n = Math.log(n)) - i) + i;\n                return Math.exp(r);\n              }, e.prototype.doAnimations = function (t) {\n                var e = this.getSliderPosition();\n                this.handle.style.top = 80 * e + \"px\";\n              }, e.prototype.remove = function () {\n                this.mouse.remove();\n              }, e;\n            }(h.Bar.Item);\n\n            e.ZoomControl = i, h.Bar.ToolbarItemNames.zoomControl = h.Bar.ToolbarItemNames.zoomcontrol = function (e, i) {\n              return new t.Bar.ZoomControl(e, i);\n            }, h.Bar.ToolbarItemNames.rearrange = function (t, e) {\n              var i = t.settings.localization.toolbar;\n              e.label = e.label || i.rearrangeButton, e.title = e.title || i.rearrangeTitle, e.cssClass = e.cssClass || \"DVSL-bar-btn-rearrange\";\n              var n = e.onClick;\n              return e.onClick = function (e, i) {\n                t.resetLayout(), n && n(e, i);\n              }, new h.Bar.Button(t, e);\n            }, h.Bar.ToolbarItemNames.freeze = function (t, e) {\n              var i = t.settings.localization.toolbar;\n              return new h.Bar.ToggleButton(t, e, {\n                labelDisabled: e.label || i.freezeButton,\n                cssClassEnabled: \"DVSL-bar-btn-lock-all-active\",\n                cssClassDisabled: e.cssClass || \"DVSL-bar-btn-lock-all\",\n                titleEnabled: i.unfreezeTitle,\n                titleDisabled: i.freezeTitle,\n                getChartState: function getChartState() {\n                  return t.isLayoutFrozen;\n                },\n                onEnable: function onEnable() {\n                  return t.freezeLayout();\n                },\n                onDisable: function onDisable() {\n                  return t.unfreezeLayout();\n                }\n              });\n            }, h.Bar.ToolbarItemNames.fit = function (t, e) {\n              var i = t.settings.localization.toolbar;\n              return new h.Bar.ToggleButton(t, e, {\n                labelDisabled: e.label || i.fitButton,\n                cssClassEnabled: \"DVSL-bar-btn-fit-active\",\n                cssClassDisabled: e.cssClass || \"DVSL-bar-btn-fit\",\n                titleDisabled: e.title || i.fitTitle,\n                getChartState: function getChartState() {\n                  return \"overview\" === t.scene.autoZoomMode;\n                },\n                onEnable: function onEnable() {\n                  return t.autoZoom.setZoom(\"overview\");\n                },\n                onDisable: function onDisable() {\n                  return t.autoZoom.setZoom(\"auto\");\n                }\n              });\n            };\n\n            var n = function (t) {\n              function e() {\n                var e = t.call(this) || this;\n                return e.zoomControl = !0, e.enabled = !0, e.side = \"bottom\", e.align = \"left\", e.showLabels = !1, e.fullscreen = !0, e.export = !1, e.items = [new h.SettingsToolbarItem(\"fit\"), new h.SettingsToolbarItem(\"rearrange\"), new h.SettingsToolbarItem(\"freeze\"), new h.SettingsToolbarItem(\"back\"), new h.SettingsToolbarItem(\"fullscreen\"), new h.SettingsToolbarItem(\"export\"), new h.SettingsToolbarItem(\"zoomControl\", \"bottom\", \"left\")], e;\n              }\n\n              return r(e, t), e;\n            }(h.SettingsToolbar);\n\n            e.SettingsToolbar = n;\n\n            var s = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.rearrangeButton = \"Rearrange\", e.rearrangeTitle = \"Rearrange elements\", e.freezeButton = \"Freeze\", e.freezeTitle = \"Lock all\", e.unfreezeTitle = \"Unlock all\", e.fitButton = \"Fit\", e.fitTitle = \"Fit to screen\", e;\n              }\n\n              return r(e, t), e;\n            }(h.SettingsLocalizationToolbar);\n\n            e.SettingsLocalizationToolbar = s;\n          }(n = t.Bar || (t.Bar = {}));\n\n          var p = function (t) {\n            function e(i) {\n              var r = t.call(this, h.SettingsMapping.NetChartSettings) || this;\n              return r.theme = e.FlatTheme, r.data = [], r.area = new g(), r.events = new w(), r.style = new x(), r.auras = new o.SettingsNodesLayerAuras(), r.layout = new C(), r.filters = {\n                nodeFilter: null,\n                linkFilter: null,\n                nodeLinksProcessor: null,\n                multilinkProcessor: null\n              }, r.interaction = new m(), r.navigation = new S(), r.toolbar = new n.SettingsToolbar(), r.localization = new f(), r.legend = new c(), r.nodeMenu.buttons = [\"hide\", \"expand\", \"focus\", \"lock\"], r.apply(i), r._initializing = !1, r;\n            }\n\n            return r(e, t), e.prototype.apply = function (e) {\n              return this.applyCompatibility(e, [{\n                from: \"interaction.zooming.autoZoomPositionEllasticity\",\n                to: \"interaction.zooming.autoZoomPositionElasticity\"\n              }, {\n                from: \"navigation.nodeExpansionRadius\",\n                to: \"navigation.focusNodeExpansionRadius\"\n              }, {\n                from: \"localization.menu.dynaminc\",\n                to: \"localization.menu.dynamic\"\n              }]), t.prototype.apply.call(this, e);\n            }, e;\n          }(o.Settings);\n\n          p.FlatTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\"\n            }\n          }, p.DarkTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-dark\"\n            },\n            area: {\n              style: {\n                fillColor: \"rgba(28,26,28,1)\"\n              }\n            },\n            title: {\n              margin: 15,\n              style: {\n                fillColor: \"#A8A7A8\"\n              }\n            },\n            legend: {\n              text: {\n                fillColor: \"#A8A7A8\"\n              }\n            },\n            style: {\n              node: {\n                fillColor: \"gray\"\n              },\n              link: {\n                fillColor: \"#09c\"\n              },\n              linkHovered: {\n                shadowColor: \"#09c\"\n              },\n              hiddenLinks: {\n                lineColor: \"#A8A7A8\"\n              },\n              nodeHovered: {\n                shadowColor: \"#fff\",\n                shadowOffsetY: 0,\n                shadowBlur: 12\n              },\n              nodeLabel: {\n                padding: 4,\n                borderRadius: 10,\n                textStyle: {\n                  fillColor: \"rgba(180,180,180,1)\"\n                },\n                backgroundStyle: {\n                  fillColor: \"rgba(60,60,60,0.8)\",\n                  lineColor: null\n                }\n              },\n              linkLabel: {\n                padding: .6,\n                backgroundStyle: {\n                  lineColor: \"#09c\",\n                  fillColor: \"#333333\"\n                },\n                textStyle: {\n                  fillColor: \"#A8A7A8\"\n                }\n              },\n              selection: {\n                fillColor: \"white\",\n                shadowColor: \"rgba(255,255,255,0.6)\",\n                sizeConstant: 4,\n                shadowBlur: 24,\n                shadowOffsetY: 4\n              }\n            }\n          }, t.Settings = p;\n\n          var f = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.toolbar = new n.SettingsLocalizationToolbar(), e.menu = {\n                dynamic: \"Pin\",\n                fixed: \"Unpin\",\n                focus: \"Focus\",\n                unfocus: \"Unfocus\",\n                collapse: \"Collapse\",\n                close: \"Close\",\n                expand: \"Expand\",\n                hide: \"Hide\"\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLocalization);\n\n          t.SettingsLocalization = f;\n\n          var g = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.centerX = .5, e.centerY = .5, e.paddingTop = 0, e.paddingLeft = 0, e.paddingRight = 0, e.paddingBottom = 0, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsArea);\n\n          t.SettingsArea = g;\n\n          var m = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.zooming = new y(), e.selection = new v(), e.rotation = {\n                fingers: !1\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsInteraction);\n\n          t.SettingsInteraction = m;\n\n          var v = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.dragSelect = !0, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsInteractionSelection);\n\n          t.SettingsInteractionSelection = v;\n\n          var y = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.initialAutoZoom = \"overview\", e.zoomExtent = [.5, 4], e.autoZoomExtent = [null, 1], e.autoZoomSize = .9, e.autoZoomPositionElasticity = 2.5e-7, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsInteractionZooming);\n\n          t.SettingsInteractionZooming = y;\n\n          var S = function () {\n            return function () {\n              this.mode = \"showall\", this.initialNodes = null, this.focusNodeExpansionRadius = 2, this.focusNodeTailExpansionRadius = null, this.focusAutoFadeout = !1, this.numberOfFocusNodes = 3, this.minNumberOfFocusNodes = 1, this.expandDelay = 0, this.expandOnClick = !0, this.autoZoomOnFocus = !1, this.autoUnfocus = !0;\n            };\n          }();\n\n          t.SettingsNavigation = S;\n\n          var b = function () {\n            return function () {\n              this.strength = .01, this.from = \"auto\", this.fromCenter = \"weighted\", this.to = \"graph\", this.toCenter = \"weighted\";\n            };\n          }();\n\n          t.GravitySettings = b;\n\n          var C = function () {\n            return function () {\n              this.mode = \"dynamic\", this.nodeSpacing = 16, this.rowSpacing = null, this.groupSpacing = null, this.incrementalLayoutMaxTime = 300, this.initialLayoutMaxTime = 2e3, this.layoutFreezeTimeout = 1e4, this.layoutFreezeMinTimeout = 1500, this.aspectRatio = !1, this.globalLayoutOnChanges = !0, this.advanced = {\n                adaptiveFreezeTreshold: 1.2\n              }, this.twoRingRadialLayout = !1, this.rotation = 0, this.gravity = new b();\n            };\n          }();\n\n          t.SettingsLayout = C;\n\n          var x = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.dragSelection = {\n                fillColor: \"rgba(30,160,220,0.15)\",\n                lineColor: \"#000000\",\n                lineWidth: 1,\n                lineDash: [1, 2]\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsNodesLayerStyle);\n\n          t.SettingsStyle = x;\n\n          var w = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.onPointerDown = null, e.onPointerUp = null, e.onPointerDrag = null, e.onPointerMove = null, e.onDataUpdated = null, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsEvents);\n\n          t.SettingsEvents = w;\n\n          var L = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(o.Scene);\n\n          t.Scene = L, function (t) {\n            function e(t) {\n              if (0 === t.children.length) return 0;\n              var e = t.children[0],\n                  i = t.children[t.children.length - 1];\n              return (e.node.x - e.hWidth + (i.node.x + i.hWidth)) / 2;\n            }\n\n            function i(t, e, i, n, r) {\n              null == e && (t[0].node.x = 0, e = t[0]);\n\n              for (var s = e.levelIndex + 1, a = null === i ? t.length : i.levelIndex, o = e.node.x + e.hWidth, l = s; l < a; l++) {\n                var h = t[l];\n                o += h.hWidth + (null == t[l].parent || t[l - 1].parent !== t[l].parent ? r : n), h.node.x = o, o += h.hWidth;\n              }\n            }\n\n            var n = function () {\n              return function () {\n                this.forceLinkList = null, this.fx = 0, this.fy = 0, this.sizeEstimate = 0, this.left = null, this.right = null, this.leafCount = 0, this.leaves = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0;\n              };\n            }(),\n                s = function () {\n              function t() {\n                this.maxLeafCount = 5, this.root = null, this.freeNodeRoot = null, this.temperature = 0, this.nodeCount = 0;\n              }\n\n              return t._swap = function (t, e, i) {\n                var n = t[e];\n                t[e] = t[i], t[i] = n;\n              }, t.prototype.buildTree = function (t) {\n                this.iters = 0;\n                var e = t.length;\n                this.root && this.freeNode(this.root), this.root = this.newNode(), e > 0 && this.buildTreeRecursive(t, 0, e, this.root);\n\n                for (var i = 0; i <= e - 1; i++) {\n                  t[i].repulsiveForceX = 0, t[i].repulsiveForceY = 0, t[i].repulsiveForceZ = 0;\n                }\n\n                this.calculateForces();\n              }, t.prototype.freeNode = function (t) {\n                t.left && this.freeNode(t.left), t.right && this.freeNode(t.right), t.left = this.freeNodeRoot, this.freeNodeRoot = t;\n              }, t.prototype.newNode = function () {\n                var t;\n                return this.freeNodeRoot ? (t = this.freeNodeRoot, this.freeNodeRoot = t.left, t.left = null, t.right = null, t.leafCount = 0, t.sizeEstimate = 0, t.forceLinkList.length = 0) : ((t = new n()).forceLinkList = [], t.leaves = new Array(this.maxLeafCount)), t.repulsiveForceX = 0, t.repulsiveForceY = 0, t.repulsiveForceZ = 0, t;\n              }, t.prototype.addForceLink = function (t, e) {\n                t.forceLinkList.push(e);\n              }, t.prototype.getMedianX = function (e, i, n) {\n                for (var r = (i + (n -= 1)) / 2 | 0;;) {\n                  if (n <= i) return r;\n                  if (n === i + 1 && e[i].x > e[n].x) return t._swap(e, i, n), r;\n                  var s = (i + n) / 2 | 0;\n                  e[s].x > e[n].x && t._swap(e, s, n), e[i].x > e[n].x && t._swap(e, i, n), e[s].x > e[i].x && t._swap(e, s, i), t._swap(e, s, i + 1);\n\n                  for (var a = i + 1, o = n;;) {\n                    for (; a += 1, e[i].x > e[a].x;) {\n                      ;\n                    }\n\n                    for (; e[o -= 1].x > e[i].x;) {\n                      ;\n                    }\n\n                    if (o < a) break;\n                    var l = e[a];\n                    e[a] = e[o], e[o] = l;\n                  }\n\n                  t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1);\n                }\n              }, t.prototype.getMedianY = function (e, i, n) {\n                for (var r = (i + (n -= 1)) / 2 | 0;;) {\n                  if (n <= i) return r;\n                  if (n === i + 1) return e[i].y > e[n].y && t._swap(e, i, n), r;\n                  var s = (i + n) / 2 | 0;\n                  e[s].y > e[n].y && t._swap(e, s, n), e[i].y > e[n].y && t._swap(e, i, n), e[s].y > e[i].y && t._swap(e, s, i), t._swap(e, s, i + 1);\n\n                  for (var a = i + 1, o = n;;) {\n                    for (; a += 1, e[i].y > e[a].y;) {\n                      ;\n                    }\n\n                    for (; e[o -= 1].y > e[i].y;) {\n                      ;\n                    }\n\n                    if (o < a) break;\n                    var l = e[a];\n                    e[a] = e[o], e[o] = l;\n                  }\n\n                  t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1);\n                }\n              }, t.prototype.buildTreeRecursive = function (t, e, i, n) {\n                for (var r = t[e].x, s = t[e].y, a = r, o = s, l = e + 1; l < i; l++) {\n                  var h = t[l],\n                      u = h.x,\n                      c = h.y;\n                  u < r && (r = u), u > a && (a = u), c < s && (s = c), c > o && (o = c);\n                }\n\n                n.sizeEstimate = Math.max(a - r, o - s), n.sizeEstimate = n.sizeEstimate * n.sizeEstimate + .1, n.sizeEstimate *= 2;\n                var d,\n                    p = i - e;\n\n                if (p <= this.maxLeafCount) {\n                  n.leafCount = p;\n                  u = 0, c = 0;\n                  var f = 0,\n                      g = 0;\n\n                  for (l = 0; l < p; l++) {\n                    var m = t[l + e];\n                    u += m.x, c += m.y, f += m.z, g += m.r, n.leaves[l] = m;\n                  }\n\n                  var v = 1 / p;\n                  return n.r = g, n.x = u * v, n.y = c * v, void (n.z = f * v);\n                }\n\n                d = a - r > o - s ? this.getMedianX(t, e, i) : this.getMedianY(t, e, i), d++;\n                var y = this.newNode();\n                n.left = y, this.buildTreeRecursive(t, e, d, y), y = this.newNode(), n.right = y, this.buildTreeRecursive(t, d, i, y);\n                var S = 1 / p;\n                n.r = n.right.r + n.left.r, n.x = (n.left.x * (d - e) + n.right.x * (i - d)) * S, n.y = (n.left.y * (d - e) + n.right.y * (i - d)) * S, n.z = (n.left.z * (d - e) + n.right.z * (i - d)) * S;\n              }, t.prototype.calculateForces = function () {\n                var t = new Array(this.nodeCount),\n                    e = 0,\n                    i = 0;\n\n                for (null !== this.root.left ? (t[i] = this.root.left, t[++i] = this.root.right, i++, this.addForceLink(this.root.left, this.root.right)) : (t[i] = this.root, i++); e < i;) {\n                  var n = t[e];\n                  e++;\n                  var r = 1 / n.r;\n\n                  if (null !== n.left) {\n                    this.processTreeNode(n, n.left), this.processTreeNode(n, n.right), t[i] = n.left, t[++i] = n.right, i++;\n                    var s = n.left.r * r,\n                        a = n.repulsiveForceX * s,\n                        o = n.repulsiveForceY * s;\n                    n.left.repulsiveForceX += a, n.left.repulsiveForceY += o, n.right.repulsiveForceX += n.repulsiveForceX - a, n.right.repulsiveForceY += n.repulsiveForceY - o, this.addForceLink(n.left, n.right);\n                  } else for (var l = 0; l <= n.leafCount - 1; l++) {\n                    var h = n.leaves[l];\n                    this.processLeafNode(n, h);\n                    s = h.r * r;\n                    h.repulsiveForceX += n.repulsiveForceX * s, h.repulsiveForceY += n.repulsiveForceY * s;\n\n                    for (var u = l + 1; u <= n.leafCount - 1; u++) {\n                      var c = n.leaves[u];\n                      this.forceBetweenParticles(h, c);\n                    }\n                  }\n\n                  n.forceLinkList.length = 0;\n                }\n              }, t.prototype.processTreeNode = function (t, e) {\n                for (var i = t.forceLinkList.length, r = 0; r < i; r++) {\n                  var s = t.forceLinkList[r],\n                      a = e.x - s.x,\n                      o = e.y - s.y,\n                      l = a * a + o * o,\n                      h = e.sizeEstimate;\n\n                  if (s instanceof n && (h += s.sizeEstimate), h < l) {\n                    var u = e.r * s.r / (l * Math.sqrt(l)),\n                        c = a * u;\n                    e.repulsiveForceX += c, s.repulsiveForceX -= c;\n                    var d = o * u;\n                    e.repulsiveForceY += d, s.repulsiveForceY -= d;\n                  } else s instanceof n ? this.addForceLink(s, e) : this.addForceLink(e, s);\n                }\n              }, t.prototype.processLeafNode = function (t, e) {\n                for (var i = 0; i < t.forceLinkList.length; i++) {\n                  var r = t.forceLinkList[i];\n\n                  if (r instanceof n) {\n                    var s = e.x - r.x,\n                        a = e.y - r.y,\n                        o = s * s + a * a;\n\n                    if (r.sizeEstimate < o) {\n                      var l = e.r * r.r / (o * Math.sqrt(o)),\n                          h = s * l;\n                      e.repulsiveForceX += h, r.repulsiveForceX -= h;\n                      var u = a * l;\n                      e.repulsiveForceY += u, r.repulsiveForceY -= u;\n                    } else this.addForceLink(r, e);\n                  } else this.forceBetweenParticles(e, r);\n                }\n              }, t.prototype.forceBetweenParticles = function (t, e) {\n                var i,\n                    n = t.x - e.x,\n                    r = t.y - e.y,\n                    s = t.z - e.z,\n                    a = n * n + r * r + s * s,\n                    o = t.r + e.r;\n                i = a * this.temperature < o ? .25 * this.temperature * Math.sqrt(this.temperature * o) : .25 * o * o / (a * Math.sqrt(a)), t.repulsiveForceX += n * i, e.repulsiveForceX -= n * i, t.repulsiveForceY += r * i, e.repulsiveForceY -= r * i, t.repulsiveForceZ += s * i, e.repulsiveForceZ -= s * i;\n              }, t;\n            }();\n\n            t.BHTree = s;\n\n            var a = function (t) {\n              function e(e) {\n                var i = t.call(this) || this;\n                return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1600, i.chart = e, i;\n              }\n\n              return r(e, t), e.ConstructLayout = function (t) {\n                switch (t.settings.layout.mode) {\n                  case \"dynamic\":\n                    return new y(t);\n\n                  case \"radial\":\n                    return new S(t);\n\n                  case \"hierarchy\":\n                    return new C(t);\n\n                  case \"static\":\n                    return new x(t);\n\n                  default:\n                    return t.error(\"Unknown layout mode: '\" + t.settings.layout.mode + \"'\"), new y(t);\n                }\n              }, e;\n            }(h.ChartElement);\n\n            t.LayoutBase = a;\n\n            var o = function () {\n              function t(t, e) {\n                this.strength = t, this.nodes = e;\n              }\n\n              return t.prototype.filterLockedNodes = function (t) {\n                for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) {\n                  t[n].layerNode.locked && (e[i++] = t[n]);\n                }\n\n                return e.length = i, e;\n              }, t.prototype.filterUnlockedNodes = function (t) {\n                for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) {\n                  t[n].layerNode.locked || (e[i++] = t[n]);\n                }\n\n                return e.length = i, e;\n              }, t;\n            }(),\n                l = function (t) {\n              function e(e, i) {\n                var n = t.call(this, e, i) || this;\n                return n.clusters = n.calculateClusters(i), n;\n              }\n\n              return r(e, t), e.prototype.calculateClusters = function (t) {\n                for (var e = [], i = new Array(t.length), n = new Object(null), r = 0; r < t.length; r++) {\n                  var s = t[r],\n                      a = s.layerNode.id;\n\n                  if (!n[a]) {\n                    var o = [s];\n                    e.push(o), n[a] = !0;\n                    var l = 0,\n                        h = 0;\n\n                    for (i[h] = s, h++; l < h;) {\n                      s = i[l], l++;\n\n                      for (var u = 0; u < s.edges.length; u++) {\n                        var c = s.edges[u].to,\n                            d = c.layerNode.id;\n                        n[d] || (n[d] = !0, o.push(c), i[h] = c, h++);\n                      }\n                    }\n                  }\n                }\n\n                return e;\n              }, e;\n            }(o),\n                u = function (t) {\n              function e(e, i, n, r) {\n                var s = t.call(this, e, i) || this;\n                return s.toCenter = n, s.lockedOnly = r, s;\n              }\n\n              return r(e, t), e.prototype.recalculate = function () {\n                for (var t = 0; t < this.clusters.length; t++) {\n                  for (var e = this.clusters[t], i = this.lockedOnly ? this.toCenter(this.filterLockedNodes(e)) : this.toCenter(e), n = 0; n < e.length; n++) {\n                    var r = e[n];\n                    r.layerNode.userLock || (r.gravityForceX = (i.x - r.x) * this.strength, r.gravityForceY = (i.y - r.y) * this.strength);\n                  }\n                }\n              }, e;\n            }(l),\n                c = function (t) {\n              function e(e, i, n, r) {\n                var s = t.call(this, e, i) || this;\n                return s.toCenter = n, s.lockedOnly = r, s;\n              }\n\n              return r(e, t), e.prototype.recalculate = function () {\n                for (var t = this.lockedOnly ? this.toCenter(this.filterLockedNodes(this.nodes)) : this.toCenter(this.nodes), e = 0; e < this.nodes.length; e++) {\n                  var i = this.nodes[e];\n                  i.layerNode.userLock || (i.gravityForceX = (t.x - i.x) * this.strength, i.gravityForceY = (t.y - i.y) * this.strength);\n                }\n              }, e;\n            }(o),\n                d = function (t) {\n              function e(e, i, n, r, s) {\n                var a = t.call(this, e, i) || this;\n                return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a;\n              }\n\n              return r(e, t), e.prototype.recalculate = function () {\n                for (var t = 0; t < this.clusters.length; t++) {\n                  var e = this.clusters[t],\n                      i = this.filterUnlockedNodes(e);\n\n                  if (!(i.length < 1)) {\n                    var n = this.fromCenter(i),\n                        r = void 0;\n\n                    if (this.lockedOnly) {\n                      var s = this.filterLockedNodes(e);\n                      r = s.length < 1 ? this.toCenter(e) : this.toCenter(s);\n                    } else r = this.toCenter(e);\n\n                    if (r.x !== n.x || r.y !== n.y) for (var a = Math.min(10, Math.sqrt(i.length)) * this.strength, o = (r.x - n.x) * a, l = (r.y - n.y) * a, h = 0; h < e.length; h++) {\n                      var u = e[h];\n                      u.gravityForceX = o, u.gravityForceY = l;\n                    }\n                  }\n                }\n              }, e;\n            }(l),\n                p = function (t) {\n              function e(e, i, n, r, s) {\n                var a = t.call(this, e, i) || this;\n                return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a;\n              }\n\n              return r(e, t), e.prototype.recalculate = function () {\n                var t;\n\n                if (this.lockedOnly) {\n                  var e = this.filterLockedNodes(this.nodes);\n                  t = e.length < 1 ? this.toCenter(this.nodes) : this.toCenter(e);\n                } else t = this.toCenter(this.nodes);\n\n                for (var i = 0; i < this.clusters.length; i++) {\n                  var n = this.clusters[i],\n                      r = this.filterUnlockedNodes(n);\n\n                  if (!(r.length < 1)) {\n                    var s = this.fromCenter(r);\n                    if (t.x !== s.x || t.y !== s.y) for (var a = Math.min(10, Math.sqrt(r.length)) * this.strength, o = (t.x - s.x) * a, l = (t.y - s.y) * a, h = 0; h < n.length; h++) {\n                      var u = n[h];\n                      u.gravityForceX = o, u.gravityForceY = l;\n                    }\n                  }\n                }\n              }, e;\n            }(l),\n                f = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.recalculate = function () {\n                for (var t = new Object(null), e = new Array(this.nodes.length), i = 0, n = 0, r = 0; r < this.nodes.length; r++) {\n                  (l = this.nodes[r]).layerNode.userLock && (e[n++] = l, t[l.layerNode.id] = l);\n                }\n\n                for (; i < n;) {\n                  var s = t[(l = e[i++]).layerNode.id];\n\n                  for (r = 0; r < l.edges.length; r++) {\n                    var a = l.edges[r].to;\n                    t[a.layerNode.id] || (t[a.layerNode.id] = s, e[n++] = a);\n                  }\n                }\n\n                var o = null;\n\n                for (r = 0; r < this.nodes.length; r++) {\n                  var l;\n\n                  if (!(l = this.nodes[r]).layerNode.userLock) {\n                    var u = t[l.layerNode.id];\n                    u ? (l.gravityForceX = (u.x - l.x) * this.strength, l.gravityForceY = (u.y - l.y) * this.strength) : (null == o && (o = h.Geometry.findWeightedCenter(this.nodes)), l.gravityForceX = (o.x - l.x) * this.strength, l.gravityForceY = (o.y - l.y) * this.strength);\n                  }\n                }\n              }, e;\n            }(o),\n                g = function () {\n              function t(t) {\n                this._needsReset = !0, this._calculation = null, this._chart = t;\n              }\n\n              return t.prototype.reset = function () {\n                this._needsReset = !0;\n              }, t.prototype.guessBestMode = function (t) {\n                if (t.length < 1) return \"node\";\n                var e = new Object(null),\n                    i = new Array(t.length),\n                    n = 0,\n                    r = 1;\n\n                for (e[t[0].layerNode.id] = !0, i[0] = t[0]; n < r;) {\n                  for (var s = i[n++], a = 0; a < s.edges.length; a++) {\n                    var o = s.edges[a].to;\n                    e[o.layerNode.id] || (e[o.layerNode.id] = !0, i[r++] = o);\n                  }\n                }\n\n                return r < t.length ? \"node\" : \"cluster\";\n              }, t.prototype.resetCalculation = function (t) {\n                var e = this._chart.settings.layout.gravity;\n\n                if (this._calculation = null, 0 !== e.strength) {\n                  var i = e.from;\n                  if (\"nearestLockedNode\" === e.to) return void (\"node\" !== i && \"auto\" !== i || (this._calculation = new f(e.strength, t)));\n                  var n = \"weighted\" === e.toCenter ? h.Geometry.findWeightedCenter : h.Geometry.circumscribeCircle;\n\n                  if (\"auto\" === i && (i = this.guessBestMode(t)), \"cluster\" === i) {\n                    var r = \"weighted\" === e.fromCenter ? h.Geometry.findWeightedCenter : h.Geometry.circumscribeCircle;\n                    \"cluster\" === e.to ? this._calculation = new d(e.strength, t, r, n, !1) : \"clusterLockedNodes\" === e.to ? this._calculation = new d(e.strength, t, r, n, !0) : \"graph\" === e.to ? this._calculation = new p(e.strength, t, r, n, !1) : \"graphLockedNodes\" === e.to && (this._calculation = new p(e.strength, t, r, n, !0));\n                  } else \"node\" === i && (\"cluster\" === e.to ? this._calculation = new u(e.strength, t, n, !1) : \"clusterLockedNodes\" === e.to ? this._calculation = new u(e.strength, t, n, !0) : \"graph\" === e.to ? this._calculation = new c(e.strength, t, n, !1) : \"graphLockedNodes\" === e.to && (this._calculation = new c(e.strength, t, n, !0)));\n                }\n              }, t.prototype.recalculate = function (t) {\n                t.length < 2 || (this._needsReset && (this.resetCalculation(t), this._needsReset = !1), this._calculation && this._calculation.recalculate());\n              }, t;\n            }();\n\n            t.Gravity = g;\n\n            var m = function () {\n              return function (t, e, i) {\n                this.pair = null, this.K = null, this.len = null, this.strength = null, this.visibility = null, this.to = t, this.direction = e, this.links = i;\n              };\n            }(),\n                v = function () {\n              return function () {\n                this.layerNode = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.zattr = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0, this.gravityForceX = 0, this.gravityForceY = 0, this.forceX = null, this.forceY = null, this.forceZ = null, this.forceSum = null, this.oldForceX = null, this.oldForceY = null, this.oldForceZ = null, this.locked = !1, this.offsetX = 0, this.offsetY = 0, this.minr = 0, this.fsum = 0, this.edges = [];\n              };\n            }(),\n                y = function (t) {\n              function e(e) {\n                var i = t.call(this, e) || this;\n                return i.enableDebugState = !1, i.debugState = [], i.nodeRepulsionFactor = 15, i.linkForceFactor = .2, i.nodeDegreeModifier = 1, i.forceReductionFactor = 1, i.random = new h.Random(1), i.nodeCount = 0, i.nodes = [], i.edges = [], i.nodesAspect = 1, i.idToNode = {}, i.temperature = 0, i.unitTemperature = 0, i.randomLayoutRadius = 0, i.zAxisAttraction = 1, i.repulsiveForceTree = new s(), i.aspectRatio = null, i.idleSince = 0, i.noMovementSince = 0, i.layoutMovement = 0, i.gravity = null, i.gravity = new g(e), i;\n              }\n\n              return r(e, t), e.prototype.updateGraph = function (t, e, i) {\n                (i || t.length !== this.nodeCount) && (this.rebuildGraph(t, e), i = !0);\n\n                for (var n = 0; n < this.edges.length; n++) {\n                  for (var r = this.edges[n], s = r.links, a = 0; a < s.length; a++) {\n                    var o = s[a],\n                        l = o.targetStrength,\n                        h = o.targetLength,\n                        u = o.visibility;\n                    if (o.added) h = .2 + (h - .2) * u, l = l * u + (o.from.links.length > 1 && o.to.links.length > 1 || o.removed ? .2 : l) * (1 - u);\n                    0 === a ? (r.strength = l, r.len = h, r.visibility = u) : (r.strength = Math.max(l, r.strength), r.len = Math.max(h, r.len), r.visibility = Math.max(u, r.visibility));\n                  }\n\n                  r.pair.strength = r.strength, r.pair.len = r.len, r.pair.visibility = r.visibility, r.K = r.pair.K = 0;\n                }\n\n                var c = this.chart.settings.layout.nodeSpacing / 2;\n\n                for (n = 0; n < t.length; n++) {\n                  var d = (C = this.nodes[n]).layerNode,\n                      p = d.outerBounds.w(),\n                      f = d.outerBounds.h();\n                  C.offsetX = d.outerBounds.x0 + d.outerBounds.x1, C.offsetY = d.outerBounds.y0 + d.outerBounds.y1, C.x = d.x + C.offsetX, C.y = d.y + C.offsetY, C.zattr = d.visibility, C.locked = d.locked, C.forceX = 0, C.forceY = 0, C.forceZ = 0, C.forceSum = 0;\n\n                  for (var g = 0, m = 0; m < C.edges.length; m++) {\n                    g += (w = C.edges[m]).to.edges.length * w.visibility;\n                  }\n\n                  var v = Math.sqrt(g);\n                  C.r = .5 * Math.max(1, p) + c, C.minr = Math.max(1, (f + .5 * p) / 3) + c, v > 4 && (C.r += (v - 4) * C.r / 4 * this.nodeDegreeModifier, C.minr += (v - 4) * C.minr / 4 * this.nodeDegreeModifier);\n                }\n\n                var y = 0,\n                    S = 0,\n                    b = 0;\n\n                for (n = 0; n < this.nodes.length; n++) {\n                  var C = this.nodes[n],\n                      x = 0;\n\n                  for (a = 0; a < C.edges.length; a++) {\n                    var w,\n                        L = (w = C.edges[a]).to;\n\n                    if (!(C.locked && L.locked || C === L)) {\n                      b++;\n                      var T = C.minr + L.minr;\n                      w.len > 0 ? (w.len = Math.max(1, T * w.len), w.K = 30 * Math.min(20, w.strength) / w.len, x += w.K, y += w.len) : (w.K = w.strength, x += w.K, y += T);\n                    }\n                  }\n\n                  C.fsum = x, S += C.r * C.r;\n                }\n\n                b > 0 ? (this.randomLayoutRadius = Math.max(1, y / 10), this.unitTemperature = y / (50 * b)) : (this.randomLayoutRadius = Math.max(1, Math.sqrt(S)), this.unitTemperature = 1), i && this.saveDebugState(\"updateGraph: Graph rebuilt.\");\n              }, e.prototype.rebuildGraph = function (t, e) {\n                var i = this.idToNode;\n                this.nodeCount = t.length, this.nodes = new Array(this.nodeCount), this.idToNode = {};\n\n                for (var n = 0, r = 0, s = 0; s < t.length; s++) {\n                  var a = t[s],\n                      o = a.id,\n                      l = new v();\n                  l.layerNode = a;\n                  var u = a.outerBounds.w(),\n                      c = a.outerBounds.h();\n\n                  if (c > 0 && (n += c / u, r += 1), this.idToNode[o] = l, this.nodes[s] = l, h.Helpers.hasProperty(i, o)) {\n                    var d = i[o];\n                    l.z = d.z, l.oldForceX = d.oldForceX, l.oldForceY = d.oldForceY, l.oldForceZ = d.oldForceZ;\n                  } else l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0;\n                }\n\n                this.nodesAspect = r > 0 ? Math.max(.3, n / r) : 1;\n                var p = {},\n                    f = {\n                  U: \"D\",\n                  null: null,\n                  D: \"U\",\n                  L: \"R\",\n                  R: \"L\"\n                };\n                this.edges = [];\n\n                for (s = 0; s < e.length; s++) {\n                  var g = e[s],\n                      y = g.multiId;\n                  if (h.Helpers.hasProperty(p, y)) p[y].push(g);else {\n                    var S = this.idToNode[g.from.id],\n                        b = this.idToNode[g.to.id],\n                        C = [g],\n                        x = new m(b, g.direction, C),\n                        w = new m(S, f[g.direction], C);\n                    x.pair = w, w.pair = x, p[y] = C, S.edges.push(x), b.edges.push(w), this.edges.push(x);\n                  }\n                }\n\n                this.gravity.reset();\n              }, e.prototype.saveDebugState = function (t) {\n                this.enableDebugState && this.debugState.push({\n                  extra: {\n                    comment: t\n                  },\n                  nodes: this.nodes.map(function (t) {\n                    return {\n                      id: t.layerNode.id,\n                      x: t.x - t.offsetX,\n                      y: t.y - t.offsetY,\n                      style: t.layerNode.data.style,\n                      extra: t.layerNode.data.extra,\n                      loaded: !0\n                    };\n                  }),\n                  links: this.edges.map(function (t) {\n                    return {\n                      from: t.to.layerNode.id,\n                      to: t.pair.to.layerNode.id\n                    };\n                  })\n                });\n              }, e.prototype.globalLayout = function (t, e) {\n                if (!(this.nodeCount <= 0)) {\n                  if (e) {\n                    if (1 === this.nodeCount) return this.nodes[0].locked || (this.nodes[0].layerNode.x = this.nodes[0].layerNode.y = 0), void this.saveDebugState(\"globalLayout: resetPositions\");\n                    this.initialRandomLayout(), this.saveDebugState(\"globalLayout: resetPositions\");\n                  }\n\n                  for (var i = 0, n = 0; n < this.nodes.length; n++) {\n                    this.nodes[n].locked || i++;\n                  }\n\n                  var r = Math.floor(Math.sqrt(i) + 10),\n                      s = 2 * r;\n                  this.forceReductionFactor = 1, this.temperature = (2 * Math.sqrt(i) + 20) * this.unitTemperature, this.zAxisAttraction = .02;\n\n                  for (var a = h.Helpers.performanceNow(), o = 3; this.temperature > this.unitTemperature && (s-- <= 0 && (s = 3 * r / o++, this.temperature = this.temperature / 1.5 - .5, this.temperature < 20 * this.unitTemperature && (this.zAxisAttraction = 1.5 * this.zAxisAttraction + .02)), this.randomnodesForRepulsion(), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.moveNodesGlobal(), this.saveDebugState(\"globalLayout: iteration\"), !(h.Helpers.performanceNow() > a + t));) {\n                    ;\n                  }\n\n                  e && (this.centerNodes(), this.saveDebugState(\"globalLayout: centerNodes\")), this.storeNodes();\n                }\n              }, e.prototype.initialRandomLayout = function () {\n                for (var t = this.nodeCount, e = new Array(t), i = 0; i <= t - 1; i++) {\n                  e[i] = this.nodes[i];\n                }\n\n                for (i = 0; i < t; i++) {\n                  var n = Math.floor(this.random.get() * (t - i)) + i,\n                      r = e[i];\n                  e[i] = e[n], e[n] = r;\n                }\n\n                for (var s = this.randomLayoutRadius, a = 2 * Math.PI / this.nodeCount, o = 0; o < t; o++) {\n                  var l = e[o];\n\n                  if (l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0, l.z = this.random.get() - .5, !l.locked) {\n                    var h = s + l.r;\n                    l.x = h * Math.cos(o * a), l.y = h * Math.sin(o * a);\n                  }\n                }\n              }, e.prototype.timedLayout = function (t) {\n                if (!(this.nodeCount <= 1) && t > 0) {\n                  var e = 0;\n                  t < .1 ? (e = 2, this.forceReductionFactor = Math.max(.002, Math.min(this.forceReductionFactor, 10 * t))) : e = Math.min(6, Math.round(2 + 10 * t)), this.zAxisAttraction = this.nodeRepulsionFactor / 28, this.temperature = this.unitTemperature;\n\n                  for (var i = 0; i <= e - 1; i++) {\n                    this.randomnodesForRepulsion(), this.applyAspect(1 / this.nodesAspect), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.applyAspect(this.nodesAspect), this.moveNodesIncremental(), this.saveDebugState(\"timedLayout: iteration\");\n                  }\n\n                  this.storeNodes();\n                }\n              }, e.prototype.prepareAspectRatio = function (t) {\n                for (var e, i, n, r, s, a, o, l = this.nodes, h = l[0].x, u = l[0].y, c = h, d = u, p = !0, f = 1; f <= this.nodeCount - 1; f++) {\n                  h = Math.min(h, l[f].x), c = Math.max(c, l[f].x), u = Math.min(u, l[f].y), d = Math.max(d, l[f].y);\n                }\n\n                var g = (h + c) / 2,\n                    m = (u + d) / 2,\n                    v = c - h,\n                    y = d - u;\n                return 0 === v || 0 === y ? p = !1 : (e = Math.sqrt(this.aspectRatio), s = g - g * (n = t * (n = (i = Math.sqrt(v * y)) * e / v) + (1 - t)), a = m - m * (r = t * (r = i / e / y) + (1 - t)), o = 1 / this.forceReductionFactor), {\n                  scaleX: n,\n                  incX: s,\n                  scaleY: r,\n                  incY: a,\n                  invForce: o,\n                  aspectRatioPrepared: p\n                };\n              }, e.prototype.updateAspectRatioNode = function (t, e) {\n                e.forceX += (e.x * (t.scaleX - 1) + t.incX) * t.invForce, e.forceY += (e.y * (t.scaleY - 1) + t.incY) * t.invForce;\n              }, e.prototype.updateAspectRatio = function (t) {\n                for (var e = this.prepareAspectRatio(t), i = this.nodes, n = 0; n <= this.nodeCount - 1; n++) {\n                  this.updateAspectRatioNode(e, i[n]);\n                }\n              }, e.prototype.moveNodesGlobal = function () {\n                this.gravity.recalculate(this.nodes);\n                var t,\n                    e = .5 * this.temperature,\n                    i = this.forceReductionFactor;\n                this.aspectRatio && ((t = this.prepareAspectRatio(.005)).aspectRatioPrepared || (this.aspectRatio = null));\n\n                for (var n = 0; n <= this.nodeCount - 1; n++) {\n                  var r = this.nodes[n];\n\n                  if (!r.locked) {\n                    this.calculateForce(r, .5), this.aspectRatio && this.updateAspectRatioNode(t, r);\n                    var s = r.oldForceX = r.forceX,\n                        a = r.oldForceY = r.forceY,\n                        o = r.oldForceZ = r.forceZ,\n                        l = r.forceSum,\n                        h = (s *= l) * s + (a *= l) * a + (o *= l) * o;\n                    h < this.temperature * this.temperature && h > .001 && (s *= h = this.temperature / Math.sqrt(h), a *= h, o *= h), r.x += s * i + (this.random.get() - .5) * e, r.y += a * i + (this.random.get() - .5) * e, r.z += o * i + (this.random.get() - .5) * e;\n                  }\n                }\n              }, e.prototype.moveNodesIncremental = function () {\n                this.gravity.recalculate(this.nodes);\n\n                for (var t = 0; t <= this.nodeCount - 1; t++) {\n                  this.nodes[t].locked || this.calculateForce(this.nodes[t], 0);\n                }\n\n                if (this.aspectRatio) {\n                  var e = Math.min(.4, .5 / Math.pow(this.nodeCount, .5));\n                  this.updateAspectRatio(e);\n                }\n\n                var i = 0,\n                    n = 0,\n                    r = 0,\n                    s = new Array(this.nodeCount);\n\n                for (t = 0; t <= this.nodeCount - 1; t++) {\n                  var a = this.nodes[t];\n\n                  if (!a.locked) {\n                    var o = a.forceX,\n                        l = a.forceY,\n                        h = a.forceZ,\n                        u = o * o + l * l + h * h;\n\n                    if (u * (p = a.forceSum) * p > this.unitTemperature * this.unitTemperature * .05 * .05) {\n                      u;\n                      var c = a.oldForceX * o + a.oldForceY * l + a.oldForceZ * h;\n                      r += c, c > 0 ? n += c : i -= c;\n                    } else s[t] = !0;\n                  }\n                }\n\n                this.layoutMovement = (n - 5 * i) / this.nodeCount, r > 1e-7 ? this.forceReductionFactor *= 1 + .4 / 1.618033989 : r < -1e-7 && (this.forceReductionFactor /= 1.4), this.forceReductionFactor = Math.min(1, this.forceReductionFactor), this.forceReductionFactor = Math.max(.002, this.forceReductionFactor);\n\n                for (t = 0; t <= this.nodeCount - 1; t++) {\n                  var d = this.nodes[t];\n\n                  if (!d.locked && !s[t]) {\n                    var p = d.forceSum * this.forceReductionFactor;\n                    d.x += d.forceX * p, d.y += d.forceY * p, d.z += d.forceZ * p;\n                  }\n\n                  d.oldForceX = d.forceX, d.oldForceY = d.forceY, d.oldForceZ = d.forceZ;\n                }\n              }, e.prototype.applyAspect = function (t) {\n                for (var e = 0; e < this.nodes.length; e++) {\n                  this.nodes[e].y *= t;\n                }\n              }, e.prototype.calculateForce = function (t, e) {\n                for (var i = t.oldForceX * e, n = t.oldForceY * e, r = t.oldForceZ * e, s = 0; s < t.edges.length; s++) {\n                  var a = t.edges[s],\n                      o = a.to,\n                      l = a.len,\n                      h = t.x - t.offsetX - o.x + o.offsetX,\n                      u = t.y - t.offsetY - o.y + o.offsetY,\n                      c = t.z - o.z;\n                  a.direction && (\"U\" === a.direction ? (u -= l, l = 0) : \"D\" === a.direction ? (u += l, l = 0) : \"L\" === a.direction ? (h -= l, l = 0) : \"R\" === a.direction && (h += l, l = 0));\n                  var d = Math.sqrt(h * h + u * u + c * c);\n                  d < .01 && (d = .01);\n                  var p = (l - d) * a.K / d * this.linkForceFactor;\n                  i += p * h, n += p * u, r += p * c;\n                }\n\n                i += t.repulsiveForceX * this.nodeRepulsionFactor, n += t.repulsiveForceY * this.nodeRepulsionFactor, r += t.repulsiveForceZ * this.nodeRepulsionFactor;\n                var f = t.zattr * this.zAxisAttraction;\n                if (r -= t.z * f, i += t.gravityForceX, n += t.gravityForceY, isNaN(i)) throw \"Internal error: Nan in layout\";\n                t.forceX = i, t.forceY = n, t.forceZ = r, t.fsum + f !== 0 && (t.forceSum = 1 / (t.fsum + f));\n              }, e.prototype.storeNodes = function () {\n                for (var t = 0; t <= this.nodeCount - 1; t++) {\n                  var e = this.nodes[t];\n                  e.locked || (e.layerNode.x = e.x - e.offsetX, e.layerNode.y = e.y - e.offsetY);\n                }\n              }, e.prototype.centerNodes = function () {\n                for (var t = new h.Random(243178931), e = this.nodes, i = e[0].x, n = i, r = e[0].y, s = r, a = 1; a <= this.nodeCount - 1; a++) {\n                  i = Math.min(i, e[a].x), n = Math.max(n, e[a].x), r = Math.min(r, e[a].y), s = Math.max(s, e[a].y);\n                }\n\n                var o = (i + n) / 2,\n                    l = (r + s) / 2;\n\n                for (a = 0; a <= this.nodeCount - 1; a++) {\n                  var u = e[a];\n\n                  if (u.x -= o, u.y -= l, !u.locked) {\n                    var c = .3 * u.r;\n                    u.x += t.get() * c, u.y += t.get() * c;\n                  }\n                }\n              }, e.prototype.randomnodesForRepulsion = function () {\n                for (var t = 0; t <= this.nodeCount - 1; t++) {\n                  var e = Math.floor(this.random.get() * (this.nodeCount - t)) + t,\n                      i = this.nodes[t];\n                  this.nodes[t] = this.nodes[e], this.nodes[e] = i;\n                }\n              }, e.prototype.onSceneChange = function (t) {\n                var e = t.changes.settingsChanges;\n                if (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges()) for (var i = this.chart.layer, n = i.links(), r = 0; r < n.length; r++) {\n                  var s = n[r];\n                  s.background && (s.background = !1, i.touchLink(s));\n                }\n                e && e.layout && this.gravity.reset();\n              }, e.prototype.doAnimations = function (t) {\n                var e = this.chart.settings.layout,\n                    i = this.chart.layer,\n                    n = e.layoutFreezeTimeout,\n                    r = e.layoutFreezeMinTimeout,\n                    s = i.hasTopologyChanges(),\n                    a = t.dtime;\n                (0 === this.idleSince || t.changes.dynamicLayout || s || t.changes.coordinates || t.changes.layout || t.changes.bounds) && (this.idleSince = t.timeStamp, this.noMovementSince = 0);\n                var o = 1;\n\n                if (!s) {\n                  var l = t.timeStamp - this.idleSince;\n                  if (this.layoutMovement < e.advanced.adaptiveFreezeTreshold) if (0 !== this.noMovementSince) {\n                    var h = t.timeStamp - this.noMovementSince;\n                    o = Math.min((r - h) / r, o);\n                  } else this.noMovementSince = t.timeStamp;\n                  o = Math.min((n - l) / n, o);\n                }\n\n                o > 0 && (this.doForceLayout(a * o, !1), t.animating = !0, t.changes.position = !0);\n              }, e.prototype.placeNewNodes = function () {\n                for (var t = {}, e = this.chart.layer, i = !1, n = 0, r = e.nodes(); n < r.length; n++) {\n                  null !== (s = r[n]).x && null !== s.y || (t[s.id] = !0);\n                }\n\n                for (n = 0, r = e.nodes(); n < r.length; n++) {\n                  var s = r[n],\n                      a = 1;\n\n                  if (t.hasOwnProperty(s.id)) {\n                    var o = 0,\n                        l = 0,\n                        h = 0;\n                    a = 1;\n\n                    for (var u = void 0, c = 0; c < s.links.length; c++) {\n                      var d = s.links[c].otherEnd(s);\n                      t.hasOwnProperty(d.id) || (u = d, l += d.x, h += d.y, o += 1);\n                    }\n\n                    var p = void 0,\n                        f = void 0;\n                    if (o > 1) p = l / o, f = h / o, a = .5;else if (1 === o) {\n                      var g = 0,\n                          m = 0,\n                          v = 0;\n\n                      for (c = 0; c < u.links.length; c++) {\n                        var y = u.links[c].otherEnd(u);\n                        y === s || t.hasOwnProperty(y.id) || (m += y.x - u.x, v += y.y - u.y, g += 1);\n                      }\n\n                      if (g > 0) {\n                        var S = Math.sqrt(m * m + v * v);\n\n                        if (S > 0) {\n                          var b = 1 / (S * g);\n                          m *= b, v *= b, p = u.x - m * u.hHeight * 1.2, f = u.y - v * u.hHeight * 1.2, a = .2;\n                        } else p = u.x, f = u.y;\n                      } else i = !0, p = u.x, f = u.y;\n                    } else i = !0, p = 0, f = 0;\n                    s.x = p + (this.random.get() - .5) * a * (s.hHeight + 1), s.y = f + (this.random.get() - .5) * a * (s.hHeight + 1);\n                  }\n                }\n\n                return {\n                  newNodes: t,\n                  majorChanges: i\n                };\n              }, e.prototype.doForceLayout = function (t, e) {\n                var i,\n                    n = this.chart.scene,\n                    r = this.chart.layer,\n                    s = this.chart.settings.layout,\n                    a = r.nodes(),\n                    o = r.links(),\n                    l = {},\n                    u = !1;\n\n                if (e) {\n                  this.random = new h.Random(1);\n\n                  for (var c = 0; c < a.length; c++) {\n                    l[(m = a[c]).id] = !0, m.x = 0, m.y = 0, m.userLock = !1;\n                  }\n\n                  i = !0, u = !0;\n                } else if (r.hasTopologyChanges()) {\n                  i = !0, this.random = new h.Random(1);\n                  var d = this.placeNewNodes();\n                  l = d.newNodes, u = d.majorChanges;\n                }\n\n                var p = (n.width + 1) / (n.height + 1);\n                p > 0 || (p = null);\n                var f = n.settings.layout.aspectRatio ? p : null;\n                this.aspectRatio = f;\n                var g = !1;\n\n                for (c = 0; c < a.length; c++) {\n                  (m = a[c]).locked = m.userLock || m.locks > 0, g = g || m.locked;\n                }\n\n                if (h.Helpers.hasProperties(l)) {\n                  for (c = 0; c < a.length; c++) {\n                    var m;\n                    (m = a[c]).locked = m.locked || !h.Helpers.hasProperty(l, m.id);\n                  }\n\n                  this.updateGraph(a, o, i), u || n.settings.layout.globalLayoutOnChanges ? (this.aspectRatio = p, this.globalLayout(u ? s.initialLayoutMaxTime : s.incrementalLayoutMaxTime, u && !g)) : this.timedLayout(.001 * t);\n                } else this.updateGraph(a, o, i), this.timedLayout(.001 * t);\n              }, e.prototype.resetLayout = function () {\n                this.doForceLayout(1, !0), this.idleSince = 0;\n              }, e;\n            }(a);\n\n            t.TimedSpringEmbedder = y;\n\n            var S = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.twoCircles = !1, e;\n              }\n\n              return r(e, t), e.getNodeSize = function (t) {\n                return Math.max(t.hHeight, t.hWidth) * t.visibility * 2;\n              }, e.getNodesBounds = function (t) {\n                if (t.length < 1) return new h.Rect(0, 0, 0, 0);\n\n                for (var e = t[0], i = new h.Rect(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight), n = 1; n < t.length; n++) {\n                  e = t[n], i.addBounds(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight);\n                }\n\n                return i;\n              }, e.prototype.onSceneChange = function (t) {\n                var e = t.changes.settingsChanges;\n                (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.updateBackgroundLinks(this.chart.getLastFocusNode(), !1);\n              }, e.prototype.doAnimations = function (t) {\n                var e = t.changes.settingsChanges,\n                    i = null != e && null != e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges(),\n                    n = t.changes.position || t.changes.dynamicLayout;\n                (i || n) && (this.performLayout(i), t.changes.position = !0);\n              }, e.prototype.resetLayout = function () {\n                for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n                  t[e].userLock = !1;\n                }\n\n                this.performLayout(!0);\n              }, e.prototype.performLayout = function (t) {\n                var i = [];\n                this.visitedNodes = {}, this.subnodes = {}, this.minAngle = {}, this.radiuses = [];\n                var n = this.chart.getLastFocusNode();\n\n                if (n) {\n                  i.push(this.layoutCircle(n, t));\n\n                  for (var r = this.chart.layer.nodes(), s = 0; s < r.length; s++) {\n                    var a = r[s];\n                    h.Helpers.hasProperty(this.visitedNodes, a.id) || i.push(this.layoutCircle(a, t));\n                  }\n\n                  if (i.length > 1) {\n                    var o = 2 * this.chart.settings.layout.nodeSpacing,\n                        l = e.getNodesBounds(i[0]).x1 + o;\n\n                    for (s = 1; s < i.length; s++) {\n                      var u = i[s];\n\n                      if (!(u.length < 1)) {\n                        var c = e.getNodesBounds(u);\n                        l -= c.x0;\n\n                        for (var d = 0; d < u.length; d++) {\n                          u[d].x += l;\n                        }\n\n                        l += c.x1 + o;\n                      }\n                    }\n                  }\n\n                  this.updateBackgroundLinks(n, !0) && this.chart.events.notifySceneChanges({\n                    highlight: !0\n                  });\n                }\n              }, e.prototype.layoutCircle = function (t, e) {\n                var i = [];\n                return this.visitedNodes[t.id] = !0, this.computeMaxRadius(t, e), this.placeNodeRec(t, 0, .5 * -Math.PI, 2 * Math.PI, i), i;\n              }, e.prototype.updateBackgroundLinks = function (t, e) {\n                if (t) {\n                  if (this.visitedNodes = {}, this.updateBackgroudLinkCircle(t, e) && e) return !0;\n\n                  for (var i = this.chart.layer.nodes(), n = 0; n < i.length; n++) {\n                    var r = i[n];\n                    if (!h.Helpers.hasProperty(this.visitedNodes, r.id) && this.updateBackgroudLinkCircle(r, e) && e) return !0;\n                  }\n\n                  return !1;\n                }\n              }, e.prototype.updateBackgroudLinkCircle = function (t, e) {\n                var i = [t];\n                this.visitedNodes[t.id] = !0;\n\n                for (var n = {}, r = this.chart.layer; i.length > 0;) {\n                  for (var s = [], a = 0; a < i.length; a++) {\n                    for (var o = i[a], l = 0; l < o.links.length; l++) {\n                      var u = o.links[l];\n\n                      if (!h.Helpers.hasProperty(n, u.id)) {\n                        n[u.id] = !0;\n                        var c = u.otherEnd(o),\n                            d = !0;\n\n                        if (h.Helpers.hasProperty(this.visitedNodes, c.id) || (this.visitedNodes[c.id] = !0, s.push(c), d = !1), u.background !== d) {\n                          if (e) return !0;\n                          u.background = d, r.touchLink(u);\n                        }\n                      }\n                    }\n                  }\n\n                  i = s;\n                }\n\n                return !1;\n              }, e.prototype.getSubnodes = function (t) {\n                var e = t.id;\n                if (this.subnodes[e]) return this.subnodes[e];\n\n                for (var i = [], n = 0; n < t.links.length; n++) {\n                  var r = t.links[n].otherEnd(t);\n                  h.Helpers.hasProperty(this.visitedNodes, r.id) || (i.push(r), this.visitedNodes[r.id] = !0);\n                }\n\n                return this.subnodes[e] = i, i;\n              }, e.prototype.computeMaxRadius = function (t, i) {\n                var n = this.chart.settings.layout.nodeSpacing,\n                    r = 0;\n                this.radiuses[0] = r;\n\n                for (var s = 1, a = [t]; a.length > 0;) {\n                  var o = void 0;\n\n                  if (1 === s && this.chart.settings.layout.twoRingRadialLayout) {\n                    t = a[0];\n                    var l = e.getNodeSize(t);\n                    o = this.getSubnodes(t);\n\n                    for (var h = Math.floor(o.length / 2), u = new Array(h), c = new Array(o.length - h), d = 0; d < o.length; d++) {\n                      (d % 2 == 0 ? c : u)[Math.floor(d / 2)] = o[d];\n                    }\n\n                    var p = 0,\n                        f = 0;\n\n                    for (d = 0; d < u.length; d++) {\n                      var g = u[d],\n                          m = e.getNodeSize(g);\n                      p = Math.max(p, m), f += n + m;\n                    }\n\n                    var v = 0,\n                        y = 0;\n\n                    for (d = 0; d < c.length; d++) {\n                      g = c[d], m = e.getNodeSize(g);\n                      v = Math.max(v, m), y += n + m;\n                    }\n\n                    var S = Math.max(.5 * (Math.max(p, v) + l) + n, (f + y) / (2 * Math.PI)),\n                        b = Math.max(.5 * (p + l) + n, f / (2 * Math.PI)),\n                        C = Math.max(b + .5 * (v + p), y / (2 * Math.PI));\n                    i && (this.twoCircles = C < S), this.twoCircles ? (this.radiuses[1] = b, this.radiuses[2] = C) : (this.radiuses[1] = S, this.radiuses[2] = S), r = this.radiuses[2], s = 3;\n                  } else {\n                    var x = 0,\n                        w = 0;\n                    o = [];\n\n                    for (var L = 0; L < a.length; L++) {\n                      t = a[L];\n                      l = e.getNodeSize(t);\n\n                      for (var T = 0, k = this.getSubnodes(t); T < k.length; T++) {\n                        g = k[T], m = e.getNodeSize(g);\n                        x = Math.max(x, m + l), w += n + m, o.push(g);\n                      }\n                    }\n\n                    var A = r + .5 * x + n,\n                        M = w / (2 * Math.PI),\n                        I = Math.max(A, M);\n                    this.radiuses[s] = I, r = I, s += 1;\n                  }\n\n                  a = o;\n                }\n              }, e.prototype.computeMinAngle = function (t, i) {\n                var n = t.id;\n                if (h.Helpers.hasProperty(this.minAngle, n)) return this.minAngle[n];\n\n                for (var r = this.chart.settings.layout.nodeSpacing, s = this.radiuses[i], a = (e.getNodeSize(t) + r) / s, o = 0, l = this.chart.settings.layout.twoRingRadialLayout && 1 === i ? 3 : i + 1, u = 0, c = this.getSubnodes(t); u < c.length; u++) {\n                  var d = c[u];\n                  o += this.computeMinAngle(d, l);\n                }\n\n                return a = Math.max(a, o), this.minAngle[n] = a, a;\n              }, e.prototype.placeNodeRec = function (t, e, i, n, r) {\n                var s = i + .5 * n,\n                    a = this.radiuses[e];\n                t.userLock || (t.x = a * Math.cos(s), t.y = a * Math.sin(s), r.push(t));\n                var o = this.getSubnodes(t),\n                    l = e + 1,\n                    h = !1;\n\n                if (this.chart.settings.layout.twoRingRadialLayout && (0 === e ? h = !0 : 1 === e && (l = 3)), o.length > 0) {\n                  for (var u = 0, c = 0; c < o.length; c++) {\n                    var d = o[c];\n                    u += this.computeMinAngle(d, h ? c % 2 == 0 ? 2 : 1 : l);\n                  }\n\n                  var p = n / u,\n                      f = i;\n\n                  for (c = 0; c < o.length; c++) {\n                    d = o[c];\n                    h && (l = c % 2 == 0 ? 2 : 1);\n                    var g = this.computeMinAngle(d, l) * p;\n                    this.placeNodeRec(d, l, f, g, r), f += g;\n                  }\n                }\n              }, e;\n            }(a);\n\n            t.RadialLayout = S;\n\n            var b = function () {\n              function t(t, e) {\n                this.children = [], this.parent = null, this.node = t, this.level = e, this.reset();\n              }\n\n              return t.prototype.reset = function () {\n                this.hWidth = this.node.hWidth, this.origX = this.node.x, this.shift = 0;\n              }, t;\n            }(),\n                C = function (t) {\n              function n() {\n                var e = t.apply(this, arguments) || this;\n                return e.forest = null, e;\n              }\n\n              return r(n, t), n.prototype.wrapNodes = function () {\n                for (var t = h.Helpers.clone(this.chart.layer.idToNode), e = [];;) {\n                  var i = null;\n\n                  for (var n in t) {\n                    if (h.Helpers.hasProperty(t, n)) {\n                      i = t[n], delete t[n];\n                      break;\n                    }\n                  }\n\n                  if (null == i) return e;\n                  var r = {},\n                      s = [new b(i, 0)],\n                      a = 0,\n                      o = 0;\n                  r[i.id] = s[0];\n\n                  for (var l = 0; l < s.length; l++) {\n                    for (var u = (g = s[l]).node, c = 0; c < u.links.length; c++) {\n                      var d = u.links[c];\n\n                      if (d.to === u) {\n                        var p = void 0;\n                        h.Helpers.hasProperty(r, d.from.id) ? p = r[d.from.id] : (p = new b(d.from, g.level - 1), a === g.level && a--, r[d.from.id] = p, s.push(p)), null === g.parent && g.level === p.level + 1 && (g.parent = p, p.children.push(g));\n                      } else {\n                        p = void 0;\n                        h.Helpers.hasProperty(r, d.to.id) ? p = r[d.to.id] : (p = new b(d.to, g.level + 1), o === g.level && o++, r[d.to.id] = p, s.push(p)), null === p.parent && p.level === g.level + 1 && (g.children.push(p), p.parent = g);\n                      }\n                    }\n                  }\n\n                  var f = new Array(o - a + 1);\n\n                  for (l = 0; l < f.length; l++) {\n                    f[l] = [];\n                  }\n\n                  for (l = 0; l < s.length; l++) {\n                    var g;\n                    delete t[(g = s[l]).node.id], g.level -= a, null === g.parent && (g.levelIndex = f[g.level].length, f[g.level].push(g));\n                  }\n\n                  for (var m = 0; m < f.length; m++) {\n                    for (var v = f[m], y = 0; y < v.length; y++) {\n                      for (var S = v[y], C = 0; C < S.children.length; C++) {\n                        var x = m + 1,\n                            w = S.children[C];\n                        w.level = x, w.levelIndex = f[x].length, f[x].push(w);\n                      }\n                    }\n                  }\n\n                  e.push({\n                    levels: f,\n                    levelStarts: new Array(f.length),\n                    levelEnds: new Array(f.length)\n                  });\n                }\n              }, n.prototype.layoutNodes = function (t) {\n                var n = t.levels,\n                    r = this.chart.settings.layout,\n                    s = r.nodeSpacing,\n                    a = null === r.groupSpacing ? 2 * s : r.groupSpacing,\n                    o = null === r.rowSpacing ? s : r.rowSpacing;\n                i(n[n.length - 1], null, null, s, a);\n\n                for (var l = n.length - 2; l >= 0; l--) {\n                  for (var h = n[l], u = null, c = void 0, d = 0; d < h.length; d++) {\n                    if (h[d].children.length > 0) {\n                      c = h[d];\n                      break;\n                    }\n                  }\n\n                  if (c.node.x = e(c), c.levelIndex > 0) {\n                    i(h, null, c, s, a);\n                    var p = h[c.levelIndex - 1],\n                        f = p.node.x + p.hWidth + s + c.hWidth;\n                    f > c.node.x && (c.shift = f - c.node.x, c.node.x += c.shift);\n                  }\n\n                  for (;;) {\n                    u = c, c = null;\n\n                    for (d = u.levelIndex + 1; d < h.length; d++) {\n                      if (h[d].children.length > 0) {\n                        c = h[d];\n                        break;\n                      }\n                    }\n\n                    if (null === c) break;\n                    c.node.x = e(c) + u.shift, c.shift = u.shift;\n                    var g = 0,\n                        m = 0;\n\n                    for (d = u.levelIndex + 1; d < c.levelIndex; d++) {\n                      g += 2 * h[d].hWidth, null != h[d].parent && h[d].parent === h[d - 1].parent || m++;\n                    }\n\n                    null != c.parent && c.parent === h[c.levelIndex - 1].parent || m++;\n                    var v = c.levelIndex - u.levelIndex,\n                        y = u.hWidth + c.hWidth + g + (v - m) * s + m * a,\n                        S = c.node.x - u.node.x;\n\n                    if (y > S) {\n                      var b = y - S;\n                      c.node.x += b, c.shift += b, S = y, i(h, u, c, s, a);\n                    } else if (0 === m) {\n                      i(h, u, c, (S - u.hWidth - c.hWidth - g) / (c.levelIndex - u.levelIndex), 0);\n                    } else {\n                      i(h, u, c, s, (S - u.hWidth - c.hWidth - g - (v - m) * s) / m);\n                    }\n                  }\n\n                  i(h, u, null, s, a);\n                }\n\n                var C = 0;\n\n                for (l = 0; l < n.length; l++) {\n                  h = n[l];\n                  var x = 0;\n\n                  for (d = 0; d < h.length; d++) {\n                    x = Math.max(x, 2 * h[d].node.hHeight);\n                  }\n\n                  C += x / 2, t.levelStarts[l] = h[0].node.x - h[0].hWidth, t.levelEnds[l] = h[h.length - 1].node.x + h[h.length - 1].hWidth;\n\n                  for (d = 0; d < h.length; d++) {\n                    var w = h[d];\n                    w.node.userLock ? w.node.x = w.origX : w.node.y = C;\n\n                    for (var L = 0; L < w.children.length; L++) {\n                      var T = w.children[L];\n                      T.node.x += w.shift, T.shift += w.shift;\n                    }\n                  }\n\n                  C += x / 2 + o;\n                }\n              }, n.prototype.layoutTrees = function (t) {\n                var e = this.chart.settings.layout;\n                t.sort(function (t, e) {\n                  var i = e.levels.length - t.levels.length;\n                  return 0 !== i ? i : t.levels[0][0].node.id.localeCompare(e.levels[0][0].node.id);\n                });\n\n                for (var i = t[0].levelEnds.slice(), n = null == e.groupSpacing ? 4 * e.nodeSpacing : 2 * e.groupSpacing, r = 1; r < t.length; r++) {\n                  for (var s = t[r], a = 0, o = 0; o < s.levels.length; o++) {\n                    var l = i[o] + n,\n                        h = a + s.levelStarts[o];\n                    h < l && (a += l - h);\n                  }\n\n                  for (o = 0; o < s.levels.length; o++) {\n                    for (var u = s.levels[o], c = 0; c < u.length; c++) {\n                      (m = u[c]).node.userLock || (m.node.x += a);\n                    }\n\n                    i[o] = a + s.levelEnds[o];\n                  }\n                }\n\n                var d = (e.rotation || 0) % 360;\n\n                if (0 !== d) {\n                  d = d * Math.PI / 180;\n                  var p = Math.sin(d),\n                      f = Math.cos(d),\n                      g = this.chart.layer.nodes();\n\n                  for (r = 0; r < g.length; r++) {\n                    var m;\n\n                    if (!(m = g[r]).userLock) {\n                      c = m.x, o = m.y;\n                      m.x = c * f - o * p, m.y = c * p + o * f;\n                    }\n                  }\n                }\n              }, n.prototype.performLayout = function (t) {\n                if (t || null == this.forest) this.forest = this.wrapNodes();else for (var e = 0; e < this.forest.length; e++) {\n                  for (var i = this.forest[e], n = 0; n < i.levels.length; n++) {\n                    for (var r = i.levels[n], s = 0; s < r.length; s++) {\n                      r[s].reset();\n                    }\n                  }\n                }\n\n                if (!(this.forest.length < 1)) {\n                  for (e = 0; e < this.forest.length; e++) {\n                    this.layoutNodes(this.forest[e]);\n                  }\n\n                  this.layoutTrees(this.forest), this.setBackgroundFlag(!0) && this.chart.events.notifySceneChanges({\n                    highlight: !0\n                  });\n                }\n              }, n.prototype.setBackgroundFlag = function (t) {\n                for (var e = h.Helpers.clone(this.chart.layer.idToNode);;) {\n                  var i = null;\n\n                  for (var n in e) {\n                    if (h.Helpers.hasProperty(e, n)) {\n                      i = e[n], delete e[n];\n                      break;\n                    }\n                  }\n\n                  if (null == i) return !1;\n                  var r = {},\n                      s = {},\n                      a = [{\n                    node: i,\n                    level: 0,\n                    hasParent: !1\n                  }],\n                      o = this.chart.layer;\n                  r[i.id] = a[0];\n\n                  for (var l = 0; l < a.length; l++) {\n                    for (var u = a[l], c = u.node, d = 0; d < c.links.length; d++) {\n                      var p = c.links[d];\n\n                      if (!h.Helpers.hasProperty(s, p.id)) {\n                        s[p.id] = !0;\n                        var f = !0;\n\n                        if (p.to === c) {\n                          var g = void 0;\n                          h.Helpers.hasProperty(r, p.from.id) ? g = r[p.from.id] : (delete e[(g = {\n                            node: p.from,\n                            level: u.level - 1,\n                            hasParent: !1\n                          }).node.id], r[p.from.id] = g, a.push(g)), u.hasParent || u.level !== g.level + 1 || (u.hasParent = !0, f = !1);\n                        } else {\n                          g = void 0;\n                          h.Helpers.hasProperty(r, p.to.id) ? g = r[p.to.id] : (delete e[(g = {\n                            node: p.to,\n                            level: u.level + 1,\n                            hasParent: !1\n                          }).node.id], r[p.to.id] = g, a.push(g)), g.hasParent || g.level !== u.level + 1 || (g.hasParent = !0, f = !1);\n                        }\n\n                        if (p.background !== f) {\n                          if (t) return !0;\n                          p.background = f, o.touchLink(p);\n                        }\n                      }\n                    }\n                  }\n                }\n              }, n.prototype.onSceneChange = function (t) {\n                var e = t.changes.settingsChanges;\n                (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.setBackgroundFlag(!1);\n              }, n.prototype.doAnimations = function (t) {\n                var e = t.changes.settingsChanges,\n                    i = this.chart.layer.hasTopologyChanges();\n                (e && e.layout || t.changes.navigation || i || t.changes.position || t.changes.dynamicLayout) && (this.performLayout(i), t.changes.position = !0);\n              }, n.prototype.resetLayout = function () {\n                for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n                  t[e].userLock = !1;\n                }\n\n                this.performLayout(!1);\n              }, n;\n            }(a);\n\n            t.HierarchyLayout = C;\n\n            var x = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.resetLayout = function () {\n                for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n                  var i = t[e],\n                      n = i.data;\n                  h.Helpers.isNumber(n.x) && (i.x = n.x), h.Helpers.isNumber(n.y) && (i.y = n.y), i.userLock = !1;\n                }\n              }, e;\n            }(a);\n\n            t.StaticLayout = x;\n          }(i = t.Layouts || (t.Layouts = {}));\n\n          var T = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 1800, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n            }\n\n            return r(e, t), e.prototype.doAnimations = function (t) {\n              var e = this.chart.layer;\n              e.updateStyle(t), e.postprocessStyle(t);\n            }, e.prototype.paintScene = function (t) {\n              h.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);\n              var e = this.chart.layer;\n              e.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), e.paint(t), h.Graphics.popClip(t);\n            }, e.prototype.paintLinks = function (t, e, i, n) {\n              this.chart.layer.paintLinksImpl(t, e, i, n);\n            }, e.prototype.paintNodes = function (t, e, i, n) {\n              this.chart.layer.paintNodesImpl(t, e, i, n);\n            }, e.prototype.findObjectAt = function (t, e, i) {\n              return this.chart.layer.findObjectAt(t, e, i);\n            }, e;\n          }(h.ChartElement);\n\n          t.Renderer = T;\n\n          var k = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.dataFunction = null, e.preloaded = null, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsData);\n\n          t.SettingsData = k;\n\n          var A = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e, i) || this;\n              return n.nodes = {}, n.links = {}, n.nodeToLinks = {}, n.pendingNodes = {}, n.requestedNodes = {}, n.pendingAllData = !1, n.requestedAllData = !1, n.nextLinkId = 0, n.hasAllData = !n.hasDataFunc(), n;\n            }\n\n            return r(e, t), e.otherEnd = function (t, e) {\n              return e === t.from ? t.to : e === t.to ? t.from : null;\n            }, e.multiLinkId = function (t) {\n              return t.from < t.to ? t.from + h.Helpers.SeparatorChar + t.to : t.to + h.Helpers.SeparatorChar + t.from;\n            }, e.prototype.buildRequest = function () {\n              if (this.pendingAllData) return this.requestedAllData ? null : (this.requestedAllData = !0, {\n                nodes: []\n              });\n              var t = [];\n\n              for (var e in this.pendingNodes) {\n                if (t.push(e), delete this.pendingNodes[e], this.requestedNodes[e] = !0, t.length >= this.dataSettings.requestMaxUnits) break;\n              }\n\n              return 0 === t.length ? null : {\n                nodes: t\n              };\n            }, e.prototype.dataFunc = function (t, e, i) {\n              var n = this.dataSettings;\n              if (n.dataFunction) n.dataFunction(t.nodes || null, e, i);else if (n.url) {\n                var r = [];\n\n                if (t.nodes) {\n                  for (var s = \"\", a = 0; a < t.nodes.length; a++) {\n                    s.length && (s += \",\"), s += encodeURIComponent(t.nodes[a]);\n                  }\n\n                  r.push([\"nodes\", s]);\n                }\n\n                h.Data.doRequest(n.url, n, r, e, i);\n              } else i({\n                error: \"Chart configuration does not define data retrieval function\"\n              });\n            }, e.prototype.verifyData = function (t, e) {\n              h.Helpers.hasProperty(e, \"links\") || (e.links = []), h.Helpers.hasProperty(e, \"nodes\") || (e.nodes = []);\n              var i = !0;\n\n              if (!Array.isArray(e.nodes)) {\n                var n = e.nodes;\n                e.nodes = [];\n\n                for (var r = Object.keys(n), s = 0; s < r.length; s++) {\n                  (m = n[o = r[s]]).id = o, e.nodes.push(m);\n                }\n              }\n\n              if (!Array.isArray(e.links)) {\n                var a = e.links;\n                e.links = [];\n\n                for (r = Object.keys(a), s = 0; s < r.length; s++) {\n                  var o;\n                  (d = a[o = r[s]]).id = o, e.links.push(d);\n                }\n              }\n\n              var l = {},\n                  u = !t && !this.hasDataFunc();\n\n              for (s = 0; s < e.nodes.length; s++) {\n                null == (m = e.nodes[s]).id ? (m.id = h.Helpers.getIdentifierStr(), h.Helpers.warn(\"Data response: `id` property is mandatory for all nodes in the NetChart data object.\", null, !0)) : m.id = m.id.toString(), l.hasOwnProperty(m.id) && h.Helpers.warn('Data response: Multiple nodes with the same ID: \"' + m.id + '\". Data will be merged.'), l[m.id] = !0, u ? m.loaded = !0 : h.Helpers.hasProperty(m, \"loaded\") ? m.loaded = !!m.loaded : (h.Helpers.warn('Data response: Node with ID \"' + m.id + '\" does not have the \"loaded\" flag. Assuming \"false\".'), m.loaded = !1), h.Helpers.hasProperty(m, \"className\") && null != m.className && !h.Helpers.isString(m.className) && (h.Helpers.warn('Data response: Node property \"className\" must be a string. Node ID: \"' + m.id + '\".'), m.className = \"\" + m.className), h.Helpers.hasProperty(m, \"error\") && null != m.error && !h.Helpers.isString(m.error) && (h.Helpers.warn('Data response: Node property \"error\" must be a string. Node ID: \"' + m.id + '\".'), m.error = \"\" + m.error), h.Helpers.hasProperty(m, \"x\") && null != m.x && !h.Helpers.isNumber(m.x) && (h.Helpers.warn('Data response: Node property \"x\" must be a number. Node ID: \"' + m.id + '\".'), m.x = h.Helpers.tryParseFloat(m.x, null)), h.Helpers.hasProperty(m, \"y\") && null != m.y && !h.Helpers.isNumber(m.y) && (h.Helpers.warn('Data response: Node property \"y\" must be a number. Node ID: \"' + m.id + '\".'), m.y = h.Helpers.tryParseFloat(m.y, null));\n              }\n\n              var c = {};\n\n              for (s = 0; s < e.links.length; s++) {\n                var d;\n                null != (d = e.links[s]).from ? (d.from = d.from.toString(), null != d.to ? (d.to = d.to.toString(), null == d.id ? (d.id = h.Helpers.SeparatorChar + this.nextLinkId, this.nextLinkId += 1) : d.id = d.id.toString(), c.hasOwnProperty(d.id) && h.Helpers.warn('Data response: Multiple links with the same ID: \"' + d.id + '\". Data will be merged.'), c[d.id] = !0, h.Helpers.hasProperty(d, \"className\") && null != d.className && !h.Helpers.isString(d.className) && (h.Helpers.warn('Data response: Link property \"className\" must be a string. Link ID: \"' + d.id + '\".'), d.className = \"\" + d.className), h.Helpers.hasProperty(d, \"error\") && null != d.error && !h.Helpers.isString(d.error) && (h.Helpers.warn('Data response: Link property \"error\" must be a string. Link ID: \"' + d.id + '\".'), d.error = \"\" + d.error), h.Helpers.hasProperty(this.nodes, d.from) || h.Helpers.hasProperty(l, d.from) || e.nodes.push({\n                  id: d.from,\n                  loaded: u\n                }), h.Helpers.hasProperty(this.nodes, d.to) || h.Helpers.hasProperty(l, d.to) || e.nodes.push({\n                  id: d.to,\n                  loaded: u\n                })) : h.Helpers.warn('Data response: Link missing property \"to\" and will be ignored. Link id: \"' + d.id + '\"')) : h.Helpers.warn('Data response: Link missing property \"from\" and will be ignored. Link id: \"' + d.id + '\"');\n              }\n\n              if (t ? this.chart.log(\"Got \" + e.nodes.length + \" nodes on [\" + t.nodes.join(\", \") + \"]\") : this.chart.log(\"Got \" + e.nodes.length + \" nodes on all nodes\"), t && t.nodes.length > 0) {\n                for (var p = !1, f = !1, g = 0; g < e.nodes.length; g++) {\n                  var m = e.nodes[g];\n                  t.nodes.indexOf(m.id) > -1 && (p = !0, f = f || m.loaded);\n                }\n\n                p ? f || (this.chart.error(\"Data response: loaded field was not set on any of the requested nodes!\"), i = !1) : (this.chart.error(\"Data response: Results set did not contain any of requested nodes!\", t.nodes), i = !1);\n              }\n\n              return i;\n            }, e.prototype.addVerifiedData = function (t, e) {\n              for (var i = this.updateGraph(e), n = 0; n < e.nodes.length; n++) {\n                var r = e.nodes[n];\n                (r.loaded || r.error) && (delete this.requestedNodes[r.id], delete this.pendingNodes[r.id]);\n              }\n\n              if (t) if (0 === t.nodes.length) this.hasAllData = !0, this.pendingAllData = !1, this.requestedAllData = !1;else for (n = 0; n < t.nodes.length; n++) {\n                var s = t.nodes[n];\n                this.requestedNodes[s] && (this.pendingNodes[s] = !0, delete this.requestedNodes[s]);\n              }\n              return i;\n            }, e.prototype.requestFailedPermanently = function (t) {\n              if (t.nodes) {\n                for (var e = [], i = 0; i < t.nodes.length; i++) {\n                  var n = t.nodes[i];\n                  e.push({\n                    id: n,\n                    error: \"Bad response\",\n                    loaded: !0\n                  });\n                }\n\n                var r = this.addVerifiedData(t, {\n                  nodes: e,\n                  links: []\n                });\n                r.dataArrived || (r.dataArrived = {}), r.dataArrived[this.dataSettings.id] = !0, this.chart.events.notifySceneChanges(r);\n              }\n\n              this.chart.error(\"Failed data request, giving up on nodes: \", t.nodes);\n            }, e.prototype.removeData = function (t) {\n              var e = {},\n                  i = [];\n              if (t.nodes) for (var n = 0; n < t.nodes.length; n++) {\n                var r = t.nodes[n];\n                e[r.id] = !0, i = this.removeNode(r.id, i);\n              }\n              if (t.links) for (var s = 0; s < t.links.length; s++) {\n                var a = t.links[s];\n                (l = this.links[a.id]) && (e[l.from] = !0, e[l.to] = !0, this.removeLink(l));\n              }\n\n              for (var o = 0; o < i.length; o++) {\n                var l;\n                e[(l = i[o]).from] = !0, e[l.to] = !0, this.removeLink(l);\n              }\n\n              var h = this.chart.createEventArguments(null, \"api\");\n              return h.dataArrived = null, h.dataRemoved = t, this.chart.notifyDataUpdated(h), {\n                netChartDataNodes: e\n              };\n            }, e.prototype.exportData = function () {\n              var t = [],\n                  e = [];\n\n              for (var i in this.nodes) {\n                var n = this.nodes[i];\n                t.push(n);\n              }\n\n              for (var i in this.links) {\n                var r = this.links[i];\n                e.push(r);\n              }\n\n              return {\n                nodes: t,\n                links: e\n              };\n            }, e.prototype.applyPreloadedData = function () {\n              this.dataSettings.randomNodes > 0 ? this.addData(this.genRandomGraph(this.dataSettings)) : t.prototype.applyPreloadedData.call(this);\n            }, e.prototype.getNode = function (t, e, i) {\n              void 0 === e && (e = !0), void 0 === i && (i = null);\n              var n = h.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;\n\n              if (i && (i.loading = !1), n) {\n                if (this.settings.legend.enabled && !this.chart.legend.isNodeVisible(n)) return null;\n                var r = this.settings.filters.nodeFilter;\n                if (r) if (!r(n, h.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : null)) return null;\n                !n.loaded && e && (i && (i.loading = !0), this.requestNodeData(t));\n              } else e ? (i && (i.loading = !0), this.requestNodeData(t)) : i && (i.loading = this.isNodeLoading(t));\n\n              return n;\n            }, e.prototype.isNodeLoading = function (t) {\n              return this.pendingAllData || this.requestedAllData || h.Helpers.hasProperty(this.pendingNodes, t) || h.Helpers.hasProperty(this.requestedNodes, t);\n            }, e.prototype.getLinks = function (t, i) {\n              void 0 === i && (i = !0);\n              var n = this.settings.legend.enabled,\n                  r = h.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;\n              if (!r) return i && this.requestNodeData(t), [];\n              if (n && !this.chart.legend.isNodeVisible(r)) return [];\n              var s = h.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : [],\n                  a = this.settings.filters.nodeFilter;\n              if (a && !a(r, s)) return [];\n              !r.loaded && i && this.requestNodeData(t);\n              var o = this.settings.filters.linkFilter,\n                  l = this.settings.filters.nodeLinksProcessor,\n                  u = this.settings.filters.multilinkProcessor,\n                  c = {};\n\n              if (c[t] = !0, s.length > 0 && (a || o || n)) {\n                for (var d = new Array(s.length), p = 0, f = 0; f < s.length; f++) {\n                  var g = s[f],\n                      m = e.otherEnd(g, t);\n                  if (null != m) {\n                    if (h.Helpers.hasProperty(this.nodes, m)) {\n                      var v = this.nodes[m];\n                      if (a || n) if (h.Helpers.hasProperty(c, m)) {\n                        if (!c[m]) continue;\n                      } else {\n                        var y = !n || this.chart.legend.isNodeVisible(v);\n                        if (y && a && (y = a(v, h.Helpers.hasProperty(this.nodeToLinks, m) ? this.nodeToLinks[m] : null)), c[m] = y, !y) continue;\n                      }\n\n                      if (o || n) {\n                        var S = void 0,\n                            b = void 0;\n                        if (g.from === t ? (S = r, b = v) : (S = v, b = r), n && !this.chart.legend.isLinkVisible(g)) continue;\n                        if (o && !o(g, S, b)) continue;\n                      }\n\n                      d[p++] = g;\n                    } else h.Helpers.error(\"Invalid situation: link data found from '\" + t + \"' to '\" + m + \"', but no node data found for '\" + m + \"'\");\n                  } else h.Helpers.error(\"Invalid situation: link data found from '\" + g.from + \"' to '\" + g.to + \"' in the collection of links for '\" + t + \"'\");\n                }\n\n                d.length = p, s = d;\n              }\n\n              if (l && (s = l(r, s)), !Array.isArray(s)) return [];\n\n              if (u) {\n                var C = {},\n                    x = !1;\n\n                for (f = 0; f < s.length; f++) {\n                  var w = e.otherEnd(s[f], t);\n\n                  if (w) {\n                    if (h.Helpers.hasProperty(C, w)) {\n                      x = !0;\n                      break;\n                    }\n\n                    C[w] = !0;\n                  }\n                }\n\n                if (x) {\n                  d = [];\n                  var L = {},\n                      T = {};\n\n                  for (f = 0; f < s.length; f++) {\n                    var k = s[f],\n                        A = e.multiLinkId(k);\n                    L.hasOwnProperty(A) ? T.hasOwnProperty(A) ? T[A].push(k) : T[A] = [L[A], k] : L[A] = k;\n                  }\n\n                  for (f = 0; f < s.length; f++) {\n                    k = s[f], A = e.multiLinkId(k);\n                    T.hasOwnProperty(A) || d.push(k);\n                  }\n\n                  var M = Object.keys(T);\n\n                  for (f = 0; f < M.length; f++) {\n                    var I = T[M[f]],\n                        P = (k = I[0], u(I, this.nodes[k.from], this.nodes[k.to]));\n                    Array.isArray(P) ? d = d.concat(P) : P && d.push(P);\n                  }\n\n                  s = d;\n                }\n              }\n\n              return s;\n            }, e.prototype.getAllNodes = function (t) {\n              void 0 === t && (t = !0);\n\n              for (var e = this.settings.filters.nodeFilter, i = Object.keys(this.nodes), n = new Array(i.length), r = 0, s = 0; s < i.length; s++) {\n                var a = i[s],\n                    o = this.nodes[a];\n                this.settings.legend.enabled && !this.chart.legend.isNodeVisible(o) || e && !e(o, h.Helpers.hasProperty(this.nodeToLinks, a) ? this.nodeToLinks[a] : null) || (n[r++] = o);\n              }\n\n              return n.length = r, this.hasAllData || this.pendingAllData || !t || (this.pendingAllData = !0, this.scheduleRequests()), n;\n            }, e.prototype.requestNodeData = function (t) {\n              return this.hasDataFunc() ? void (this.pendingNodes.hasOwnProperty(t) || this.requestedNodes.hasOwnProperty(t) || (this.pendingNodes[t] = !0, this.scheduleRequests())) : void this.chart.error(\"Cannot request node data! Please specify either data function or data URL in the settings!\");\n            }, e.prototype.hasDataFunc = function () {\n              return null != this.dataSettings.dataFunction || null != this.dataSettings.url;\n            }, e.prototype.updateGraph = function (t) {\n              for (var e = {}, i = 0; i < t.nodes.length; i++) {\n                var n = t.nodes[i];\n\n                if (h.Helpers.hasProperty(this.nodes, n.id)) {\n                  var r = this.nodes[n.id];\n                  n.error || r.loaded && !n.loaded || (h.Helpers.extendDataItem(r, n), r.resetCoordinates = (null != n.x || null != n.y) && null != r.x && null != r.y, r.resetLocked = null != n.locked, e[n.id] = !0);\n                } else {\n                  var s = h.Helpers.extendDataItem({}, n);\n                  s.resetCoordinates = null != s.x && null != s.y, s.resetLocked = null != s.locked, this.nodes[n.id] = s, this.nodeToLinks[n.id] = [], e[n.id] = !0;\n                }\n              }\n\n              for (var a = 0; a < t.links.length; a++) {\n                var o = t.links[a];\n\n                if (h.Helpers.hasProperty(this.links, o.id)) {\n                  r = this.links[o.id];\n\n                  if (o.from && r.from !== o.from || o.to && r.to !== o.to) {\n                    this.chart.error('Changing link from/to not supported. Link ignored. Link ID: \"' + o.id + '\"');\n                    continue;\n                  }\n\n                  h.Helpers.extendDataItem(r, o);\n                } else {\n                  if (!o.from || !o.to) continue;\n                  this.links[o.id] = o, this.nodeToLinks[o.from].push(o), o.from !== o.to && this.nodeToLinks[o.to].push(o);\n                }\n\n                e[o.from] = !0, e[o.to] = !0;\n              }\n\n              return {\n                netChartDataNodes: e\n              };\n            }, e.prototype.removeNode = function (t, e) {\n              return delete this.pendingNodes[t], delete this.requestedNodes[t], h.Helpers.hasProperty(this.nodes, t) && delete this.nodes[t], h.Helpers.hasProperty(this.nodeToLinks, t) && (e = e.concat(this.nodeToLinks[t]), delete this.nodeToLinks[t]), e;\n            }, e.prototype.removeLink = function (t) {\n              delete this.links[t.id], h.Helpers.hasProperty(this.nodeToLinks, t.from) && h.Helpers.removeFromArrayHasty(this.nodeToLinks[t.from], t), h.Helpers.hasProperty(this.nodeToLinks, t.to) && h.Helpers.removeFromArrayHasty(this.nodeToLinks[t.to], t);\n            }, e.prototype.genRandomGraph = function (t) {\n              var e,\n                  i = t.randomNodes,\n                  n = t.randomLinks;\n              e = \"grid\" === t.random ? this.genRandomGrid(i, t.randomGridLinkProbability) : \"tree\" === t.random ? this.genRandomTree(i, t.randomTreeDensity) : this.genRandomUniform(i, n);\n\n              for (var r = 0; r < e.nodes.length; r++) {\n                var s = e.nodes[r];\n                s.style = {\n                  label: \"Node \" + s.id\n                };\n              }\n\n              for (var a = 0; a < e.links.length; a++) {\n                var o = e.links[a];\n                o.style = {\n                  label: \"Link \" + o.id\n                };\n              }\n\n              return e;\n            }, e.prototype.genRandomGrid = function (t, e) {\n              for (var i = [], n = [], r = 0; r <= t - 1; r++) {\n                var s = {\n                  id: \"n\" + r,\n                  loaded: !0\n                };\n                i.push(s);\n              }\n\n              for (var a = Math.ceil(Math.sqrt(t)), o = new h.Random(32131), l = 0; l <= a - 1; l++) {\n                for (var u = 0; u <= a - 1; u++) {\n                  var c = u + l * a;\n                  c >= t || (u > 0 && o.get() <= e && n.push({\n                    from: \"n\" + c,\n                    to: \"n\" + (c - 1)\n                  }), l > 0 && o.get() <= e && n.push({\n                    from: \"n\" + c,\n                    to: \"n\" + (c - a)\n                  }));\n                }\n              }\n\n              for (var d = 0; d < n.length; d++) {\n                n[d].id = \"\" + d;\n              }\n\n              return {\n                nodes: i,\n                links: n\n              };\n            }, e.prototype.genRandomUniform = function (t, e) {\n              for (var i = new h.Random(32131), n = [], r = [], s = 0; s < t; s++) {\n                var a = {\n                  id: \"n\" + s,\n                  loaded: !0\n                };\n\n                if (n.length > 0) {\n                  var o = {\n                    id: \"l\" + s,\n                    from: a.id,\n                    to: n[i.get() * n.length | 0].id\n                  };\n                  r.push(o);\n                }\n\n                n.push(a);\n              }\n\n              for (s = r.length; s <= e - 1; s++) {\n                o = {\n                  id: \"l\" + (s + 1),\n                  from: n[i.get() * n.length | 0].id,\n                  to: n[i.get() * n.length | 0].id\n                };\n                r.push(o);\n              }\n\n              return {\n                nodes: n,\n                links: r\n              };\n            }, e.prototype.genRandomTree = function (t, e) {\n              for (var i = new h.Random(31927832), n = {\n                id: \"n0\",\n                loaded: !0\n              }, r = [n], s = [n], a = []; s.length < t;) {\n                var o = i.getArrayElement(r);\n                h.Helpers.removeFromArrayHasty(r, o);\n\n                for (var l = Math.max(1, Math.ceil(i.get() * e)), u = 0; u < l; u++) {\n                  var c = {\n                    id: \"n\" + s.length,\n                    loaded: !0\n                  },\n                      d = {\n                    id: \"l\" + s.length,\n                    from: o.id,\n                    to: c.id\n                  };\n                  a.push(d), s.push(c), r.push(c);\n                }\n              }\n\n              return {\n                nodes: s,\n                links: a\n              };\n            }, e;\n          }(h.Data);\n\n          t.Data = A;\n\n          var M = function () {\n            function t(t) {\n              this.restoredState = {}, this.chart = t;\n            }\n\n            return t.prototype.exportCoordinates = function (t) {\n              for (var e = this.chart.layer.idToNode, i = 0; i < t.length; i++) {\n                var n = t[i],\n                    r = n.id;\n\n                if (h.Helpers.hasProperty(e, r)) {\n                  var s = e[r];\n                  s.removed || (n.x = s.x, n.y = s.y);\n                }\n              }\n            }, t.prototype.save = function () {\n              for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n                var r = e[i[n]];\n                r.removed || (t[r.id] = {\n                  x: r.x,\n                  y: r.y,\n                  r: r.hHeight,\n                  w: r.hWidth\n                });\n              }\n\n              return t;\n            }, t.prototype.restore = function (t) {\n              this.restoredState = {};\n\n              for (var e = this.chart.layer.idToNode, i = Object.keys(t), n = 0; n < i.length; n++) {\n                var r = i[n],\n                    s = t[r];\n\n                if (h.Helpers.hasProperty(e, r)) {\n                  var a = e[r];\n                  a.x = s.x, a.y = s.y, a.hHeight = s.r, a.hWidth = s.w ? s.w : s.r;\n                } else this.restoredState[r] = s;\n              }\n            }, t.prototype.applyRestoredCoordinates = function (t) {\n              if (h.Helpers.hasProperty(this.restoredState, t.id)) {\n                var e = this.restoredState[t.id];\n                delete this.restoredState[t.id], t.x = e.x, t.y = e.y, t.hHeight = e.r, t.hWidth = e.w ? e.w : e.r;\n              }\n            }, t.prototype.lockNode = function (t, e, i) {\n              void 0 === e && (e = null), void 0 === i && (i = null);\n              var n = this.chart.layer.idToNode;\n\n              if (h.Helpers.hasProperty(n, t)) {\n                var r = n[t];\n                r.userLock = !0, null !== e && null !== i && (r.x = e, r.y = i), this.chart.layer.touchNode(r);\n              } else this.chart.error(\"Locking nonexistant node: \" + t);\n            }, t.prototype.unlockNode = function (t) {\n              var e = this.chart.layer.idToNode;\n\n              if (h.Helpers.hasProperty(e, t)) {\n                var i = e[t];\n                i.userLock && (i.userLock = !1, this.chart.layer.touchNode(i), this.chart.events.notifySceneChanges({\n                  dynamicLayout: !0\n                }));\n              } else this.chart.error(\"Unlocking nonexistant node: \" + t);\n            }, t.prototype.exportData = function () {\n              for (var t = this.chart.layer.idToNode, e = Object.keys(t), i = new Array(e.length), n = 0, r = 0; r < e.length; r++) {\n                var s = t[e[r]];\n                s.removed || (i[n++] = s.data);\n              }\n\n              i.length = n;\n              var a = this.chart.layer.idToLink;\n              e = Object.keys(a);\n              var o = new Array(e.length);\n              n = 0;\n\n              for (r = 0; r < e.length; r++) {\n                var l = a[e[r]];\n                l.removed || (o[n++] = l.data);\n              }\n\n              return o.length = n, {\n                nodes: i,\n                links: o\n              };\n            }, t;\n          }();\n\n          t.Graph = M;\n\n          var I = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              i.numPointers = 0, i.resetZoom = !1, i.minimumAutoZoom = 1 / 0, i.animationOrder = 700, i.paintOrder = 20, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.layer = e.layer, i.events = e.events, i.settings = i.scene.settings;\n\n              var n = i._getInertiaAccelerations();\n\n              return i.inertiaX = new h.Inertia(n.x, 0), i.inertiaY = new h.Inertia(n.y, 0), i.inertiaZ = new h.Inertia(n.z, 1), i;\n            }\n\n            return r(e, t), e.prototype.setZoom = function (t, e) {\n              void 0 === e && (e = !0);\n              var i = 1 + this.scene.settings.interaction.zooming.sensitivity;\n              if (\"auto\" === t) this.scene.autoZoomMode = !0, this.autoZoom(e);else if (\"overview\" === t) this.scene.autoZoomMode = \"overview\", this.autoZoom(e);else {\n                var n = void 0;\n                \"in\" === t ? n = 1 / this.inertiaZ.getTargetValue() * i : \"out\" === t ? n = 1 / this.inertiaZ.getTargetValue() / i : null === (n = h.Helpers.tryParseFloat(t, null)) && (this.chart.error(\"Invalid zoom value: \" + t), n = 1 / this.inertiaZ.getTargetValue()), this.manualZoom(n / this.scene.zoom, void 0, void 0, e);\n              }\n              this.chart.events.notifySceneChanges({\n                position: !0\n              });\n            }, e.prototype.previewPointerDown = function () {\n              this.numPointers += 1;\n            }, e.prototype.previewPointerUp = function () {\n              this.numPointers -= 1;\n            }, e.prototype.previewPointerCancel = function () {\n              this.numPointers -= 1;\n            }, e.prototype.doAnimations = function (t) {\n              var e = t.changes.settingsChanges;\n\n              if (e && e.interaction && e.interaction.zooming) {\n                this.minimumAutoZoom = 1 / 0;\n                var i = e.interaction.zooming.initialAutoZoom;\n                \"true\" === i ? i = !0 : \"false\" === i && (i = !1), this.scene.autoZoomMode = i, i && this.autoZoom(!0);\n              }\n\n              if (this.resetZoom || t.changes.newGraph) this.resetZoom = !1, this.setZoom(\"overview\", !1);else if (0 === this.numPointers && this.layer.nodes().length > 0) {\n                this.scene.autoZoomMode && this.autoZoom(!0) && (t.changes.position = !0);\n                var n = t.timeStamp,\n                    r = this.inertiaX.getValue(n),\n                    s = this.inertiaY.getValue(n),\n                    a = 1 / this.inertiaZ.getValue(n);\n                r === this.scene.centerX && s === this.scene.centerY && a === this.scene.zoom || (this.scene.centerX = r, this.scene.centerY = s, this.scene.zoom = a, t.changes.position = !0), this.inertiaX.finished(n) && this.inertiaY.finished(n) && this.inertiaZ.finished(n) || (t.animating = !0);\n              } else this.inertiaX.jump(this.scene.centerX), this.inertiaY.jump(this.scene.centerY), this.inertiaZ.jump(1 / this.scene.zoom);\n            }, e.prototype._getInertiaAccelerations = function () {\n              var t = this.scene.settings.interaction.zooming.autoZoomPositionElasticity,\n                  e = .5 * (this.scene.width + this.scene.height) * t;\n              return {\n                x: e,\n                y: e,\n                z: 2 * t\n              };\n            }, e.prototype.autoZoom = function (t, e) {\n              var i = !1,\n                  n = this.computeAutoZoom(\"overview\" === this.scene.autoZoomMode);\n              if (null == n) return !1;\n\n              var r = n.centerX,\n                  s = n.centerY,\n                  a = n.zoom,\n                  o = .01,\n                  l = 1 / this.inertiaZ.getTargetValue() / a,\n                  h = this._getInertiaAccelerations();\n\n              (l > 1.01 || l < .99) && (t ? this.inertiaZ.setTarget(1 / a, e, h.z) : (this.inertiaZ.jump(1 / a), this.scene.zoom = a), i = !0);\n              var u = this.scene.width,\n                  c = (this.inertiaX.getTargetValue() - r) * a / u;\n              (c > o || c < -o) && (t ? this.inertiaX.setTarget(r, e, h.x) : (this.inertiaX.jump(r), this.scene.centerX = r), i = !0);\n              var d = this.scene.height,\n                  p = (this.inertiaY.getTargetValue() - s) * a / d;\n              return (p > o || p < -o) && (t ? this.inertiaY.setTarget(s, e, h.y) : (this.inertiaY.jump(s), this.scene.centerY = s), i = !0), i;\n            }, e.prototype.computeAutoZoom = function (t, e, i) {\n              var n,\n                  r = this.scene,\n                  s = (n = t ? this.layer.getGraphBounds(e) : this.layer.getNodeNeighborsBounds(r.lastClickedNode)).x0,\n                  a = n.y0,\n                  o = n.x1,\n                  l = n.y1;\n              if (0 === s && 0 === o && 0 === a && 0 === l) return null;\n              i && (n.y0 -= i[0], n.x1 += i[1], n.y1 += i[2], n.x0 -= i[3]);\n              var h = r.getVisibleBounds(),\n                  u = r.settings.interaction.zooming,\n                  c = (1 - u.autoZoomSize) / 2,\n                  d = c * n.w(),\n                  p = c * n.h(),\n                  f = n.clone();\n              if (f.x0 -= d, f.x1 += d, f.y0 -= p, f.y1 += p, n.isInside(h) && !f.isInside(h)) return null;\n              var g = Math.min(r.width / f.w(), r.height / f.h()),\n                  m = u.autoZoomExtent;\n              m && (g = Math.min(m[1], g), null === m[0] ? this.minimumAutoZoom = Math.min(g, this.minimumAutoZoom) : g = Math.max(m[0], g));\n              var v = (f.x0 + f.x1) / 2,\n                  y = (f.y0 + f.y1) / 2,\n                  S = (h.x0 + h.x1) / 2,\n                  b = (h.y0 + h.y1) / 2;\n              return this.scene.zoom === g && Math.abs(v - S) <= d && Math.abs(y - b) <= p ? null : {\n                centerX: v,\n                centerY: y,\n                zoom: g\n              };\n            }, e.prototype.manualZoom = function (t, e, i, n) {\n              void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !1);\n              var r,\n                  s,\n                  a,\n                  l,\n                  h = this.scene,\n                  u = this.settings.interaction.zooming.zoomExtent,\n                  c = this.layer.getGraphBounds(),\n                  d = c.x0,\n                  p = c.y0,\n                  f = c.x1,\n                  g = c.y1,\n                  m = h.zoom * t;\n\n              if (m = Math.min(m, Math.max(h.zoom, u[1])), t = (m = Math.max(m, Math.min(h.zoom, Math.min(this.minimumAutoZoom, u[0])))) / h.zoom, null !== e && null !== i) {\n                var v = h.fromDisplay(e, i);\n                r = v.x, s = v.y;\n              } else if (h.selection.length > 0) {\n                for (var y = 0, S = 0, b = 0, C = 0; C < h.selection.length; C++) {\n                  var x = h.selection[C];\n                  x instanceof o.Node && (y += x.x, S += x.y, b += 1);\n                }\n\n                b > 0 && (r = y / b, s = S / b);\n              }\n\n              r && s ? (a = (h.centerX - r) / t + r, l = (h.centerY - s) / t + s) : (a = r = h.centerX, l = s = h.centerY);\n              var w = h.zoom * t,\n                  L = h.getVisibleBounds();\n\n              if (r < d || r > f) {\n                a += L.x0 > d && L.x1 > f ? Math.max(f - L.x1, d - L.x0) : L.x1 < f && L.x0 < d ? Math.min(f - L.x1, d - L.x0) : 0;\n              }\n\n              if (s < p || s > g) {\n                l += L.y0 > p && L.y1 > g ? Math.max(g - L.y1, p - L.y0) : L.y1 < g && L.y0 < d ? Math.min(g - L.y1, p - L.y0) : 0;\n              }\n\n              if (n && w !== h.zoom ? this.inertiaZ.setTarget(1 / w) : (this.inertiaZ.jump(1 / w), h.zoom = w), !n || a === h.centerX && l === h.centerY) h.centerX = a, h.centerY = l, this.inertiaX.jump(a), this.inertiaY.jump(l);else {\n                var T = this._getInertiaAccelerations();\n\n                this.inertiaX.setTarget(a, null, T.x), this.inertiaY.setTarget(l, null, T.y);\n              }\n              h.autoZoomMode = !1;\n            }, e.prototype.scrollIntoView = function (t, e) {\n              if (t && t.length) {\n                var i = h.Helpers.performanceNow();\n                this.scene.autoZoomMode = !1;\n\n                var n = this._getInertiaAccelerations(),\n                    r = this.computeAutoZoom(!0, t, e);\n\n                r && (this.inertiaX.setTarget(r.centerX, i, n.x), this.inertiaY.setTarget(r.centerY, i, n.y), this.inertiaZ.setTarget(1 / r.zoom, i, n.z), this.chart.events.notifySceneChanges({\n                  position: !0\n                }));\n              }\n            }, e;\n          }(h.ChartElement);\n\n          t.AutoZoom = I;\n\n          var P = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.updateOrder = 150, i.chart = e, i;\n            }\n\n            return r(e, t), e.CreateNavigator = function (t) {\n              switch (t.settings.navigation.mode) {\n                case \"manual\":\n                  return new D(t);\n\n                case \"showall\":\n                  return new F(t);\n\n                case \"focusnodes\":\n                  return new O(t);\n\n                default:\n                  return t.error(\"Unknown navigation mode: '\" + t.settings.navigation.mode + \"'\"), new F(t);\n              }\n            }, e.prototype.updateGraphWithNewData = function (t, e) {\n              for (var i = this.chart.layer, n = this.chart.scene.mainData, r = i.idToNode, s = Object.keys(t || r), a = {\n                loading: !1\n              }, o = 0; o < s.length; o++) {\n                var l = s[o];\n\n                if (h.Helpers.hasProperty(r, l)) {\n                  var u = r[l];\n\n                  if (!u.removed) {\n                    var c = n.getNode(l, !1, a);\n                    c ? (this.updateNodeWithNewData(u, c, n.getLinks(l, !1)), i.touchNode(u)) : a.loading ? u.loading || (u.loading = !0, i.touchNode(u)) : this.ensureNodeRemoved(u);\n                  }\n                }\n              }\n            }, e.prototype.calcExpanded = function (t) {\n              var e = t.expanded;\n              if (t.links.length < t.dataLinks.length) return t.expanded = !1, e;\n\n              for (var i = 0; i < t.links.length; i++) {\n                if (t.links[i].removed) return t.expanded = !1, e;\n              }\n\n              return t.expanded = !0, !e;\n            }, e.prototype.syncNodeLinks = function (t) {\n              for (var e = this.chart.layer, i = t.links, n = t.dataLinks, r = {}, s = 0; s < n.length; s++) {\n                r[n[s].id] = n[s];\n              }\n\n              for (var a = 0; a < i.length; a++) {\n                (u = i[a]).removed || (h.Helpers.hasProperty(r, u.id) ? (u.data = r[u.id], e.touchLink(u), delete r[u.id]) : this.ensureLinkRemoved(u));\n              }\n\n              var o = Object.keys(r),\n                  l = t.id;\n\n              for (s = 0; s < o.length; s++) {\n                var u = r[o[s]],\n                    c = A.otherEnd(u, l);\n                h.Helpers.hasProperty(e.idToNode, c) && !e.idToNode[c].removed && this.ensureLink(u);\n              }\n\n              this.calcExpanded(t);\n            }, e.prototype.updateNodeWithNewData = function (t, e, i) {\n              t.data = e, e.resetCoordinates && (t.x = e.x, t.y = e.y, e.resetCoordinates = !1), e.resetLocked && (t.userLock = e.locked, e.resetLocked = !1), e.loaded && (t.loading = !1), t.dataLinks = i, this.syncNodeLinks(t);\n            }, e.prototype.ensureNode = function (t, e) {\n              var i = this.chart.layer,\n                  n = h.Helpers.hasProperty(i.idToNode, t.id) ? i.idToNode[t.id] : null;\n              return !(n && !n.removed || (n = i.addNode(t.id), null != t.x && (n.x = t.x), null != t.y && (n.y = t.y), null != t.locked && (n.userLock = t.locked), t.resetCoordinates = !1, n.loading = !t.loaded, n.data = t, n.dataLinks = e, this.chart.graph.applyRestoredCoordinates(n), this.syncNodeLinks(n), 0));\n            }, e.prototype.ensureLink = function (t) {\n              var e = this.chart.layer,\n                  i = h.Helpers.hasProperty(e.idToLink, t.id) ? e.idToLink[t.id] : null;\n              if (i && !i.removed) return !1;\n              var n = h.Helpers.hasProperty(e.idToNode, t.from) ? e.idToNode[t.from] : null,\n                  r = h.Helpers.hasProperty(e.idToNode, t.to) ? e.idToNode[t.to] : null;\n              return !(!n || n.removed || !r || r.removed || (i = e.addLink(t.id, t.from, t.to), i.data = t, this.calcExpanded(n), this.calcExpanded(r), 0));\n            }, e.prototype.ensureNodeRemoved = function (t) {\n              if (!t || t.removed) return !1;\n\n              for (var e = this.chart.layer, i = t.links, n = i.length - 1; n >= 0; n--) {\n                var r = i[n];\n\n                if (!r.removed) {\n                  var s = r.otherEnd(t);\n                  s !== t && !s.removed && s.expanded && (s.expanded = !1, e.touchNode(s)), e.removeLink(r);\n                }\n              }\n\n              return e.removeNode(t), !0;\n            }, e.prototype.ensureLinkRemoved = function (t) {\n              if (!t || t.removed) return !1;\n              var e = this.chart.layer;\n              return !t.from.removed && t.from.expanded && (t.from.expanded = !1, e.touchNode(t.from)), !t.to.removed && t.to.expanded && (t.to.expanded = !1, e.touchNode(t.to)), e.removeLink(t), !0;\n            }, e;\n          }(h.Navigator);\n\n          t.Navigator = P;\n\n          var D = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.saveHack = null, e.retryList = [], e;\n            }\n\n            return r(e, t), e.prototype.executeAllSceneChanges = function (t) {\n              var e = this.retryList;\n              this.retryList = [];\n\n              for (var i = 0; i < e.length; i++) {\n                var n = e[i].fun(t);\n                null === n ? this.retryList.push(e[i]) : n && e[i].origin && this.chart.notifyChartUpdate(e[i].origin);\n              }\n            }, e.prototype.notifyNavigation = function (t, e) {\n              this.chart.events.notifySceneChanges({\n                navigation: !0\n              }), this.retryList.push({\n                fun: e,\n                origin: t\n              });\n            }, e.prototype.clearFocusNodes = function (t) {\n              var e = this;\n              this.notifyNavigation(t, function () {\n                for (var t = !1, i = e.chart.layer, n = i.idToNode, r = Object.keys(n), s = 0; s < r.length; s++) {\n                  var a = n[r[s]];\n                  a.focused && !a.removed && (t = !0, a.focused = !1, i.touchNode(a));\n                }\n\n                return t;\n              });\n            }, e.prototype.hideNode = function (t, e) {\n              var i = this;\n              this.notifyNavigation(e, function () {\n                return i.ensureNodeRemoved(h.Helpers.hasProperty(i.chart.layer.idToNode, t) ? i.chart.layer.idToNode[t] : null);\n              });\n            }, e.prototype.showNode = function (t, e) {\n              var i = this;\n              this.notifyNavigation(e, function () {\n                var e = {\n                  loading: !1\n                },\n                    n = i.chart.scene.mainData,\n                    r = n.getNode(t, !0, e);\n                return r ? (i.ensureNode(r, n.getLinks(t)), !0) : !!e.loading && null;\n              });\n            }, e.prototype.collapseNode = function (t, e) {\n              var i = this;\n              this.notifyNavigation(e, function () {\n                var e = i.chart.layer,\n                    n = h.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;\n                if (!n || n.removed) return !1;\n\n                for (var r = !1, s = 0; s < n.links.length; s++) {\n                  var a = n.links[s];\n\n                  if (!a.removed) {\n                    var o = a.otherEnd(n);\n                    o !== n && (r = i.ensureNodeRemoved(o) || r);\n                  }\n                }\n\n                return i.canHideNode(n) && (r = i.ensureNodeRemoved(n) || r), r;\n              });\n            }, e.prototype.calculateCloseNodes = function (t) {\n              for (var e = {}, i = [], n = 0; n < t.links.length; n++) {\n                var r = t.links[n];\n                if (!r.removed) (u = r.otherEnd(t)) === t || u.removed || (i.push(u), e[u.id] = !0);\n              }\n\n              e[t.id] = !0;\n              var s = [];\n\n              for (n = 0; n < i.length; n++) {\n                for (var a = i[n], o = !0, l = 0; l < a.links.length; l++) {\n                  var u = a.links[l].otherEnd(a);\n\n                  if (!h.Helpers.hasProperty(e, u.id)) {\n                    o = !1;\n                    break;\n                  }\n                }\n\n                o && s.push(a);\n              }\n\n              return s;\n            }, e.prototype.closeNode = function (t, e) {\n              var i = this;\n              this.notifyNavigation(e, function () {\n                var e = i.chart.layer,\n                    n = h.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;\n                if (!n || n.removed) return !1;\n\n                for (var r = !1, s = i.calculateCloseNodes(n), a = 0; a < s.length; a++) {\n                  r = i.ensureNodeRemoved(s[a]) || r;\n                }\n\n                return r;\n              });\n            }, e.prototype.focusNode = function (t, e, i) {\n              var n = this;\n              this.chart.settings.navigation.autoUnfocus && this.clearFocusNodes(\"single\"), this.notifyNavigation(i, function () {\n                var e = n.chart.layer.idToNode[t];\n                return e instanceof o.Node && !e.removed && !e.focused && (e.focused = !0, n.chart.layer.touchNode(e), !0);\n              });\n            }, e.prototype.expandNode = function (t, e) {\n              var i = this,\n                  n = {},\n                  r = !1;\n              this.notifyNavigation(e, function () {\n                var e = i.chart.layer,\n                    s = e.idToNode[t];\n                if (!(s instanceof o.Node) || s.removed) return !1;\n                var a = i.chart.scene.mainData,\n                    l = s.dataLinks;\n                if (null != l) for (var u = 0; u < l.length; u++) {\n                  var c = l[u];\n\n                  if (!h.Helpers.hasProperty(n, c.id)) {\n                    n[c.id] = !0;\n                    var d = h.Helpers.hasProperty(e.idToLink, c.id) ? e.idToLink[c.id] : null;\n\n                    if (!d || d.removed) {\n                      var p = A.otherEnd(c, t);\n\n                      if (p !== t) {\n                        var f = h.Helpers.hasProperty(e.idToNode, p) ? e.idToNode[p] : null;\n\n                        if (!f || f.removed) {\n                          var g = a.getNode(p);\n                          if (!g) continue;\n                          i.ensureNode(g, a.getLinks(p));\n                        }\n                      }\n\n                      r = !0;\n                    }\n                  }\n                }\n                return s.data.loaded ? r : null;\n              });\n            }, e.prototype.unfocusNode = function (t, e) {\n              var i = this;\n              this.notifyNavigation(e, function () {\n                var e = i.chart.layer.idToNode[t];\n                return e instanceof o.Node && !e.removed && !!e.focused && (e.focused = !1, i.chart.layer.touchNode(e), !0);\n              });\n            }, e.prototype.save = function () {\n              if (this.saveHack) return this.saveHack;\n\n              for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n                var r = e[i[n]];\n                r.removed || (t[r.id] = r.focused);\n              }\n\n              return t;\n            }, e.prototype.restore = function (t) {\n              var e = this,\n                  i = t;\n\n              if (i) {\n                this.saveHack = i, this.chart.notifyChartUpdate(\"restore\"), this.saveHack = null;\n                var n = {},\n                    r = !1,\n                    s = !1;\n                this.notifyNavigation(null, function () {\n                  var t,\n                      a = e.chart.layer,\n                      o = e.chart.scene.mainData,\n                      l = !1,\n                      u = {\n                    loading: !1\n                  },\n                      c = a.idToNode;\n\n                  if (!s) {\n                    t = Object.keys(c);\n\n                    for (var d = 0; d < t.length; d++) {\n                      var p = t[d];\n                      h.Helpers.hasProperty(i, p) || c[p].removed || (r = e.ensureNodeRemoved(c[p]) || r);\n                    }\n\n                    s = !0;\n                  }\n\n                  t = Object.keys(i);\n\n                  for (d = 0; d < t.length; d++) {\n                    p = t[d];\n\n                    if (!h.Helpers.hasProperty(n, p)) {\n                      var f = h.Helpers.hasProperty(a.idToNode, p) ? a.idToNode[p] : null;\n\n                      if (!f || f.removed) {\n                        var g = o.getNode(p, !0, u);\n\n                        if (!g) {\n                          u.loading ? l = !0 : n[p] = !0;\n                          continue;\n                        }\n\n                        e.ensureNode(g, o.getLinks(p)), a.idToNode[p].focused = i[p], r = !0;\n                      } else f && f.focused !== i[p] && (f.focused = i[p], a.touchNode(f), r = !0);\n\n                      n[p] = !0;\n                    }\n                  }\n\n                  return l ? null : r;\n                });\n              }\n            }, e.prototype.onNewDataObject = function () {\n              for (var t = this, e = this.save(), i = this.chart.scene.mainData, n = Object.keys(e), r = 0; r < n.length; r++) {\n                i.getNode(n[r]);\n              }\n\n              this.notifyNavigation(null, function () {\n                var n,\n                    r = t.chart.layer.idToNode,\n                    s = {\n                  loading: !1\n                };\n                n = Object.keys(e);\n\n                for (var a = 0; a < n.length; a++) {\n                  var o = n[a];\n\n                  if (h.Helpers.hasProperty(r, o) && !r[o].removed) {\n                    if (i.getNode(o, !0, s)) delete e[o];else if (s.loading) return null;\n                  } else delete e[o];\n                }\n\n                return !0;\n              });\n            }, e.prototype.showInitialNodes = function () {\n              var t = this,\n                  e = !1,\n                  i = this.chart.settings.navigation.initialNodes,\n                  n = !1,\n                  r = !1;\n              this.retryList = [], this.notifyNavigation(\"init\", function (s) {\n                var a = t.chart.layer;\n                if (e || (h.Helpers.hasProperties(a.nodes) && (a.clearObjects(), n = !0), e = !0), null == i || i.length < 1) return n;\n                var o = {\n                  loading: !1\n                },\n                    l = t.chart.scene.mainData,\n                    u = !1,\n                    c = i;\n                i = [];\n\n                for (var d = 0; d < c.length; d++) {\n                  var p = c[d],\n                      f = l.getNode(p, !0, o);\n                  f ? (n = t.ensureNode(f, l.getLinks(p)) || n, r || (r = !0, s.changes.newGraph = !0)) : o.loading && (i.push(p), u = !0);\n                }\n\n                return u ? null : n;\n              });\n            }, e.prototype.onSceneChange = function (t) {\n              t.changes.filters ? this.updateGraphWithNewData(null, t) : (t.changes.dataArrived || t.changes.data) && this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.retryList.length > 0 && (t.changes.navigation || t.changes.dataArrived) && this.executeAllSceneChanges(t);\n            }, e.prototype.canFocusNode = function (t) {\n              return !t.focused;\n            }, e.prototype.canUnfocusNode = function (t) {\n              return t.focused;\n            }, e.prototype.canExpandNode = function (t) {\n              return !t.expanded;\n            }, e.prototype.canCollapseNode = function (t) {\n              return this.canHideNode(t);\n            }, e.prototype.canHideNode = function (t) {\n              for (var e = this.chart.layer, i = Object.keys(e.idToNode), n = 0; n < i.length; n++) {\n                var r = e.idToNode[i[n]];\n                if (r !== t && !r.removed) return !0;\n              }\n\n              return !1;\n            }, e.prototype.canCloseNode = function (t) {\n              return this.calculateCloseNodes(t).length > 0;\n            }, e;\n          }(P);\n\n          t.ManualNavigator = D;\n\n          var N,\n              F = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.hiddenNodes = {}, e.isInitialized = !1, e;\n            }\n\n            return r(e, t), e.prototype.showNode = function (e, i) {\n              delete this.hiddenNodes[e], t.prototype.showNode.call(this, e, i);\n            }, e.prototype.hideNode = function (e, i) {\n              var n = this.chart.layer.idToNode;\n              h.Helpers.hasProperty(n, e) && (this.hiddenNodes[e] = !0, t.prototype.hideNode.call(this, e, i));\n            }, e.prototype.collapseNode = function (e, i) {\n              var n = this.chart.layer.idToNode;\n\n              if (h.Helpers.hasProperty(n, e)) {\n                this.hiddenNodes[e] = !0;\n\n                for (var r = n[e], s = 0; s < r.links.length; s++) {\n                  var a = r.links[s];\n\n                  if (!a.removed) {\n                    var o = a.otherEnd(r);\n                    o !== r && (this.hiddenNodes[o.id] = !0);\n                  }\n                }\n\n                t.prototype.collapseNode.call(this, e, i);\n              }\n            }, e.prototype.closeNode = function (e, i) {\n              var n = this.chart.layer.idToNode;\n\n              if (h.Helpers.hasProperty(n, e)) {\n                for (var r = this.calculateCloseNodes(n[e]), s = 0; s < r.length; s++) {\n                  this.hiddenNodes[r[s].id] = !0;\n                }\n\n                t.prototype.closeNode.call(this, e, i);\n              }\n            }, e.prototype.save = function () {\n              if (this.saveHack) return this.saveHack;\n              var t;\n              t = [];\n\n              for (var e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n                var r = e[i[n]];\n                !r.removed && r.focused && t.push(r.id);\n              }\n\n              return {\n                hidden: Object.keys(this.hiddenNodes),\n                focused: t\n              };\n            }, e.prototype.restore = function (t) {\n              var e = this,\n                  i = t;\n              this.hiddenNodes = {};\n\n              for (var n = 0; n < i.hidden.length; n++) {\n                this.hiddenNodes[i.hidden[n]] = !0;\n              }\n\n              this.saveHack = i, this.chart.notifyChartUpdate(\"restore\"), this.saveHack = null, this.notifyNavigation(null, function (t) {\n                e.updateGraphWithNewData(null, t);\n\n                for (var n = {}, r = 0; r < i.focused.length; r++) {\n                  n[i.focused[r]] = !0;\n                }\n\n                var s = e.chart.layer,\n                    a = s.idToNode,\n                    o = Object.keys(a);\n\n                for (r = 0; r < o.length; r++) {\n                  var l = a[o[r]],\n                      u = h.Helpers.hasProperty(n, o[r]);\n                  l.removed || l.focused === u || (l.focused = u, s.touchNode(l));\n                }\n\n                return !1;\n              });\n            }, e.prototype.expandNode = function (e, i) {\n              var n = this.chart.layer.idToNode;\n\n              if (h.Helpers.hasProperty(n, e)) {\n                for (var r = n[e], s = 0; s < r.dataLinks.length; s++) {\n                  var a = r.dataLinks[s],\n                      o = A.otherEnd(a, e);\n                  o !== e && delete this.hiddenNodes[o];\n                }\n\n                t.prototype.expandNode.call(this, e, i);\n              }\n            }, e.prototype.showInitialNodes = function () {\n              var t = this;\n              this.retryList = [], this.notifyNavigation(\"init\", function (e) {\n                var i = t.chart.layer,\n                    n = t.chart.scene.mainData;\n                t.hiddenNodes = {}, i.clearObjects(), t.isInitialized = !0;\n                var r,\n                    s = t.chart.settings.navigation.initialNodes,\n                    a = {};\n\n                if (null == s || s.length < 1) {\n                  r = n.getAllNodes();\n\n                  for (var o = 0; o < r.length; o++) {\n                    a[r[o].id] = !0;\n                  }\n                } else {\n                  r = n.getAllNodes(!1);\n\n                  for (o = 0; o < r.length; o++) {\n                    a[r[o].id] = !0;\n                  }\n\n                  for (o = 0; o < s.length; o++) {\n                    var l = s[o];\n\n                    if (!h.Helpers.hasProperty(a, l)) {\n                      var u = n.getNode(l);\n                      u && (r.push(u), a[l] = !0);\n                    }\n                  }\n                }\n\n                for (o = 0; o < r.length; o++) {\n                  var c = r[o],\n                      d = n.getLinks(c.id);\n                  t.ensureNode(c, d);\n\n                  for (var p = 0; p < d.length; p++) {\n                    var f = A.otherEnd(d[p], c.id);\n\n                    if (f && f !== c.id && !h.Helpers.hasProperty(a, f)) {\n                      a[f] = !0;\n                      var g = n.getNode(f);\n                      g && r.push(g);\n                    }\n                  }\n                }\n\n                return r.length > 0 && (e.changes.newGraph = !0), !0;\n              });\n            }, e.prototype.onNewDataObject = function () {\n              var t = this,\n                  e = this.chart.settings.navigation.initialNodes;\n              (null == e || e.length < 1) && this.chart.scene.mainData.getAllNodes(), this.notifyNavigation(null, function (e) {\n                return t.updateGraphWithNewData(null, e), !1;\n              });\n            }, e.prototype.updateGraphWithNewData = function (t, e) {\n              if (this.isInitialized) {\n                var i,\n                    n = this.chart.layer,\n                    r = this.chart.scene.mainData,\n                    s = n.idToNode,\n                    a = {};\n\n                if (t) {\n                  i = Object.keys(t);\n\n                  for (var o = 0; o < i.length; o++) {\n                    a[i[o]] = r.getNode(i[o], !1);\n                  }\n                } else {\n                  var l = r.getAllNodes(!1);\n\n                  for (o = 0; o < l.length; o++) {\n                    a[l[o].id] = l[o];\n                  }\n\n                  var u = Object.keys(s);\n\n                  for (o = 0; o < u.length; o++) {\n                    h.Helpers.hasProperty(a, u[o]) || (a[u[o]] = null);\n                  }\n\n                  u = Object.keys(this.hiddenNodes);\n\n                  for (o = 0; o < u.length; o++) {\n                    h.Helpers.hasProperty(a, u[o]) || (a[u[o]] = null);\n                  }\n\n                  i = Object.keys(a);\n                }\n\n                var c = !1,\n                    d = Object.keys(s);\n\n                for (o = 0; o < d.length; o++) {\n                  if (!s[d[o]].removed) {\n                    c = !0;\n                    break;\n                  }\n                }\n\n                var p = !1;\n\n                for (o = 0; o < i.length; o++) {\n                  var f = i[o],\n                      g = a[f],\n                      m = h.Helpers.hasProperty(s, f) ? s[f] : null;\n\n                  if (g) {\n                    if (h.Helpers.hasProperty(this.hiddenNodes, f)) {\n                      this.ensureNodeRemoved(m);\n                      continue;\n                    }\n\n                    var v = r.getLinks(f, !1);\n                    m && !m.removed ? (this.updateNodeWithNewData(m, g, v), n.touchNode(m)) : (this.ensureNode(g, v), m = s[f], p = !0);\n\n                    for (var y = 0; y < v.length; y++) {\n                      var S = A.otherEnd(v[y], f);\n\n                      if (S && S !== f && !h.Helpers.hasProperty(this.hiddenNodes, S)) {\n                        var b = h.Helpers.hasProperty(s, S) ? s[S] : null;\n\n                        if (!b || b.removed) {\n                          var C = r.getNode(S);\n                          C && this.ensureNode(C, r.getLinks(S));\n                        }\n                      }\n                    }\n                  } else r.isNodeLoading(f) ? m && !m.loading && (m.loading = !0, n.touchNode(m)) : (this.ensureNodeRemoved(m), delete this.hiddenNodes[f]);\n                }\n\n                !c && p && (e.changes.newGraph = !0);\n              }\n            }, e;\n          }(D);\n\n          t.ShowAllNavigator = F, function (t) {\n            t[t.Hidden = 1] = \"Hidden\", t[t.Expanded = 2] = \"Expanded\";\n          }(N || (N = {}));\n\n          var O = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.focusNodes = [], e.extraFlags = {}, e.needsFullRecalculate = !1, e.wasReset = !1, e;\n            }\n\n            return r(e, t), e.prototype.expandNode = function (t, e) {\n              var i = this.chart.layer.idToNode,\n                  n = h.Helpers.hasProperty(i, t) ? i[t] : null,\n                  r = !1;\n\n              if (n && !n.removed) {\n                n.relevance < 2 && (this.extraFlags[t] = N.Expanded, r = !0);\n\n                for (var s = 0; s < n.dataLinks.length; s++) {\n                  var a = A.otherEnd(n.dataLinks[s], t);\n                  a && a !== t && h.Helpers.hasProperty(this.extraFlags, a) && this.extraFlags[a] === N.Hidden && (delete this.extraFlags[a], r = !0);\n                }\n\n                r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e));\n              }\n            }, e.prototype.collapseNode = function (t, e) {\n              var i = this.chart.layer.idToNode,\n                  n = h.Helpers.hasProperty(i, t) ? i[t] : null,\n                  r = !1;\n\n              if (n && !n.removed) {\n                h.Helpers.hasProperty(this.extraFlags, t) && (delete this.extraFlags[t], r = !0);\n\n                for (var s = 0; s < n.links.length; s++) {\n                  var a = n.links[s].otherEnd(n);\n                  a && a !== n && !a.removed && a.baseRelevance < n.baseRelevance && (this.extraFlags[a.id] = N.Hidden, r = !0);\n                }\n\n                r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e));\n              }\n            }, e.prototype.closeNode = function (t, e) {}, e.prototype.focusNode = function (t, e, i) {\n              for (var n = 0; n < this.focusNodes.length; n++) {\n                if (this.focusNodes[n].id === t) return;\n              }\n\n              if (this.focusNodes.length >= this.chart.settings.navigation.numberOfFocusNodes) {\n                if (!this.chart.settings.navigation.autoUnfocus) return;\n                this.focusNodes.pop();\n              }\n\n              this.focusNodes.unshift({\n                id: t,\n                assignedRelevance: e,\n                calculatedRelevance: null\n              }), h.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === N.Hidden && delete this.extraFlags[t];\n              var r = this.chart.scene.mainData.getLinks(t, !1);\n              if (r) for (n = 0; n < r.length; n++) {\n                var s = A.otherEnd(r[n], t);\n                s && s !== t && h.Helpers.hasProperty(this.extraFlags, s) && this.extraFlags[s] === N.Hidden && delete this.extraFlags[s];\n              }\n              this.chart.notifyChartUpdate(i), this.scheduleFullRecalculate();\n            }, e.prototype.unfocusNode = function (t, e) {\n              if (!(this.focusNodes.length <= Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1))) for (var i = 0; i < this.focusNodes.length; i++) {\n                if (this.focusNodes[i].id === t) return this.focusNodes.splice(i, 1), this.chart.notifyChartUpdate(e), void this.scheduleFullRecalculate();\n              }\n            }, e.prototype.clearFocusNodes = function (t) {\n              this.focusNodes = [], this.extraFlags = {}, this.wasReset = !0, this.chart.notifyChartUpdate(t), this.scheduleFullRecalculate();\n            }, e.prototype.hideNode = function (t, e) {\n              var i = this.chart.layer.idToNode,\n                  n = h.Helpers.hasProperty(i, t) ? i[t] : null;\n              n && !n.removed && this.canHideNode(n) && (this.extraFlags[t] = N.Hidden, this.chart.notifyChartUpdate(e), this.scheduleFullRecalculate());\n            }, e.prototype.showNode = function (t, e) {\n              h.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === N.Hidden && (delete this.extraFlags[t], this.scheduleFullRecalculate());\n            }, e.prototype.showInitialNodes = function () {\n              this.extraFlags = {};\n              var t = this.chart.settings.navigation.initialNodes;\n\n              if (t) {\n                var e = {};\n                this.focusNodes = new Array(t.length);\n\n                for (var i = 0, n = 0; n < t.length; n++) {\n                  var r = t[n];\n                  h.Helpers.hasProperty(e, r) || (e[r] = !0, this.focusNodes[i++] = {\n                    id: r,\n                    assignedRelevance: -1,\n                    calculatedRelevance: null\n                  });\n                }\n\n                i < this.chart.settings.navigation.minNumberOfFocusNodes && this.chart.error(\"Too few initialNodes. minNumberOfFocusNodes is \" + this.chart.settings.navigation.minNumberOfFocusNodes + \" but there are only \" + i + \" nodes in initialNodes\"), i > this.chart.settings.navigation.numberOfFocusNodes && (this.chart.error(\"Too many initialNodes. numberOfFocusNodes is \" + this.chart.settings.navigation.numberOfFocusNodes + \" but there are \" + i + \" nodes in initialNodes. Discarding excess focus nodes.\"), i = this.chart.settings.navigation.numberOfFocusNodes), this.focusNodes.length = i;\n              } else this.focusNodes = [];\n\n              this.wasReset = !0, this.chart.notifyChartUpdate(\"init\"), this.scheduleFullRecalculate();\n            }, e.prototype.save = function () {\n              return {\n                focusNodes: this.focusNodes,\n                extraFlags: this.extraFlags\n              };\n            }, e.prototype.restore = function (t) {\n              this.focusNodes = h.Helpers.realClone(t.focusNodes), this.extraFlags = h.Helpers.clone(t.extraFlags), this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(\"restore\");\n            }, e.prototype.onNewDataObject = function () {\n              for (var t = this.chart.scene.mainData, e = Object.keys(this.chart.layer.idToNode), i = 0; i < e.length; i++) {\n                t.getNode(e[i]);\n              }\n            }, e.prototype.onSceneChange = function (t) {\n              t.changes.filters ? (this.updateGraphWithNewData(null, t), this.needsFullRecalculate = !0) : t.changes.dataArrived || t.changes.data ? (this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.needsFullRecalculate = !0) : t.changes.settings && t.changes.settingsChanges.navigation && (this.needsFullRecalculate = !0), this.needsFullRecalculate && (this.needsFullRecalculate = !1, this.fullRecalculate(t.timeStamp, t));\n            }, e.prototype.scheduleFullRecalculate = function () {\n              this.needsFullRecalculate = !0, this.chart.events.notifySceneChanges({\n                navigation: !0\n              });\n            }, e.prototype.fullRecalculate = function (t, e) {\n              var i = this,\n                  n = this.chart.settings.navigation,\n                  r = this.chart.layer,\n                  s = this.chart.scene.mainData;\n              if (this.focusNodes.length < 1) return r.clearObjects(), this.wasReset && (e.changes.newGraph = !0), void (this.wasReset = !1);\n\n              for (var a = t - this.chart.settings.navigation.expandDelay, o = r.idToNode, l = Object.keys(o), u = r.idToLink, c = 0; c < l.length; c++) {\n                (H = o[l[c]]).baseRelevance = -1 / 0, H.relevance = -1 / 0, H.focused = !1, r.touchNode(H);\n              }\n\n              if (n.numberOfFocusNodes > 1) {\n                var d = null == n.focusNodeTailExpansionRadius ? n.focusNodeExpansionRadius : n.focusNodeTailExpansionRadius,\n                    p = Math.max(n.focusNodeExpansionRadius + 1, 1),\n                    f = (p - Math.max(d + 1, 1)) / (n.numberOfFocusNodes - 1);\n\n                for (c = 0; c < this.focusNodes.length; c++) {\n                  this.focusNodes[c].calculatedRelevance = p - c * f;\n                }\n              } else this.focusNodes[0].calculatedRelevance = Math.max(n.focusNodeExpansionRadius + 1, 1);\n\n              var g = [],\n                  m = {},\n                  v = {};\n\n              for (c = 0; c < this.focusNodes.length; c++) {\n                var y = this.focusNodes[c];\n\n                if (!(H = h.Helpers.hasProperty(o, y.id) ? o[y.id] : null) || H.removed) {\n                  if (!(O = s.getNode(y.id))) continue;\n                  this.ensureNode(O, s.getLinks(y.id)), H = o[y.id];\n                }\n\n                H.focused = !0, H.baseRelevance = y.assignedRelevance >= 1 ? y.assignedRelevance : y.calculatedRelevance, H.relevance = H.baseRelevance, H.showTimestamp = -1 / 0, g.push(H), m[y.id] = !0, v[y.id] = !0, this.wasReset && (this.wasReset = !1, e.changes.newGraph = !0);\n              }\n\n              var S = Object.keys(this.extraFlags);\n\n              for (c = 0; c < S.length; c++) {\n                var b = S[c];\n                if ((H = h.Helpers.hasProperty(o, b) ? o[b] : null) && !H.removed) if (this.extraFlags[b] === N.Hidden) H.relevance = -100;else if (H.relevance < 2) {\n                  H.relevance = 2;\n\n                  for (var C = 0; C < H.links.length; C++) {\n                    (D = H.links[C].otherEnd(H)) && D !== H && D.relevance < 1 && -100 !== D.relevance && (D.relevance = 1);\n                  }\n                } else delete this.extraFlags[b];\n              }\n\n              var x = 1 / 0;\n\n              for (c = 0; c < g.length; c++) {\n                delete m[(H = g[c]).id];\n                b = H.id;\n                var w = H.baseRelevance - 1,\n                    L = H.relevance - 1,\n                    T = h.Helpers.hasProperty(v, b) && H.relevance > 0;\n\n                for (C = 0; C < H.dataLinks.length; C++) {\n                  var k = H.dataLinks[C],\n                      M = A.otherEnd(k, b);\n\n                  if (M && M !== b) {\n                    T && (v[M] = !0);\n                    var I = h.Helpers.hasProperty(this.extraFlags, M) ? this.extraFlags[M] : null;\n\n                    if (I !== N.Hidden) {\n                      var P = L;\n                      I === N.Expanded && L >= 2 && delete this.extraFlags[M];\n                      var D,\n                          F = !1;\n\n                      if (!(D = h.Helpers.hasProperty(o, M) ? o[M] : null) || D.removed) {\n                        if (P <= 0) continue;\n                        var O;\n                        if (!(O = s.getNode(M))) continue;\n\n                        if (H.showTimestamp > a) {\n                          x > H.showTimestamp && (x = H.showTimestamp);\n                          continue;\n                        }\n\n                        this.ensureNode(O, s.getLinks(M)), (D = o[M]).relevance = P, D.baseRelevance = w, D.showTimestamp = t, F = !0;\n                      } else D.relevance < P && (D.relevance = P, r.touchNode(D), F = !0), D.baseRelevance < w && (D.baseRelevance = w, r.touchNode(D), F = !0);\n\n                      var E = u[k.id],\n                          R = Math.min(H.relevance, D.relevance);\n                      E.relevance !== R && (E.relevance = R, r.touchLink(E)), F && !h.Helpers.hasProperty(m, M) && (m[M] = !0, g.push(D));\n                    }\n                  }\n                }\n              }\n\n              for (c = 0; c < l.length; c++) {\n                var H;\n                (H = o[b = l[c]]).removed || (h.Helpers.hasProperty(v, b) ? H.relevance <= 0 && this.ensureNodeRemoved(H) : (this.ensureNodeRemoved(H), delete this.extraFlags[b]));\n              }\n\n              x < 1 / 0 && window.setTimeout(function () {\n                return i.scheduleFullRecalculate();\n              }, x + this.chart.settings.navigation.expandDelay - t);\n            }, e.prototype.canFocusNode = function (t) {\n              return !t.focused && (this.focusNodes.length < this.chart.settings.navigation.numberOfFocusNodes || this.chart.settings.navigation.autoUnfocus);\n            }, e.prototype.canUnfocusNode = function (t) {\n              return t.focused && this.focusNodes.length > Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1);\n            }, e.prototype.canExpandNode = function (t) {\n              return !t.expanded;\n            }, e.prototype.canCollapseNode = function (t) {\n              for (var e = 0; e < t.links.length; e++) {\n                var i = t.links[e].otherEnd(t);\n                if (i && i !== t && !i.removed && i.baseRelevance < t.baseRelevance) return !0;\n              }\n\n              return !1;\n            }, e.prototype.canHideNode = function (t) {\n              return !t.focused || this.canUnfocusNode(t);\n            }, e.prototype.canCloseNode = function (t) {\n              return !1;\n            }, e;\n          }(P);\n\n          t.FocusNodesNavigator = O, function (t) {\n            var e = function () {\n              function t(t) {\n                this.pointers = [], this.manager = t;\n              }\n\n              return t.prototype.addPointer = function (t, e) {\n                this.pointers.push(t.identifier), t.consumed = !0;\n              }, t.prototype.removePointer = function (t) {\n                h.Helpers.removeFromArrayHasty(this.pointers, t.identifier), t.consumed = !0;\n              }, t.prototype.movePointer = function (t) {\n                t.consumed = !0;\n              }, t;\n            }();\n\n            t.Gesture = e;\n\n            var i = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.startX = 0, e.startY = 0, e.lastX = 0, e.lastY = 0, e.selectedNodes = null, e;\n              }\n\n              return r(e, t), e.prototype.addPointer = function (e, i) {\n                t.prototype.addPointer.call(this, e, i), this.startX = this.lastX = e.x, this.startY = this.lastY = e.y, this.selectedNodes = new Object(null), e.cursor = \"crosshair\";\n                var n = this.manager.chart.scene;\n                n.disableSelectionChangeNotification();\n                var r = n.selection.filter(function (t) {\n                  return t.dragging;\n                });\n                r.length !== n.selection.length && n.setSelection(r), this.manager.chart.events.requestPaint();\n              }, e.prototype.movePointer = function (e) {\n                t.prototype.movePointer.call(this, e), this.lastX = e.x, this.lastY = e.y, this.manager.chart.events.requestPaint(), e.cursor = \"crosshair\", this.updateSelection();\n              }, e.prototype.removePointer = function (e) {\n                for (var i in t.prototype.removePointer.call(this, e), this.selectedNodes) {\n                  this.selectedNodes[i].selectionLock = !1;\n                }\n\n                this.manager.chart.scene.enableSelectionChangeNotification(), this.manager.chart.scene.notifySelectionChangesIfNeeded(this.manager.chart, \"user\"), this.manager.chart.events.requestPaint();\n              }, e.prototype.doAnimations = function (t) {\n                this.pointers.length > 0 && (t.changes.position || t.changes.selection || this.manager.chart.layer.hasTopologyChanges()) && this.updateSelection();\n              }, e.prototype.updateSelection = function () {\n                for (var t = this.manager.chart.layer.nodes(), e = this.manager.chart.scene, i = e.fromDisplay(this.startX, this.startY), n = e.fromDisplay(this.lastX, this.lastY), r = Math.min(i.x, n.x), s = Math.min(i.y, n.y), a = Math.max(i.x, n.x), o = Math.max(i.y, n.y), l = 0; l < t.length; l++) {\n                  var h = t[l];\n                  h.removed ? this.selectedNodes[h.id] && delete this.selectedNodes[h.id] : h.dragging || (h.x >= r && h.x <= a && h.y >= s && h.y <= o ? this.selectedNodes[h.id] || (this.selectedNodes[h.id] = h, h.selectionLock = !0, h.selected || e.addToSelection(h)) : this.selectedNodes[h.id] && (delete this.selectedNodes[h.id], h.selectionLock = !1, h.selected && e.removeFromSelection(h)));\n                }\n              }, e.prototype.paintScene = function (t) {\n                if (this.pointers.length > 0) {\n                  var e = this.manager.chart.settings.style.dragSelection,\n                      i = h.Graphics.beginStrokeAndFill(t.context, e);\n                  i.rect(this.startX - .5, this.startY - .5, this.lastX - this.startX, this.lastY - this.startY), h.Graphics.endStrokeAndFill(t.context, i, e);\n                }\n              }, e;\n            }(e);\n\n            t.MultiSelectGesture = i;\n\n            var n = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.dragPointers = {}, e;\n              }\n\n              return r(e, t), e.prototype.addPointer = function (e, i) {\n                t.prototype.addPointer.call(this, e, i);\n                var n = this.manager.chart.scene.selection.filter(function (t) {\n                  return !t.dragging;\n                });\n                n.indexOf(i.object) < 0 && n.push(i.object);\n\n                for (var r = n.filter(function (t) {\n                  return t instanceof o.Node;\n                }), s = 0; s < r.length; s++) {\n                  r[s].locks++;\n                }\n\n                for (s = 0; s < n.length; s++) {\n                  n[s].dragging = !0;\n                }\n\n                var a = this.manager.chart.scene.fromDisplay(e.x, e.y);\n                this.dragPointers[e.identifier] = {\n                  nodes: r,\n                  all: n,\n                  mainNode: i.object,\n                  startPointerX: e.x,\n                  startPointerY: e.y,\n                  lastPointerX: e.x,\n                  lastPointerY: e.y,\n                  lastSceneX: a.x,\n                  lastSceneY: a.y\n                };\n              }, e.prototype.removePointer = function (e) {\n                t.prototype.removePointer.call(this, e);\n                var i = this.dragPointers[e.identifier];\n                delete this.dragPointers[e.identifier];\n\n                for (var n = 0; n < i.nodes.length; n++) {\n                  i.nodes[n].locks--;\n                }\n\n                for (n = 0; n < i.all.length; n++) {\n                  i.all[n].dragging = !1;\n                }\n\n                this.manager.autoZoomIn(e, i.mainNode);\n              }, e.prototype.movePointer = function (e) {\n                t.prototype.movePointer.call(this, e);\n                var i = this.dragPointers[e.identifier];\n                i.lastPointerX = e.x, i.lastPointerY = e.y;\n                var n = this.manager.chart.settings.interaction.selection,\n                    r = this.manager.chart.scene.fromDisplay(e.x, e.y),\n                    s = r.x - i.lastSceneX,\n                    a = r.y - i.lastSceneY;\n\n                if (0 !== s || 0 !== a) {\n                  i.lastSceneX = r.x, i.lastSceneY = r.y;\n                  var o = n.lockNodesOnMove;\n\n                  if (o) {\n                    var l = e.x - i.startPointerX,\n                        h = e.y - i.startPointerY,\n                        u = this.manager.chart.settings.advanced.pointer,\n                        c = Math.max(u.clickSensitivity, u.longPressSensitivity);\n                    o = l * l + h * h > c * c;\n                  }\n\n                  this.moveNodes(i.nodes, s, a, o), this.manager.chart.events.notifySceneChanges({\n                    coordinates: !0\n                  });\n                }\n              }, e.prototype.moveNodes = function (t, e, i, n) {\n                for (var r = this.manager.chart.scene, s = r.getVisibleBounds(), a = r.zoom, o = this.manager.chart.settings.interaction.selection.allowMoveNodesOffscreen, l = this.manager.chart.layer, h = 0; h < t.length; h++) {\n                  var u = t[h];\n\n                  if (u.x += e, u.y += i, n && !u.userLock && (u.userLock = !0, l.touchNode(u)), !o) {\n                    var c = 1.2 * u.renderHwidth / a,\n                        d = 1.2 * u.renderHheight / a;\n                    u.x = Math.min(Math.max(u.x, s.x0 + c), s.x1 - c), u.y = Math.min(Math.max(u.y, s.y0 + d), s.y1 - d);\n                  }\n                }\n              }, e.prototype.doAnimations = function (t) {\n                for (var e = this.manager.chart.scene, i = 0; i < this.pointers.length; i++) {\n                  var n = this.dragPointers[this.pointers[i]],\n                      r = e.fromDisplay(n.lastPointerX, n.lastPointerY),\n                      s = r.x - n.lastSceneX,\n                      a = r.y - n.lastSceneY;\n                  0 === s && 0 === a || (n.lastSceneX = r.x, n.lastSceneY = r.y, this.moveNodes(n.nodes, s, a, !1), t.changes.coordinates = !0);\n                }\n              }, e;\n            }(e);\n\n            t.NodeDragGesture = n;\n\n            var s = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.pinnedSceneX = 0, e.pinnedSceneY = 0, e;\n              }\n\n              return r(e, t), e.prototype.addPointer = function (e, i) {\n                t.prototype.addPointer.call(this, e, i);\n                var n = this.manager.chart.scene.fromDisplay(e.x, e.y);\n                this.pinnedSceneX = n.x, this.pinnedSceneY = n.y;\n              }, e.prototype.movePointer = function (e) {\n                t.prototype.movePointer.call(this, e);\n                var i = this.manager.chart.scene;\n                i.autoZoomMode = !1;\n                var n = i.fromDisplay(e.x, e.y);\n                i.centerX += this.pinnedSceneX - n.x, i.centerY += this.pinnedSceneY - n.y, e.changes.position = !0;\n              }, e;\n            }(e);\n\n            t.PanGesture = s;\n\n            var a = function (t) {\n              function e() {\n                var e = t.apply(this, arguments) || this;\n                return e.x1 = 0, e.y1 = 0, e.x2 = 0, e.y2 = 0, e.centerX = 0, e.centerY = 0, e.centerDistance = 0, e;\n              }\n\n              return r(e, t), e.prototype.addPointer = function (e, i) {\n                if (t.prototype.addPointer.call(this, e, i), 1 === this.pointers.length) this.x1 = e.x, this.y1 = e.y;else {\n                  this.x2 = e.x, this.y2 = e.y;\n                  var n = this.manager.chart.scene,\n                      r = n.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n                  this.centerX = r.x, this.centerY = r.y;\n                  var s = this.x1 - this.x2,\n                      a = this.y1 - this.y2,\n                      o = Math.sqrt(s * s + a * a);\n                  this.centerDistance = o / n.zoom;\n                }\n              }, e.prototype.movePointer = function (e) {\n                t.prototype.movePointer.call(this, e), e.identifier === this.pointers[0] ? (this.twoFingerDrag(e.x, e.y, this.x2, this.y2), this.x1 = e.x, this.y1 = e.y) : (this.twoFingerDrag(this.x1, this.y1, e.x, e.y), this.x2 = e.x, this.y2 = e.y), e.changes.position = !0;\n              }, e.prototype.twoFingerDrag = function (t, e, i, n) {\n                var r = this.manager.chart.settings.interaction,\n                    s = this.manager.chart.scene;\n                s.autoZoomMode = !1;\n                var a = i - t,\n                    o = n - e,\n                    l = this.manager.chart.settings.layout.mode;\n                !r.rotation.fingers || \"static\" !== l && \"dynamic\" !== l || this._twoFingerRotation(t, e, i, n);\n                var h = Math.sqrt(a * a + o * o) / s.zoom,\n                    u = (i + t) / 2,\n                    c = (n + e) / 2;\n\n                if (!r.rotation.fingers && r.panning.enabled) {\n                  var d = s.fromDisplay(u, c);\n                  s.centerX += this.centerX - d.x, s.centerY += this.centerY - d.y;\n                }\n\n                if (r.zooming.fingers) {\n                  var p = h / this.centerDistance;\n                  this.manager.chart.autoZoom.manualZoom(p, u, c);\n                }\n              }, e.prototype._twoFingerRotation = function (t, e, i, n) {\n                var r = i - t,\n                    s = n - e,\n                    a = Math.atan2(s, r) - Math.atan2(this.y2 - this.y1, this.x2 - this.x1);\n                if (0 === a) return !1;\n                var o,\n                    l,\n                    u,\n                    c,\n                    d,\n                    p = t - this.x1,\n                    f = e - this.y1,\n                    g = i - this.x2,\n                    m = n - this.y2,\n                    v = p * p + f * f,\n                    y = g * g + m * m;\n                v >= y ? (o = this.x1, l = this.y1, u = t, c = e, d = Math.sqrt(v)) : (o = this.x2, l = this.y2, u = i, c = n, d = Math.sqrt(y));\n                var S = u - o,\n                    b = c - l,\n                    C = S / d,\n                    x = b / d,\n                    w = (Math.PI + a) / 2,\n                    L = Math.PI - w,\n                    T = h.Geometry.rotateVector(C, x, Math.sin(L), Math.cos(L)),\n                    k = h.Geometry.rotateVector(C, x, Math.sin(w), Math.cos(w)),\n                    A = h.Geometry.lineIntersectsLine(0, 0, T.x, T.y, S, b, S + k.x, b + k.y);\n                if (A === 1 / 0) return !1;\n\n                for (var M, I = o + T.x * A, P = l + T.y * A, D = this.manager.chart.scene.fromDisplay(I, P), N = D.x, F = D.y, O = this.manager.chart.layer.nodes(), E = Math.sin(a), R = Math.cos(a), H = 0; H < O.length; H++) {\n                  var B = O[H];\n                  B.dragging || (M = h.Geometry.rotateVector(B.x - N, B.y - F, E, R), B.x = N + M.x, B.y = F + M.y);\n                }\n\n                return !0;\n              }, e;\n            }(e);\n\n            t.TwoFingerGesture = a;\n\n            var l = {\n              object: null,\n              details: null\n            },\n                u = function (t) {\n              function u(r) {\n                var o = t.call(this) || this;\n                return o.animationOrder = 2e3, o.updateOrder = 1100, o.paintOrder = 37, o.hoverPointer = null, o.ignoreGesture = new e(o), o.postponeGesture = new e(o), o.multiSelectGesture = new i(o), o.nodeDragGesture = new n(o), o.panGesture = new s(o), o.twoFingerGesture = new a(o), o.pointerMap = {}, o.chart = r, o;\n              }\n\n              return r(u, t), u.prototype.findObject = function (t) {\n                return this.chart.renderer.findObjectAt(t.x, t.y, this.chart.settings.interaction.selection.tolerance) || l;\n              }, u.prototype.assignPointer = function (t, e, i) {\n                var n = this.pointerMap[t.identifier];\n                return n ? (n.gesture.removePointer(t), n.gesture = i) : n = this.pointerMap[t.identifier] = {\n                  gesture: i,\n                  lastX: t.x,\n                  lastY: t.y,\n                  longPressGesture: null\n                }, i.addPointer(t, e), n;\n              }, u.prototype.reassignToTwoFinger = function (t, e, i) {\n                var n = this.pointerMap[t],\n                    r = new h.MouseEvent(n.lastX, n.lastY, e.timeStamp, t);\n                n.longPressGesture = null, this.assignPointer(r, l, this.twoFingerGesture), this.assignPointer(e, i, this.twoFingerGesture);\n              }, u.prototype.assignUnknownPointer = function (t, e) {\n                e.object instanceof o.Node && this.chart.settings.interaction.nodesMovable && e.object.draggable ? this.assignNodePointer(t, e) : this.assignEmptyPointer(t, e);\n              }, u.prototype.assignEmptyPointer = function (t, e) {\n                var i = this.chart.settings.interaction,\n                    n = i.rotation.fingers || i.zooming.fingers,\n                    r = i.selection.enabled && i.selection.dragSelect;\n\n                if (this.twoFingerGesture.pointers.length > 0) {\n                  var s = this.assignPointer(t, e, this.ignoreGesture);\n                  r && (s.longPressGesture = this.multiSelectGesture);\n                } else if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);else if (n && this.postponeGesture.pointers.length > 0) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);else if (n && this.nodeDragGesture.pointers.length > 0) this.reassignToTwoFinger(this.nodeDragGesture.pointers[0], t, e);else {\n                  s = this.assignPointer(t, e, i.panning.enabled && this.panGesture.pointers.length < 1 ? this.panGesture : this.postponeGesture);\n                  r && (s.longPressGesture = this.multiSelectGesture);\n                }\n              }, u.prototype.assignNodePointer = function (t, e) {\n                var i = this.chart.settings.interaction,\n                    n = i.rotation.fingers || i.zooming.fingers;\n                if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);else if (n && this.postponeGesture.pointers.length > 0 && this.twoFingerGesture.pointers.length < 1) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);else if (e.object.dragging) {\n                  this.assignPointer(t, e, this.postponeGesture).longPressGesture = this.ignoreGesture;\n                } else {\n                  this.assignPointer(t, e, this.nodeDragGesture).longPressGesture = this.ignoreGesture;\n                }\n              }, u.prototype.updateSelection = function (t, e) {\n                var i = this.chart.settings.interaction.selection;\n\n                if (i.enabled && (e.object instanceof o.Node && i.nodesSelectable || e.object instanceof o.Link && i.linksSelectable) && !e.object.selectionLock && !e.object.dragging) {\n                  var n = !1;\n                  if (t.shiftKey || t.ctrlKey) n = e.object.selected ? this.chart.scene.removeFromSelection(e.object) : this.chart.scene.addToSelection(e.object);else if (!e.object.selected) {\n                    var r = this.chart.scene.selection.filter(function (t) {\n                      return t.dragging || t.selectionLock;\n                    });\n                    r.push(e.object), n = this.chart.scene.setSelection(r);\n                  }\n                  n && this.chart.scene.notifySelectionChangesIfNeeded(this.chart, \"user\");\n                }\n              }, u.prototype.onPointerDown = function (t) {\n                var e = this.findObject(t);\n                this.chart.notifyPointerDown(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0), this.updateSelection(t, e), this.assignUnknownPointer(t, e);\n              }, u.prototype.onPointerUp = function (t) {\n                this.chart.notifyPointerUp(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n                var e = this.pointerMap[t.identifier];\n\n                if (e.gesture.removePointer(t), delete this.pointerMap[t.identifier], e.gesture === this.twoFingerGesture) {\n                  var i = this.twoFingerGesture.pointers[0],\n                      n = this.pointerMap[i];\n                  delete this.pointerMap[i];\n                  var r = new h.MouseEvent(n.lastX, n.lastY, t.timeStamp, i);\n                  this.twoFingerGesture.removePointer(r), this.assignPointer(r, l, this.chart.settings.interaction.panning.enabled ? this.panGesture : this.postponeGesture);\n                }\n              }, u.prototype.onPointerDrag = function (t) {\n                this.chart.notifyPointerDrag(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n                var e = this.findObject(t);\n                t.cursor = e.object && e.object.cursor || \"default\";\n                var i = this.pointerMap[t.identifier];\n                i.lastX = t.x, i.lastY = t.y, i.gesture.movePointer(t);\n              }, u.prototype.onPointerCancel = function (t) {\n                this.onPointerUp(t);\n              }, u.prototype.onInstantClick = function (t) {\n                if (!t.shiftKey && !t.ctrlKey && !this.findObject(t).object) {\n                  var e = this.chart.scene.selection.filter(function (t) {\n                    return t.dragging || t.selectionLock;\n                  });\n                  e.length !== this.chart.scene.selection.length && (this.chart.scene.setSelection(e), this.chart.scene.notifySelectionChangesIfNeeded(this.chart, \"user\"));\n                }\n              }, u.prototype.doAnimations = function (t) {\n                this.nodeDragGesture.doAnimations(t), this.multiSelectGesture.doAnimations(t);\n              }, u.prototype.paintScene = function (t) {\n                this.multiSelectGesture.paintScene(t);\n              }, u.prototype.buildClickEventArgs = function (t) {\n                var e = this.chart.createEventArguments(t, \"user\"),\n                    i = this.findObject(t);\n                e.clickItem = i.details;\n                var n = i.object;\n                return n instanceof o.Node ? (e.clickNode = n, this.autoZoomIn(t, n)) : e.clickLink = n, e;\n              }, u.prototype.updateHover = function (t, e) {\n                t.changes.current = !0, this.chart.scene.setActiveObject(e.object, e.details), this.chart.notifyHoverChanged(t, this.chart.createEventArguments(null, \"api\"));\n              }, u.prototype.autoZoomIn = function (t, e) {\n                this.chart.scene.lastClickedNode = e, this.chart.settings.interaction.zooming.autoZoomAfterClick && (this.chart.scene.autoZoomMode = !0, t.changes.zoom = !0);\n              }, u.prototype.onPointerMove = function (t) {\n                if (this.chart.notifyPointerMove(t, this.chart.createEventArguments(null, \"user\")), t.defaultPrevented && (t.consumed = !0), this.chart.scene.xyInChart(t.x, t.y)) {\n                  this.hoverPointer = t.identifier;\n                  var e = this.findObject(t);\n                  t.cursor = e.object && e.object.cursor || \"default\", e.object === (this.chart.scene.hoverLink || this.chart.scene.hoverNode) && e.details === this.chart.scene.hoverItem || this.updateHover(t, e);\n                } else this.onPointerOut(t);\n              }, u.prototype.onPointerOut = function (t) {\n                this.hoverPointer === t.identifier && (this.hoverPointer = null, this.updateHover(t, l)), this.pointerMap[t.identifier] && this.onPointerUp(t);\n              }, u.prototype.onWheel = function (t) {\n                if (this.chart.scene.xyInChart(t.x, t.y) && this.chart.settings.interaction.zooming.wheel) {\n                  var e = Math.pow(1 + this.chart.settings.interaction.zooming.sensitivity, .004 * t.wheely);\n                  this.chart.autoZoom.manualZoom(e, t.x, t.y), t.consumed = !0, t.changes.position = !0;\n                }\n              }, u.prototype.onClick = function (t) {\n                this.chart.notifyClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n              }, u.prototype.onRightClick = function (t) {\n                this.chart.scene.xyInChart(t.x, t.y) && (this.chart.notifyRightClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n              }, u.prototype.onLongPress = function (t) {\n                if (this.chart.scene.xyInChart(t.x, t.y)) {\n                  var e = this.pointerMap[t.identifier];\n                  e && (e.longPressGesture && (e.longPressGesture === this.multiSelectGesture && this.multiSelectGesture.pointers.length > 0 && (e.longPressGesture = this.ignoreGesture), this.assignPointer(t, l, e.longPressGesture), e.longPressGesture = null), t.consumed = e.gesture !== this.ignoreGesture);\n                }\n              }, u.prototype.onDoubleClick = function (t) {\n                if (this.chart.scene.xyInChart(t.x, t.y)) if (this.chart.notifyDoubleClick(t, this.buildClickEventArgs(t)), t.defaultPrevented) t.consumed = !0;else {\n                  var e = this.chart.settings.interaction.zooming.doubleClickZoom;\n                  e && this.chart.settings.interaction.zooming.zoomInOnDoubleClick && (this.chart.autoZoom.manualZoom(e, t.x, t.y), t.changes.position = !0, t.consumed = !0);\n                }\n              }, u;\n            }(h.ChartElement);\n\n            t.GestureManager = u;\n          }(e = t.Gestures || (t.Gestures = {}));\n\n          var E = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e.prototype.showHide = function (t, e) {\n              t.style.display = e ? \"\" : \"none\";\n            }, e.prototype.btnExpand = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-expand\", this.scene.settings.localization.menu.expand, this.scene.settings.localization.menu.expand, null, function (t, i) {\n                e.chart.expandNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canExpandNode(t));\n              });\n            }, e.prototype.btnCollapse = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-collapse\", this.scene.settings.localization.menu.collapse, this.scene.settings.localization.menu.collapse, null, function (t, i) {\n                e.chart.collapseNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canCollapseNode(t));\n              });\n            }, e.prototype.btnClose = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-collapse\", this.scene.settings.localization.menu.close, this.scene.settings.localization.menu.close, null, function (t, i) {\n                e.chart.closeNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canCloseNode(t));\n              });\n            }, e.prototype.btnFocus = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-focus\", this.scene.settings.localization.menu.focus, this.scene.settings.localization.menu.focus, null, function (t, i) {\n                e.chart.addFocusNode(t.id, -1);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canFocusNode(t));\n              });\n            }, e.prototype.btnUnfocus = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-unfocus\", this.scene.settings.localization.menu.unfocus, this.scene.settings.localization.menu.unfocus, null, function (t, i) {\n                e.chart.removeFocusNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canUnfocusNode(t));\n              });\n            }, e.prototype.btnLock = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-lock\", this.scene.settings.localization.menu.fixed, this.scene.settings.localization.menu.fixed, null, function (t, i) {\n                e.chart.unlockNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, t.userLock);\n              });\n            }, e.prototype.btnUnlock = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-unlock\", this.scene.settings.localization.menu.dynamic, this.scene.settings.localization.menu.dynamic, null, function (t, i) {\n                e.chart.lockNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, !t.userLock);\n              });\n            }, e.prototype.btnHide = function (t) {\n              var e = this;\n              this.buildButton(t, \"DVSL-NC-button-hide\", this.scene.settings.localization.menu.hide, this.scene.settings.localization.menu.hide, null, function (t, i) {\n                e.chart.hideNode(t.id);\n              }, function (t, i) {\n                e.showHide(i, e.chart.navigator.canHideNode(t));\n              });\n            }, e.prototype.buildDefaultButton = function (t, e) {\n              if (t instanceof o.Node) switch (e) {\n                case \"btn:expand\":\n                  this.btnExpand(t);\n                  break;\n\n                case \"btn:collapse\":\n                  this.btnCollapse(t);\n                  break;\n\n                case \"btn:close\":\n                  this.btnClose(t);\n                  break;\n\n                case \"btn:focus\":\n                  this.btnFocus(t);\n                  break;\n\n                case \"btn:unfocus\":\n                  this.btnUnfocus(t);\n                  break;\n\n                case \"btn:lock\":\n                  this.btnLock(t);\n                  break;\n\n                case \"btn:unlock\":\n                  this.btnUnlock(t);\n                  break;\n\n                case \"btn:hide\":\n                  this.btnHide(t);\n                  break;\n\n                case \"expand\":\n                  this.btnExpand(t), this.btnCollapse(t), this.btnClose(t);\n                  break;\n\n                case \"focus\":\n                  this.btnFocus(t), this.btnUnfocus(t);\n                  break;\n\n                case \"lock\":\n                  this.btnLock(t), this.btnUnlock(t);\n                  break;\n\n                case \"hide\":\n                  this.btnHide(t);\n                  break;\n\n                default:\n                  this.chart.error(\"The node menu button with name `\" + e + \"` was not recognized.\");\n              } else this.chart.error(\"The link menu does not support any named buttons.\");\n            }, e;\n          }(o.Menu);\n\n          t.Menu = E;\n\n          var R = function (n) {\n            function s(r, s) {\n              var a = n.call(this, new p(r), new L(), s) || this;\n              a.isLayoutFrozen = !1, a.focusNodeStack = [];\n              var l = \"focusnodes\" === a.settings.navigation.mode && a.settings.navigation.focusAutoFadeout;\n              return a.layer = new o.NodesLayer(a, a.settings, l), a.graph = new M(a), a.navigator = a.events.addElement(P.CreateNavigator(a)), a.gestures = a.events.addElement(new e.GestureManager(a)), a.layout = a.events.addElement(i.LayoutBase.ConstructLayout(a)), a.info = a.events.addElement(new o.InfoPopup(a)), a.menu = a.events.addElement(new t.Menu(a)), a.autoZoom = a.events.addElement(new I(a)), a.renderer = a.events.addElement(new T(a)), a.legend = a.events.addElement(new d(a)), a.autoZoom.resetZoom = !0, a.scene.loading = !1, a.navigator.showInitialNodes(), a.finalInitialize(), a;\n            }\n\n            return r(s, n), s.prototype.createDataObj = function (t) {\n              return new A(this, t);\n            }, s.prototype.getData = function (t) {\n              return n.prototype.getData.call(this, t);\n            }, s.prototype.onSettingsChanged = function (t) {\n              var e = {};\n              this.layer.onSettingsChanged(t), t.navigation && t.navigation.mode && (this.events.removeElement(this.navigator), this.navigator = P.CreateNavigator(this), this.events.addElement(this.navigator));\n              var n = !(!t.navigation || !t.navigation.mode && !t.navigation.initialNodes);\n\n              if (t.data && t.data.length) {\n                var r = t.data[0];\n                (r.dataFunction || r.format || r.preloaded || r.url || r.randomNodes) && (n = !0);\n              }\n\n              n && (this.navigator.showInitialNodes(), this.autoZoom.resetZoom = !0), t.filters && (e.filters = !0), t.style && (e.style = !0), t.layout && t.layout.mode && (this.events.removeElement(this.layout), this.layout = i.LayoutBase.ConstructLayout(this), this.events.addElement(this.layout), this.isLayoutFrozen = !1), this.events.notifySceneChanges(e);\n            }, s.prototype.save = function () {\n              var t = this.graph.save(),\n                  e = this.navigator.save();\n              return JSON.stringify({\n                xy: t,\n                nav: e\n              });\n            }, s.prototype.restore = function (t, e) {\n              if (t) {\n                var i = JSON.parse(t),\n                    n = i.xy,\n                    r = i.nav;\n                r && this.navigator.restore(r), n && this.graph.restore(n), this.autoZoom.resetZoom = !0;\n              }\n            }, s.prototype.saveNavigation = function () {\n              var t = JSON.stringify(this.navigator.save());\n              return \"{}\" === t ? null : t;\n            }, s.prototype.restoreNavigation = function (t) {\n              this.navigator.restore(JSON.parse(t));\n            }, s.prototype.getCurrentNodes = function () {\n              for (var t = [], e = 0, i = this.layer.nodes(); e < i.length; e++) {\n                var n = i[e];\n                n.removed || t.push(n);\n              }\n\n              return t;\n            }, s.prototype.getCurrentLinks = function () {\n              for (var t = [], e = 0, i = this.layer.links(); e < i.length; e++) {\n                var n = i[e];\n                n.removed || t.push(n);\n              }\n\n              return t;\n            }, s.prototype.getNodeDimensions = function (t) {\n              var e;\n              if (!(e = h.Helpers.isString(t) ? this.getNode(t) : t)) return null;\n              var i = this.scene.toDisplay(e.x, e.y);\n              return {\n                x: i.x,\n                y: i.y,\n                radius: e.hHeight * this.scene.zoom,\n                hwidth: e.hWidth * this.scene.zoom\n              };\n            }, s.prototype.lockNode = function (t, e, i) {\n              void 0 === e && (e = null), void 0 === i && (i = null), h.Helpers.isObjectOrArray(t) && (t = t.id), this.graph.lockNode(t, e, i);\n            }, s.prototype.unlockNode = function (t) {\n              t.id && (t = t.id), this.graph.unlockNode(t);\n            }, s.prototype.addFocusNode = function (t, e) {\n              return t.id && (t = t.id), this.settings.navigation.autoZoomOnFocus && (this.scene.autoZoomMode = !0), this.focusNodeStack.push(t), this.navigator.focusNode(t, e, \"api\");\n            }, s.prototype.getLastFocusNode = function () {\n              for (; this.focusNodeStack.length > 0;) {\n                var t = this.focusNodeStack[this.focusNodeStack.length - 1];\n                if ((i = h.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null) && i.focused) return i;\n                this.focusNodeStack.pop();\n              }\n\n              if (this.settings.navigation.initialNodes) for (var e = 0; e < this.settings.navigation.initialNodes.length; e++) {\n                var i;\n                t = this.settings.navigation.initialNodes[e];\n                if (i = h.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null) return i;\n              }\n              var n = this.layer.nodes();\n              return n.length > 0 ? n[0] : null;\n            }, s.prototype.clearFocus = function () {\n              this.navigator.clearFocusNodes(\"api\");\n            }, s.prototype.removeFocusNode = function (t) {\n              return t.id && (t = t.id), this.navigator.unfocusNode(t, \"api\");\n            }, s.prototype.expandNode = function (t) {\n              return t.id && (t = t.id), this.navigator.expandNode(t, \"api\");\n            }, s.prototype.collapseNode = function (t) {\n              return t.id && (t = t.id), this.navigator.collapseNode(t, \"api\");\n            }, s.prototype.closeNode = function (t) {\n              return t.id && (t = t.id), this.navigator.closeNode(t, \"api\");\n            }, s.prototype.hideNode = function (t) {\n              return t.id && (t = t.id), this.navigator.hideNode(t, \"api\");\n            }, s.prototype.showNode = function (t) {\n              return this.navigator.showNode(t, \"api\");\n            }, s.prototype.getNode = function (t) {\n              return this.layer.idToNode[t];\n            }, s.prototype.getLink = function (t) {\n              return this.layer.idToLink[t];\n            }, s.prototype.touchObjects = function (t) {\n              for (var e = 0; e < t.length; e++) {\n                var i = this.layer,\n                    n = i.findObjectById(t[e]);\n                n && i.touchNodeOrLink(n);\n              }\n            }, s.prototype.setZoom = function (t, e) {\n              this.autoZoom.setZoom(t, e);\n            }, s.prototype.resetLayout = function () {\n              this.layout.resetLayout(), this.autoZoom.setZoom(\"overview\", !1), this.events.notifySceneChanges({\n                layout: !0\n              });\n            }, s.prototype.removeData = function (t, e) {\n              if (void 0 === e && (e = \"default\"), null == e && (e = \"default\"), !this.removed) {\n                var i = this.getData(e).removeData(t);\n                i.data = {}, i.data[e] = !0, this.events.notifySceneChanges(i);\n              }\n            }, s.prototype.exportData = function (t, e) {\n              var i;\n              return i = t ? this.graph.exportData() : this.scene.mainData.exportData(), e && this.graph.exportCoordinates(i.nodes), i;\n            }, s.prototype.hideMenu = function () {\n              this.menu.hideMenu();\n            }, s.prototype.createEventArguments = function (t, e) {\n              var i = n.prototype.createEventArguments.call(this, t, e),\n                  r = this.layer;\n              return r && (i.nodes = r.nodes(), i.links = r.links()), i;\n            }, s.prototype.defaultClick = function (t, e) {\n              if (!t.shiftKey && !t.ctrlKey) {\n                var i = e.clickNode;\n                i && this.scene.settings.navigation.expandOnClick && (i.expanded || (this.expandNode(i.id), t.preventDefault()));\n              }\n            }, s.prototype.defaultRightClick = function (t, e) {\n              e.clickNode && (this.scene.mainData.getLinks(e.clickNode.id), this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault());\n            }, s.prototype.defaultDoubleClick = function (t, e) {\n              var i = e.clickNode;\n              i && (this.addFocusNode(i.id, -1), t.preventDefault());\n            }, s.prototype.scrollIntoView = function (t, e) {\n              for (var i, n = [], r = 0; r < t.length; r++) {\n                var s = t[r];\n                s instanceof o.Node ? n.push(s) : h.Helpers.isString(s) && (i = this.getNode(s)) ? n.push(i) : this.error(\"scrollIntoView: the argument is not a node or the ID cannot be found: `\" + s + \"`.\");\n              }\n\n              this.autoZoom.scrollIntoView(n, e);\n            }, s.prototype.freezeLayout = function () {\n              this.isLayoutFrozen || (this.events.removeElement(this.layout), this.isLayoutFrozen = !0, this.events.notifySceneChanges({\n                layout: !0\n              }));\n            }, s.prototype.unfreezeLayout = function () {\n              this.isLayoutFrozen && (this.events.addElement(this.layout), this.isLayoutFrozen = !1, this.events.notifySceneChanges({\n                layout: !0\n              }));\n            }, s.prototype.remove = function () {\n              n.prototype.remove.call(this), this.info.remove(), this.menu.remove();\n            }, s;\n          }(o.Impl);\n\n          t.Impl = R;\n        }(n.NetChart || (n.NetChart = {})), function (t) {\n          t.Bar || (t.Bar = {});\n\n          var e = t.Series || (t.Series = {}),\n              i = t.Renderers || (t.Renderers = {}),\n              n = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.panel = new h.SettingsLegendPanel(\"bottom\", \"left\", void 0, 95), e.advanced = new a(), e.marker = new s(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegend);\n\n          t.SettingsLegend = n;\n\n          var s = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.shape = null, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegendMarker);\n\n          t.SettingsLegendMarker = s;\n\n          var a = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.disabledSeries = {\n                fillColor: \"rgba(191,187,185,0.3)\",\n                lineColor: \"rgba(64,62,62,0.3)\",\n                textColor: \"rgba(64,62,62,0.3)\"\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegendAdvanced);\n\n          t.SettingsLegendAdvanced = a;\n\n          var o = function (t) {\n            function e(e, i, n, r, s, a, o) {\n              var l = t.call(this, i, n, r, s) || this;\n              return l.seriesHovered = !1, l.disabledSeries = o, l.series = e, l.enabled = a, l;\n            }\n\n            return r(e, t), e.prototype.isHovered = function () {\n              return this.hoverCount > 0 || this.seriesHovered;\n            }, e;\n          }(h.LegendEntry),\n              l = function (t) {\n            function n(e) {\n              var i = t.call(this, e) || this;\n              return i.paintOrder = 75, i.updateOrder = 100, i;\n            }\n\n            return r(n, t), n.prototype.notifyHoveredSeries = function (t) {\n              for (var e = 0; e < this.entries.length; e++) {\n                var i = this.entries[e];\n                i.seriesHovered = i.series.indexOf(t) >= 0;\n              }\n            }, n.prototype.getLastHoveredSeries = function () {\n              var t = this.getLastHoveredEntry();\n              return t ? t.series[0] : null;\n            }, n.prototype.onSceneChange = function (e) {\n              t.prototype.onSceneChange.call(this, e);\n              var i = e.changes;\n              i.linearChartSeries && (this.rebuildItems(e), i.bounds = !0);\n            }, n.prototype.paintMarker = function (t, e, n, r, s) {\n              var a = t.context,\n                  o = s.isEnabled() ? s.series[0] : s.disabledSeries,\n                  l = this.settings.marker,\n                  u = o.style.legend.marker,\n                  c = u.shape || l.shape;\n\n              if (a.beginPath(), c) {\n                var d = {\n                  fillColor: u.fillColor || o.style.fillColor || o.style.lineColor,\n                  lineColor: u.lineColor || l.lineColor,\n                  lineWidth: u.lineWidth || 1\n                };\n                null != u.width && (r = u.width / 2), h.Graphics.strokeMarker(a, c, e, n, r), h.Graphics.paint(a, d);\n              } else {\n                var p = l.size,\n                    f = e - p / 2,\n                    g = e,\n                    m = e + p / 2,\n                    v = p / 2.1,\n                    y = p / 2,\n                    S = 3 * p / 4,\n                    w = n + p / 2;\n\n                if (o instanceof C) {\n                  var L = o.style.marker.width;\n                  o.style.marker.width *= .8;\n                  var T = [[v, y, S]],\n                      k = [f, g, m],\n                      A = [k, [w - v, w - y, w - S]],\n                      M = w - y,\n                      I = new i.Line(null, [o]);\n                  I.paintLines(a, [o], [{\n                    markerY: null,\n                    segments: A\n                  }], k, [null], T, w), I.paintMarkers(a, o, [g], [y], [M]), o.style.marker.width = L;\n                } else if (o instanceof b) {\n                  T = [p, p];\n                  new i.Columns(this.chart.scene, [o]).paintStack(t, [e], [p / 2], [T], [null], w);\n                } else if (o instanceof x) {\n                  var P = [[0], [p / 3], [2 * p / 3], [p]];\n                  new i.Candlestick(this.chart.scene, [o]).paintStack(t, [e], [p / 2], P, [null], w);\n                }\n              }\n            }, n.prototype.rebuildItems = function (t) {\n              for (var i = [], n = this.chart.scene.settings._computedSeries, r = this.settings.advanced.disabledSeries, s = {}, a = this.settings.text.fillColor, l = 0; l < n.length; l++) {\n                var u = n[l];\n\n                if (u.showInLegend) {\n                  var c = void 0;\n\n                  if (u instanceof x) {\n                    if (h.Helpers.hasProperty(s, u.stack)) {\n                      s[u.stack].push(u);\n                      continue;\n                    }\n\n                    c = [u], s[u.stack] = c;\n                  } else c = [u];\n\n                  var d = u.nameLegend || u.name || this.chart.settings.localization.unnamedSeries,\n                      p = h.Helpers.realClone(u),\n                      f = p.style;\n                  f.fillColor = f._currentFillStyle = f.fillColor && r.fillColor, f._currentFillStyleKey = null, f.fillPattern && (f._fillPatternOpacity = .3, e.Stack.computeFillPattern(this.chart, t.context, f)), f.lineColor = r.lineColor;\n                  var g = f.legend.marker;\n                  g.fillColor = g.fillColor && r.fillColor, g.lineColor = g.lineColor && r.lineColor, i.push(new o(c, d, u.style.legend.textColor || a, r.textColor, u.legendGroupId, u.enabled, p));\n                }\n              }\n\n              this.resetEntries(i);\n            }, n.prototype.itemClicked = function (e, i) {\n              t.prototype.itemClicked.call(this, e, i);\n\n              for (var n = 0; n < this.entries.length; n++) {\n                for (var r = this.entries[n], s = 0; s < r.series.length; s++) {\n                  r.series[s].enabled = r.enabled;\n                }\n              }\n\n              this.chart.events.notifySceneChanges({\n                linearChartSeries: !0\n              });\n            }, n;\n          }(h.Legend);\n\n          t.Legend = l;\n\n          var u = function () {\n            return function () {\n              this.enabled = !0, this.animate = \"auto\", this.initialAnimationValue = null, this.initialAnimationValueMultiplier = 4.5, this.logScale = !1, this.position = \"outside\", this.side = \"left\", this.title = null, this.minValue = null, this.maxValue = null, this.size = null, this.hgrid = null, this.axisLine = !1, this.scaleAdjustmentTolerance = .3, this.scaleAdjustmentAnimationDelay = 200, this.scaleAdjustmentAnimation = \"=\", this.scaleStep = null, this.scaleMinStep = 0, this.zeroLine = \"visible\", this.valueFormatterFunction = null, this.style = {\n                title: {\n                  textStyle: {\n                    fillColor: \"#000000\",\n                    font: \"13px Arial\"\n                  },\n                  reverseDirection: !1,\n                  align: \"center\",\n                  margin: 5\n                },\n                tick: {\n                  lineColor: \"#AAAAAA\"\n                },\n                axisLine: {\n                  lineColor: \"rgba(127,127,127,0.5)\",\n                  lineWidth: 1\n                },\n                valueLabel: {\n                  textStyle: {\n                    fillColor: \"#000000\",\n                    font: \"11px Arial\"\n                  },\n                  margin: 0\n                },\n                labelSpacing: 25,\n                baseLine: {\n                  lineColor: \"rgba(127,127,127,0.5)\",\n                  depthColor: \"rgba(127,127,127,0.5)\",\n                  lineWidth: 1,\n                  lineDepth: 0,\n                  showLabel: 1\n                },\n                hgrid: {\n                  lineColor: \"rgba(255,255,255,0.2)\"\n                }\n              }, this.thresholds = [];\n            };\n          }();\n\n          t.SettingsValueAxis = u;\n\n          var c = function () {\n            return function () {\n              this.from = -1 / 0, this.to = 1 / 0, this.position = \"under\", this.style = {\n                fillColor: \"rgba(255,133,152,0.2)\",\n                lineColor: \"rgba(255,0,0,0.5)\",\n                lineWidth: 1,\n                lineDash: null\n              };\n            };\n          }();\n\n          t.SettingsValueAxisThreshold = c;\n\n          var d = function () {\n            function t(t, e) {\n              var i = this;\n              this.locations = [], this.values = [], this.labels = [], this.title = null, this.cachedUnits = {\n                lin: [],\n                log: []\n              }, this.isPrimary = !1, this._chart = t, this.options = e, this.events = t.events, this.scene = t.scene, this.isLogScale = this.options.logScale, this.isInside = \"inside\" === this.options.position, this.panel = new h.ChartPanel(), this.panel.packingOrder = 110, this.panel.computeSize = function (t, e, n, r) {\n                return i.computePanelSize(t, e, n, r);\n              }, this.lastMaxValue = 0, this.lastMinValue = 0, this.minValue = 0, this.maxValue = 0, this.scale = 0, this.zeroY = 0, this.logOffset = 1, this.minValueAnimation = null, this.maxValueAnimation = null, this.axisChanged = !1, this.seriesDepth = 0, this.seriesMinValue = null, this.seriesMaxValue = null, this.series = 0, this.createTitle();\n            }\n\n            return t.prototype.createTitle = function () {\n              var t = this.options,\n                  e = t.style.title,\n                  i = this.title = new h.Label(e);\n              i.text = t.title, i.allowCache = !1;\n              var n = i.style.angle;\n              null == n && (n = \"right\" === t.side ? 90 : -90), e.reverseDirection && (n = -n), i.style.angle = n;\n            }, t.prototype.getPanel = function () {\n              var t = this.options;\n              return t.enabled ? (this.panel.location = t.position, this.panel.side = t.side, this.panel) : null;\n            }, t.prototype.setPanel = function (t) {\n              null != t && (this.panel = t);\n            }, t.prototype.computePanelSize = function (t, e, i, n) {\n              if (!this._chart.assetsLoaded) return {\n                width: 0,\n                height: 0\n              };\n              var r = 8,\n                  s = this.title;\n              s && (s.style.maxWidth = e);\n              var a = this.options;\n              if (a.size) r = a.size;else {\n                var o = a.style.valueLabel,\n                    l = \"9999 M\";\n                a.valueFormatterFunction ? l = a.valueFormatterFunction(1e7 - 1 - 2e-4, \"M\", 1e6, l) || l : r++, r += 2 * o.margin + h.Graphics.getTextWidth(i, o.textStyle, l), s && s.text && (n.measure(i, s), r += 2 * (s.style.margin + s.hheight));\n              }\n              return {\n                width: Math.ceil(r),\n                height: e\n              };\n            }, t.prototype.receiveSeriesGeometry = function (t, e, i) {\n              null !== this.options.minValue ? this.seriesMinValue = this.options.minValue : void 0 !== t && (null !== this.seriesMinValue ? this.seriesMinValue = Math.min(t, this.seriesMinValue) : this.seriesMinValue = t), null !== this.options.maxValue ? this.seriesMaxValue = this.options.maxValue : void 0 !== e && (null !== this.seriesMaxValue ? this.seriesMaxValue = Math.max(e, this.seriesMaxValue) : this.seriesMaxValue = e), this.seriesDepth = Math.max(i, this.seriesDepth);\n            }, t.prototype.updateMinMax = function (t) {\n              var e,\n                  i,\n                  n = t.changes,\n                  r = n.bounds || n.assets || 0 === this.locations.length;\n\n              if (n.settings && (this.isLogScale = this.options.logScale, this.isInside = \"inside\" === this.options.position, r = !0), this.shouldChangeScale() && (this.seriesMinValue !== this.lastMinValue && (r = !0, \"always\" === this.options.animate || null !== this.lastMinValue && !n.displayUnit && this.minValue !== this.maxValue ? this.minValueAnimation ? this.minValueAnimation.retarget(this.seriesMinValue, t.timeStamp) : this.minValueAnimation = new h.Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp) : this.minValueAnimation = null, this.lastMinValue = this.seriesMinValue), this.seriesMaxValue !== this.lastMaxValue)) {\n                if (r = !0, \"always\" === this.options.animate || null !== this.lastMaxValue && !n.displayUnit && this.minValue !== this.maxValue) {\n                  if (this.maxValueAnimation) this.maxValueAnimation.retarget(this.seriesMaxValue, t.timeStamp);else {\n                    var s = this.lastMaxValue;\n                    this.lastMaxValue || (null !== this.options.initialAnimationValue ? s = this.options.initialAnimationValue : this.seriesMaxValue && (s = this.seriesMaxValue * this.options.initialAnimationValueMultiplier)), this.maxValueAnimation = new h.Animator(s, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp);\n                  }\n                } else this.maxValueAnimation = null;\n                this.lastMaxValue = this.seriesMaxValue;\n              }\n\n              this.seriesMaxValue = this.options.minValue, this.seriesMinValue = this.options.maxValue, this.minValueAnimation ? (r = !0, e = this.minValueAnimation.get(t.timeStamp), this.minValueAnimation.finished(t.timeStamp) && (this.minValueAnimation = null)) : e = this.lastMinValue, this.maxValueAnimation ? (r = !0, i = this.maxValueAnimation.get(t.timeStamp), this.maxValueAnimation.finished(t.timeStamp) && (this.maxValueAnimation = null)) : i = this.lastMaxValue, this.axisChanged = r, r && this.computeNewScale(e, i), (this.minValueAnimation || this.maxValueAnimation) && (t.animating = !0);\n            }, t.prototype.doAnimations = function (t) {\n              if (this.axisChanged && this._chart.assetsLoaded) {\n                this.axisChanged = !1;\n                var e = this.options;\n\n                if (e.enabled) {\n                  this.locations = [], this.values = [];\n                  var i,\n                      n = \"right\" === e.side,\n                      r = this.scene.y0,\n                      s = r + this.scene.height;\n\n                  if (this.scale <= 0) {\n                    i = e.scaleStep ? e.scaleStep : 100;\n                    var a = e.style.labelSpacing,\n                        o = s - a,\n                        l = 1;\n\n                    for (e.logScale || (l = i); o > r;) {\n                      this.locations.push(o), this.values.push(l), e.logScale ? l *= 10 : l += i, o -= a;\n                    }\n                  } else {\n                    if (this.fontHeight || (this.fontHeight = 1.4 * h.Graphics.getTextHeight(t.context, e.style.valueLabel.textStyle.font) || 0), 0 === r && (r += this.fontHeight / 2), this.scene.bottomAxisSize < this.fontHeight && (s -= this.fontHeight / 2), this.isLogScale) {\n                      for (var u = this.calcExpValuePerLine(), c = u.unit, d = u.valueMultiplier, p = 1 / c;;) {\n                        if (p *= d, (f = this.zeroY - this.valueToRelativeY(p)) <= r) break;\n                        f >= s || (this.locations.push((0 | f) - .5), this.values.push(p));\n                      }\n\n                      for (p = -1 / c;;) {\n                        if (p *= d, (f = this.zeroY - this.valueToRelativeY(p)) >= s) break;\n                        this.locations.push((0 | f) - .5), this.values.push(p);\n                      }\n                    } else {\n                      i = this.calcLinearValuePerLine();\n                      p = 0;\n\n                      for (e.scaleStep && (i = Math.max(i, this.fontHeight / this.scale));;) {\n                        if (p += i, (f = this.zeroY - this.valueToRelativeY(p)) <= r) break;\n                        f >= s || (this.locations.push(0 | f), this.values.push(p));\n                      }\n\n                      for (p = 0;;) {\n                        var f;\n                        if (p -= i, (f = this.zeroY - this.valueToRelativeY(p)) >= s) break;\n                        this.locations.push(0 | f), this.values.push(p);\n                      }\n                    }\n\n                    var g = this.minValue,\n                        m = this.maxValue;\n\n                    if (g <= 0 && m >= 0) {\n                      var v = e.style.baseLine.showLabel;\n                      (2 === v || 1 === v && (g < 0 || !this.isInside && 0 === g)) && (this.locations.push(0 | this.zeroY), this.values.push(0));\n                    }\n                  }\n\n                  var y,\n                      S,\n                      b,\n                      C = e.valueFormatterFunction;\n                  if (!this.isLogScale) y = (L = this.getUnitAndName(i, this.scene.settings)).unit, S = L.digitsAfterComma, b = L.name;\n\n                  for (var x = 0; x < this.values.length; x++) {\n                    p = this.values[x];\n                    if (this.isLogScale) y = (L = this.getUnitAndName(p, this.scene.settings)).unit, S = L.digitsAfterComma, b = L.name;\n                    var w = (p / y).toFixed(S);\n\n                    if (p && (w = w + \" \" + b), C && (w = C(p, b, y, w)), !C && e.valueFormat) {\n                      var L,\n                          T = h.Helpers.matchPercentFormat(e.valueFormat),\n                          k = h.Helpers.matchCurrencyFormat(e.valueFormat);\n                      if (T) y = (L = this.getUnitAndName(100 * p, this.scene.settings)).unit, b = L.name, w = h.Helpers.printPercentValue(p / y, T, b);else y = (L = this.getUnitAndName(p, this.scene.settings)).unit, b = L.name, w = h.Helpers.printCurrencyValue(p / y, k, b);\n                    }\n\n                    var A = new h.Label(e.style.valueLabel);\n                    A.text = w.toString(), this.isInside || (A.style.align = n ? \"left\" : \"right\"), this.labels[x] = A;\n                  }\n                }\n              }\n            }, t.prototype.paintUnder = function (t) {\n              var e = this.options;\n\n              if (e.enabled) {\n                var i = t.context;\n                if (e.thresholds) for (var n = 0; n < e.thresholds.length; n++) {\n                  var r = e.thresholds[n];\n                  \"under\" === r.position && this.paintThreshold(i, r);\n                }\n                this.paintZeroLineDepth(i);\n              }\n            }, t.prototype.paint = function (t) {\n              var e = this.options;\n\n              if (e.enabled) {\n                var i = t.context;\n                if (e.thresholds) for (var n = 0; n < e.thresholds.length; n++) {\n                  var r = e.thresholds[n];\n                  \"above\" === r.position && this.paintThreshold(i, r);\n                }\n\n                if (this.locations.length > 0 && (this.paintGrid(i), this.paintZeroLine(i), this.paintLabels(i, t.labelRenderer)), e.axisLine) {\n                  var s = h.Graphics.beginStrokeAndFill(i, e.style.axisLine);\n                  this.paintAxisLine(s), h.Graphics.endStrokeAndFill(i, s, e.style.axisLine);\n                }\n              }\n            }, t.prototype.shouldChangeScale = function () {\n              var t = this.seriesMinValue,\n                  e = this.seriesMaxValue;\n              if (null === t || null === e) return !1;\n              if (null === this.lastMinValue || null === this.lastMaxValue || !(this.lastMinValue < this.lastMaxValue)) return !0;\n              if (\"center\" === this.options.zeroLine ? t = -(e = Math.max(e, -t)) : \"visible\" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), t < this.minValue || e > this.maxValue) return !0;\n              var i = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;\n              return t > this.lastMinValue + i || e < this.lastMaxValue - i;\n            }, t.prototype.computeNewScale = function (t, e) {\n              var i = this.scene.height,\n                  n = this.scene.y0;\n              if (\"center\" === this.options.zeroLine ? t = -(e = Math.max(e, -t)) : \"visible\" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), null !== this.options.minValue && (t = this.options.minValue), null !== this.options.maxValue && (e = this.options.maxValue), !(i > 0 && t < e)) return this.minValue = 0, this.maxValue = 0, this.logOffset = 1, this.scale = 0, void (this.zeroY = n + i);\n              var r = 0;\n              this.options.scaleStep > 0 ? r = this.options.scaleStep : this.options.scaleMinStep > 0 && (r = this.options.scaleMinStep), r > 0 && (t < 0 && (t = Math.floor(t / r) * r), e > 0 && (e = Math.ceil(e / r) * r));\n              var s,\n                  a = e - t;\n              if (this.isLogScale) t = h.Helpers.sign(t) * Math.pow(Math.abs(t), 1 - h.Helpers.sign(t) * this.options.scaleAdjustmentTolerance);else {\n                var o = t - a * this.options.scaleAdjustmentTolerance;\n                t > 0 ? t = Math.max(0, o) : t < 0 && (t = Math.min(0, o));\n              }\n              if (this.isLogScale) e = h.Helpers.sign(e) * Math.pow(Math.abs(e), 1 + h.Helpers.sign(e) * this.options.scaleAdjustmentTolerance);else {\n                var l = e + a * this.options.scaleAdjustmentTolerance;\n                e > 0 ? e = Math.max(0, l) : e < 0 && (e = Math.min(0, l));\n              }\n              null !== this.options.minValue && (t = this.options.minValue), null !== this.options.maxValue && (e = this.options.maxValue), this.minValue = t, this.maxValue = e, this.isLogScale ? t <= 0 && e >= 0 ? (this.logOffset = 1, s = Math.log(e + this.logOffset) + Math.log(-t + this.logOffset)) : t < 0 ? (this.logOffset = 1 - t, s = Math.log(-t + this.logOffset)) : e > 0 && (this.logOffset = 1 + e, s = Math.log(e + this.logOffset)) : s = e - t, this.scale = i / s;\n              var u = this.valueToRelativeY(t);\n              this.zeroY = n + i + u;\n            }, t.prototype.valueToRelativeY = function (t) {\n              return this.isLogScale ? t > 0 ? this.scale * Math.log(t + this.logOffset) : t < 0 ? -this.scale * Math.log(-t + this.logOffset) : 0 : this.scale * t;\n            }, t.prototype.calcLinearValuePerLine = function () {\n              if (this.options.scaleStep) return this.options.scaleStep;\n              var t = this.options.style.labelSpacing / this.scale,\n                  e = Math.log(t) / Math.log(10),\n                  i = Math.pow(10, Math.floor(e - 1));\n\n              for (i = Math.max(i, this.options.scaleMinStep); i < t;) {\n                if (2 * i >= t) return 2 * i;\n                if (i > 10 && 2.5 * i >= t) return 2.5 * i;\n                if (5 * i >= t) return 5 * i;\n                i *= 10;\n              }\n\n              return i;\n            }, t.prototype.calcExpValuePerLine = function () {\n              var t = this.valueToRelativeY(10) - this.valueToRelativeY(1),\n                  e = 10,\n                  i = t;\n              if (i > 4 * this.options.style.labelSpacing) return {\n                unit: 2,\n                valueMultiplier: 2\n              };\n\n              for (; i < this.options.style.labelSpacing;) {\n                e *= 10, i += t;\n              }\n\n              return {\n                unit: 10,\n                valueMultiplier: e\n              };\n            }, t.prototype.getUnitAndName = function (t, e) {\n              t = Math.abs(t);\n              var i = this.isLogScale ? this.cachedUnits.log : this.cachedUnits.lin,\n                  n = 1,\n                  r = \"\";\n              if (i[t]) return i[t];\n\n              for (var s in e.localization.valueUnits) {\n                var a = e.localization.valueUnits[s],\n                    o = Math.abs(t / a);\n                if (this.isLogScale) t === Math.round(t / a) * a && n < a && (n = a, r = s);else if (o < 1e3 && o >= 1) {\n                  n = a, r = s;\n                  break;\n                }\n              }\n\n              var l = 0;\n              if (t > 0) for (var h = 1; t < h;) {\n                l += 1, h /= 10;\n              }\n              return i[t] = {\n                unit: n,\n                digitsAfterComma: l,\n                name: r\n              };\n            }, t.prototype.paintGrid = function (t) {\n              if (!1 !== this.options.hgrid && (null != this.options.hgrid || this.isPrimary)) {\n                var e = this.options.style.hgrid.lineColor;\n                this.options.style.hgrid.lineWidth = 1, h.Graphics.clearShadow(t);\n\n                for (var i = h.Graphics.beginStrokeAndFill(t, this.options.style.hgrid), n = this.scene.x0, r = this.scene.x0 + this.scene.width, s = 0; s < this.locations.length; s++) {\n                  var a = this.locations[s];\n                  0 !== this.values[s] && (i.moveTo(n, a + .5), i.lineTo(r, a + .5));\n                }\n\n                h.Graphics.endStrokeAndFill(t, i, this.options.style.hgrid);\n                var o = h.Colors.colorTone(e, .5, .5);\n\n                if (o.opacity < .3) {\n                  this.options.style.hgrid.lineColor = o.color, i = h.Graphics.beginStrokeAndFill(t, this.options.style.hgrid);\n\n                  for (s = 0; s < this.locations.length; s++) {\n                    a = this.locations[s];\n                    0 !== this.values[s] && (i.moveTo(n, a - .5), i.lineTo(r, a - .5));\n                  }\n\n                  h.Graphics.endStrokeAndFill(t, i, this.options.style.hgrid), this.options.style.hgrid.lineColor = e;\n                }\n              }\n            }, t.prototype.paintAxisLine = function (t) {\n              var e,\n                  i = this.options.side,\n                  n = this.panel.left,\n                  r = this.panel.right,\n                  s = this.scene.y0 + this.scene.height;\n              this.isInside ? (\"right\" === i && (e = n), \"left\" === i && (e = r)) : e = \"right\" === i ? n - .5 : r + .5, t.moveTo(e, this.scene.y0), t.lineTo(e, s);\n            }, t.prototype.paintZeroLineDepth = function (t) {\n              if (!(this.zeroY > this.scene.chartHeight)) {\n                var e = this.options.style.baseLine,\n                    i = Math.max(e.lineDepth, this.seriesDepth);\n\n                if (i > 0) {\n                  var n = h.Graphics.beginStroke(t, this.options.style.baseLine),\n                      r = this.scene.x0,\n                      s = r + this.scene.width,\n                      a = Math.round(this.zeroY) - .5 * (e.lineWidth || 1);\n                  n.moveTo(r, a), n.lineTo(r + i, a - i), n.lineTo(s, a - i), n.lineTo(s, a), t.fillStyle = e.depthColor, t.fill(), h.Graphics.endStroke(t, n, e);\n                }\n              }\n            }, t.prototype.paintZeroLine = function (t) {\n              if (!(this.zeroY > this.scene.chartHeight)) {\n                var e = this.options.style.baseLine,\n                    i = this.scene.x0,\n                    n = i + this.scene.width,\n                    r = Math.round(this.zeroY) - .5 * (e.lineWidth || 1),\n                    s = h.Graphics.beginStroke(t, e);\n                s.moveTo(i, r), s.lineTo(n, r), h.Graphics.endStroke(t, s, e);\n              }\n            }, t.prototype.paintThreshold = function (t, e) {\n              if (0 !== this.scale) {\n                var i = this.scene.x0,\n                    n = this.scene.x0 + this.scene.width,\n                    r = this.scene.y0,\n                    s = r + this.scene.height,\n                    a = this.zeroY - this.valueToRelativeY(e.from),\n                    o = this.zeroY - this.valueToRelativeY(e.to);\n                a = a >= s - .5 ? .5 + (0 | s) : (this.zeroY - this.valueToRelativeY(e.from) | 0) - .5, o = o <= r - .5 ? .5 + (0 | r) : (this.zeroY - this.valueToRelativeY(e.to) | 0) - .5, e.style.fillColor && (t.fillStyle = e.style.fillColor, t.beginPath(), t.rect(i, o, this.scene.width, a - o), t.fill(), t.closePath());\n                var l = h.Graphics.beginStroke(t, e.style);\n                a - .5 !== s && (l.moveTo(i, a), l.lineTo(n, a)), o - .5 !== r && (l.moveTo(i, o), l.lineTo(n, o)), h.Graphics.endStroke(t, l, e.style);\n              }\n            }, t.prototype.paintLabels = function (t, e) {\n              if (this._chart.assetsLoaded) {\n                var i = this.scene,\n                    n = this.panel.left,\n                    r = this.panel.right,\n                    s = \"right\" === this.options.side,\n                    a = this.title;\n\n                if (this.options.title && a) {\n                  var o = i.y0,\n                      l = i.height,\n                      u = a.hheight,\n                      c = a.style.margin || 0,\n                      d = o + .5 * l,\n                      p = void 0;\n                  s ? (p = r - c - u, r -= u + 2 * c) : (p = n + c + u, n += u + 2 * c), e.paint(t, p, d, 1, a);\n                }\n\n                var f,\n                    g = (n + r) / 2;\n\n                if (f = s ? n : r - 4, !this.isInside) {\n                  t.beginPath();\n\n                  for (var m = 0; m < this.locations.length; m++) {\n                    var v = this.locations[m];\n                    t.moveTo(f, v), t.lineTo(f + 4, v);\n                  }\n\n                  h.Graphics.stroke(t, this.options.style.tick);\n                }\n\n                for (var y = 0; y < this.locations.length; y++) {\n                  var S = this.locations[y],\n                      b = this.labels[y],\n                      C = void 0;\n                  e.measure(t, b), C = this.isInside ? g : s ? f + b.hwidth + 7 : f - b.hwidth - 3, C = Math.min(C, i.chartLeft + i.chartWidth - b.hwidth), C = Math.max(C, i.chartLeft + b.hwidth), e.paint(t, C, S, 1, b);\n                }\n              }\n            }, t;\n          }();\n\n          t.ValueAxis = d, function (t) {\n            var e = function () {\n              function t(t, e) {\n                this.series = e, this.scene = t, this.prevy = [];\n              }\n\n              return t.prototype.paintStack = function (t, e, i, n, r, s, a) {\n                if (this.zeroY = s, e.length > 0) {\n                  var o = this.series,\n                      l = this.prevy;\n                  l.length < e.length && (l = this.prevy = new Array(e.length));\n\n                  for (var h = 0; h <= e.length - 1; h++) {\n                    l[h] = s;\n                  }\n\n                  for (var u = 0; u < o.length; u++) {\n                    var c = o[u],\n                        d = r[u],\n                        p = a && a.length ? a[u] : null;\n                    this.plainColumns(t, c.style, e, i, l, n, d, u, p);\n                  }\n                }\n              }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n                if (!(t.length > 1)) return {\n                  result: null,\n                  distance: 1 / 0\n                };\n                var l = this.series,\n                    u = h.Helpers.binSearch(t, s),\n                    c = t[u] - e[u],\n                    d = t[u] + e[u];\n\n                if (c > s && u > 0) {\n                  var p = t[u - 1] - e[u - 1],\n                      f = t[u - 1] + e[u - 1];\n                  (f > s || Math.abs(f - s) < Math.abs(c - s)) && (u -= 1, c = p, d = f);\n                }\n\n                for (var g = null, m = 1 / 0, v = r, y = 0; y < l.length; y++) {\n                  var S = i[y][u];\n\n                  if (h.Helpers.isNumber(S)) {\n                    var b = v - S,\n                        C = Math.min(v, b),\n                        x = Math.max(v, b),\n                        w = h.Geometry.distanceToRect(s, a, c, C, d, x);\n                    w < m && (m = w, g = {\n                      x0: c,\n                      y0: C,\n                      x1: d,\n                      y1: x,\n                      seriesIndex: y,\n                      isMarker: !1\n                    }), v = b;\n                  }\n                }\n\n                return {\n                  result: g,\n                  distance: m\n                };\n              }, t.prototype.plainColumns = function (t, e, i, n, r, s, a, o, l) {\n                for (var u, c, d, p, f, g = t.context, m = this.scene.y0, v = this.scene.height, y = e.minHeight, S = m + v, b = s[o], C = null, x = 0; x < i.length; x++) {\n                  var w = i[x],\n                      L = b[x];\n\n                  if (h.Helpers.isNumber(L)) {\n                    var T = n[x],\n                        k = r[x],\n                        A = k - L;\n                    r[x] = A;\n                    var M = w - T,\n                        I = T + T,\n                        P = void 0,\n                        D = void 0,\n                        N = void 0,\n                        F = !0;\n\n                    if (k < A) {\n                      F = !1, P = Math.max(A - k, y), D = k;\n\n                      for (var O = !0, E = o - 1; E > 0;) {\n                        if (null !== s[E][x]) {\n                          O = !1;\n                          break;\n                        }\n\n                        E--;\n                      }\n\n                      N = O;\n                    } else {\n                      if (!(k > A)) continue;\n                      D = k - (P = Math.max(k - A, y));\n                      var R = !0;\n\n                      for (E = o + 1; E < s.length;) {\n                        if (null !== s[E][x]) {\n                          R = !1;\n                          break;\n                        }\n\n                        E++;\n                      }\n\n                      N = R;\n                    }\n\n                    var H = a && a[x] || e;\n\n                    if (C !== H) {\n                      f = (C = H).lineColor ? C.lineWidth : 0, c = C.shadowColor, u = C.depth, d = C._currentFillStyle;\n                      var B = C.gradient,\n                          z = h.Helpers.isString(d);\n\n                      if (z && u ? (p = C.fillColor, h.Helpers.isNumber(C.depthBrightness) && (p = h.Colors.derive(p, C.depthBrightness, 1))) : p = null, B && 1 !== B && z) {\n                        var U = g.createLinearGradient(0, S, 0, S - 2 * v / 3);\n                        U.addColorStop(0, h.Colors.derive(d, B, 1)), U.addColorStop(1, d), d = U;\n                      }\n\n                      g.fillStyle = d;\n                    }\n\n                    if (e.fillGradientMode) {\n                      var G = null,\n                          j = e.fillGradient ? e.fillGradient : [];\n\n                      if (\"horizontal\" === e.fillGradientMode && I > 2 ? G = g.createLinearGradient(w - I / 2, 0, w + I / 2, 0) : \"vertical\" === e.fillGradientMode && P > 2 && (G = g.createLinearGradient(0, D, 0, D + P)), \"cylinder\" === e.fillGradientType) {\n                        var W = h.Colors.parse(e.fillColor);\n                        j.push([0, h.Colors.format(h.Colors.derive(W, .6, 1))]), j.push([.25, h.Colors.format(h.Colors.derive(W, .8, 1))]), j.push([.75, h.Colors.format(h.Colors.derive(W, 1.1, 1))]), j.push([1, h.Colors.format(h.Colors.derive(W, .8, 1))]);\n                      }\n\n                      if (G) {\n                        for (var V = 0, Z = j; V < Z.length; V++) {\n                          var Y = Z[V];\n                          G.addColorStop(Y[0], Y[1]);\n                        }\n\n                        g.fillStyle = G;\n                      }\n                    }\n\n                    if (p && (g.beginPath(), h.Graphics.applyShadow(g, C), N ? (g.moveTo(M + u, D - u), g.lineTo(M + I + u, D - u), g.lineTo(M + I + u, D + P - u), g.lineTo(M + I, D + P), g.lineTo(M + I, D), g.lineTo(M, D)) : (g.moveTo(M + I, D), g.lineTo(M + I + u, D - u), g.lineTo(M + I + u, D + P - u), g.lineTo(M + I, D + P), g.lineTo(M + I, D)), g.closePath(), g.fillStyle = p, g.fill(), h.Graphics.clearShadow(g), g.fillStyle = d), !p && c && h.Graphics.applyShadow(g, C), d) {\n                      var q = C.radius;\n\n                      if (q[0] || q[1] || q[2] || q[3]) {\n                        var _ = [];\n                        F ? _ = q : (_[0] = q[2], _[1] = q[3], _[2] = q[0], _[3] = q[1]), g.beginPath();\n                        var X = P / 2,\n                            Q = I / 2;\n                        _[0] ? (g.moveTo(M, D + Math.min(X, _[0])), g.quadraticCurveTo(M, D, M + Math.min(Q, _[0]), D)) : g.moveTo(M, D), _[1] ? (g.lineTo(M + I - Math.min(_[1], Q), D), g.quadraticCurveTo(M + I, D, M + I, D + Math.min(_[1], X))) : g.lineTo(M + I, D), _[2] ? (g.lineTo(M + I, D + P - Math.min(_[2], X)), g.quadraticCurveTo(M + I, D + P, M + I - Math.min(_[2], Q), D + P)) : g.lineTo(M + I, D + P), _[3] ? (g.lineTo(M + Math.min(Q, _[3]), D + P), g.quadraticCurveTo(M, D + P, M, D + P - Math.min(X, _[2]))) : g.lineTo(M, D + P), g.closePath(), g.fill();\n                      } else g.fillRect(M, D, I, P);\n\n                      !p && c && h.Graphics.clearShadow(g);\n                    }\n\n                    if (f > 0) {\n                      D += f / 2, M += f / 2;\n                      X = (P -= f) / 2, Q = (I -= f) / 2;\n                      var J = h.Graphics.beginStroke(g, C);\n                      if (I > 0) {\n                        if (P > 0) {\n                          var K = C.radius;\n                          _ = [];\n                          F ? _ = K : (_[0] = K[2], _[1] = K[3], _[2] = K[0], _[3] = K[1]), _[0] ? (J.moveTo(M, D + Math.min(X, _[0])), J.quadraticCurveTo(M, D, M + Math.min(Q, _[0]), D)) : J.moveTo(M, D), _[1] ? (J.lineTo(M + I - Math.min(_[1], Q), D), J.quadraticCurveTo(M + I, D, M + I, D + Math.min(_[1], X))) : J.lineTo(M + I, D), _[2] ? (J.lineTo(M + I, D + P - Math.min(_[2], X)), J.quadraticCurveTo(M + I, D + P, M + I - Math.min(_[2], Q), D + P)) : J.lineTo(M + I, D + P), _[3] ? (J.lineTo(M + Math.min(Q, _[3]), D + P), J.quadraticCurveTo(M, D + P, M, D + P - Math.min(X, _[2]))) : J.lineTo(M, D + P), J.closePath();\n                        } else f > 0 && (g.moveTo(M, k), g.lineTo(M + I, k));\n                      } else f > 0 && (g.moveTo(w, D), g.lineTo(w, D + P));\n                      h.Graphics.endStroke(g, J, C);\n                    }\n\n                    d || p || !c || h.Graphics.clearShadow(g);\n                    var $ = C.previewLineColor;\n\n                    if (l && l[x]) {\n                      g.beginPath();\n\n                      for (var tt = 0, et = A - k, it = l[x], nt = 0; nt < it.length; nt++) {\n                        L = k + (tt += it[nt]) * et, g.moveTo(M, L), g.lineTo(M + I, L);\n                      }\n\n                      g.lineWidth = 1, g.strokeStyle = $, g.stroke();\n                    }\n                  }\n                }\n              }, t;\n            }();\n\n            t.Columns = e;\n\n            var i = function () {\n              function t(t, e) {\n                this.stack = t, this.series = e, this.seriesData = [];\n\n                for (var i = 0; i < e.length; i++) {\n                  this.seriesData.push({\n                    markerY: [],\n                    segments: []\n                  });\n                }\n\n                this.prevyL = [], this.prevyR = [];\n              }\n\n              return t.prototype.paintStack = function (t, e, i, n, r, s) {\n                if (0 !== e.length) {\n                  var a = t.context;\n                  this.paintLines(a, this.series, this.seriesData, e, i, n, s);\n\n                  for (var o = 0; o < this.series.length; o++) {\n                    var l = this.series[o];\n                    l.style.markerStyleFunction ? this.paintCustomMarkers(a, l, e, n[o], this.seriesData[o].markerY) : this.paintMarkers(a, l, e, n[o], this.seriesData[o].markerY);\n                  }\n                }\n              }, t.prototype.paintLines = function (t, e, i, n, r, s, a) {\n                this.computeLineSegments(n, r, a, s);\n\n                for (var o = [[-1 / 0, 0, 1 / 0], [a, a, a]], l = 0; l < e.length; l++) {\n                  var h = e[l];\n                  this.paintLine(t, h.style, o, i[l].segments, a), l < e.length - 1 && (o = this.mergePreviousSegments(o, this.seriesData[l].segments));\n                }\n              }, t.prototype.mergePreviousSegments = function (t, e) {\n                for (var i = [], n = [], r = 0, s = t[0], a = t[1], o = 0; o < e.length; o += 2) {\n                  for (var l = e[o], h = e[o + 1]; s[r] <= l[0];) {\n                    i.push(s[r]), n.push(a[r]), r++;\n                  }\n\n                  for (s[r - 1] !== l[0] && (i.push(l[0]), n.push(a[r - 1])), i.push.apply(i, l), n.push.apply(n, h); s[r] < l[l.length - 1];) {\n                    r++;\n                  }\n\n                  l[l.length - 1] !== s[r] && (i.push(l[l.length - 1]), n.push(a[r]));\n                }\n\n                for (; r < s.length;) {\n                  i.push(s[r]), n.push(a[r]), r++;\n                }\n\n                return [i, n];\n              }, t.prototype.paintCustomMarkers = function (t, e, i, n, r) {\n                var s = e.style.markerStyleFunction(this.stack.externalItems(), n);\n                if (s && s.length === n.length) for (var a = e.style.marker, o = 0; o < n.length; o++) {\n                  var l = s[o];\n                  l && l.shape && (l.fillColor || (l.fillColor = a.fillColor || e.style.lineColor || e.style.fillColor), l.width || (l.width = a.width || 10), t.beginPath(), h.Graphics.strokeMarker(t, l.shape, i[o], r[o], l.width / 2), h.Graphics.paint(t, l));\n                } else h.Helpers.error(\"markerStyleFunction() must return an array with the same number of elements as the input arrays.\");\n              }, t.prototype.paintMarkers = function (t, e, i, n, r) {\n                var s = e.style.marker;\n\n                if (s.shape) {\n                  var a = {\n                    fillColor: s.fillColor || e.style.lineColor || e.style.fillColor,\n                    lineColor: s.lineColor,\n                    lineWidth: s.lineWidth\n                  },\n                      o = s.width / 2,\n                      l = s.shape;\n                  t.beginPath();\n\n                  for (var u = 0; u < n.length; u++) {\n                    null !== n[u] && h.Graphics.strokeMarker(t, l, i[u], r[u], o);\n                  }\n\n                  h.Graphics.paint(t, a);\n                }\n              }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n                var l = this.series,\n                    u = t.length;\n                if (0 === u) return {\n                  result: null,\n                  distance: 1 / 0\n                };\n\n                for (var c = Math.min(h.Helpers.binSearch(t, s), u - 2), d = null, p = 1 / 0, f = r - a, g = 0; g < l.length; g++) {\n                  for (var m = l[g].style, v = this.seriesData[g], y = Math.max(0, c - 2); y < Math.min(u, c + 3); y++) {\n                    if (null !== i[g][y] && m.marker) {\n                      var S = t[y],\n                          b = v.markerY[y],\n                          C = m.marker.width / 2,\n                          x = s - S,\n                          w = a - b,\n                          L = Math.sqrt(x * x + w * w);\n                      L < C + o && p > L - C && (p = L - C, d = {\n                        x0: S,\n                        y0: b,\n                        x1: S,\n                        y1: b,\n                        seriesIndex: g,\n                        isMarker: !0\n                      });\n                    }\n                  }\n\n                  var T = null,\n                      k = v.segments;\n\n                  for (y = 0; y < k.length; y += 2) {\n                    for (var A = k[y], M = k[y + 1], I = A[0], P = 1; P < A.length; P++) {\n                      var D = A[P];\n\n                      if (I <= s + o && D >= s - o) {\n                        var N = M[P - 1],\n                            F = M[P],\n                            O = Math.sqrt(h.Geometry.distanceToSegmentSq(I, N, D, F, s, a));\n                        O < o && O <= p && (p = O, d = {\n                          x0: I,\n                          y0: N,\n                          x1: D,\n                          y1: F,\n                          seriesIndex: g,\n                          isMarker: !1\n                        });\n                      }\n\n                      if (I <= s && D >= s) {\n                        N = M[P - 1], F = M[P];\n                        var E = h.Geometry.lineIntersectsSegment(s, a, 0, 1, I, N, D, F);\n                        E !== 1 / 0 && (T = E);\n                      }\n\n                      I = D;\n                    }\n                  }\n\n                  null !== T && (h.Helpers.sign(T) !== h.Helpers.sign(f) && (m.fillColor || m.fillGradient) && p >= 0 && (p = 0, d = {\n                    x0: 0,\n                    y0: 0,\n                    x1: 1,\n                    y1: 1,\n                    seriesIndex: g,\n                    isMarker: !1\n                  }), f = T);\n                }\n\n                return {\n                  result: d,\n                  distance: Math.max(p, 0)\n                };\n              }, t.prototype.computeLineSegments = function (t, e, i, n) {\n                var r = t.length,\n                    s = this.prevyL,\n                    a = this.prevyR;\n                s.length < r && (s.length = r, a.length = r);\n\n                for (var o = 0; o < r; o++) {\n                  s[o] = i, a[o] = i;\n                }\n\n                for (var l = s, h = 0; h < this.series.length; h++) {\n                  var u = this.series[h],\n                      c = this.seriesData[h];\n\n                  if (c.segments.length = 0, c.markerY.length < r && (c.markerY.length = r), u.style.steps) {\n                    var d = this.buildStepSegments(t, e, i, s, a, l, n[h], u.data.noDataPolicy);\n                    c.segments = d.segments, c.markerY = d.markerY;\n                  } else {\n                    var p = this.buildLineSegments(t, i, s, a, l, n[h], u.data.noDataPolicy);\n                    if (c.segments = p.segments, c.markerY = p.markerY, u.style.smoothing) for (var f = 0; f < c.segments.length; f += 2) {\n                      var g = this.smoothLine(c.segments[f], c.segments[f + 1]);\n                      c.segments[f] = g.x, c.segments[f + 1] = g.y;\n                    }\n                  }\n\n                  l = c.markerY;\n                }\n              }, t.prototype.buildLineSegments = function (t, e, i, n, r, s, a) {\n                var o = [],\n                    l = [],\n                    h = [];\n\n                if (\"zero\" === a) {\n                  for (var u = 0; u < t.length; u++) {\n                    var c = t[u],\n                        d = s[u],\n                        p = i[u],\n                        f = n[u];\n                    null !== d ? (o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d) : (o.push(r[u]), p !== f ? (h.push(p), h.push(f), l.push(c), l.push(c)) : (h.push(p), l.push(c)));\n                  }\n\n                  return {\n                    segments: [l, h],\n                    markerY: o\n                  };\n                }\n\n                if (\"join\" === a) {\n                  var g = null;\n\n                  for (u = 0; u < t.length; u++) {\n                    c = t[u], d = s[u], p = i[u], f = n[u];\n\n                    if (null !== d) {\n                      if (null === g) o.push(r[u] - d), l.push(c), h.push(f - d), n[u] -= d;else {\n                        if (g < u - 1) for (var m = s[g], v = t[g], y = (d - m) / (c - v), S = g + 1; S < u; S++) {\n                          var b = t[S],\n                              C = m + y * (b - v);\n                          o.push(r[S] - C);\n                          var x = i[S],\n                              w = n[S];\n                          l.push(b), h.push(x - C), x !== w && (l.push(b), h.push(w - C)), i[S] -= C, n[S] -= C;\n                        }\n                        o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d;\n                      }\n                      g = u;\n                    } else null === g && o.push(r[u]);\n                  }\n\n                  return l.length > 2 && l[l.length - 1] === l[l.length - 2] && (l.pop(), h.pop()), {\n                    segments: [l, h],\n                    markerY: o\n                  };\n                }\n\n                var L = !1,\n                    T = [];\n\n                for (u = 0; u < t.length; u++) {\n                  c = t[u], d = s[u], p = i[u], f = n[u];\n                  null !== d ? (o.push(r[u] - d), L ? (l.length > 1 && i[u - 1] !== n[u - 1] && (l.push(t[u - 1]), h.push(n[u - 1])), l.push(c), h.push(p - d), i[u] -= d, n[u] -= d) : (l.push(c), h.push(f - d), n[u] -= d), L = !0) : (o.push(r[u]), L && (l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h), l = [], h = []), n[u - 1] += s[u - 1]), L = !1);\n                }\n\n                return l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h)), {\n                  segments: T,\n                  markerY: o\n                };\n              }, t.prototype.buildStepSegments = function (t, e, i, n, r, s, a, o) {\n                for (var l = [], h = [], u = [], c = [], d = null, p = 0, f = 0; f < t.length; f++) {\n                  var g = t[f] - e[f],\n                      m = a[f];\n\n                  if (null !== m) {\n                    null !== d && (u.push(g), c.push(d));\n                    var v = s[f] - m;\n                    u.push(g), c.push(v), d = v, p = g + 2 * e[f], h.push(v), n[f] = r[f] = v;\n                  } else if (\"zero\" === o) {\n                    v = s[f];\n                    h.push(v), r[f] = n[f] = v, null !== d && (u.push(p), c.push(d)), u.push(g), c.push(v), d = v, p = g + 2 * e[f];\n                  } else if (\"join\" === o) {\n                    v = null !== d ? d : s[f];\n                    h.push(v), r[f] = n[f] = v;\n                  } else {\n                    v = s[f];\n                    h.push(v), r[f] = n[f] = v, u.length > 0 && (null !== d && (u.push(p), c.push(d)), d = null, l.push(u, c), u = [], c = []);\n                  }\n                }\n\n                return u.length > 0 && (null !== d && (u.push(p), c.push(d)), l.push(u, c)), {\n                  segments: l,\n                  markerY: h\n                };\n              }, t.prototype.smoothLine = function (t, e) {\n                var i = t[0],\n                    n = t[t.length - 1],\n                    r = (n - i) / t.length;\n                if (r < 2) return {\n                  x: t,\n                  y: e\n                };\n                var s = [],\n                    a = [];\n                s.push(i), a.push(e[0]);\n\n                for (var o = 0; o + 1 < t.length;) {\n                  var l = o + 1;\n                  if (t[o] !== t[l]) for (; l + 1 < t.length && t[l] !== t[l + 1];) {\n                    l += 1;\n                  }\n                  if (l - o == 1) s.push(t[l]), a.push(e[l]);else {\n                    var u = new h.MonotoneCurve(t, e, o, l + 1);\n                    n = t[o];\n\n                    for (var c = o + 1; c <= l; c++) {\n                      i = n, n = t[c];\n\n                      for (var d = e[c], p = (r = n - i) / Math.ceil(Math.min(50, Math.max(2, r / 3))), f = s.length; (i += p) < n;) {\n                        s.push(i);\n                      }\n\n                      u.interpolateArray(c - 1, s, f, s.length, a), s.push(n), a.push(d);\n                    }\n\n                    u.clear();\n                  }\n                  o = l;\n                }\n\n                return t.length = 0, e.length = 0, {\n                  x: s,\n                  y: a\n                };\n              }, t.prototype.paintLine = function (t, e, i, n, r) {\n                if (e._currentFillStyle) {\n                  e.shadowColor && h.Graphics.applyShadow(t, e), t.fillStyle = e._currentFillStyle, t.beginPath();\n\n                  for (var s = 0; s < n.length; s += 2) {\n                    this.paintArea(t, n[s], n[s + 1], i, r);\n                  }\n\n                  t.fill(), e.shadowColor && h.Graphics.clearShadow(t);\n                }\n\n                if (e.lineColor) {\n                  !e.fillColor && e.shadowColor && h.Graphics.applyShadow(t, e);\n                  var a = h.Graphics.beginStroke(t, e);\n\n                  for (s = 0; s < n.length; s += 2) {\n                    var o = n[s],\n                        l = n[s + 1];\n                    a.moveTo(o[0], l[0]);\n\n                    for (var u = 1; u < o.length; u++) {\n                      a.lineTo(o[u], l[u]);\n                    }\n                  }\n\n                  h.Graphics.endStroke(t, a, e), !e.fillColor && e.shadowColor && h.Graphics.clearShadow(t);\n                }\n              }, t.prototype.paintArea = function (t, e, i, n, r) {\n                t.moveTo(e[0], i[0]);\n\n                for (var s = 1; s < e.length; s++) {\n                  t.lineTo(e[s], i[s]);\n                }\n\n                for (var a = e[0], o = r, l = e[e.length - 1], h = n.length - 2; h >= 0; h += -2) {\n                  var u = n[h],\n                      c = n[h + 1];\n\n                  if (!(u.length < 2 || u[0] > l || u[u.length - 1] < a)) {\n                    var d = u.length - 1,\n                        p = u[d];\n                    p < l && (t.lineTo(l, o), t.lineTo(p, o), l = p);\n                    s = void 0;\n                    var f = void 0;\n\n                    for (s = d; s >= 0; s--) {\n                      if (f = u[s], l === p) t.lineTo(p, c[s + 1]), l = f;else if (l < p && l > f) {\n                        var g = (m = c[s]) + (l - f) / (p - f) * (c[s + 1] - m);\n                        t.lineTo(l, g), l = f;\n                      }\n\n                      if (l <= a) {\n                        l = a;\n                        var m;\n                        g = (m = c[s]) + (l - f) / (p - f) * (c[s + 1] - m);\n                        t.lineTo(l, g);\n                        break;\n                      }\n\n                      p = f;\n                    }\n\n                    -1 === s && l === f && t.lineTo(l, c[0]);\n                  }\n                }\n\n                l !== a && (t.lineTo(l, o), t.lineTo(a, o)), t.closePath();\n              }, t;\n            }();\n\n            t.Line = i;\n\n            var n = function () {\n              function t(t, e) {\n                this.series = e, this.scene = t, this.prevy = [];\n              }\n\n              return t.prototype.paintStack = function (t, e, i, n, r, s) {\n                if (e.length > 0) {\n                  var a = this.series[0];\n                  this.seriesEnabled = a.enabled;\n                  var o = this.prevy;\n                  o.length < e.length && (o = this.prevy = new Array(e.length));\n\n                  for (var l = 0; l <= e.length - 1; l++) {\n                    o[l] = s;\n                  }\n\n                  this.plainBar(t.context, a.style, e, i, o, n);\n                }\n              }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n                if (!(t.length > 1)) return {\n                  result: null,\n                  distance: 1 / 0\n                };\n                var l = this.series,\n                    u = h.Helpers.binSearch(t, s),\n                    c = t[u] - e[u],\n                    d = t[u] + e[u];\n\n                if (c > s && u > 0) {\n                  var p = t[u - 1] - e[u - 1],\n                      f = t[u - 1] + e[u - 1];\n                  (f > s || Math.abs(f - s) < Math.abs(c - s)) && (u -= 1, c = p, d = f);\n                }\n\n                for (var g = null, m = 1 / 0, v = r, y = 0; y < l.length; y++) {\n                  var S = i[y][u];\n\n                  if (null !== S) {\n                    var b = v - S,\n                        C = Math.min(v, b),\n                        x = Math.max(v, b),\n                        w = h.Geometry.distanceToRect(s, a, c, C, d, x);\n                    w < m && (m = w, g = {\n                      x0: c,\n                      y0: C,\n                      x1: d,\n                      y1: x,\n                      seriesIndex: y,\n                      isMarker: !1\n                    }), v = b;\n                  }\n                }\n\n                return {\n                  result: g,\n                  distance: m\n                };\n              }, t.prototype.plainBar = function (t, e, i, n, r, s) {\n                for (var a = 0; a < i.length; a++) {\n                  var o = i[a],\n                      l = r[a],\n                      u = s[0][a],\n                      c = s[1][a],\n                      d = s[2][a],\n                      p = s[3][a];\n\n                  if (void 0 !== p && null !== p || void 0 !== u && null !== u || void 0 !== c && null !== c || void 0 !== d && null !== d) {\n                    var f,\n                        g = (o - n[a] || 0) + .5,\n                        m = (o + n[a] || 0) + .5,\n                        v = (l - p || 0) + .5,\n                        y = (l - u || 0) + .5,\n                        S = (l - c || 0) + .5,\n                        b = (l - d || 0) + .5,\n                        C = this.applyPatternStyle(t, e, S, b);\n                    if (\"bar\" === e.pattern) (f = h.Graphics.beginStroke(t, C)).moveTo(o, y), f.lineTo(o, v), f.moveTo(g, S), f.lineTo(o, S), f.moveTo(m, b), f.lineTo(o, b), h.Graphics.endStroke(t, f, C);else (f = h.Graphics.beginStroke(t, C)).moveTo(o, y), f.lineTo(o, S), f.moveTo(o, b), f.lineTo(o, v), h.Graphics.endStroke(t, f, C), (f = h.Graphics.beginStroke(t, C, !0)).moveTo(g, S), f.lineTo(m, S), f.lineTo(m, b), f.lineTo(g, b), f.closePath(), h.Graphics.endStroke(t, f, C, !0);\n                    e.shadowColor && h.Graphics.clearShadow(t);\n                  }\n                }\n              }, t.prototype.applyPatternStyle = function (t, e, i, n) {\n                var r = i >= n ? e.increase : e.decrease,\n                    s = \"candlestick\" === e.pattern ? r.candlestick : r.bar,\n                    a = s;\n\n                if (!this.seriesEnabled) {\n                  a = h.Helpers.realClone(s);\n                  var o = this.scene.settings.legend.advanced.disabledSeries;\n                  a.lineColor = o.lineColor, void 0 !== a.fillColor && (a.fillColor = o.fillColor);\n                }\n\n                return e.lineColor && e.shadowColor && h.Graphics.applyShadow(t, e), a;\n              }, t;\n            }();\n\n            t.Candlestick = n;\n          }(i = t.Renderers || (t.Renderers = {}));\n\n          var p = function () {\n            function t(t, e, i) {\n              this.scene = e, this.chart = t, this.valueAxis = i;\n            }\n\n            return t.prototype.setSeriesFont = function (t, e, i, n, r, s) {\n              var a = this.scene.dataLabels.metaData,\n                  o = 2 * n[0];\n              null === a.styles && (a.styles = {});\n\n              for (var l = 0; l < i.length; l++) {\n                var h = i[l],\n                    u = this.getLongestNumber(r[l]);\n                if (a.styles[h.id] = null, u.max === -1 / 0) break;\n                var c = this.createContent(u.max, s[u.index], h.valueLabels.contentsFunction) || \"\",\n                    d = this.reduceFontWidth(t, e, h.id, h.valueLabels, o, c);\n                d && (a.styles[h.id] = d);\n              }\n            }, t.prototype.scanValueLabels = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = this.chart.shell.getChartInnerArea(), u = this.chart.getBottomHeight(), c = 0; c < 2; c++) {\n                var d = 0 === c ? s : a;\n                if (null !== d) for (var p = 0; p < n.length; p++) {\n                  for (var f = n[p], g = this.valueAxis.zeroY, m = 0, v = 0; v < d.length; v++) {\n                    var y = o[v][p],\n                        S = d[v][p];\n\n                    if (null !== S && null !== y) {\n                      m += y, g -= S;\n                      var C = r[v];\n\n                      if (C.valueLabels && C.valueLabels.enabled) {\n                        var x = C.valueLabels.useStackedValue,\n                            w = this.chart.settings._computedStacks[C.stack],\n                            L = w && \"based\" === w.type;\n\n                        if (null === x && (x = !L), !L || 0 !== S || 0 === m) {\n                          if (C instanceof b) {\n                            var T = S >= 0 ? 1 : -1,\n                                k = C.style.minHeight;\n                            k && (S = S * T < k ? k * T : S);\n                          }\n\n                          this.createDrawingSpots(t, h, S, g + S, f, C, x ? m : y, u, i[0], l[p]);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              this.paintDataLabels(t, e, i[0], r.length);\n            }, t.prototype.createDrawingSpots = function (t, e, i, n, r, s, a, o, l, u) {\n              var c = s.id,\n                  d = s.valueLabels.position,\n                  p = this.scene.dataLabels,\n                  f = r.toFixed(1),\n                  g = this.scene.dataLabels.spots[f];\n\n              if (null !== p.metaData.styles[c] && null != this.createContent(a, u, s.valueLabels.contentsFunction)) {\n                var m = new h.LabelLayoutBase().totalPadding(s.valueLabels.style);\n                i = Math.abs(i);\n                var v = this.getPositionVerticalDimensions(t, a, n, i, p.metaData.styles[c], s.valueLabels.minFontSize, d, m);\n\n                if (null !== v) {\n                  var y = v.min,\n                      S = v.max,\n                      b = e.findTopPosition(r, Math.min(r + l, this.scene.x0 + this.scene.width));\n                  b > y && (S = S - y + b, y = b);\n                  var C = this.scene.chartTop + this.scene.chartHeight - this.scene.bottomAxisSize;\n                  if (S > C && (y = y - S + C, S = C), g) for (var x = 0; x < g.length; x++) {\n                    var w = g[x];\n\n                    if (null != w) {\n                      var L = w.edges[0];\n\n                      if (y < w.edges[1] && S > L) {\n                        if (!(s.type === w.type && a > w.value)) return;\n                        g[x] = null;\n                      }\n                    }\n                  }\n                  g || (g = this.scene.dataLabels.spots[f] = []), g.push({\n                    value: a,\n                    type: s.type,\n                    edges: [y, S],\n                    x: parseInt(f, 10),\n                    y: y + v.fontHeight / 2,\n                    font: v.font,\n                    id: c,\n                    style: s.valueLabels.style,\n                    function: s.valueLabels.contentsFunction,\n                    timestamp: u\n                  });\n                }\n              }\n            }, t.prototype.reduceFontSize = function (t, e, i, n, r) {\n              var s = e.match(/^([^\\\"\\d]*)(\\d+\\.?\\d*)(.*)$/i);\n              if (!s) return h.Helpers.warn(\"Could not parse the font size from the value `\" + e + \"`.\"), {\n                font: e,\n                value: n(e)\n              };\n\n              for (var a = s[2], o = s[1], l = s[3], u = parseFloat(a); u >= i;) {\n                var c = o + u + l,\n                    d = n(c);\n                if (d <= r) return {\n                  font: c,\n                  value: d\n                };\n                if (u === i) break;\n                (u = Math.round((u - 1) * r / d * 100) / 100) < i && (u = i);\n              }\n\n              return null;\n            }, t.prototype.getPositionVerticalDimensions = function (t, e, i, n, r, s, a, o) {\n              var l = e >= 0 ? -1 : 1,\n                  u = null,\n                  c = null,\n                  d = l * n,\n                  p = h.Graphics.getTextHeight(t, r) + 2 * o + 4,\n                  f = p < n;\n\n              if (!f && (\"insideTop\" === a || \"insideCenter\" === a || \"insideBase\" === a)) {\n                var g = this.reduceFontSize(t, r, s, function (e) {\n                  return h.Graphics.getTextHeight(t, e);\n                }, n);\n                if (!g) return null;\n                r = g.font, p = g.value + 2 * o + 4;\n              }\n\n              switch (a) {\n                case \"outside\":\n                  c = (u = i + d) + l * p;\n                  break;\n\n                case \"insideTop\":\n                  c = (u = i + d) - l * p;\n                  break;\n\n                case \"insideCenter\":\n                  c = (u = i + d / 2 + p / 2) - p;\n                  break;\n\n                case \"insideBase\":\n                  u = i + l * p, c = i;\n                  break;\n\n                case \"aboveValue\":\n                  c = (u = i + d) - p;\n                  break;\n\n                case \"belowValue\":\n                  c = (u = i + d) + p;\n                  break;\n\n                case \"insideTopAuto\":\n                  f ? c = (u = i + d) - l * p : c = (u = i + d) + l * p;\n                  break;\n\n                case \"value\":\n                  f && (c = (u = i + d - p / 2) + p);\n                  break;\n\n                default:\n                  h.Helpers.warn(\"Invalid position: '\" + a + \"'. Possible values: outside, insideTop, insideCenter, insideBase, aboveValue, belowValue, belowValueAuto, value.\"), c = (u = i + d) + l * p;\n              }\n\n              return null === u ? null : u > c ? {\n                min: c,\n                max: u,\n                font: r,\n                fontHeight: p\n              } : {\n                min: u,\n                max: c,\n                font: r,\n                fontHeight: p\n              };\n            }, t.prototype.reduceFontWidth = function (t, e, i, n, r, s) {\n              var a = this.scene.dataLabels.fontWidths,\n                  o = n.style.textStyle;\n              if (s = s.replace(/\\d/g, \"9\"), (a[o.font + \";\" + s] || 1 / 0) <= r) return o.font;\n              var l = new h.Label(n.style),\n                  u = l.style.textStyle,\n                  c = u.font;\n              l.text = s;\n              var d = this.reduceFontSize(t, c, n.minFontSize, function (i) {\n                var n = a[i + \";\" + s];\n                return n || (u.font = i, e.labelRenderer.measure(t, l), a[i + \";\" + s] = n = 2 * l.hwidth), n;\n              }, r);\n              return d ? d.font : null;\n            }, t.prototype.getLongestNumber = function (t) {\n              for (var e = 0, i = -1, n = 0; n < t.length; n++) {\n                var r = t[n];\n                r < 0 && (r *= -10), e <= r && (e = r, i = n);\n              }\n\n              return {\n                max: -1 === i || null === t[i] ? -1 / 0 : t[i],\n                index: i\n              };\n            }, t.prototype.createContent = function (t, e, i) {\n              if (i) {\n                var n = i.call(this.chart.api, t, e) || null;\n                return null != n && \"string\" != typeof n ? void h.Helpers.warn(\"`valueLabels.contentsFunction` has to return `null` or a string value.\") : n;\n              }\n\n              return t === (0 | t) ? t.toFixed(0) : t.toFixed(2);\n            }, t.prototype.paintDataLabels = function (t, e, i, n) {\n              var r = this.scene,\n                  s = r.dataLabels.metaData,\n                  a = 2 * i,\n                  o = s.availableWidth !== a;\n\n              if (s.processed += n, s.processed >= r.seriesWithLabels) {\n                s.processed = 0;\n\n                for (var l = r.dataLabels.spots, u = Object.keys(l), c = 0, d = u.length; c < d; c++) {\n                  var p = l[u[c]];\n                  if (p) for (var f = 0; f < p.length; f++) {\n                    var g = p[f];\n\n                    if (null != g) {\n                      var m = new h.Label(g.style);\n                      m.text = this.createContent(g.value, g.timestamp, g.function), m.style.textStyle.font = g.font, e.labelRenderer.paint(t, g.x, g.y, 1, m);\n                    }\n                  }\n                }\n\n                r.dataLabels.spots = {}, o && (s.availableWidth = a);\n              }\n            }, t;\n          }();\n\n          t.ValueLabels = p, function (t) {\n            var e = function () {\n              function t(t, e, i, n, r) {\n                this.series = [], this.seriesId = [], this.min = 0, this.max = 0, this.renderingType = null, this.needsAfterProcess = !1, this.paddingLeft = 0, this.paddingRight = 0, this.centers = [], this.radii = [], this.vstack = [], this.countStack = [], this.ystack = [], this.xes = [], this.times = [], this.styles = [], this.previewData = [], this.calculatedDepth = 0, this.ystackNegative = null, this.valueLabels = null, this.externalItems = null, this.externalItemsCache = null, this.va = r, this.options = n, this.cluster = i, this.scene = e, this.chart = t, this.va.series++;\n              }\n\n              return t.computeFillPattern = function (t, e, i) {\n                var n = i.fillPattern,\n                    r = i._currentFillStyleKey,\n                    s = i.fillColor,\n                    a = s + \"|\" + n;\n\n                if (!r || r.pattern !== a) {\n                  var o,\n                      l,\n                      h = t.assetsLoader.getAssetImage(i.fillPattern);\n\n                  if (h) {\n                    var u = i._fillPatternOpacity;\n\n                    if (s || u) {\n                      var c = document.createElement(\"canvas\");\n                      c.width = h.width, c.height = h.height;\n                      var d = c.getContext(\"2d\");\n                      s && (d.fillStyle = s, d.fillRect(0, 0, h.width, h.height)), d.globalAlpha = i._fillPatternOpacity, d.drawImage(h, 0, 0), h = c;\n                    }\n\n                    o = e.createPattern(h, \"repeat\"), l = {\n                      pattern: a\n                    };\n                  } else o = s || null, l = null;\n\n                  i._currentFillStyle = o, i._currentFillStyleKey = l;\n                }\n              }, t.prototype.addSeries = function (t, e) {\n                this.renderingType || (this.renderingType = e.type), this.series.push(e), this.seriesId.push(t);\n                var i = e;\n                this.calculatedDepth = Math.max(this.calculatedDepth, i.style.depth), \"columns\" === this.renderingType && (this.paddingLeft = Math.max(this.paddingLeft, i.style.padding[0]), this.paddingRight = Math.max(this.paddingRight, i.style.padding[1]));\n              }, t.prototype.afterInit = function () {\n                \"line\" === this.renderingType ? this.renderer = new i.Line(this, this.series) : \"columns\" === this.renderingType ? this.renderer = new i.Columns(this.scene, this.series) : \"candlestick\" === this.renderingType && (this.candleStacks = !0, this.renderer = new i.Candlestick(this.scene, this.series));\n              }, t.prototype.process = function (t) {\n                this.processData(t), this.computeMinMax(), this.addLeads(t), this.needsAfterProcess = !0;\n              }, t.prototype.afterProcess = function () {\n                if (this.needsAfterProcess || this.va.axisChanged) return this.needsAfterProcess = !1, this.computeY();\n              }, t.prototype.paint = function (t, e) {\n                if (0 !== this.ystack.length && !isNaN(this.radii[0])) {\n                  for (var i = 0; i < this.series.length; i++) {\n                    var n = this.series[i];\n                    this.computeFillStyle(e, n.style), this.chart.assetsLoaded && n.valueLabels && n.valueLabels.enabled && (null === this.valueLabels && (this.valueLabels = new p(this.chart, this.scene, this.va)), this.valueLabels.setSeriesFont(e, t, this.series, this.radii, this.vstack, this.times));\n                  }\n\n                  var r = this.styles;\n                  if (r) for (var s = 0; s < r.length; s++) {\n                    var a = r[s];\n                    if (a) for (var o = 0; o < a.length; o++) {\n                      this.computeFillStyle(e, a[o]);\n                    }\n                  }\n                  this.ystackNegative && this.renderer.paintStack(t, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, this.previewData), this.renderer.paintStack(t, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, this.previewData), null !== this.valueLabels && this.valueLabels.scanValueLabels(e, t, this.radii, this.centers, this.series, this.ystack, this.ystackNegative, this.vstack, this.times);\n                }\n              }, t.prototype.hitTestStack = function (t, e) {\n                var i = h.Helpers.binSearch(this.centers, t),\n                    n = this.centers[i] - this.radii[i],\n                    r = this.centers[i] + this.radii[i];\n\n                if (n > t && i > 0) {\n                  var s = this.centers[i - 1] - this.radii[i - 1],\n                      a = this.centers[i - 1] + this.radii[i - 1];\n                  (a > t || Math.abs(a - t) < Math.abs(n - t)) && (i -= 1, n = s, r = a);\n                }\n\n                return {\n                  result: {\n                    x0: n,\n                    y0: 0,\n                    x1: r,\n                    y1: 0,\n                    seriesIndex: null,\n                    isMarker: !1,\n                    stack: this\n                  },\n                  distance: h.Geometry.distanceToRect(t, 0, n, 0, r, 0)\n                };\n              }, t.prototype.hitTest = function (t, e, i) {\n                var n = this.renderer.hitTest(this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, t, e, i),\n                    r = n.result,\n                    s = n.distance;\n                return this.ystackNegative && (n = this.renderer.hitTest(this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, t, e, i)).distance < s && (r = n.result, s = n.distance), null !== r && (r.seriesIndex = this.seriesId[r.seriesIndex], r.stack = this), {\n                  result: r,\n                  distance: s\n                };\n              }, t.prototype.computeFillStyle = function (e, i) {\n                if (i) if (i.fillPattern) t.computeFillPattern(this.chart, e, i);else {\n                  if (i.fillGradient) return void this.computeFillGradient(e, i);\n                  i._currentFillStyle = i.fillColor || null, i._currentFillStyleKey = null;\n                }\n              }, t.prototype.computeFillGradient = function (t, e) {\n                var i = e.fillGradient,\n                    n = this.va,\n                    r = n.zeroY,\n                    s = this.scene.y0,\n                    a = this.scene.x0,\n                    o = this.scene.height,\n                    l = e._currentFillStyleKey,\n                    u = n.scale + \"|\" + r + \"|\" + s + \"|\" + a + \"|\" + o + \"|\" + r;\n\n                if (!l || !e._currentFillStyle || i !== l.gradient || u !== l.hash) {\n                  for (var c = [], d = 0; d < i.length; d++) {\n                    var p = i[d],\n                        f = (r - n.valueToRelativeY(p[0]) - s) / o;\n                    c.push([f, p[1]]);\n                  }\n\n                  c.sort(function (t, e) {\n                    return t[0] - e[0];\n                  });\n\n                  for (var g = t.createLinearGradient(a, s, a, s + o), m = null, v = 0; v < c.length; v++) {\n                    var y = c[v],\n                        S = y[0],\n                        b = y[1];\n\n                    if (S > 0) {\n                      if (m && m[0] < 0 && g.addColorStop(0, h.Colors.blend(m[1], b, (0 - m[0]) / (S - m[0]), !1)), S > 1) {\n                        m && g.addColorStop(1, h.Colors.blend(m[1], b, (1 - m[0]) / (S - m[0]), !1));\n                        break;\n                      }\n\n                      g.addColorStop(S, b);\n                    }\n\n                    m = y;\n                  }\n\n                  e._currentFillStyle = g, e._currentFillStyleKey = {\n                    hash: u,\n                    gradient: i\n                  };\n                }\n              }, t.prototype.processData = function (t) {\n                var e = this;\n                this.vstack = [], this.countStack = [], this.styles = [];\n                var i = t[this.seriesId[0]];\n\n                if (0 !== i.times.length) {\n                  this.xes = i.xes.slice(i.fromIndex, i.toIndex), this.times = i.times.slice(i.fromIndex, i.toIndex), this.centers = new Array(this.xes.length - 1), this.radii = new Array(this.xes.length - 1), this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii), this.externalItemsCache = null, this.externalItems = function () {\n                    var t = e.externalItemsCache;\n                    return null === t && (t = e.externalItemsCache = i.externalItems(i.fromIndex, i.toIndex - 1)), t;\n                  }, this.previewData = [];\n\n                  for (var n = 0; n < this.seriesId.length; n++) {\n                    var r = this.seriesId[n];\n\n                    if (i = t[r], this.vstack.push(i.values.slice(i.fromIndex, i.toIndex - 1)), this.countStack.push(i.counts.slice(i.fromIndex, i.toIndex - 1)), i.config) {\n                      for (var s = [], a = [], o = i.fromIndex; o < i.toIndex - 1; o++) {\n                        var l = i.config[o];\n                        l && (s.push(l.style), a.push(l.previewData));\n                      }\n\n                      this.styles.push(s), this.previewData.push(a);\n                    } else this.styles.push(null);\n                  }\n                }\n              }, t.prototype.addLeads = function (t) {\n                for (var e = 0; e < this.seriesId.length; e++) {\n                  var i = t[this.seriesId[e]];\n                  i.leadIn && this.injectLead(i.leadIn, e), i.leadOut && this.injectLead(i.leadOut, e);\n                }\n              }, t.prototype.injectLead = function (t, e) {\n                var i = this.series.length,\n                    n = t.values[0],\n                    r = t.times[0],\n                    s = [0],\n                    a = [0];\n                this.cluster.computeStackCenterRadius(this, t.xes, s, a);\n\n                for (var o = s[0], l = a[0], h = 0; h < this.centers.length && this.centers[h] < o;) {\n                  h++;\n                }\n\n                if (h === this.centers.length || this.centers[h] > o) {\n                  this.centers.splice(h, 0, o), this.radii.splice(h, 0, l), this.times.splice(h, 0, r);\n\n                  for (var u = 0; u <= i - 1; u++) {\n                    this.vstack[u].splice(h, 0, null), this.countStack[u].splice(h, 0, null), this.styles[u] && this.styles[u].splice(h, 0, null);\n                  }\n                }\n\n                this.vstack[e][h] = n, this.countStack[e][h] = t.counts[0];\n              }, t.prototype.getSeparateNegative = function () {\n                var t = this.options.separateNegativeValues;\n                return null === t && (t = \"line\" !== this.renderingType), t;\n              }, t.prototype.computeMinMax = function () {\n                var t = 1 / 0,\n                    e = -1 / 0;\n\n                if (this.vstack.length > 0) {\n                  for (var i = this.vstack, n = i[0].length, r = i.length, s = this.options.type, a = this.getSeparateNegative(), o = this.scene.x0, l = o + this.scene.width, u = 0, c = n - 1; u < n && this.centers[u] + this.radii[u] < o;) {\n                    u += 1;\n                  }\n\n                  for (; c >= u && this.centers[c] - this.radii[c] > l;) {\n                    c -= 1;\n                  }\n\n                  if (\"proportional\" === s) t = 0, e = 100;else if (this.candleStacks) for (var d = u; d <= c; d++) {\n                    for (var p = 0; p <= r - 1; p++) {\n                      var f = i[p][d];\n                      h.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n                    }\n                  } else if (1 === r) {\n                    var g = i[0];\n\n                    for (d = u; d <= c; d++) {\n                      f = g[d];\n                      h.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n                    }\n                  } else if (\"based\" === s) for (d = u; d <= c; d++) {\n                    for (p = 0; p <= r - 1; p++) {\n                      f = i[p][d];\n                      h.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n                    }\n                  } else if (\"normal\" !== s || a) {\n                    if (\"normal\" !== s) throw \"stack.type unknown value: \" + s;\n\n                    for (d = u; d <= c; d++) {\n                      var m = 0,\n                          v = 0;\n\n                      for (p = 0; p <= r - 1; p++) {\n                        f = i[p][d];\n                        h.Helpers.isNumber(f) && (f > 0 ? v += f : f < 0 && (m += f), t = Math.min(t, m), e = Math.max(e, v));\n                      }\n                    }\n                  } else for (d = u; d <= c; d++) {\n                    var y = 0;\n\n                    for (p = 0; p <= r - 1; p++) {\n                      f = i[p][d];\n                      h.Helpers.isNumber(f) && (null !== f && (y += f), t = Math.min(t, y), e = Math.max(e, y));\n                    }\n                  }\n                }\n\n                this.min = t, this.max = e, t <= e ? this.va.receiveSeriesGeometry(t, e, this.calculatedDepth) : this.va.receiveSeriesGeometry(void 0, void 0, this.calculatedDepth);\n              }, t.prototype.computeY = function () {\n                var t = this.vstack,\n                    e = t.length;\n\n                if (0 !== e) {\n                  var i,\n                      n = this.options.type,\n                      r = this.getSeparateNegative(),\n                      s = t[0].length,\n                      a = this.va,\n                      o = null;\n\n                  if (\"proportional\" === n) {\n                    i = t.map(function () {\n                      return [];\n                    }), a.options.scaleAdjustmentTolerance = 0;\n\n                    for (var l = 0; l <= s - 1; l++) {\n                      for (var h = 0, u = 0; u <= e - 1; u++) {\n                        null !== (b = t[u][l]) && (h += Math.abs(b));\n                      }\n\n                      if (h > 0) {\n                        h *= .01;\n\n                        for (u = 0; u <= e - 1; u++) {\n                          null !== (b = t[u][l]) ? i[u].push(a.valueToRelativeY(Math.abs(b) / h)) : i[u].push(null);\n                        }\n                      } else for (u = 0; u <= e - 1; u++) {\n                        i[u].push(null);\n                      }\n                    }\n                  } else if (\"based\" === n || 1 === e) {\n                    i = [];\n\n                    for (var c = t[0].map(function () {\n                      return 0;\n                    }), d = 0; d < t.length; d++) {\n                      for (var p = t[d], f = new Array(s), g = 0; g < p.length; g++) {\n                        if (null !== (b = p[g])) {\n                          var m = a.valueToRelativeY(b),\n                              v = c[g];\n                          b >= 0 && m <= v || b < 0 && m >= v ? f[g] = 0 : (f[g] = m - v, c[g] = m);\n                        } else f[g] = null;\n                      }\n\n                      i.push(f);\n                    }\n                  } else if (\"normal\" === n && r && this.min < 0 && this.max > 0) {\n                    i = t.map(function () {\n                      return [];\n                    }), o = t.map(function () {\n                      return [];\n                    });\n\n                    for (l = 0; l <= s - 1; l++) {\n                      for (u = 0; u <= e - 1; u++) {\n                        (b = t[u][l]) > 0 ? (i[u].push(a.valueToRelativeY(b)), o[u].push(null)) : b < 0 ? (i[u].push(null), o[u].push(a.valueToRelativeY(b))) : (i[u].push(null), o[u].push(null));\n                      }\n                    }\n                  } else if (\"candlestick\" === this.renderingType) {\n                    i = t.map(function () {\n                      return [];\n                    });\n\n                    for (l = 0; l <= s - 1; l++) {\n                      for (u = 0; u <= e - 1; u++) {\n                        null !== (b = t[u][l]) ? i[u].push(a.valueToRelativeY(b)) : i[u].push(null);\n                      }\n                    }\n                  } else {\n                    if (\"normal\" !== n) throw \"stack.type unknown value: \" + n;\n                    var y = 0,\n                        S = 0;\n                    i = t.map(function () {\n                      return [];\n                    });\n\n                    for (l = 0; l <= s - 1; l++) {\n                      for (u = 0; u <= e - 1; u++) {\n                        var b = t[u][l];\n\n                        if (0 === u && (y = S = 0), null !== b) {\n                          y += b;\n                          var C = a.valueToRelativeY(y);\n                          i[u].push(C - S), S = C;\n                        } else i[u].push(null);\n                      }\n                    }\n                  }\n\n                  this.ystackNegative = o, this.ystack = i;\n                }\n              }, t.prototype.exportData = function (t, e) {\n                var i;\n\n                if (this.times && this.vstack) {\n                  for (var n = this.times, r = this.centers.length, s = 0; s < r && n[s + 1] <= t;) {\n                    s++;\n                  }\n\n                  for (var a = s; a < r && n[a + 1] < e;) {\n                    a++;\n                  }\n\n                  i = [];\n\n                  for (var o = 0; o < this.vstack.length; o++) {\n                    var l = this.vstack[o],\n                        h = this.countStack[o],\n                        u = 0,\n                        c = -1 / 0,\n                        d = 1 / 0,\n                        p = null,\n                        f = null;\n                    r = 0;\n                    var g = this.series[o].data.aggregation,\n                        m = !1,\n                        v = !1;\n                    \"sum\" === g ? (m = !1, v = !0) : \"avg\" === g && (m = !0, v = !0);\n\n                    for (var y = s; y <= a; y++) {\n                      var S = l[y],\n                          b = 0 | h[y];\n                      null == S || isNaN(S) || (u += m ? S * b : S, c = Math.max(c, S), d = Math.min(d, S), null === p && (p = S), f = S, r += b);\n                    }\n\n                    r > 0 ? i.push({\n                      sum: u,\n                      max: c,\n                      min: d,\n                      first: p,\n                      last: f,\n                      count: r,\n                      avg: v ? u / r : null,\n                      change: f - p\n                    }) : i.push(null);\n                  }\n                } else i = this.series.map(function () {\n                  return null;\n                });\n\n                for (var C = [], x = this.series.length - 1; x >= 0; x--) {\n                  var w = this.series[x];\n                  C.push({\n                    name: w.name || \"\",\n                    values: i[x],\n                    config: w\n                  });\n                }\n\n                return {\n                  name: this.options.name,\n                  stack: this,\n                  config: this.options,\n                  data: C\n                };\n              }, t;\n            }();\n\n            t.Stack = e;\n          }(e = t.Series || (t.Series = {}));\n\n          var f = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e._computedValueAxisList = [], e._computedValueAxis = {}, e._computedSeries = [], e._computedStacks = {}, e.area = new N(), e.legend = new n(), e.valueAxisDefault = new u(), e.valueAxis = {}, e.chartTypes = {\n                columns: {\n                  type: \"columns\"\n                },\n                line: {\n                  type: \"line\"\n                },\n                candlestick: {\n                  type: \"candlestick\"\n                }\n              }, e.stacks = {}, e.seriesDefault = {\n                type: \"columns\"\n              }, e.series = [], e.info = new k(), e.events = new g(), e.interaction = new I(), e.localization = new A(), e.style = {\n                columnColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\"],\n                lineColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\"]\n              }, e;\n            }\n\n            return r(e, t), e.addSeparateSeries = function (t, e, i, n, r, s, a) {\n              var o = h.Helpers.extendCopy({}, t);\n              o.stack = r, o.id = \"series\" + h.Helpers.SeparatorChar + s, o.name = e, o.data = {\n                aggregation: n,\n                index: i\n              }, o.style = t.style, a.push(o);\n            }, e._hasSeriesSettingsChanged = function (t) {\n              return t.series || t.chartTypes || t.seriesDefault || t.stacks || t.style;\n            }, e.prototype.apply = function (i, n) {\n              var r = i.valueAxis;\n\n              if (r) {\n                var s = [{\n                  from: \"style.baseLineColor\",\n                  to: \"style.baseLine.lineColor\"\n                }, {\n                  from: \"style.baseLineWidth\",\n                  to: \"style.baseLine.lineWidth\"\n                }, {\n                  from: \"style.hgridLineColor\",\n                  to: \"style.hgrid.lineColor\"\n                }, {\n                  from: \"style.title.alignment\",\n                  to: \"style.title.align\"\n                }, {\n                  from: \"style.title.font\",\n                  to: \"style.title.textStyle.font\"\n                }, {\n                  from: \"style.title.fillColor\",\n                  to: \"style.title.textStyle.fillColor\"\n                }, {\n                  from: \"style.valueLabel.font\",\n                  to: \"style.valueLabel.textStyle.font\"\n                }, {\n                  from: \"style.valueLabel.fillColor\",\n                  to: \"style.valueLabel.textStyle.fillColor\"\n                }];\n\n                for (var a in r) {\n                  this.applyCompatibility(r[a], s, \"valueAxis[\" + a + \"]\");\n                }\n              }\n\n              this.applyCompatibility(i, [{\n                from: \"valueAxis.default\",\n                to: \"valueAxisDefault\"\n              }, {\n                from: \"valueAxisDefault.style.baseLineColor\",\n                to: \"valueAxisDefault.style.baseLine.lineColor\"\n              }, {\n                from: \"valueAxisDefault.style.baseLineWidth\",\n                to: \"valueAxisDefault.style.baseLine.lineWidth\"\n              }, {\n                from: \"valueAxisDefault.style.hgridLineColor\",\n                to: \"valueAxisDefault.style.hgrid.lineColor\"\n              }, {\n                from: \"valueAxisDefault.style.title.alignment\",\n                to: \"valueAxisDefault.style.title.align\"\n              }, {\n                from: \"valueAxisDefault.style.title.font\",\n                to: \"valueAxisDefault.style.title.textStyle.font\"\n              }, {\n                from: \"valueAxisDefault.style.title.fillColor\",\n                to: \"valueAxisDefault.style.title.textStyle.fillColor\"\n              }, {\n                from: \"valueAxisDefault.style.valueLabel.font\",\n                to: \"valueAxisDefault.style.valueLabel.textStyle.font\"\n              }, {\n                from: \"valueAxisDefault.style.valueLabel.fillColor\",\n                to: \"valueAxisDefault.style.valueLabel.textStyle.fillColor\"\n              }]);\n              var o = t.prototype.apply.call(this, i);\n\n              if (this._initializing || e._hasSeriesSettingsChanged(o)) {\n                this._initializing && !o.series && (o.series = []);\n                var l = this.series,\n                    c = [],\n                    d = null,\n                    p = 0;\n                this._computedStacks = h.Helpers.clone(this.stacks);\n\n                for (var f = 0; f < l.length; f++) {\n                  var g = l[f];\n                  if (!g.valueAxis || \"default\" === g.valueAxis || this.valueAxis[g.valueAxis]) {\n                    if (g.data && 0 === g.data.index) h.Helpers.error(\"Value `0` references the timestamp and cannot be used when specifying `series.data.index`.\");else if (g.data && 0 === g.data.countIndex) h.Helpers.error(\"Value `0` references the timestamp and cannot be used when specifying `series.data.countIndex`.\");else if (\"candlestick\" !== g.type || g.data && g.data.index) c.push(g);else {\n                      if (void 0 === g.stack || null === g.stack) {\n                        d = \"default\" + h.Helpers.SeparatorChar + p++;\n                        var v = new m();\n                        v.name = g.name, this._computedStacks[d] = v;\n                      }\n\n                      var y = g.data;\n\n                      if (null == y || null == y.high || null == y.low || null == y.open || null == y.close) {\n                        h.Helpers.error(\"Each candlestick series should define four data properties: low, high, open, close\");\n                        continue;\n                      }\n\n                      var S = g.localization;\n                      S || (S = this.chartTypes.candlestick.localization), S || (S = new x().localization), e.addSeparateSeries(g, S.high || \"high\", y.high, \"max\", d, p++, c), e.addSeparateSeries(g, S.open || \"open\", y.open, \"first\", d, p++, c), e.addSeparateSeries(g, S.close || \"close\", y.close, \"last\", d, p++, c), e.addSeparateSeries(g, S.low || \"low\", y.low, \"min\", d, p++, c);\n                    }\n                  } else h.Helpers.error(\"The series reference a non-existant value axis `\" + g.valueAxis + \"`.\");\n                }\n\n                this._computedSeries = h.SettingsHelper.mergeDefaultValues(c, this.seriesDefault, this.chartTypes, n.createInstance, n.getMapping, \"series\"), this.applySeriesColor(this._computedSeries);\n              }\n\n              if (this._initializing || o.valueAxis || o.valueAxisDefault || !this._computedValueAxisList.length) {\n                this._initializing && !o.valueAxis && (o.valueAxis = {});\n\n                for (var b = !1, C = 0; C < this._computedSeries.length; C++) {\n                  var w = this._computedSeries[C];\n                  b = b || \"default\" === w.valueAxis;\n                }\n\n                this._computedValueAxisList = [], this._computedValueAxis = {};\n                var L = this.valueAxisDefault;\n\n                for (var T in this.valueAxis) {\n                  var k = new u(),\n                      A = this.valueAxis[T];\n                  this.applyCompatibility(A, [{\n                    from: \"style.baseLineColor\",\n                    to: \"style.baseLine.lineColor\"\n                  }, {\n                    from: \"style.baseLineWidth\",\n                    to: \"style.baseLine.lineWidth\"\n                  }, {\n                    from: \"style.hgridLineColor\",\n                    to: \"style.hgrid.lineColor\"\n                  }]), h.SettingsHelper.updateRecursive(k, L, h.SettingsMapping.LinearChartSettingsValueAxis, {}, \"valueAxisDefault\"), h.SettingsHelper.updateRecursive(k, A, h.SettingsMapping.LinearChartSettingsValueAxis, {}, \"valueAxis[\" + T + \"]\"), k.id = T, this._computedValueAxis[T] = k, this._computedValueAxisList.push(k);\n                }\n\n                if (b && !this.valueAxis.default) {\n                  var M = h.Helpers.realClone(L);\n                  M.id = \"default\", this._computedValueAxis[M.id] = M, this._computedValueAxisList.push(M);\n                }\n\n                this._computedValueAxisList.sort(function (t, e) {\n                  return t.id.localeCompare(e.id);\n                });\n              }\n\n              return o;\n            }, e.prototype.applySeriesColor = function (t) {\n              for (var e = 0, i = 0, n = this.style.columnColors, r = this.style.lineColors, s = 0; s < t.length; s++) {\n                var a = t[s];\n                \"columns\" === a.type && null == a.style.fillColor ? (a.style.fillColor = n[e], e = (e + 1) % n.length) : \"line\" === a.type && null == a.style.lineColor && (a.style.lineColor = r[i], i = (i + 1) % r.length);\n              }\n            }, e;\n          }(h.Settings);\n\n          t.Settings = f;\n\n          var g = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.onAnimationDone = null, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsEvents);\n\n          t.SettingsEvents = g;\n\n          var m = function () {\n            return function () {\n              this.name = \"\", this.type = \"normal\", this.separateNegativeValues = null;\n            };\n          }();\n\n          t.SettingsStack = m;\n\n          var v = function () {\n            function t() {\n              this.id = null, this.enabled = !0, this.data = new S(), this.type = \"columns\", this.valueAxis = \"default\", this.name = null, this.nameLegend = null, this.showInLegend = !0, this.legendGroupId = null, this.stack = null, this.cluster = null, this.style = new y();\n            }\n\n            return t.getMapping = function (t, e) {\n              throw new Error(\"This method is abstract.\");\n            }, t.createInstance = function (t, e) {\n              throw new Error(\"This method is abstract.\");\n            }, t;\n          }();\n\n          t.SettingsSeries = v;\n\n          var y = function () {\n            return function () {\n              this.fillColor = null, this.lineColor = null, this.fillGradient = null, this.fillPattern = null, this._fillPatternOpacity = 1, this._currentFillStyleKey = null, this.lineDash = null, this.lineWidth = 1, this.shadowOffsetX = 1, this.shadowOffsetY = -1, this.shadowColor = null, this.legend = {\n                textColor: null,\n                marker: {\n                  shape: null\n                }\n              }, this.depth = 0;\n            };\n          }();\n\n          t.SettingsSeriesStyle = y;\n\n          var S = function () {\n            return function () {\n              this.source = \"default\", this.valueFunction = null, this.aggregation = \"sum\", this.aggregatedValueFunction = null, this.noDataPolicy = \"join\";\n            };\n          }();\n\n          t.SettingsSeriesData = S;\n\n          var b = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.valueLabels = {\n                enabled: !1,\n                style: {\n                  padding: 1,\n                  margin: 0,\n                  aspectRatio: 3,\n                  align: \"center\",\n                  textStyle: {\n                    fillColor: \"black\",\n                    font: \"12px Arial\"\n                  },\n                  backgroundStyle: {\n                    lineColor: \"rgba(255,255,255,0.4)\",\n                    fillColor: \"rgba(255,255,255,0.4)\"\n                  }\n                },\n                position: \"insideTopAuto\",\n                minFontSize: 7,\n                contentsFunction: null,\n                useStackedValue: null\n              }, e.style = new w(), e.type = \"columns\", e;\n            }\n\n            return r(e, t), e;\n          }(v);\n\n          t.SettingsSeriesColumns = b;\n\n          var C = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.valueLabels = {\n                enabled: !1,\n                style: {\n                  padding: 2,\n                  margin: 0,\n                  aspectRatio: 3,\n                  align: \"center\",\n                  textStyle: {\n                    fillColor: \"black\",\n                    font: \"12px Arial\"\n                  },\n                  backgroundStyle: {\n                    lineColor: \"rgba(255,255,255,0.4)\",\n                    fillColor: \"rgba(255,255,255,0.4)\"\n                  }\n                },\n                position: \"value\",\n                minFontSize: 7,\n                contentsFunction: null,\n                useStackedValue: null\n              }, e.style = new L(), e.type = \"line\", e;\n            }\n\n            return r(e, t), e;\n          }(v);\n\n          t.SettingsSeriesLines = C;\n\n          var x = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.style = new T(), e.localization = {\n                high: \"high\",\n                low: \"low\",\n                open: \"open\",\n                close: \"close\"\n              }, e.type = \"candlestick\", e;\n            }\n\n            return r(e, t), e;\n          }(v);\n\n          t.SettingsSeriesCandleStick = x;\n\n          var w = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.minHeight = 4, e.gradient = .8, e.fillGradientMode = null, e.fillGradientType = null, e.lineColor = \"\", e.padding = [3, 3], e.shadowBlur = 3, e.depth = 0, e.depthBrightness = .5, e.radius = [0, 0, 0, 0], e;\n            }\n\n            return r(e, t), e;\n          }(y);\n\n          t.SettingsSeriesColumnsStyle = w;\n\n          var L = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.shadowBlur = 5, e.smoothing = !1, e.steps = !1, e.marker = {\n                shape: null,\n                width: 10,\n                fillColor: null,\n                lineColor: null,\n                lineWidth: 1\n              }, e.markerStyleFunction = null, e;\n            }\n\n            return r(e, t), e;\n          }(y);\n\n          t.SettingsSeriesLinesStyle = L;\n\n          var T = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.pattern = \"candlestick\", e.padding = [1, 1], e.increase = {\n                bar: {\n                  lineColor: \"green\",\n                  shadowColor: null,\n                  lineDash: null,\n                  lineWidth: 1,\n                  shadowOffsetX: 1,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0\n                },\n                candlestick: {\n                  lineColor: \"#000\",\n                  shadowColor: null,\n                  lineDash: null,\n                  lineWidth: 1,\n                  shadowOffsetX: 1,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0,\n                  fillColor: \"yellow\"\n                }\n              }, e.decrease = {\n                bar: {\n                  lineColor: \"red\",\n                  shadowColor: null,\n                  lineDash: null,\n                  lineWidth: 1,\n                  shadowOffsetX: 1,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0\n                },\n                candlestick: {\n                  lineColor: \"#000\",\n                  shadowColor: null,\n                  lineDash: null,\n                  lineWidth: 1,\n                  shadowOffsetX: 1,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0,\n                  fillColor: \"black\"\n                }\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(y);\n\n          t.SettingsSeriesCandleStickStyle = T;\n\n          var k = function () {\n            return function () {\n              this.enabled = !0, this.showNoData = !0, this.position = \"inside\", this.valueFormatterFunction = null, this.aggregations = null, this.style = {\n                highlight: {\n                  fillColor: \"rgba(30,160,220,0.15)\",\n                  fadeIn: 200,\n                  fadeOut: 200\n                }\n              }, this.advanced = {\n                contentsFunction: null,\n                showOnlyHoveredSeries: !1,\n                scope: null,\n                showHeader: !0\n              };\n            };\n          }();\n\n          t.SettingsInfoPopup = k;\n\n          var A = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.valueUnits = {\n                K: 1e3,\n                M: 1e6,\n                B: 1e9,\n                T: 1e12,\n                P: 1e15\n              }, e.noDataLabel = \"No data\", e.unnamedSeries = \"Unnamed\", e.toolbar = new M(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLocalization);\n\n          t.SettingsLocalization = A;\n\n          var M = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.linButton = \"Lin\", e.logButton = \"Log\", e.linLogTitle = \"Switch lin/log scale\", e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLocalizationToolbar);\n\n          t.SettingsLocalizationToolbar = M;\n\n          var I = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.swipeSensitivity = .6, e.ignoreBottomAxis = !1, e.scrolling = new D(), e.zooming = new P(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsInteraction);\n\n          t.SettingsInteraction = I;\n\n          var P = function () {\n            return function () {\n              this.enabled = !0, this.wheel = !1, this.swipe = !0, this.fingers = !0, this.fingersMaxZoom = 10, this.sensitivity = 2, this.wheelSensitivity = 1.5, this.keyboardFactor = 2, this.upDownTreshold = 10, this.zoomHighlightThreshold = 1.5;\n            };\n          }();\n\n          t.SettingsInteractionZooming = P;\n\n          var D = function () {\n            return function () {\n              this.enabled = !0, this.swipePageFlipping = !0, this.keyboardScrollingFactor = 1, this.kineticFriction = 1e-6, this.maxAnimationLength = 1500;\n            };\n          }();\n\n          t.SettingsInteractionScrolling = D;\n\n          var N = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.style = new F(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsArea);\n\n          t.SettingsArea = N;\n\n          var F = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.noData = {\n                fillColor: \"#888\",\n                image: null\n              }, e.zoomHighlight = {\n                fillColor: \"rgba(30,160,220,0.15)\",\n                fadeIn: 100,\n                fadeOut: 500\n              }, e.zoomHighlightInactive = {\n                fillColor: \"rgba(30,160,220,0.08)\"\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsAreaStyle);\n\n          t.SettingsAreaStyle = F, function (e) {\n            var i = function (t) {\n              function e(e, i) {\n                var n,\n                    r = e.settings.localization.toolbar;\n                i.title = i.title || r.linLogTitle, i.label = i.label || r.linButton, n = t.call(this, e, i) || this;\n                var s = (i.cssClass || \"\") + \" DVSL-bar-btn DVSL-bar-btn-l\";\n                return n.linClass = s + \"in\", n.logClass = s + \"og\", n.logScale = n.chart.scene.settings.valueAxisDefault.logScale, n.updateElements(), n;\n              }\n\n              return r(e, t), e.prototype.onClick = function (e) {\n                this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, \"user\"), t.prototype.onClick.call(this, e);\n              }, e.prototype.updateElements = function () {\n                var t = this.chart.settings.localization.toolbar,\n                    e = this.logScale;\n                this.a.className = e ? this.logClass : this.linClass, !1 !== this.options.showLabel && (this.p.innerHTML = e ? t.logButton : t.linButton);\n              }, e.prototype.onSceneChange = function (t) {\n                var e = this.chart.scene.settings.valueAxisDefault.logScale;\n                t.settings && e !== this.logScale && (this.logScale = e, this.updateElements());\n              }, e;\n            }(h.Bar.Button);\n\n            e.LinLogButton = i, h.Bar.ToolbarItemNames.logScale = function (e, i) {\n              return new t.Bar.LinLogButton(e, i);\n            };\n          }(t.Bar || (t.Bar = {}));\n\n          var O = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.enabled = !0, e.export = !0, e.back = !0, e.zoomOut = !0, e.logScale = !0, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsToolbar);\n\n          t.SettingsToolbar = O;\n\n          var E = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 1e3, i.chart = null, i.scene = null, i.events = null, i.pointer1 = null, i.pointer2 = null, i.t1 = 0, i.t2 = 0, i.x1 = 0, i.x2 = 0, i.scaleOrigin = null, i.initialZoom = null, i.dragStartFrom = null, i.dragStartTo = null, i.active = !1, i.lastScrollingY = 0, i.scrollingActive = !1, i.scalingActive = 0, i.hadSecondPointer = !1, i.wheelOrigin = null, i.wheelProportion = null, i.highlight = null, i.highlightRemoveWhenDone = !1, i._animationsDone = !0, i.chart = e, i.scene = e.scene, i.events = e.events, i._settings = e.settings.interaction, i.inertiaF = new h.Inertia(1, 0, !0), i.inertiaT = new h.Inertia(1, 0, !0), i;\n            }\n\n            return r(e, t), e.prototype.getVisibleRange = function () {\n              return this._currentTo - this._currentFrom;\n            }, e.prototype.onZoomOut = function (t, e, i, n) {\n              return null == n && (n = 2), {\n                from: i - (i - t) * n,\n                to: i + (e - i) * n,\n                center: i\n              };\n            }, e.prototype.onZoomIn = function (t, e, i, n) {\n              return void 0 === n && (n = .5), null == n && (n = .5), {\n                from: i - (i - t) * n,\n                to: i + (e - i) * n,\n                center: i\n              };\n            }, e.prototype.onScroll = function (t, e, i) {\n              return \"<\" === i ? {\n                from: 2 * t - e,\n                to: t\n              } : {\n                from: e,\n                to: 2 * e - t\n              };\n            }, e.prototype.onGoHome = function (t, e) {\n              return {\n                from: t,\n                to: e,\n                origin: e\n              };\n            }, e.prototype.getFrom = function (t) {\n              return null == t || t === 1 / 0 ? this.inertiaF.getTargetValue() : this.inertiaF.getValue(t);\n            }, e.prototype.getTo = function (t) {\n              return null == t || t === 1 / 0 ? this.inertiaT.getTargetValue() : this.inertiaT.getValue(t);\n            }, e.prototype.setFrom = function (t, e, i, n) {\n              void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaF.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentFrom = t, this.inertiaF.jump(t));\n            }, e.prototype.setTo = function (t, e, i, n) {\n              void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaT.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentTo = t, this.inertiaT.jump(t));\n            }, e.prototype.onWheel = function (t) {\n              if (null === this.pointer1) {\n                var e = this.getFrom(),\n                    i = this.getTo();\n\n                if (!(e >= i)) {\n                  var n = this._settings;\n\n                  if (n.zooming.wheel && n.zooming.enabled && this.xyInArea(t.x, t.y)) {\n                    this.active = !0;\n                    var r = this.wheelOrigin;\n                    null === r && (this.wheelOrigin = this.scaleOrigin = r = this.xyToPosition(t.x, t.y), this.wheelProportion = (r - e) / (i - e), this.x1 = t.x);\n                    var s = this.wheelProportion,\n                        a = Math.pow(Math.max(1.1, n.zooming.wheelSensitivity), .004 * t.wheely);\n                    i = r + (i - (e = r - (i - e) * s * a)) * (1 - s) * a;\n                    var o = t.wheely < 0 ? 1 : -1,\n                        l = h.Helpers.performanceNow();\n                    this.handleZoomWheel(e, i, r, l, o), t.consumed = !0, this.active = !1;\n                  }\n                }\n              }\n            }, e.prototype.onPointerDown = function (t) {\n              this.wheelOrigin = null;\n              var e = this._settings;\n\n              if (this.xyInArea(t.x, t.y) && (e.scrolling.enabled || e.zooming.enabled)) {\n                var i = this.xyToPosition(t.x, t.y),\n                    n = h.Helpers.performanceNow(),\n                    r = this.getFrom(n),\n                    s = this.getTo(n);\n\n                if (r > s) {\n                  var a = s;\n                  s = r, r = a;\n                }\n\n                null === this.pointer1 ? (this.pointer1 = t.identifier, this.x1 = t.x, this.t1 = i, this.scaleOrigin = i, this.onStartDragging(r, s, i), this.lastScrollingY = t.y, this.dragStartFrom = r, this.dragStartTo = s, this.dragCurFrom = r, this.dragCurTo = s, t.consumed = !0, this.inertiaF.finished(n) && this.inertiaT.finished(n) || (this.setFrom(r), this.setTo(s), this.stopAnimations(), this.scrollingActive = !0), this.chart.cancelChartUpdateNotify(), t.consumed = !0) : null === this.pointer2 ? (this.pointer2 = t.identifier, this.x2 = t.x, this.t2 = i, this.initialZoom = s - r, this.scaleOrigin = (this.t1 + this.t2) / 2, t.consumed = !0) : (this.scalingActive || this.scrollingActive) && (t.consumed = !0);\n              }\n            }, e.prototype.xyToDragPosition = function (t, e) {\n              return this.dragCurFrom + (t - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom);\n            }, e.prototype.scaleViewRange = function (t, e, i) {\n              var n = Math.pow(1 + this._settings.zooming.sensitivity, -t.dy / this.scene.height);\n              return {\n                from: e = (e - this.scaleOrigin) * n + this.scaleOrigin,\n                to: i = (i - this.scaleOrigin) * n + this.scaleOrigin\n              };\n            }, e.prototype.onPointerMove = function (t) {\n              null !== this.wheelOrigin && Math.abs(this.x1 - t.x) > this._settings.zooming.sensitivity && (this.wheelOrigin = null);\n            }, e.prototype.onPointerDrag = function (t) {\n              var e = this.dragCurFrom,\n                  i = this.dragCurTo,\n                  n = this._settings;\n\n              if (t.identifier === this.pointer1 && null === this.pointer2) {\n                this.scaleOrigin = this.t1, this.x1 = t.x;\n                var r = t.y - this.lastScrollingY;\n\n                if (Math.abs(t.dx) > 4 * Math.abs(t.dy) && n.scrolling.enabled && (this.scrollingActive = !0), !this.hadSecondPointer && (n.zooming.enabled && n.zooming.swipe && Math.abs(r) > n.zooming.upDownTreshold ? this.scalingActive = r > 0 ? 1 : -1 : this.scalingActive = 0, this.scalingActive)) {\n                  this.clearZoomHighlight();\n                  var s = this.scaleViewRange(t, e, i);\n                  e = s.from, i = s.to, t.consumed = !0;\n                }\n\n                if (this.scrollingActive) {\n                  var a = this.xyToDragPosition(t.x, t.y),\n                      o = this.t1 - a;\n                  e += o, i += o;\n                }\n              } else if (t.identifier === this.pointer1 && n.scrolling.enabled) {\n                this.x1 = t.x, this.clearZoomHighlight(), e = (l = this.twoPointerDrag()).from, i = l.to;\n              } else {\n                if (t.identifier !== this.pointer2 || !n.scrolling.enabled) return void ((this.scalingActive || this.scrollingActive) && (t.consumed = !0));\n                var l;\n                this.x2 = t.x, this.clearZoomHighlight(), e = (l = this.twoPointerDrag()).from, i = l.to;\n              }\n\n              this.dragCurFrom = e, this.dragCurTo = i;\n              var h = this.onSnapWhileDragging(e, i, this.scaleOrigin, this.scrollingActive, this.scalingActive);\n              this.goToPositionDragging(h.from, h.to), t.consumed = !0;\n            }, e.prototype.twoPointerDrag = function () {\n              var t = this._settings,\n                  e = t.zooming.fingersMaxZoom;\n              this.scaleOrigin = (this.t1 + this.t2) / 2;\n              var i = this.t2 - this.t1,\n                  n = this.dragCurFrom,\n                  r = this.dragCurTo,\n                  s = this.xyToDragPosition(this.x1, 0),\n                  a = this.xyToDragPosition(this.x2, 0);\n\n              if (t.scrolling.enabled && t.zooming.enabled && t.zooming.fingers && 0 !== i) {\n                var o = this.initialZoom,\n                    l = ((s + a) / 2 - this._currentFrom) / (this._currentTo - this._currentFrom),\n                    h = (a - s) / (this._currentTo - this._currentFrom),\n                    u = void 0;\n                u = i * h > 0 ? i / h : 1 / 0;\n                var c = o * e,\n                    d = o / e;\n                u = Math.max(d, Math.min(c, u)), n = this.scaleOrigin - l * u, r = this.scaleOrigin + (1 - l) * u, this.scalingActive = u < o ? 1 : -1, this.scrollingActive = !0, this.hadSecondPointer = !0;\n              } else if (t.scrolling.enabled) {\n                var p = (this.t1 + this.t2) / 2 - (s + a) / 2;\n                n += p, r += p, this.scrollingActive = !0;\n              }\n\n              return {\n                from: n,\n                to: r\n              };\n            }, e.prototype.onPointerUp = function (t) {\n              var e = this._settings,\n                  i = h.Helpers.performanceNow(),\n                  n = this.scrollingActive,\n                  r = this.scalingActive;\n              if (t.identifier === this.pointer2) this.pointer2 = null, t.consumed = !0, this.scaleOrigin = this.t1;else if (t.identifier === this.pointer1 && null !== this.pointer2) this.pointer1 = this.pointer2, this.pointer2 = null, this.t1 = this.t2, this.scaleOrigin = this.t1, t.consumed = !0;else if (t.identifier === this.pointer1) {\n                this.pointer1 = null, this.active = !0;\n                var s = void 0,\n                    a = void 0,\n                    o = void 0;\n                if (e.scrolling.enabled) o = (o = (o = -t.vx) > 0 ? Math.min(o, .002 * this.scene.width) : Math.max(o, .002 * -this.scene.width)) * this.getVisibleRange() / this.scene.width;else o = 0;\n\n                if (this.updateFriction(i), this.inertiaF.jump(this._currentFrom, o, i), this.inertiaT.jump(this._currentTo, o, i), this._animationsDone = !1, e.scrolling.swipePageFlipping && t.swipeUp && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {\n                  var l = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);\n                  s = l.from, a = l.to;\n                } else if (e.scrolling.swipePageFlipping && t.swipeDown && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {\n                  var u = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);\n                  s = u.from, a = u.to;\n                } else if (n || r) {\n                  if (n && !r && e.scrolling.swipePageFlipping && (t.swipeLeft || t.swipeRight) && t.swipeSpeed > this.scene.width / e.swipeSensitivity * .7) {\n                    var c = t.swipeLeft ? \"<\" : \">\",\n                        d = this.onScroll(this.dragStartFrom, this.dragStartTo, c);\n                    s = d.from, a = d.to;\n                  } else s = this._currentFrom, a = this._currentTo;\n\n                  this.scaleOrigin = (s + a) / 2;\n                }\n\n                if (s || a) {\n                  var p = this.onSnapAfterDragging(this.inertiaF.getTargetValue(), this.inertiaT.getTargetValue(), this.scaleOrigin, n || 0 !== r, r);\n                  p && this.goToPosition(p.from, p.to, !0, i, !1), t.consumed = !0, this.scaleOrigin = null;\n                }\n\n                this.hadSecondPointer = !1, this.active = !1, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1;\n              } else (r || n) && (t.consumed = !0);\n            }, e.prototype.onPointerCancel = function (t) {\n              t.identifier === this.pointer2 ? (this.pointer2 = null, this.scaleOrigin = this.t1) : t.identifier === this.pointer1 && null !== this.pointer2 ? (this.pointer1 = this.pointer2, this.t1 = this.t2, this.scaleOrigin = this.t1, this.pointer2 = null, this.t2 = null) : t.identifier === this.pointer1 && (this.active = !0, this.pointer1 = null, this.t1 = null, this.scaleOrigin = null, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1, this.active = !1, this.hadSecondPointer = !1);\n            }, e.prototype.onKeyDown = function (t) {}, e.prototype.goToPositionDragging = function (t, e) {\n              this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e);\n            }, e.prototype.goToPosition = function (t, e, i, n, r) {\n              if (t < e) if (this._currentFrom < this._currentTo || (i = !1), this.stopAnimations(), i) {\n                var s = this._settings.zooming.zoomHighlightThreshold,\n                    a = this._currentFrom,\n                    o = this._currentTo;\n                this.updateFriction(n, t, e), this.setFrom(t, !0, n, r), this.setTo(e, !0, n, r);\n                var l = Math.abs((t - e) / (a - o + 1));\n                if (l < 1 / s) this.setZoomHighlight(t, e, !0);else if (l > s) {\n                  var h = null !== this.dragStartFrom ? this.dragStartFrom : a,\n                      u = null !== this.dragStartTo ? this.dragStartTo : o;\n                  this.setZoomHighlight(h, u, !1);\n                }\n                this.events.notifySceneChanges({\n                  requestPaint: !0\n                });\n              } else this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e), this.onAnimationDone(t, e), this._animationsDone = !0;\n            }, e.prototype.doAnimations = function (t) {\n              if (!this._animationsDone) {\n                var e = t.timeStamp,\n                    i = this.inertiaF.finished(e),\n                    n = this.inertiaT.finished(e);\n                this._animationsDone = i && n;\n                var r = this._currentFrom = this.getFrom(e),\n                    s = this._currentTo = this.getTo(e);\n                this._animationsDone || isNaN(r + s) ? (this.stopAnimations(), this.onPositionChanged(r, s, !1), this.onAnimationDone(r, s)) : (this.onPositionChanged(r, s, !0), t.animating = !0);\n              }\n            }, e.prototype.stopAnimations = function () {\n              this.highlight && (this.highlightRemoveWhenDone ? this.clearZoomHighlight() : (this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor, this.events.notifySceneChanges({\n                highlight: !0\n              })));\n            }, e.prototype.abort = function () {\n              this.isActive() && (this.pointer2 && this.onPointerCancel({\n                identifier: this.pointer2\n              }), this.pointer1 && this.onPointerCancel({\n                identifier: this.pointer1\n              }), this.setFrom(this._currentFrom), this.setTo(this._currentTo), this.clearZoomHighlight(), this._animationsDone = !0);\n            }, e.prototype.isActive = function () {\n              return this.active || null != this.pointer1 || !this._animationsDone;\n            }, e.prototype.clearZoomHighlight = function () {\n              this.highlight && (this.scene.removeHighlight(\"zoomTrace\"), this.highlight = null, this.events.notifySceneChanges({\n                highlight: !0\n              }));\n            }, e.prototype.setZoomHighlight = function (t, e, i) {\n              this.highlight = this.scene.setHighlight(\"zoomTrace\", t, e, this.scene.settings.area.style.zoomHighlight), this.highlightRemoveWhenDone = i, this.events.notifySceneChanges({\n                highlight: !0\n              });\n            }, e.prototype.updateFriction = function (t, e, i) {\n              var n = this.getVisibleRange();\n\n              if (null != e && null != i) {\n                var r = i - e,\n                    s = .7 * n > r,\n                    a = 1.3 * n < r;\n                a && (n = r), (s || a) && (n *= 2);\n              }\n\n              var o = n * this._settings.scrolling.kineticFriction;\n              this.inertiaF.setAcceleration(o, t), this.inertiaT.setAcceleration(o, t);\n            }, e;\n          }(h.ChartElement);\n\n          t.Scrolling = E;\n\n          var R = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.highlights = {}, e.seriesWithLabels = 0, e.dataLabels = {\n                spots: {},\n                fontWidths: Object.create(null),\n                metaData: {\n                  availableWidth: 0,\n                  processed: 0,\n                  styles: null\n                }\n              }, e.bottomAxisSize = 0, e;\n            }\n\n            return r(e, t), e.prototype.xyInChart = function (t, e) {\n              return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height;\n            }, e.prototype.xyInChartOrBottom = function (t, e) {\n              var i = this.settings.interaction.ignoreBottomAxis ? 0 : this.bottomAxisSize;\n              return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height + i;\n            }, e.prototype.xyInBottom = function (t, e) {\n              return !this.settings.interaction.ignoreBottomAxis && t >= this.x0 && t < this.x0 + this.width && e >= this.y0 + this.height && e < this.y0 + this.height + this.bottomAxisSize;\n            }, e.prototype.timeToX = function (t) {\n              throw \"Need to implement timeToX\";\n            }, e.prototype.xToTime = function (t) {\n              throw \"Need to implement xToTime\";\n            }, e.prototype.setHighlight = function (t, e, i, n) {\n              var r = this.highlights[t];\n              return r ? (r.from = e, r.to = i, r.style = n, r.removed = !1) : (r = {\n                from: e,\n                to: i,\n                style: n,\n                removed: !1\n              }, this.highlights[t] = r), r;\n            }, e.prototype.removeHighlight = function (t) {\n              var e = this.highlights[t];\n              e && (e.removed = !0, delete this.highlights[t]);\n            }, e;\n          }(h.Scene);\n\n          t.Scene = R;\n\n          var H = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 45, i.updateOrder = 700, i.scene = null, i.customId = 0, i.animating = !1, i.highlights = {}, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.prototype.doAnimations = function (t) {\n              if (t.changes.highlight) {\n                var e = [];\n\n                for (var i in this.highlights) {\n                  (r = this.highlights[i]).exiting = !0, r.origin.removed && (delete this.highlights[i], r.animator = null, e.push(r));\n                }\n\n                for (var n = 0; n < e.length; n++) {\n                  var r = e[n];\n                  this.highlights[\"__\" + ++this.customId] = r;\n                }\n\n                for (var i in this.scene.highlights) {\n                  var s = this.scene.highlights[i];\n\n                  if (this.highlights[i]) {\n                    (r = this.highlights[i]).exiting = !1, r.from = s.from, r.to = s.to, r.style = h.Helpers.clone(s.style);\n                  } else {\n                    r = {\n                      from: s.from,\n                      to: s.to,\n                      style: h.Helpers.clone(s.style),\n                      animator: null,\n                      exiting: !1,\n                      origin: s\n                    };\n                    this.highlights[i] = r, s.style.fadeIn > 0 && (this.animating = !0, r.animator = new h.ColorAnimator(h.Colors.derive(h.Colors.parse(r.style.fillColor), 1, 0), r.style.fillColor, r.style.fadeIn, \"=\", t.timeStamp));\n                  }\n                }\n\n                for (var i in this.highlights) {\n                  if ((r = this.highlights[i]).exiting && !r.animator) {\n                    var a = r.style;\n                    a.fadeOut > 0 ? (this.animating = !0, r.animator = new h.ColorAnimator(a.fillColor, h.Colors.derive(h.Colors.parse(a.fillColor), 1, 0), a.fadeOut, \"=\", t.timeStamp)) : delete this.highlights[i];\n                  }\n                }\n              }\n\n              if (this.animating) {\n                var o = !1,\n                    l = t.timeStamp;\n\n                for (var i in this.highlights) {\n                  (r = this.highlights[i]).animator && (r.style.fillColor = r.animator.get(l), r.animator.finished(l) ? (r.animator = null, r.exiting && delete this.highlights[i]) : o = !0);\n                }\n\n                this.animating = o, t.animating = t.animating || o;\n              }\n            }, e.prototype.paintScene = function (t) {\n              var e = this.scene.x0,\n                  i = e + this.scene.width,\n                  n = Math.round(this.scene.y0),\n                  r = this.scene.height,\n                  s = t.context;\n\n              for (var a in this.highlights) {\n                var o = this.highlights[a],\n                    l = Math.max(this.scene.timeToX(o.from), e),\n                    u = Math.min(this.scene.timeToX(o.to), i);\n                u < e || l > i || (h.Graphics.rectStyle(s, o.style), s.fillRect(l, n, u - l, r));\n              }\n            }, e;\n          }(h.ChartElement);\n\n          t.Highlights = H;\n\n          var B = function (t) {\n            function e(e) {\n              var i = t.call(this, e) || this;\n              return i.rightAxis = null, i.leftAxis = null, i.timeAxisPanel = null, i;\n            }\n\n            return r(e, t), e.prototype.createDom = function (e) {\n              t.prototype.createDom.call(this, e), this.timeAxisPanel = h.Helpers.createDom(\"div\", \"DVSL-TC-timeAxis\", null, this.backgroundContainer), h.DomLayer.setContainerStyle(this.timeAxisPanel), this.leftAxis = h.Helpers.createDom(\"div\", \"DVSL-valueAxis\", null, this.backgroundContainer), h.DomLayer.setContainerStyle(this.leftAxis), this.rightAxis = h.Helpers.createDom(\"div\", \"DVSL-valueAxis\", null, this.backgroundContainer), h.DomLayer.setContainerStyle(this.rightAxis);\n            }, e.prototype.doAnimations = function (e) {\n              t.prototype.doAnimations.call(this, e), e.changes.bounds && (this.background.style.left = this.scene.x0 + \"px\", this.background.style.right = this.scene.chartWidth - (this.scene.x0 + this.scene.width) + \"px\", this.leftAxis.style.width = this.scene.leftMargin + \"px\", this.leftAxis.style.bottom = this.scene.bottomMargin + \"px\", this.rightAxis.style.width = this.scene.rightMargin + \"px\", this.rightAxis.style.bottom = this.scene.bottomMargin + \"px\", this.timeAxisPanel.style.top = this.scene.y0 + this.scene.height + \"px\", this.timeAxisPanel.style.left = this.scene.x0 + \"px\", this.timeAxisPanel.style.width = this.scene.width + \"px\", this.outerBorder.style.left = this.scene.x0 + \"px\", this.outerBorder.style.width = this.scene.width + \"px\");\n            }, e;\n          }(h.DomLayer);\n\n          t.DomLayer = B;\n\n          var z = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e, i, n) || this;\n              return r.scrolling = null, r.renderer = null, r;\n            }\n\n            return r(e, t), e.prototype.createDomLayer = function () {\n              return new B(this);\n            }, e.prototype.notifyAnimationDone = function () {\n              var t = this;\n              window.setTimeout(function () {\n                t.removed || t.dispatchEventParams(\"animationDone\", t.createEventArguments(null, \"api\"), null);\n              }, 0);\n            }, e.prototype.processChangedSettings = function (t) {\n              var e = t.settingsChanges;\n              e && (f._hasSeriesSettingsChanged(e) && (t.linearChartSeries = !0), (e.valueAxis || e.valueAxisDefault) && (t.linearChartValueAxis = !0));\n            }, e.prototype.updateSettings = function (e, i) {\n              t.prototype.updateSettings.call(this, e, i);\n            }, e.prototype.setLogScale = function (t, e) {\n              var i = {};\n\n              for (var n in this.settings.valueAxis) {\n                i[n] = {\n                  logScale: t\n                };\n              }\n\n              this.updateSettings({\n                valueAxisDefault: {\n                  logScale: t\n                },\n                valueAxis: i\n              }, e);\n            }, e.prototype.finalInitialize = function () {\n              t.prototype.finalInitialize.call(this), this.legend = this.events.addElement(new l(this));\n            }, e.prototype.getEnabledSeries = function () {\n              for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) {\n                e[i].enabled && t.push(e[i]);\n              }\n\n              return t;\n            }, e.prototype.getSeries = function () {\n              for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) {\n                t.push(e[i]);\n              }\n\n              return t;\n            }, e;\n          }(h.Impl);\n\n          t.Impl = z;\n\n          var U = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 10, i.t0 = 0, i.t1 = 0, i.object = null, i.activePointer = null, i.pointerX = 0, i.pointerY = 0, i.chart = e, i.container = e.shell.interactiveContainer, i.scene = e.scene, i.events = e.events, i.popup = new h.InfoPopup(i.chart), i.settings = e.scene.settings.info, i;\n            }\n\n            return r(e, t), e.prototype.getPopupAreaMouseMoved = function (t, e) {\n              return null;\n            }, e.prototype.buildHeader = function (t, e) {\n              return \"\";\n            }, e.prototype.show = function (t) {\n              this.settings.enabled && (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t));\n            }, e.prototype.previewPointerMove = function (t) {\n              !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t));\n            }, e.prototype.previewPointerDrag = function (t) {\n              !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.activePointer = t.identifier, this.pointerX = t.x, this.pointerY = t.y);\n            }, e.prototype.previewPointerCancel = function (t) {\n              null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n            }, e.prototype.previewPointerUp = function (t) {\n              null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n            }, e.prototype.previewPointerOut = function (t) {\n              !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || t.touch || (this.activePointer = null, this.pointerX = null, this.pointerY = null, h.Helpers.isParentOf(this.popup.popup, t.target) || this.hideInfoPopup(t));\n            }, e.prototype.previewRightClick = function (t) {\n              this.settings.enabled && t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t));\n            }, e.prototype.previewPointerDown = function (t) {\n              this.settings.enabled && null === this.activePointer && (this.activePointer = t.identifier, this.hideInfoPopup(t));\n            }, e.prototype.updatePopup = function (t) {\n              if (this.pointerX || this.pointerY) {\n                var e = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);\n                e ? this.showInfoPopup(e.t0, e.t1, e.obj, e.contents, t) : this.hideInfoPopup(t);\n              } else this.hideInfoPopup(t);\n            }, e.prototype.manualShowInfoPopup = function (t, e, i) {\n              this.showInfoPopup(t, e, null, i || this.buildContent(t, e, null, null), null);\n            }, e.prototype.showInfoPopup = function (t, e, i, n, r) {\n              if (!this.popup.visible || t !== this.t0 || e !== this.t1 || i !== this.object || this.contents !== n) {\n                var s = this.scene,\n                    a = this.settings;\n                this.t0 = t, this.t1 = e, this.object = i, this.contents = n, s.setHighlight(\"infoRange\", t, e, a.style.highlight), this.popup.show(s.timeToX(this.t0), s.timeToX(this.t1), s.y0, n, h.InfoPopupPosition[a.position]), this.notifyChanges(r);\n              }\n            }, e.prototype.notifyChanges = function (t) {\n              t ? (t.changes.infoLabel = !0, t.changes.highlight = !0) : this.events.notifySceneChanges({\n                infoLabel: !0,\n                highlight: !0\n              });\n            }, e.prototype.hideInfoPopup = function (t) {\n              this.popup.visible && (this.popup.hide(), this.t0 = 0, this.t1 = 0, this.scene.removeHighlight(\"infoRange\"), this.notifyChanges(t));\n            }, e.prototype.paintScene = function (t) {\n              this.popup.visible && this.updateXY();\n            }, e.prototype.updateXY = function () {\n              var t = this.scene;\n              this.popup.updateXY(t.timeToX(this.t0), t.timeToX(this.t1), t.y0, h.InfoPopupPosition[t.settings.info.position]);\n            }, e.prototype.getPopupMouseMoved = function (t, e, i, n, r, s) {\n              if (this.scene.displayUnit && !this.scene.xyInChartOrBottom(t, e)) return null;\n              var a = this.getPopupAreaMouseMoved(t, e);\n              if (!a) return null;\n              var o = a.t0,\n                  l = a.t1,\n                  h = null,\n                  u = null,\n                  c = this.scene.hoverSeriesItem,\n                  d = this.settings.advanced.scope,\n                  p = o,\n                  f = l;\n              return c && (u = c.seriesIndex, (\"stack\" === d || \"value\" === d || \"auto\" === d && void 0 !== u && null !== u) && (p = this.scene.xToTime(c.x0), f = this.scene.xToTime(c.x1)), h = c.stack), null === p ? null : p === i && f === n && u === r ? {\n                t0: i,\n                t1: n,\n                obj: r,\n                contents: s\n              } : {\n                t0: p,\n                t1: f,\n                obj: u,\n                contents: this.buildContent(o, l, u, h)\n              };\n            }, e.prototype.getContentsFunctionRange = function (t, e) {\n              return [t, e];\n            }, e.prototype.buildContent = function (t, e, i, n) {\n              var r,\n                  s = this.settings.advanced,\n                  a = this.chart.renderer.exportData(t, e);\n\n              if (s.contentsFunction) {\n                var o = null;\n                null !== i && this.scene.settings._computedSeries.length > i && (o = this.scene.settings._computedSeries[i]), r = s.contentsFunction.call(this.chart.api, a, o, this.getContentsFunctionRange(t, e));\n              } else r = this.buildValues(a, i, n);\n\n              return s.showHeader ? this.buildHeader(t, e) + r : r;\n            }, e.prototype.buildValues = function (t, e, i) {\n              var n = this.chart.settings,\n                  r = {},\n                  s = 0;\n\n              for (var a in n.valueAxis) {\n                if (n.valueAxis[a].valueFormat) {\n                  var o = h.Helpers.matchPercentFormat(n.valueAxis[a].valueFormat);\n                  r[a] = o, s++;\n                }\n              }\n\n              var l = void 0;\n              n.valueAxisDefault && n.valueAxisDefault.valueFormat && (l = h.Helpers.matchPercentFormat(n.valueAxisDefault.valueFormat));\n              var u = {},\n                  c = 0;\n\n              for (var a in n.valueAxis) {\n                if (n.valueAxis[a].valueFormat) {\n                  o = h.Helpers.matchCurrencyFormat(n.valueAxis[a].valueFormat);\n                  u[a] = o, c++;\n                }\n              }\n\n              var d = void 0;\n              n.valueAxisDefault && n.valueAxisDefault.valueFormat && (d = h.Helpers.matchCurrencyFormat(n.valueAxisDefault.valueFormat));\n\n              for (var p = n.localization.noDataLabel, f = n.info.valueFormatterFunction, g = n.info.advanced.showOnlyHoveredSeries ? n.info.advanced.scope : null, m = i && (\"stack\" === g || \"value\" === g) || \"auto\" === g && void 0 !== e && null !== e, v = \"value\" === g, y = \"\", S = !1, C = 0; C < t.length; C++) {\n                var x = t[C];\n\n                if (m) {\n                  for (var w = !1, L = 0; L < x.data.length; L++) {\n                    (k = x.data[L]).config.showInLegend && (k.values || n.info.showNoData) && (w = w || null !== e && k.config === n._computedSeries[e] || i === x.stack);\n                  }\n\n                  if (!w) continue;\n                }\n\n                var T = t.length + x.data.length === 2 ? \"\" : n.localization.unnamedSeries;\n                x.name && (S && (y += \"</table>\", S = !1), x.data.length > 1 ? y += \"<h3>\" + x.name + \"</h3>\" : T = x.name), S || (y += '<table cellspacing=\"0\">', S = !0);\n\n                for (L = 0; L < x.data.length; L++) {\n                  var k = x.data[L],\n                      A = null !== e && k.config === this.scene.settings._computedSeries[e];\n\n                  if (k.config.showInLegend && (k.values || n.info.showNoData) && (!v || A)) {\n                    y += \"<tr><td\";\n                    var M = void 0,\n                        I = void 0,\n                        P = k.config;\n                    if (n instanceof b ? (M = P.style.fillColor, I = P.style.lineColor) : (M = P.style.lineColor, I = P.style.fillColor), M && \"transparent\" !== M || (M = I), M && (y += ' data-color=\"' + M + '\"'), A && (y += \" data-selected\"), y += \">\", y += k.name || T, y += \"</td><td>\", f) y += f.call(this.chart.api, k.values, k.config);else if (s > 0 || l || c > 0 || d) {\n                      if (k.values) {\n                        var D = P.data.aggregation ? k.values[P.data.aggregation] : k.values.sum;\n                        y += r[k.config.valueAxis] ? h.Helpers.printPercentValue(D, r[k.config.valueAxis]) : l ? h.Helpers.printPercentValue(D, l) : u[k.config.valueAxis] ? h.Helpers.printCurrencyValue(D, u[k.config.valueAxis]) : d ? h.Helpers.printPercentValue(D, d) : h.Helpers.numberFormat(D);\n                      } else y += n.localization.noDataLabel;\n                    } else if (k.values) {\n                      if (k.values.count > 1 && n.info.aggregations && n.info.aggregations.length > 0) for (var N = 0; N < n.info.aggregations.length; N++) {\n                        var F = n.info.aggregations[N];\n                        y += h.Helpers.numberFormat(k.values[F]) + \"&nbsp;(\" + F + \")\";\n                      } else y += P.data.aggregation ? h.Helpers.numberFormat(k.values[P.data.aggregation]) : h.Helpers.numberFormat(k.values.sum);\n                    } else y += p;\n                    y += \"</td></tr>\";\n                  }\n                }\n              }\n\n              return S && (y += \"</table>\"), y;\n            }, e.prototype.remove = function () {\n              this.popup.remove();\n            }, e;\n          }(h.ChartElement);\n\n          t.InfoPopup = U;\n\n          var G = function () {\n            function t(t, e) {\n              if (this.axisConfigList = e, this.chart = t, this.axis = Object.create(null), 0 !== e.length) for (var i = !1, n = 0; n < e.length; n++) {\n                var r = e[n];\n                this.axis[r.id] = new d(t, r), !i && r.enabled && (i = !0, this.axis[r.id].isPrimary = !0);\n              }\n            }\n\n            return t.prototype.getAxis = function (t) {\n              return this.axis[t];\n            }, t.prototype.getPanels = function (t) {\n              for (var e = [], i = 0; i < this.axisConfigList.length; i++) {\n                var n = this.axisConfigList[i],\n                    r = this.axis[n.id].getPanel();\n                (r || t) && e.push(r);\n              }\n\n              return e;\n            }, t.prototype.setPanels = function (t) {\n              for (var e = 0; e < this.axisConfigList.length; e++) {\n                var i = this.axisConfigList[e];\n                this.axis[i.id].setPanel(t[e]);\n              }\n            }, t.prototype.updateMinMax = function (t) {\n              for (var e in this.axis) {\n                this.axis[e].updateMinMax(t);\n              }\n            }, t.prototype.doAnimations = function (t) {\n              for (var e in this.axis) {\n                this.axis[e].doAnimations(t);\n              }\n            }, t.prototype.paintUnder = function (t) {\n              for (var e in this.axis) {\n                this.axis[e].paintUnder(t);\n              }\n            }, t.prototype.paint = function (t) {\n              for (var e in this.axis) {\n                this.axis[e].paint(t);\n              }\n            }, t;\n          }();\n\n          t.ValueAxisSet = G, function (t) {\n            var e = function () {\n              function e(t, e) {\n                this.stacks = [], this.idToStack = {}, this.paddingSum = 0, this.scene = e, this.chart = t;\n              }\n\n              return e.prototype.addSeries = function (e, i, n, r) {\n                var s;\n\n                if (i.stack) {\n                  var a = i.stack + \"#\" + i.type;\n                  (s = this.idToStack[a]) || (s = this.idToStack[a] = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s));\n                } else s = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s);\n\n                s.addSeries(e, i);\n              }, e.prototype.afterInit = function () {\n                for (var t = 0; t < this.stacks.length; t++) {\n                  this.stacks[t].afterInit();\n                }\n              }, e.prototype.process = function (t) {\n                for (var e = 0; e < this.stacks.length; e++) {\n                  this.stacks[e].process(t);\n                }\n              }, e.prototype.afterProcess = function () {\n                for (var t = 0; t < this.stacks.length; t++) {\n                  this.stacks[t].afterProcess();\n                }\n              }, e.prototype.paint = function (t, e) {\n                for (var i = 0; i < this.stacks.length; i++) {\n                  this.stacks[i].paint(t, e);\n                }\n              }, e.prototype.hitTestStack = function (t, e) {\n                for (var i = null, n = 1 / 0, r = 0; r < this.stacks.length; r++) {\n                  var s = this.stacks[r].hitTestStack(t, e),\n                      a = s.result,\n                      o = s.distance;\n                  o < n && (n = o, i = a);\n                }\n\n                return {\n                  result: i,\n                  distance: n\n                };\n              }, e.prototype.hitTest = function (t, e, i) {\n                for (var n = null, r = 1 / 0, s = 0; s < this.stacks.length; s++) {\n                  var a = this.stacks[s].hitTest(t, e, i),\n                      o = a.result,\n                      l = a.distance;\n                  l < r && (r = l, n = o);\n                }\n\n                return {\n                  result: n,\n                  distance: r\n                };\n              }, e.prototype.exportData = function (t, e, i) {\n                for (var n = 0; n < this.stacks.length; n++) {\n                  var r = this.stacks[n];\n                  i.push(r.exportData(t, e));\n                }\n              }, e.prototype.computeStackCenterRadius = function (t, e, i, n) {\n                if (!(e.length < 2)) {\n                  for (var r = this.stacks.length, s = (this.stacks.indexOf(t) + .5) / r, a = .5 / r, o = 0, l = 0, h = 0; h < this.stacks.length; h++) {\n                    o += (u = this.stacks[h]).paddingLeft + u.paddingRight;\n                  }\n\n                  for (h = 0; h < this.stacks.length; h++) {\n                    var u;\n                    if (l += (u = this.stacks[h]).paddingLeft, u === t) break;\n                    l += u.paddingRight;\n                  }\n\n                  var c = e[1] - e[0];\n                  o > c / 2 && (l = l / c * (c - (o = c / 2)));\n\n                  for (h = 0; h < e.length - 1; h++) {\n                    var d = e[h],\n                        p = e[h + 1] - d - o;\n                    i[h] = d + p * s + l, n[h] = p * a;\n                  }\n                }\n              }, e;\n            }();\n\n            t.Cluster = e;\n          }(e = t.Series || (t.Series = {}));\n\n          var j = function () {\n            function t(t, e) {\n              this.valueAxisSet = e, this.chart = t, this.scene = this.chart.scene, this.clusters = [], this.buildSeries();\n            }\n\n            return t.prototype.buildSeries = function () {\n              this.clusters = [];\n\n              for (var t = {}, i = null, n = {}, r = new m(), s = this.scene.settings, a = 0; a < s._computedSeries.length; a++) {\n                var o = s._computedSeries[a];\n\n                if (o.enabled) {\n                  var l = void 0;\n                  o.cluster ? (l = t[o.cluster]) || (l = t[o.cluster] = new e.Cluster(this.chart, this.scene), this.clusters.push(l)) : \"line\" === o.type ? o.stack ? n.hasOwnProperty(o.stack) ? l = n[o.stack] : (l = n[o.stack] = new e.Cluster(this.chart, this.scene), this.clusters.push(l)) : (l = new e.Cluster(this.chart, this.scene), this.clusters.push(l)) : (i || (i = new e.Cluster(this.chart, this.scene), this.clusters.push(i)), l = i);\n                  var h = s._computedStacks[o.stack] || r;\n                  l.addSeries(a, o, h, this.valueAxisSet.getAxis(o.valueAxis));\n                }\n              }\n\n              for (var u = 0; u < this.clusters.length; u++) {\n                (l = this.clusters[u]).afterInit();\n              }\n            }, t.prototype.process = function (t) {\n              for (var e = 0; e < this.clusters.length; e++) {\n                this.clusters[e].process(t);\n              }\n            }, t.prototype.afterProcess = function () {\n              for (var t = 0; t < this.clusters.length; t++) {\n                this.clusters[t].afterProcess();\n              }\n            }, t.prototype.paint = function (t) {\n              var e = t.context;\n              this.scene.seriesWithLabels = 0;\n\n              for (var i = 0; i < this.clusters.length; i++) {\n                for (var n = this.clusters[i], r = 0; r < n.stacks.length; r++) {\n                  for (var s = n.stacks[r].series, a = 0; a < s.length; a++) {\n                    var o = s[a];\n                    o.valueLabels && o.valueLabels.enabled && this.scene.seriesWithLabels++;\n                  }\n                }\n              }\n\n              for (var l = 0; l < this.clusters.length; l++) {\n                this.clusters[l].paint(t, e);\n              }\n            }, t.prototype.hitTest = function (t, e, i) {\n              void 0 === i && (i = 4);\n\n              for (var n = null, r = 1 / 0, s = 0; s < this.clusters.length; s++) {\n                var a = this.clusters[s].hitTest(t, e, i),\n                    o = a.result;\n                (l = a.distance) < r && (n = o, r = l);\n              }\n\n              if (r > i) {\n                r = 1 / 0, n = null;\n\n                for (s = 0; s < this.clusters.length; s++) {\n                  var l,\n                      h = this.clusters[s].hitTestStack(t, e);\n                  o = h.result;\n                  (l = h.distance) < r && (n = o, r = l);\n                }\n              }\n\n              return n;\n            }, t.prototype.exportData = function (t, e) {\n              for (var i = [], n = 0; n < this.clusters.length; n++) {\n                this.clusters[n].exportData(t, e, i);\n              }\n\n              return i;\n            }, t;\n          }();\n\n          t.Renderer = j;\n        }(a = n.LinearChart || (n.LinearChart = {})), function (t) {\n          t.Bar || (t.Bar = {});\n\n          var e = 864e5,\n              i = function () {\n            function i(t, e, n) {\n              this.count = e;\n              var r = i.parsingMap[t];\n              if (!r) throw new Error(\"Time unit `\" + t + \"` is not recognized.\");\n              this.unit = r, this.name = void 0 === n ? e + \" \" + r : n;\n            }\n\n            return i.isGoodUnit = function (t) {\n              return i.parsingMap.hasOwnProperty(t);\n            }, i.parse = function (t, e, n) {\n              if (void 0 === n && (n = !0), null == t) return null;\n\n              if (h.Helpers.isString(t)) {\n                var r = 1,\n                    s = void 0,\n                    a = t.split(\" \");\n\n                if (2 === a.length) {\n                  if (null === (r = h.Helpers.tryParseFloat(a[0], null)) || (0 | r) !== r) {\n                    if (n) throw new Error(\"Cannot parse the time unit - the correct format is `1 s`: \" + t);\n                    return null;\n                  }\n\n                  s = a[1];\n                } else {\n                  if (1 !== a.length) {\n                    if (n) throw new Error(\"Cannot parse the time unit - the correct format is `1 s`: \" + t);\n                    return null;\n                  }\n\n                  r = 1, s = a[0];\n                }\n\n                if (!this.isGoodUnit(s)) {\n                  if (n) throw new Error(\"Cannot parse the time unit - unrecognized time unit: \" + t);\n                  return null;\n                }\n\n                return new i(s, r, e || t);\n              }\n\n              if (t instanceof i) return t;\n              if (n) throw new Error(\"Cannot parse the unit text because it is not a string: \" + t);\n              return null;\n            }, i.prototype.clone = function () {\n              return new i(this.unit, this.count, this.name);\n            }, i.prototype.add = function (t, i) {\n              void 0 === i && (i = 1);\n              var n = this.unit,\n                  r = this.count * i;\n              if (\"ms\" === n) t += r;else if (\"s\" === n) t += 1e3 * r;else if (\"m\" === n) t += 6e4 * r;else if (\"h\" === n) t += 36e5 * r;else if (\"d\" === n) t += r * e;else if (\"w\" === n) t += r * e * 7;else {\n                var s = new Date(t);\n                \"y\" === n ? s.setUTCFullYear(s.getUTCFullYear() + r) : \"M\" === n && s.setUTCMonth(s.getUTCMonth() + r), t = s.getTime();\n              }\n              return t;\n            }, i.prototype.sub = function (t, e) {\n              return void 0 === e && (e = 1), this.add(t, -1 * e);\n            }, i.prototype.numberOfUnits = function (e, n) {\n              return Math.round(t.moment(n).utc().diff(t.moment(e).utc(), i.unitsTranslation[this.unit], !0) / this.count);\n            }, i.prototype.toShortString = function () {\n              return 1 === this.count ? this.unit : this.toString();\n            }, i.prototype.toString = function () {\n              return this.count + \" \" + this.unit;\n            }, i.prototype.approxTime = function () {\n              return i.timeUnitDiffs[this.unit] * this.count;\n            }, i.prototype.isSmallerOrEqual = function (t) {\n              return this.approxTime() <= t.approxTime();\n            }, i.prototype.isSmaller = function (t) {\n              return this.approxTime() < t.approxTime();\n            }, i.prototype.isBigger = function (t) {\n              return this.approxTime() > t.approxTime();\n            }, i.prototype.isEqual = function (t) {\n              return !!t && this.approxTime() === t.approxTime();\n            }, i.prototype.getBigger = function () {\n              return \"y\" === this.unit ? new i(this.unit, 10 * this.count) : new i(i.toBiggerUnit[this.unit], 1);\n            }, i.prototype.roundTimeDown = function (t, i) {\n              if (null == t) return null;\n              t = Math.round(t);\n              var n = this.count,\n                  r = this.unit;\n              if (\"ms\" === r) return Math.floor(t / n) * n;\n              if (\"s\" === r) return Math.floor(t / 1e3 / n) * n * 1e3;\n              if (\"m\" === r) return Math.floor(t / 6e4 / n) * n * 6e4;\n              if (\"h\" === r) return Math.floor(t / 36e5 / n) * n * 36e5;\n\n              if (\"d\" === r) {\n                if (n % 7 != 0) return Math.floor(t / e / n) * n * e;\n                r = \"w\", n /= 7;\n              }\n\n              if (\"w\" === r) {\n                var s = i.week.dow + 3,\n                    a = t;\n                return t = (t / e - s) / 7 + 1, (t = (Math.floor(t / n) * n * 7 + s) * e) > a && (t -= 7 * e), t;\n              }\n\n              var o = new Date(Math.floor(t / e) * e);\n              if (\"y\" === r) return o.setUTCFullYear(Math.floor(o.getUTCFullYear() / n) * n, 0, 1), o.getTime();\n\n              if (\"M\" === r) {\n                var l = 12 * o.getUTCFullYear() + o.getUTCMonth();\n                return o.setUTCMonth(o.getUTCMonth() + Math.floor(l / n) * n - l, 1), o.getTime();\n              }\n\n              throw new Error(\"Unrecognized unit: `\" + this.unit + \"`\");\n            }, i.prototype.roundTimeUp = function (t, e) {\n              return null == t ? null : this.roundTimeDown(this.add(t) - 1, e);\n            }, i.prototype.roundTimeRound = function (t, e) {\n              return null == t ? null : this.roundTimeDown((this.add(t) + t - 1) / 2, e);\n            }, i.prototype.isMultipleOf = function (t) {\n              var e = this.unit,\n                  i = t.unit,\n                  n = this.approxTime(),\n                  r = t.approxTime(),\n                  s = n / r;\n              if (s < 1 || (0 | s) !== s) return !1;\n              if (e === i) return !0;\n              if (1 === t.count && \"w\" !== i) return !0;\n              var a = 864e5 / r;\n              return a >= 1 && (0 | a) === a || (\"y\" === e ? \"M\" === i : \"M\" !== e && \"w\" !== e);\n            }, i;\n          }();\n\n          i.parsingMap = {\n            milliseconds: \"ms\",\n            millisecond: \"ms\",\n            sec: \"s\",\n            second: \"s\",\n            seconds: \"s\",\n            min: \"m\",\n            minute: \"m\",\n            minutes: \"m\",\n            hour: \"h\",\n            hours: \"h\",\n            day: \"d\",\n            days: \"d\",\n            week: \"w\",\n            weeks: \"w\",\n            mon: \"M\",\n            month: \"M\",\n            months: \"M\",\n            year: \"y\",\n            years: \"y\",\n            ms: \"ms\",\n            s: \"s\",\n            m: \"m\",\n            h: \"h\",\n            d: \"d\",\n            D: \"d\",\n            w: \"w\",\n            W: \"w\",\n            M: \"M\",\n            y: \"y\",\n            Y: \"y\"\n          }, i.knownUnits = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"w\", \"M\", \"y\"], i.timeUnitDiffs = {\n            ms: 1,\n            s: 1e3,\n            m: 6e4,\n            h: 36e5,\n            d: 864e5,\n            w: 6048e5,\n            M: 2592e6,\n            y: 31104e6\n          }, i.unitsTranslation = {\n            ms: \"millisecond\",\n            s: \"second\",\n            m: \"minute\",\n            h: \"hour\",\n            d: \"day\",\n            w: \"week\",\n            M: \"month\",\n            y: \"year\"\n          }, i.toBiggerUnit = {\n            ms: \"s\",\n            s: \"m\",\n            m: \"h\",\n            h: \"d\",\n            d: \"w\",\n            w: \"M\",\n            M: \"y\",\n            y: null\n          }, i.toSmallerUnit = {\n            ms: null,\n            s: \"ms\",\n            m: \"s\",\n            h: \"m\",\n            d: \"h\",\n            w: \"d\",\n            M: \"d\",\n            y: \"M\"\n          }, t.TimeStep = i, function (e) {\n            var i = function (t) {\n              function e(e, i) {\n                var n;\n                return i.cssClass = i.cssClass || \"DVSL-bar-btn-month\", i.title = i.title || e.settings.localization.toolbar.periodDropdownTitle, (n = t.call(this, e, i) || this)._getItemsCache = null, n.custom = {\n                  displayAnchor: null,\n                  disabled: !1,\n                  displayPeriod: null,\n                  displayPeriodStr: null,\n                  displayUnit: null,\n                  displayUnitStr: null,\n                  selected: !1,\n                  name: e.settings.localization.toolbar.customPeriod\n                }, n.updateSelectedItem(), n;\n              }\n\n              return r(e, t), e.prototype.onSelectionChange = function (t) {\n                this.chart.setDisplayPeriod(t.displayPeriodStr, t.displayAnchor, null == t.displayUnit ? null : t.displayUnit.toString(), !0, \"user\");\n              }, e.prototype.onSceneChange = function (t) {\n                t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem();\n              }, e.prototype.updateSelectedItem = function () {\n                var t = this._lastSelectedItem;\n                if (t && t !== this.custom && this.chart.isThisDisplayPeriod(t.displayPeriodStr, t.displayAnchor, t.displayUnitStr)) this.setSelectedItem(t);else {\n                  for (var e = this.getItems(), i = 0; i < e.length; i++) {\n                    var n = e[i];\n                    if (n !== t && this.chart.isThisDisplayPeriod(n.displayPeriodStr, n.displayAnchor, n.displayUnitStr)) return void this.setSelectedItem(n);\n                  }\n\n                  this.setSelectedItem(this.custom);\n                }\n              }, e.prototype.setSelectedItem = function (e) {\n                this._lastSelectedItem && (this._lastSelectedItem.selected = !1), e.selected = !0, t.prototype.setSelectedItem.call(this, e), this._lastSelectedItem = e;\n              }, e.prototype.getItems = function () {\n                if (this._getItemsCache) return this._getItemsCache;\n\n                for (var t = [], e = this.chart.settings._minUnit, i = this.custom, n = 0; n < this.chart.settings.toolbar.periods.length; n++) {\n                  var r = this.chart.settings.toolbar.periods[n],\n                      s = r.parse(),\n                      a = s.displayPeriod,\n                      o = s.displayUnit;\n                  o && o.isSmaller(e) || a && a.isSmallerOrEqual(e) || (t.push(s), this.chart.isThisDisplayPeriod(r.displayPeriod, s.displayAnchor, r.displayUnit) && (i = s));\n                }\n\n                return this._lastSelectedItem = i, i.selected = !0, this._getItemsCache = t, t;\n              }, e;\n            }(h.Bar.Combobox);\n\n            e.DisplayPeriodDropdown = i, h.Bar.ToolbarItemNames.displayPeriod = function (e, i) {\n              return new t.Bar.DisplayPeriodDropdown(e, i);\n            };\n\n            var n = function (t) {\n              function e(e, i) {\n                var n;\n                return i || (i = {}), i.cssClass = i.cssClass || \"DVSL-bar-btn-bars\", i.title = i.title || e.settings.localization.toolbar.unitDropdownTitle, (n = t.call(this, e, i) || this).updateSelectedItem(), n;\n              }\n\n              return r(e, t), e.prototype.onSelectionChange = function (t) {\n                this.chart.setDisplayUnit(t.value, !0, \"user\");\n              }, e.prototype.onSceneChange = function (t) {\n                t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem();\n              }, e.prototype.updateSelectedItem = function () {\n                var t = this.chart.displayUnit;\n\n                if (t) {\n                  for (var e = this.getItems(), i = 0; i < e.length; i++) {\n                    var n = e[i];\n                    if (n.value.isEqual(t)) return void this.setSelectedItem(n);\n                  }\n\n                  this.setSelectedItem({\n                    name: t.name,\n                    value: t,\n                    disabled: !1,\n                    selected: !0\n                  });\n                }\n              }, e.prototype.getItems = function () {\n                if (this._getItemsCache) return this._getItemsCache;\n\n                for (var t = this.chart.scene, e = [], i = (t.timeEnd - t.timeStart) / t.width * this.chart.settings.timeAxis.minUnitWidth, n = !1, r = 0; r < this.chart.settings._displayUnitsParsed.length; r++) {\n                  var s = this.chart.settings._displayUnitsParsed[r];\n                  s.approxTime() < i ? n || (e.push({\n                    name: this.chart.settings.localization.toolbar.unavailableUnitTitle,\n                    value: s,\n                    disabled: !0,\n                    selected: !1\n                  }), n = !0) : e.push({\n                    name: s.name,\n                    value: s,\n                    disabled: !1,\n                    selected: s.isEqual(t.displayUnit)\n                  });\n                }\n\n                return e;\n              }, e;\n            }(h.Bar.Combobox);\n\n            e.DisplayUnitDropdown = n, h.Bar.ToolbarItemNames.displayUnit = function (e, i) {\n              return new t.Bar.DisplayUnitDropdown(e, i);\n            };\n          }(t.Bar || (t.Bar = {}));\n\n          var n = function () {\n            function t(t, e, i, n) {\n              this.name = null, this.displayAnchor = null, this.displayPeriod = null, this.displayUnit = null, void 0 === e ? this.displayPeriod = t : (this.name = t, this.displayAnchor = e, this.displayPeriod = i, this.displayUnit = n);\n            }\n\n            return t.prototype.parse = function () {\n              var t = this.displayPeriod,\n                  e = this.displayUnit;\n              return {\n                name: this.name,\n                displayAnchor: this.displayAnchor,\n                displayPeriod: \"max\" === t ? null : i.parse(t),\n                displayPeriodStr: t,\n                displayUnit: \"auto\" === e ? null : i.parse(e),\n                displayUnitStr: e,\n                selected: !1,\n                disabled: !1\n              };\n            }, t;\n          }();\n\n          t.SettingsAreaDisplayPeriod = n;\n\n          var s = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.enabled = !0, e.zoomOut = !0, e.logScale = !0, e.displayUnit = !0, e.displayPeriod = !0, e.zoomOutFunction = null, e.periods = [new n(\"Last second\", \"now\", \"1 s\", \"25 ms\"), new n(\"Last minute\", \"now\", \"1 m\", \"1 s\"), new n(\"Last hour\", \"now\", \"1 h\", \"1 m\"), new n(\"Last day\", \"now\", \"1 d\", \"1 h\"), new n(\"Last week\", \"now\", \"1 w\", \"6 h\"), new n(\"Last month\", \"now\", \"1 M\", \"1 d\"), new n(\"Last year\", \"now\", \"1 y\", \"1 M\"), new n(\"All data\", \"newestData\", \"max\", \"auto\")], e.items = [new h.SettingsToolbarItem(\"fullscreen\", \"left\"), new h.SettingsToolbarItem(\"back\", \"left\"), new h.SettingsToolbarItem(\"zoomOut\", \"left\"), new h.SettingsToolbarItem(\"logScale\", \"right\"), new h.SettingsToolbarItem(\"displayPeriod\", \"right\"), new h.SettingsToolbarItem(\"displayUnit\", \"right\"), new h.SettingsToolbarItem(\"export\", \"right\")], e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsToolbar);\n\n          t.SettingsToolbar = s;\n\n          var o,\n              l = function () {\n            function t(t) {\n              this.settings = t.settings, this.chart = t, this.scene = t.scene;\n            }\n\n            return t.prototype.toBiggerDisplayUnit = function (t) {\n              for (var e = null, i = 0; i < this.settings._displayPeriodsParsed.length; i++) {\n                var n = this.settings._displayPeriodsParsed[i];\n                n.approxTime() > t.approxTime() && (null === e || n.approxTime() < e.approxTime()) && (e = n);\n              }\n\n              return e;\n            }, t.prototype.getMinRangeForUnit = function (t, e, i, n) {\n              var r = i.approxTime(),\n                  s = this.scene.settings.timeAxis.minUnitWidth,\n                  a = this.scene.settings.timeAxis.maxUnitWidth,\n                  o = this.verifyUnitWidth(t, e, i);\n\n              if (o.min || o.max) {\n                h.Helpers.warn(\"Could not show all data as requested by `navigation.initialDisplayPeriod`. Please adjust either `navigation.initialDisplayPeriod` or `timeAxis.minUnitWidth` and `timeAxis.maxUnitWidth`.\");\n                var l = void 0;\n                o.min ? l = this.scene.width / s * r : o.max && (l = this.scene.width / a * r), \"oldestData\" === n ? e = t + l : t = e - l;\n              }\n\n              return {\n                from: t,\n                to: e\n              };\n            }, t.prototype.verifyUnitWidth = function (t, e, i) {\n              var n = i.approxTime(),\n                  r = this.scene.settings.timeAxis.minUnitWidth,\n                  s = this.scene.settings.timeAxis.maxUnitWidth,\n                  a = (e - t) / this.scene.width;\n              return {\n                min: !(r * a < n),\n                max: !(s * a > n)\n              };\n            }, t.prototype.adjustTimeRangeToUnits = function (t, e, i, n) {\n              var r = i - (i - e) / 2,\n                  s = n.approxTime(),\n                  a = this.getUnitRange(t, [n]),\n                  o = (i - e < a.minTime ? Math.ceil(a.minTime / s) : Math.min((i - e) / s, Math.floor(a.maxTime / s))) * s;\n              return {\n                from: e = r - o / 2 + 1,\n                to: i = r + o / 2 - 1\n              };\n            }, t.prototype.preventUnitWidthViolation = function (t, e) {\n              var i = this.scene;\n              return (t - e) / i.width * i.settings.timeAxis.minUnitWidth > i.displayUnit.approxTime();\n            }, t.prototype.getBiggerDisplayPeriod = function (t, e) {\n              for (var i = Math.abs(e - t), n = 0, r = null, s = 0; s < this.settings._displayPeriodsParsed.length; s++) {\n                var a = this.settings._displayPeriodsParsed[s],\n                    o = i / a.approxTime();\n                o < .9 && o > n && (n = o, r = a);\n              }\n\n              return r;\n            }, t.prototype.getBiggerDisplayUnit = function (t) {\n              for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = 0; n < e.length; n++) {\n                var r = e[n];\n                if (r.approxTime() > i) return r;\n              }\n\n              return t;\n            }, t.prototype.getSmallerDisplayUnit = function (t) {\n              for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = e.length - 1; n >= 0; n--) {\n                var r = e[n];\n                if (r.approxTime() < i) return r;\n              }\n\n              return null;\n            }, t.prototype.getClosestDisplayPeriod = function (t, e, i) {\n              for (var n = null, r = 0, s = null, a = 1 / 0, o = 0; o < this.settings._displayPeriodsParsed.length; o++) {\n                var l = this.settings._displayPeriodsParsed[o],\n                    h = l.approxTime();\n                h <= t && (null === n || r < h) && (n = l, r = h), h >= t && (null === s || a > h) && (s = l, a = h);\n              }\n\n              return i ? e && e.approxTime() < .8 * t ? e : null !== s && a < 1.2 * t || null === n ? s : n : null !== n && (r > .8 * t || a > 1.2 * t) ? n : s;\n            }, t.prototype.isAllowedDisplayUnit = function (t) {\n              for (var e = 0; e < this.settings._displayUnitsParsed.length; e++) {\n                if (this.settings._displayUnitsParsed[e].isEqual(t)) return !0;\n              }\n\n              return !1;\n            }, t.prototype.adjustTimeAfterScale = function (t, e, i, n) {\n              var r = this.scene,\n                  s = (e - t) / r.width,\n                  a = r.settings.timeAxis.minUnitWidth,\n                  o = r.displayUnit.approxTime();\n\n              if (!(a * s <= o)) {\n                var l = i + (n - i) / 2,\n                    h = r.width / a | 0;\n                t = l - h / 2 * o, e = l + h / 2 * o;\n              }\n\n              return {\n                from: t,\n                to: e\n              };\n            }, t.prototype.computeDisplayUnit = function (t, e, i, n, r, s, a) {\n              var o = {\n                from: n,\n                to: r,\n                unit: null\n              };\n              if (null != n && null != r || h.Helpers.error(\"`computeDisplayUnit` called with invalid arguments.\"), a && !a.scale && a.scroll) return o.unit = i || this.scene.displayUnit, o;\n              if (null !== t && null !== e && i && Math.abs(e - t - (r - n)) < .001) return o.unit = i, o;\n\n              var l = this.scene.displayUnit,\n                  u = this.scene.settings,\n                  c = Math.max(s.width, 10),\n                  d = u.timeAxis,\n                  p = Math.max(d.minUnitWidth, Math.min(c / 3, d.maxUnitWidth)),\n                  f = (r - n) / c * d.minUnitWidth,\n                  g = (r - n) / c * p,\n                  m = null,\n                  v = 0,\n                  y = u._displayUnitsParsed,\n                  S = u._minUnit.approxTime(),\n                  b = \"min\" === d.unitSizePolicy;\n\n              if (a && a.scale) {\n                var C = 1 / 0;\n                i && 2 !== a.scale && (-1 === a.scale ? S = i.approxTime() : C = i.approxTime());\n\n                for (var x = 0; x < y.length; x++) {\n                  if (!((N = (D = y[x]).approxTime()) < S || N > C)) {\n                    (null === m || (b ? N >= f && N < v || v < f && N > v : N <= g && N > v || v > g && N < v)) && (m = D, v = N);\n                  }\n                }\n\n                m || (l.approxTime() !== y[y.length - 1].approxTime() && (h.Helpers.warn(\"`computeDisplayUnit` could not lookup the new unit - no units available matching the `minUnitWidth` and `maxUnitWidth` for the current range.\", null, !0), this.scene.disableScaleLimiter = !0), m = this.scene.displayUnit);\n              } else {\n                var w = n,\n                    L = r,\n                    T = u.navigation.initialDisplayAnchor,\n                    k = this.chart.getDisplayLimits(),\n                    A = r === k.to && (\"now\" === T || \"newestData\" === T),\n                    M = n === k.from && \"oldestData\" === T;\n                l && l.unit === u._minUnit.unit && 1 === l.count && (m = l);\n\n                for (var I = 50; --I > 0;) {\n                  var P = !1;\n\n                  for (x = 0; x < y.length; x++) {\n                    var D, N;\n                    if (!((N = (D = y[x]).approxTime()) < S)) if (N < f) P = !0;else {\n                      if (!(N <= g)) break;\n                      (null == m || (b ? N < v : N > v)) && (m = D, v = N);\n                    }\n                  }\n\n                  if (!m && !P) {\n                    var F = (w + L) / 2,\n                        O = c / p * S / 2;\n                    m = u._minUnit, w = F - O, L = F + O;\n                  }\n\n                  if (m) {\n                    var E = this.scene.timeStepSettings;\n                    return {\n                      from: m.roundTimeDown(w, E),\n                      to: m.roundTimeUp(L, E),\n                      unit: m\n                    };\n                  }\n\n                  var R = L - w,\n                      H = R - R / 4 >= S ? R / 4 : R - S;\n                  A ? w += H : M ? L -= H : (w += H / 2, L -= H / 2), f = (L - w) / c * d.minUnitWidth, g = (L - w) / c * p;\n                }\n\n                0 === I && h.Helpers.warn(\"`computeDisplayUnit` could not lookup the new unit. It is possible that the chart did not load the data properly.\");\n              }\n\n              if (!m) throw h.Helpers.error(\"\", t, e, i, n, r, c), new Error(\"Could not calculate displayUnit\");\n              return o.unit = m, o;\n            }, t.prototype.tryComputeDisplayPeriod = function (t, e, n, r, s, a, o) {\n              var l = \"auto\" === n ? null : i.parse(n),\n                  u = null,\n                  c = null;\n\n              if (t && t.indexOf(\">\") > -1) {\n                var d = t.split(\">\", 2);\n                u = parseInt(d[0], 10), c = parseInt(d[1], 10);\n                var p = i.timeUnitDiffs,\n                    f = !l || p[l.unit] < p.d;\n                u = this.scene.timestampToInternal(u, f), c = this.scene.timestampToInternal(c, f);\n              } else if (\"max\" === t && null !== r && null !== s) u = r, c = \"now\" === e ? o : s;else if (\"max\" !== t) {\n                var g,\n                    m = i.parse(t);\n                g = \"now\" === e ? o : \"newestData\" === e && null !== s ? s : h.Helpers.tryParseFloat(e, null), m && null !== g && (u = m.sub(g), c = g);\n              }\n\n              if (null === u || null === c) return {\n                from: null,\n                to: null,\n                unit: null\n              };\n              var v = this.getUnitRange(a),\n                  y = v.minTime,\n                  S = v.maxTime,\n                  b = v.minUnit,\n                  C = v.maxUnit;\n              return c - u > S && (l = C, u = c - S), c - u < y && (l = b, u = c - y), {\n                from: u,\n                to: c,\n                unit: l\n              };\n            }, t.prototype.resolveFromTo = function (t, e, i) {\n              var n,\n                  r,\n                  s,\n                  a = this.scene,\n                  o = a.timeStepSettings,\n                  l = null,\n                  u = a.majorTimeUnit || i;\n              return h.Helpers.isNumber(t) ? n = t : (s = \"oldestDataRounded\" === t) || \"oldestData\" === t ? (null === l && (l = this.chart.getDisplayLimits(i)), n = l.from, s && (n = u.roundTimeDown(n, o))) : (t && h.Helpers.error(\"Invalid `interaction.scrolling.limitFrom` value '\" + t + \"'.\"), n = null), h.Helpers.isNumber(e) ? r = e : (s = \"newestDataRounded\" === e) || \"newestData\" === e ? (null === l && (l = this.chart.getDisplayLimits(i)), r = l.to, s && (r = u.roundTimeUp(r, o))) : \"now\" === e ? r = a.getCurTime() : (e && h.Helpers.error(\"Invalid `interaction.scrolling.limitTo` value '\" + e + \"'.\"), r = null), {\n                from: i.roundTimeDown(n, o),\n                to: i.roundTimeUp(r, o)\n              };\n            }, t.prototype.getUnitRange = function (t, e) {\n              void 0 === e && (e = this.settings._displayUnitsParsed);\n              var i = e[e.length - 1],\n                  n = i.approxTime(),\n                  r = e[0],\n                  s = r.approxTime(),\n                  a = Math.max(10, t.width),\n                  o = a / this.settings.timeAxis.minUnitWidth * n;\n              return {\n                minTime: a / this.settings.timeAxis.maxUnitWidth * s,\n                maxTime: o,\n                minUnit: r,\n                maxUnit: i\n              };\n            }, t.prototype.getLimits = function (t, e) {\n              var i = this.settings.interaction.scrolling,\n                  n = i.limitMode;\n              return (e ? null !== n : \"block\" === n) && t ? this.resolveFromTo(i.limitFrom, i.limitTo, t) : {\n                from: null,\n                to: null\n              };\n            }, t.prototype.preventOverscale = function (t, e, i, n, r, s, a) {\n              var o = this.getLimits(s, a),\n                  l = o.from,\n                  u = o.to,\n                  c = this.getUnitRange(t, e),\n                  d = c.minTime,\n                  p = c.maxTime;\n\n              if (null !== l && null !== u && r - n > u - l) {\n                var f = (l + u) / 2,\n                    g = (u - l) / 2;\n                return g = Math.max(g, d / 2), this.adjustTimeRangeToUnits(t, f - g, f + g, s);\n              }\n\n              p *= .99, d *= 1.01;\n              var m = r - n;\n              m = Math.min(m, p);\n              var v = (m = Math.max(m, d)) === d ? m / (r - n) : 1;\n              return null === i && (i = (n + r) / 2), n === r && n > 0 && h.Helpers.error(\"From = To, trouble\", n, r), {\n                from: i + (n - i) * v,\n                to: i + (r - i) * v\n              };\n            }, t.prototype.preventOverscroll = function (t, e, i, n) {\n              var r = this.getLimits(t, n),\n                  s = r.from,\n                  a = r.to,\n                  o = this.settings.interaction.scrolling,\n                  l = i - e;\n              return null !== s && null !== a && (l = Math.min(l, a - s)), l *= o.overscrollProportion, null !== s && (s -= l), null !== a && (a += l), null !== s && null !== a && a - s < i - e ? (s < e ? l = e - s : a > i && (l = i - a), e -= l, i -= l) : null !== a && a < i ? (e -= l = i - a, i -= l) : null !== s && s > e && (l = s - e, e = s, i += l), {\n                from: e,\n                to: i\n              };\n            }, t.prototype.scroll = function (t, e, n, r, s, a) {\n              var o;\n              if (\"displayUnit\" === a) o = n.clone();else if (\"page\" === a) o = this.getTimeRangeStep(t, e);else {\n                if (!i.isGoodUnit(a)) return void h.Helpers.error(\"Incorrect scroll unit: \" + a);\n                o = i.parse(a);\n              }\n              return o.count *= s, \"<\" === r ? {\n                from: o.sub(t),\n                to: o.sub(e)\n              } : {\n                from: o.add(t),\n                to: o.add(e)\n              };\n            }, t.prototype.getTimeRangeStep = function (t, e) {\n              t = Math.round(t), e = Math.round(e);\n\n              for (var n = null, r = this.scene.timeStepSettings, s = 0; s < i.knownUnits.length; s++) {\n                var a = i.knownUnits[s],\n                    o = new i(a, 1),\n                    l = o.roundTimeRound(t, r),\n                    h = o.roundTimeRound(e, r);\n                t === l && e === h && (null === n || n.approxTime() < o.approxTime()) && (n = o);\n              }\n\n              return n.count = Math.max(1, n.numberOfUnits(t, e)), n;\n            }, t;\n          }();\n\n          t.TimeSetup = l, o = \"undefined\" != typeof Float64Array ? function (t) {\n            return Array.isArray(t) || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array || t instanceof Int16Array || t instanceof Uint16Array;\n          } : function (t) {\n            return Array.isArray(t);\n          };\n\n          var u = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.units = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"M\", \"y\"], e.url = null, e.urlByUnit = null, e.requestMaxUnits = 1e4, e.prefetchRatio = 1, e.minimizeRequests = !1, e.cacheSize = 5e5, e.timestampInSeconds = !1, e.stringTimestampFormat = null, e.timeZoneOffset = null, e.dataFunction = null, e.preloaded = null, e.suppressWarnings = !1, e.useSmallerUnitCache = !0, e._skipRequestRangeRounding = !1, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsData);\n\n          t.SettingsData = u;\n\n          var c = function () {\n            function e(t, e) {\n              this.chart = null, this.scene = null, this.settings = null, this.noData = !1, this.dataLimitFrom = null, this.dataLimitTo = null, this.dataLimitFromUnit = null, this.dataLimitToUnit = null, this.dataFrom = null, this.dataTo = null, this.error = null, this.cache = {}, this.requests = {}, this._pendingAddData = [], this.dataSettings = e, this.scene = t.scene, this.settings = t.settings, this.chart = t, this.dataId = \"data\" + e.id, this._prepareUsableUnits(), this.updateDataLimit(null, null, null, null, new i(\"ms\", 1));\n            }\n\n            return e.binSearch = function (t, e) {\n              var i = 0;\n              if (!t) throw \"no data\";\n\n              for (var n = t.length - 1; i < n;) {\n                var r = (n + i) / 2 | 0;\n                if (t[r][0] < e) i = r + 1;else {\n                  if (!(t[r][0] > e)) {\n                    for (; r > 0 && t[r - 1][0] === e;) {\n                      r -= 1;\n                    }\n\n                    return r;\n                  }\n\n                  n = r;\n                }\n              }\n\n              return i < t.length && t[i][0] < e ? i + 1 : i;\n            }, e.linSearchUp = function (t, e, i, n) {\n              if (n) {\n                for (var r = e + 1; r <= t.length - 1; r++) {\n                  if (null !== n(t[r])) return r;\n                }\n              } else for (r = e + 1; r <= t.length - 1; r++) {\n                if (null !== t[r][i]) return r;\n              }\n\n              return -1;\n            }, e.linSearchDown = function (t, e, i, n) {\n              if (n) {\n                for (var r = e - 1; r >= 0; r--) {\n                  if (null !== n(t[r])) return r;\n                }\n              } else for (r = e - 1; r >= 0; r--) {\n                if (null !== t[r][i]) return r;\n              }\n\n              return -1;\n            }, e.findSubrange = function (t, i, n) {\n              return {\n                i0: e.binSearch(t, i),\n                i1: e.binSearch(t, n)\n              };\n            }, e.prototype.notifyAssetsLoaded = function () {\n              if (t.moment && t.moment.tz) {\n                for (var e = this._pendingAddData, i = 0; i < e.length; i++) {\n                  var n = e[i];\n                  this.addDataInt(n.request, n.parsedData, n.append);\n                }\n\n                this._pendingAddData = [];\n              }\n            }, e.prototype.applyPreloadedData = function () {\n              this.dataSettings.preloaded && this.addData(this.dataSettings.preloaded);\n            }, e.prototype.remove = function () {\n              for (var t in this.scene.setMessage(this.dataId, null), this.requests) {\n                var e = this.requests[t];\n                e && (e.callback = null);\n              }\n            }, e.prototype._prepareUsableUnits = function () {\n              var t = this.dataSettings.units;\n              if (0 === t.length) throw new Error(\"The `data.units` array must contain at least one value.\");\n\n              for (var e = this._units = new Array(t.length), n = 0; n < t.length; n++) {\n                var r = t[n],\n                    s = i.parse(r, r, !0);\n                s && (e[n] = {\n                  size: s.approxTime(),\n                  unit: s,\n                  key: s.toString()\n                });\n              }\n\n              e.sort(function (t, e) {\n                return e.size - t.size;\n              });\n            }, e.prototype._findUsableUnit = function (t) {\n              for (var e = this._units, i = this.cache, n = 0; n < e.length; n++) {\n                var r = e[n];\n                if (null !== i[r.key] && t.isMultipleOf(r.unit)) return r.unit;\n              }\n\n              this.chart.error(\"Cannot load data - no suitable data unit configured for the requested `\" + t + \"`.\");\n            }, e.prototype.determineDataLimits = function (t, e, i, n) {\n              var r = this;\n\n              if (t) {\n                if (!(t = this._findUsableUnit(t))) return;\n              } else t = this._units[0].unit;\n\n              var s = null,\n                  a = null,\n                  o = t.approxTime();\n\n              if (this.dataLimitFromUnit && this.dataLimitFromUnit.approxTime() <= o && (s = this.dataLimitFrom), this.dataLimitToUnit && this.dataLimitToUnit.approxTime() <= o && (a = this.dataLimitTo), e && null == s || i && null == a) {\n                this.scene.setMessage(this.dataId, this.settings.localization.determiningDataBounds, 999);\n\n                var l = function l(t, i, s, a) {\n                  if (a) {\n                    if (null === r.dataLimitFrom && e) {\n                      if (t !== i) return void r.scheduleDataLoading(a, null, i, !1, function (t, e, n) {\n                        return l(i, t, e, n);\n                      });\n                      r.dataLimitFrom = i;\n                    }\n\n                    r.scene.setMessage(r.dataId, null), n(r.dataLimitFrom, r.dataLimitTo, a);\n                  } else r.scene.setMessage(r.dataId, null);\n                },\n                    h = function h(t, e, n, s, a) {\n                  if (a) {\n                    if (null === r.dataLimitTo && i) {\n                      if (e !== s) return void r.scheduleDataLoading(a, s, null, !1, function (e, i, n) {\n                        return h(t, s, e, i, n);\n                      });\n                      r.dataLimitTo = s;\n                    }\n\n                    l(t + 1, t, s, a);\n                  } else r.scene.setMessage(r.dataId, null);\n                };\n\n                this.scheduleDataLoading(t, null, null, !1, function (t, e, i) {\n                  return h(t, e, t, e, i);\n                });\n              } else n(this.dataLimitFrom, this.dataLimitTo, t);\n            }, e.prototype.getDataForRange = function (t, i, n, r) {\n              var s = this.dataSettings,\n                  a = null,\n                  o = t,\n                  l = i;\n              null !== this.dataLimitFrom && (o = Math.max(this.dataLimitFrom, o), l = Math.max(l, this.dataLimitFrom)), null !== this.dataLimitTo && (l = Math.min(this.dataLimitTo, l), o = Math.min(o, this.dataLimitTo));\n              var u = o !== l;\n              if (u) for (var c = 0; c < this._units.length; c++) {\n                var d = this._units[c],\n                    p = this.cache[d.key];\n\n                if (p && n.isMultipleOf(d.unit) && p.from < i && p.to > t) {\n                  (s.useSmallerUnitCache || p.unit.approxTime() === n.approxTime()) && (a = p, u = o < p.from || l > p.to);\n                  break;\n                }\n              }\n              var f = !1;\n\n              if (u && (u = !!s.dataFunction || !!s.url || !!s.urlByUnit) && (!s.minimizeRequests || !this.chart.scrolling.isActive())) {\n                var g = this._findUsableUnit(n),\n                    m = !1;\n\n                a && g.approxTime() === a.unit.approxTime() && (o >= a.from && (m = !0, o = Math.max(o, a.to)), (l <= a.to || o < a.from) && (l = Math.min(l, a.from)));\n                var v = g.numberOfUnits(t, i),\n                    y = s.cacheSize;\n                v > y && (h.Helpers.warn(\"The chart requires \" + v + \" values (using data unit `\" + g + \"`) to display the current time range. `data.cacheSize` limit (currently \" + y + \") will be automatically increased to allow this.\"), s.cacheSize = 1.2 * v | 0), f = this.scheduleDataLoading(g, o, l, m, r);\n              }\n\n              if (a) {\n                var S = e.findSubrange(a.values, t, i),\n                    b = S.i0,\n                    C = S.i1;\n                return {\n                  unit: n.unit,\n                  count: n.count,\n                  from: a.from,\n                  to: a.to,\n                  values: a.values,\n                  startIndex: b,\n                  endIndex: C,\n                  loading: f\n                };\n              }\n\n              return f ? {\n                unit: n.unit,\n                count: n.count,\n                from: o,\n                to: l,\n                values: [],\n                startIndex: 0,\n                endIndex: 0,\n                loading: !0\n              } : (o !== l && h.Helpers.warn(\"The datasource `\" + s.id + \"` cannot return data for unit \" + n, null, !0), {\n                unit: null,\n                count: null,\n                from: null,\n                to: null,\n                values: [],\n                startIndex: 0,\n                endIndex: 0,\n                loading: !1\n              });\n            }, e.prototype.updateData = function (t, e, i) {\n              var n = this._findUsableUnit(t),\n                  r = n.toString();\n\n              if (this.cache[r] && !this.requests[r]) {\n                var s = this.scene.timeStepSettings,\n                    a = n.roundTimeUp(e, s),\n                    o = n.roundTimeDown(this.cache[r].lastTimestamp, s);\n                o <= a && this.scheduleDataLoading(t, o, a, !1, i);\n              }\n            }, e.prototype.scheduleDataLoading = function (t, e, n, r, s) {\n              var a = this;\n              if (!t) throw \"No unit\";\n              if (e > n) return !1;\n              this.chart.log(\"Scheduling data loading \" + t + \",\" + e + \",\" + n);\n              var o = h.Helpers.performanceNow(),\n                  l = t.toString(),\n                  u = this.requests[l];\n\n              if (u) {\n                if (!(u.time + this.dataSettings.requestTimeout < o)) return this.chart.log(\"Already loading for selected period\"), !0;\n                u.callback = null, delete this.requests[l];\n              }\n\n              var c = e,\n                  d = n,\n                  f = this.scene.timeStepSettings;\n              (this.dataSettings._skipRequestRangeRounding || (null !== c && (c = t.roundTimeDown(c, f)), null !== d && (d = t.roundTimeUp(d, f))), null !== c && null !== d) && (d - c) / t.approxTime() > this.dataSettings.requestMaxUnits && (r ? d = t.add(c, this.dataSettings.requestMaxUnits) : c = t.sub(d, this.dataSettings.requestMaxUnits));\n              var g = this.getDataFunction();\n              if (!g) return this.chart.log(\"No data function. Cannot load data?\"), !1;\n              var m = i.timeUnitDiffs[t.unit] < i.timeUnitDiffs.d,\n                  v = m ? null : this.settings.timeAxis.timeZone;\n              this.requests[l] = u = new p(t, c, d, s, o, v);\n              (c = this.convertTimestampFromInternal(c, m)) === (d = this.convertTimestampFromInternal(d, m)) && null !== d && d++;\n              var y = g(c, d, t.toShortString(), function (t) {\n                return a.dataReceivedRaw(u, t);\n              }, function () {\n                return a.dataFailed(u);\n              }, v);\n              return this.chart.log(\"Data requested \" + t + \", \" + c + \", \" + d), (h.Helpers.isObjectOrArray(y) || h.Helpers.isString(y)) && (this.dataSettings.suppressWarnings || h.Helpers.warn(\"Data object should not be returned directly from the `dataFunction` delegate - instead call the `success` callback.\"), this.dataReceivedRaw(u, y)), !0;\n            }, e.prototype.dataReceivedRaw = function (t, e) {\n              if (!this.chart.removed) {\n                this.scene.setMessage(this.dataId, null), delete this.requests[t.unitStr], this.chart.log(\"Data arrived\");\n                var i = h.Helpers.parseData(e, this.dataSettings.format);\n                h.Helpers.isObjectOrArray(e) && (i = this.cloneDataObject(i)), this.addDataInt(t, i, !1);\n              }\n            }, e.prototype.cloneDataObject = function (t) {\n              var e = (t = h.Helpers.clone(t)).values;\n              if (!t.error && e) if (Array.isArray(e)) {\n                t.values = e = e.slice();\n\n                for (var i = 0; i < e.length; i++) {\n                  var n = e[i];\n\n                  if (!o(n)) {\n                    t.error = \"The `values` in the TimeChart data object must be an array of arrays. The value at index \" + i + \" is not an array.\";\n                    break;\n                  }\n\n                  e[i] = Array.prototype.slice.call(n);\n                }\n              } else t.error = \"The `values` in the TimeChart data object must be an array or arrays.\";\n              return t;\n            }, e.prototype.addData = function (t) {\n              t = this.cloneDataObject(t), this.addDataInt(null, t, !0);\n            }, e.prototype.addDataInt = function (e, i, n) {\n              if (void 0 === n && (n = !1), null !== i) {\n                if (!t.moment || !t.moment.tz) return void this._pendingAddData.push({\n                  request: e,\n                  parsedData: i,\n                  append: n\n                });\n                var r,\n                    s,\n                    a = this.cleanupData(i);\n                if (a.error) return \"no-unit\" === a.error && e && (this.cache[e.unitStr] = null), void this.chart.error(a.error);\n                if (r = e ? this.analyzeData(a, e) : this.analyzeDataNoRequest(a, n), e && !e.unit.isMultipleOf(r.unit)) this.chart.error(\"Incorrect data - requested unit `\" + e.unit + \"`, got `\" + r.unit + \"`. The requested unit must be a multiple of returned unit.\"), this.cache[e.unitStr] = null, e.callback && e.callback(null, null, null);else {\n                  var o = r.unitStr;\n\n                  if (e && o !== e.unitStr) {\n                    this.cache[e.unitStr] = null;\n\n                    for (var l = !0, u = this._units, c = 0; c < u.length; c++) {\n                      if (u[c].unit.isEqual(r.unit)) {\n                        l = !1;\n                        break;\n                      }\n                    }\n\n                    l && (h.Helpers.warn(\"The data source returned unit `\" + o + \"` which was not declared in `data.units`.\"), this.dataSettings.units.push(o), this._prepareUsableUnits());\n                  }\n\n                  if (r.unit && null != r.from && null != r.to) this.cache[r.unitStr] ? this.cache[r.unitStr].merge(r, this.dataSettings.cacheSize, this.chart, n) : this.cache[r.unitStr] = r;\n                  e && e.callback && e.callback(r.from, r.to, r.unit);\n                }\n                this.chart.events.notifySceneChanges({\n                  data: (s = {}, s[this.dataSettings.id] = !0, s)\n                });\n              }\n            }, e.prototype.dataFailed = function (t) {\n              this.cache[t.unitStr] || (this.cache[t.unitStr] = null), this.scene.setMessage(this.dataId, this.settings.localization.dataRequestFailed, 1e3), this.chart.error(\"Failed data loading request\"), t.callback && t.callback(null, null, null);\n            }, e.prototype.updateDataLimit = function (t, e, i, n, r) {\n              this.chart.invalidateDataLimits(), void 0 !== t && null !== t && (null === this.dataFrom || this.dataFrom > t) && (this.dataFrom = t), void 0 !== e && null !== e && (null === this.dataTo || this.dataTo < e) && (this.dataTo = e), null != i && (this.dataLimitFrom = i, this.dataLimitFromUnit = r, this.dataFrom = null == this.dataFrom ? i : Math.max(this.dataFrom, i)), null != n && (this.dataLimitTo = n, this.dataLimitToUnit = r, this.dataTo = null == this.dataTo ? n : Math.min(this.dataTo, n));\n            }, e.prototype.cleanupData = function (e) {\n              if (e.error) return e;\n              \"local\" === e.timeZone && (h.Helpers.error(\"The data source has to specify a timezone that is not `local` so that it works independent of the browser settings.\"), e.timeZone = t.moment.tz.guess()), e.error = \"bad-response\";\n              var n = !this.dataSettings.suppressWarnings,\n                  r = \"\";\n              e.data && !e.values && (n && h.Helpers.warn(\"Use of property `data` in the TimeChart data object (returned from the URL, dataFunction or preloaded property) is deprecated. Please use `values` instead.\", null, !0), e.values = e.data), null == e.unit && (r += \"\\nRequired field 'unit' not set in data\"), null == e.values && (r += \"\\nRequired field 'values' not set in data\");\n              var s = i.parse(e.unit, void 0, !1);\n              if (null === s && (r += \"\\nData error: unrecognized data unit: \" + e.unit), r.length) return e.error = r.substr(1), e;\n              e.error = null;\n              var a = e.timeZone || \"UTC\",\n                  o = i.timeUnitDiffs[s.unit] < i.timeUnitDiffs.d,\n                  l = t.moment.defaultZone,\n                  u = t.moment.locale();\n              t.moment.locale(this.scene.momentLocale), t.moment.tz.setDefault(a), e.from = this.convertTimestampToInternal(e.from, o), e.to = this.convertTimestampToInternal(e.to, o), e.dataLimitFrom = this.convertTimestampToInternal(e.dataLimitFrom, o), e.dataLimitTo = this.convertTimestampToInternal(e.dataLimitTo, o);\n              var c,\n                  d,\n                  p = -1e30,\n                  f = !1;\n              null != e.from && null != e.to && e.from >= e.to && (this.chart.error(\"Data logic error. from >= to: \" + e.from + \", \" + e.to + \". The values will be ignored.\"), e.from = null, e.to = null), null != e.dataLimitFrom && null != e.dataLimitTo && e.dataLimitFrom >= e.dataLimitTo && (this.chart.error(\"Data logic error. dataLimitFrom >= dataLimitTo: \" + e.dataLimitFrom + \", \" + e.dataLimitTo + \". The values will be ignored.\"), e.dataLimitFrom = null, e.dataLimitTo = null);\n              var g = e.dataLimitFrom,\n                  m = e.dataLimitTo;\n              null == g && (g = -1 / 0), null == m && (m = 1 / 0);\n              var v = 0;\n\n              if (\"UTC\" === a && \"UTC\" === this.settings.timeAxis.timeZone && (v = this.dataSettings.timestampInSeconds ? 1e3 : 1), e.values.length > 0) {\n                for (var y = [], S = 0; S < e.values.length; S++) {\n                  var b = e.values[S];\n\n                  if (Array.isArray(b)) {\n                    for (var C = b.length, x = 1; x < C; x++) {\n                      var w = b[x];\n                      null != w ? \"number\" != typeof w && isNaN(b[x] = parseFloat(w)) ? (this.chart.error(\"Data error: the value is not a number: values[\" + S + \"][\" + x + \"] = \" + w), b[x] = null) : isNaN(w) && (b[x] = null) : b[x] = null;\n                    }\n\n                    var L = C ? b[0] : null;\n\n                    if (null != L) {\n                      if (b[0] = L = v && \"number\" == typeof L ? L * v : this.convertTimestampToInternal(L, o), null === L) continue;\n                      (L < g || L > m) && this.chart.error(\"Data error: value timestamp outside data limits. values[\" + S + \"][0] = \" + b[0] + \". Limits: \" + g + \"...\" + m), n && p === L && h.Helpers.warn(\"There are multiple values given for the same timestamp \" + b[0] + \" which might produce invalid results.\"), p > L && !f && (n && h.Helpers.warn(\"Data values are not sorted on timestamp in ascending order (timestamp \" + b[0] + \"). TimeChart will sort the data automatically but to achieve better performance the data source should be sorted.\"), f = !0), p = b[0], y.push(b);\n                    }\n                  } else this.chart.error(\"Data error: the value at index \" + S + \" is not an array.\");\n                }\n\n                e.values = y, f && y.sort(function (t, e) {\n                  return t[0] - e[0];\n                }), c = y[0][0], d = y[y.length - 1][0];\n              }\n\n              return null != e.from && c < e.from && (h.Helpers.warn(\"Data logic error. Data time \" + c + \" outside [from, to) range: \" + e.from + \", \" + e.to), e.from = c), null != e.to && d >= e.to && (h.Helpers.warn(\"Data logic error. Data time \" + d + \" outside [from, to) range: \" + e.from + \", \" + e.to), e.to = d + 1), t.moment.defaultZone = l, t.moment.locale(u), e;\n            }, e.prototype.analyzeDataNoRequest = function (t, e) {\n              var n = this.dataSettings,\n                  r = t.from,\n                  s = t.to,\n                  a = i.parse(t.unit),\n                  o = null,\n                  l = null;\n\n              if ((null == r || null == s) && t.values.length > 0) {\n                var u = this.scene.timeStepSettings;\n                o = t.values[0][0], l = t.values[t.values.length - 1][0], o = a.roundTimeDown(o, u), l = a.roundTimeUp(l + 1, u), null == r && (r = o), null == s && (s = l);\n              }\n\n              null != n.dataFunction || null != n.url || null != t.dataLimitFrom || null != t.dataLimitTo || h.Helpers.hasProperties(n.urlByUnit) || (h.Helpers.warn(\"Using preloaded data without specifying `dataLimitFrom` and `dataLimitTo` is not recommended - these values will be implied from the data and might result in invalid behavior.\", null, 1e30), null == t.dataLimitFrom && (t.dataLimitFrom = Math.min((e ? this.dataLimitFrom : 0) || 1e30, t.from || o)), null == t.dataLimitTo && (t.dataLimitTo = Math.max((e ? this.dataLimitTo : 0) || -1e30, t.to || l))), this.updateDataLimit(o, l, t.dataLimitFrom, t.dataLimitTo, a);\n              var c = new d(a, r, s, t.values);\n              return null != t.error && (c.error = t.error), c;\n            }, e.prototype.analyzeData = function (t, e) {\n              null === e.from && null == t.from && null != t.dataLimitFrom && (t.from = t.dataLimitFrom, h.Helpers.warn(\"`from` is not set in the data response - using `dataLimitFrom` instead. This may produce unexpected results.\")), null === e.to && null == t.to && null != t.dataLimitTo && (t.to = t.dataLimitTo, h.Helpers.warn(\"`to` is not set in the data response - using `dataLimitTo` instead. This may produce unexpected results.\"));\n              var n = t.from,\n                  r = t.to,\n                  s = null,\n                  a = null;\n              null != n && null != r && n >= r && this.chart.error(\"Data logic error. from >= to: \" + n + \", \" + r);\n              var o = i.parse(t.unit),\n                  l = this.scene.timeStepSettings;\n              (t.values.length > 0 ? (s = t.values[0][0], a = t.values[t.values.length - 1][0], s = o.roundTimeDown(s, l), a = o.roundTimeUp(a + 1, l), null == n && (n = null !== e.from ? Math.min(e.from, s) : s), null == r && (r = null !== e.to ? Math.max(e.to, a) : a), e.from && a <= e.unit.add(e.from) && (this.dataSettings._skipRequestRangeRounding = !0)) : (null == n && (n = e.from), null == r && (r = e.to), null != t.from && null != t.to ? (s = t.from, a = t.to) : (s = e.from, a = e.to, null === e.from && null === e.to && null == n && null == r && null == t.dataLimitFrom && null == t.dataLimitTo && (this.noData = !0))), this.updateDataLimit(s, a, t.dataLimitFrom, t.dataLimitTo, o), null !== e.from && null != t.to) && o.roundTimeDown(t.to, l) <= e.from && this.updateDataLimit(null, null, null, t.to, o);\n              null !== e.to && null != t.from && o.roundTimeUp(t.from, l) >= e.to && this.updateDataLimit(null, null, t.from, null, o);\n              null == t.from && null == t.dataLimitFrom && (null !== this.dataLimitFrom && (null === e.from || e.from <= this.dataLimitFrom && s > this.dataLimitFrom) || null === this.dataLimitFrom && (void 0 === e.from || null === e.from)) && (this.updateDataLimit(null, null, s, null, o), n = s), null == t.to && null == t.dataLimitTo && (null !== this.dataLimitTo && (null === e.to || e.to >= this.dataLimitTo && a < this.dataLimitTo) || null === this.dataLimitTo && (void 0 === e.to || null === e.to)) && (this.updateDataLimit(null, null, null, a, o), r = a);\n              var u = new d(o, n, r, t.values);\n              return t.error && (u.error = t.error), u;\n            }, e.prototype.getDataFunction = function () {\n              var t = this,\n                  e = this.dataSettings;\n              if (e.dataFunction) return e.dataFunction;\n              var i = h.Helpers.hasProperties(e.urlByUnit);\n              return e.url || i ? function (n, r, s, a, o, l) {\n                var u;\n\n                if (i) {\n                  if (!(u = e.urlByUnit[s])) return '{\"error\":\"no-unit\", \"errormessage\":\"no data url for this time unit: ' + s + '\"}';\n                } else u = e.url;\n\n                var c = [];\n                null !== n && c.push([\"from\", n.toString(10)]), null !== r && c.push([\"to\", r.toString(10)]), c.push([\"unit\", s]), null !== l && c.push([\"timeZone\", l]), h.Data.doRequest(u, t.dataSettings, c, a, o);\n              } : null;\n            }, e.prototype.hasPendingRequests = function () {\n              return h.Helpers.hasProperties(this.requests);\n            }, e.prototype.convertTimestampToInternal = function (e, i) {\n              if (null == e) return null;\n              var n = this.dataSettings,\n                  r = this.settings.timeAxis,\n                  s = h.Helpers.isNumber(e);\n              s && n.timestampInSeconds && (e *= 1e3);\n              var a = t.moment(e, s ? null : n.stringTimestampFormat);\n\n              if (!a.isValid()) {\n                var o = parseFloat(e);\n                return s || isNaN(o) ? (h.Helpers.error(\"Could not parse timestamp value `\" + e + \"`. The value will be ignored.\"), null) : (h.Helpers.warn(\"Numeric timestamp value `\" + e + \"` was passed as string. This has been deprecated starting from version 1.12.\"), this.convertTimestampToInternal(o, i));\n              }\n\n              return i && (a = a.tz(r.timeZone)), (e = +a + 6e4 * (a.utcOffset ? a.utcOffset() : a.zone())) + 6e4 * (r.timeZoneOffset - n.timeZoneOffset);\n            }, e.prototype.convertTimestampFromInternal = function (t, e) {\n              if (null == t) return null;\n              var i = this.dataSettings;\n              return t = this.scene.timestampFromInternal(t, e), t += 6e4 * i.timeZoneOffset, i.timestampInSeconds && (t /= 1e3), t;\n            }, e;\n          }();\n\n          t.Data = c;\n\n          var d = function () {\n            function t(t, e, i, n) {\n              this.values = null, this.error = null, this.values = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.updateLastTimestamp();\n            }\n\n            return t.prototype.updateLastTimestamp = function () {\n              this.values.length > 0 ? this.lastTimestamp = this.values[this.values.length - 1][0] : this.lastTimestamp = 0;\n            }, t.prototype.merge = function (t, e, i, n) {\n              if (t.unit.approxTime() !== this.unit.approxTime()) throw new Error(\"merge unit mismatch\");\n              if (!n && (this.from > t.to || this.to < t.from)) return this.values = t.values, this.from = t.from, void (this.to = t.to);\n              t.values.length > 0 && t.from > t.values[0][0] && i.error(\"Data merge - oldest data before from\"), t.values.length > 0 && t.to < t.values[t.values.length - 1][0] && i.error(\"Data merge - newest data after to\");\n\n              for (var r = 0; r < this.values.length && this.values[r][0] < t.from;) {\n                r += 1;\n              }\n\n              for (var s = this.values.length; s > 0 && this.values[s - 1][0] >= t.to;) {\n                s -= 1;\n              }\n\n              var a = t.values;\n\n              if (this.from = Math.min(this.from, t.from), this.to = Math.max(this.to, t.to), r > 0) {\n                var o = Math.max(0, a.length + r - e);\n                a = this.values.slice(o, r - 1 + 1).concat(a), o > 0 && (this.from = this.values[o - 1][0] + 1);\n              }\n\n              if (s < this.values.length) {\n                var l = this.values.length - s;\n                l = Math.min(l, e - a.length), a = a.concat(this.values.slice(s, s + l + 1)), l < this.values.length - s && (this.to = this.values[s + l][0]);\n              }\n\n              this.values = a, this.updateLastTimestamp();\n            }, t;\n          }();\n\n          t.TimeData = d;\n\n          var p = function () {\n            return function (t, e, i, n, r, s) {\n              this.time = r, this.callback = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.timeZone = s;\n            };\n          }(),\n              f = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.limitMode = \"snapBack\", e.limitFrom = \"oldestData\", e.limitTo = \"newestData\", e.overscrollProportion = 0, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsInteractionScrolling);\n\n          t.SettingsInteractionScrolling = f;\n\n          var g = function (t) {\n            function e(e) {\n              var i = t.call(this, e) || this;\n              return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1400, i.animationUnit = null, i.targetUnit = null, i.dragStartBar0 = null, i.dragStartBar1 = null, i.dragStartUnit = null, i.timeSetup = new l(e), i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (e) {\n              t.prototype.onSceneChange.call(this, e);\n              var i = this.scene,\n                  n = this.scene.displayUnit;\n              !this.scalingActive && i.timeScale && i.lastUnit === n || !n || this.timeSetup.preventUnitWidthViolation(this.chart.timeEnd, this.chart.timeStart) || (i.timeScale = (i.timeEnd - i.timeStart) / i.width), i.lastUnit !== n && (i.lastUnit = n);\n            }, e.prototype.scaleViewRange = function (e, i, n) {\n              var r = t.prototype.scaleViewRange.call(this, e, i, n),\n                  s = this.scene,\n                  a = s.settings.timeAxis,\n                  o = (r.to - r.from) / s.width * a.minUnitWidth / 1.5;\n              return s.disableScaleLimiter || o <= s.displayUnit.approxTime() ? r : {\n                from: i,\n                to: n\n              };\n            }, e.prototype.setTimeRangeSnap = function (t, e, i, n, r, s, a, o) {\n              var l = this.snap(t, e, i, n, a, o);\n              t = l.from, e = l.to;\n              var h = l.unit,\n                  u = l.period,\n                  c = l.anchor;\n              this.setTimeRange(t, e, h, r, s, c, u);\n            }, e.prototype.computeDisplayPeriod = function (t, e, i, n, r) {\n              var s = this.timeSetup.tryComputeDisplayPeriod(t, e, i, n, r, this.scene, this.scene.getCurTime()),\n                  a = s.from,\n                  o = s.to,\n                  l = s.unit;\n              return null === a || null === o ? {\n                from: null,\n                to: null,\n                unit: null\n              } : this.computeTimeRangeExtend(a, o, l);\n            }, e.prototype.computeTimeRangeExtend = function (t, e, i) {\n              var n = this.scene;\n\n              if (!i) {\n                var r = this.timeSetup.computeDisplayUnit(n.timeStart, n.timeEnd, n.displayUnit, t, e, n);\n                t = r.from, e = r.to, i = r.unit;\n              }\n\n              var s = n.timeStepSettings;\n              t = i.roundTimeDown(t, s), (e = i.roundTimeUp(e, s)) === t && (e = i.add(e, 1));\n\n              var a = this._preventOverscroll(t, e, i, !0);\n\n              return {\n                from: t = a.from,\n                to: e = a.to,\n                unit: i\n              };\n            }, e.prototype.computeDisplayUnit = function (t, e, i) {\n              var n = null !== this.dragStartFrom ? this.dragStartFrom : this.scene.timeStart,\n                  r = null !== this.dragStartTo ? this.dragStartTo : this.scene.timeEnd,\n                  s = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit,\n                  a = this.chart.scrolling,\n                  o = {\n                scroll: a.scrollingActive,\n                scale: a.scalingActive,\n                animate: i\n              };\n              return this.timeSetup.computeDisplayUnit(n, r, s, t, e, this.scene, o);\n            }, e.prototype.setTimeRange = function (t, e, i, n, r, s, a) {\n              if (void 0 === s && (s = null), void 0 === a && (a = null), !((t = Math.round(t)) > (e = Math.round(e)))) {\n                var o;\n                if (!i) t = (o = this.computeDisplayUnit(t, e)).from, e = o.to, i = o.unit;\n                if (\"init\" === r) t = (o = this.timeSetup.getMinRangeForUnit(t, e, i, s)).from, e = o.to;\n                t === this.getFrom() && e === this.getTo() && i.isEqual(this.scene.displayUnit) || (n && this.abort(), this.scene.anchor = s, this.scene.period = a, this.targetUnit = i, this.animationUnit = !i || this.scene.displayUnit && i.toString() !== this.scene.displayUnit.toString() ? null : i, this.goToPosition(t, e, n, h.Helpers.performanceNow(), !0), this.events.notifySceneChanges({\n                  time: !0\n                }), r && this.chart.notifyTimeChanged(t, e, i, r));\n              }\n            }, e.prototype.zoomOut = function (t, e, i, n, r) {\n              if (this.scene.displayUnit) {\n                var s = this.computeZoomOut(e, i);\n                this.scene.displayUnit = s.unit, this.setTimeRangeSnap(s.from, s.to, s.center, s.unit, n, r, !1, !0);\n              }\n            }, e.prototype.zoomIn = function (t, e, i, n, r, s) {\n              if (this.scene.displayUnit) {\n                null === e && (e = (i + n) / 2);\n                var a = this.onZoomIn(i, n, e, .5);\n                this.setTimeRangeSnap(a.from, a.to, a.center, t, r, s, !1, !0);\n              }\n            }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {\n              var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);\n              t = s.from, e = s.to;\n              var a = s.unit;\n\n              if (this.scene.displayUnit = a, null === this.pointer1) {\n                var o = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);\n                t = o.from, e = o.to, a = o.unit, this.scene.displayUnit = a;\n              }\n\n              this.goToPosition(t, e, !0, n, !0);\n            }, e.prototype.xyInArea = function (t, e) {\n              return this.scene.xyInChart(t, e);\n            }, e.prototype.xyToPosition = function (t, e) {\n              return this.scene.xToTime(t);\n            }, e.prototype.onZoomOut = function (e, i, n, r) {\n              return void 0 === r && (r = null), r ? t.prototype.onZoomOut.call(this, e, i, n, r) : this.computeZoomOut(e, i);\n            }, e.prototype.onZoomIn = function (e, i, n, r) {\n              if (void 0 === r && (r = null), r) return t.prototype.onZoomIn.call(this, e, i, n, r);\n\n              if (this.dragStartBar0 && (e = this.dragStartBar0, (i = this.dragStartBar1) - e > this.scene.timeEnd - this.scene.timeStart)) {\n                var s = this.scene.getClickBar(n);\n                e = s.time0, i = s.time1;\n              }\n\n              return {\n                from: e,\n                to: i,\n                center: (e + i) / 2\n              };\n            }, e.prototype.onScroll = function (t, e, i) {\n              return this.timeSetup.scroll(t, e, this.scene.displayUnit, i, 1, \"page\");\n            }, e.prototype.onGoHome = function (t, e) {\n              var i = this.chart.getDisplayLimits().to;\n              return null === i ? {\n                from: t,\n                to: e,\n                origin: null\n              } : (this.scene.anchor = \"newestData\", {\n                from: i - (e - t),\n                to: i,\n                origin: i\n              });\n            }, e.prototype.onStartDragging = function (t, e, i) {\n              this.scene.anchor = null, this.animationUnit = null, this.dragStartUnit = this.scene.displayUnit;\n              var n = this.scene.getClickBar(i);\n              this.dragStartBar0 = n.time0, this.dragStartBar1 = n.time1;\n            }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {\n              if (t > e) {\n                var s = e;\n                e = t, t = s;\n              }\n\n              var a = this._preventOverscale(t, e, null, i, !1);\n\n              t = a.from, e = a.to;\n\n              var o = this.computeDisplayUnit(t, e).unit,\n                  l = this._preventOverscroll(t, e, o, !1);\n\n              return t = l.from, e = l.to, this.events.notifySceneChanges({\n                time: !0\n              }), {\n                from: t,\n                to: e,\n                unit: o\n              };\n            }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {\n              if (r) {\n                var s = this.timeSetup.adjustTimeAfterScale(t, e, this.dragStartBar0, this.dragStartBar1);\n                t = s.from, e = s.to;\n              }\n\n              var a = this.snap(t, e, i, null, n, !1),\n                  o = a.unit,\n                  l = a.period,\n                  h = a.anchor;\n              return this.targetUnit = o, this.animationUnit = this.scene.displayUnit, this.scene.period = l, this.scene.anchor = h, this.dragStartBar0 = null, this.dragStartBar1 = null, this.dragStartFrom = null, this.dragStartTo = null, this.dragStartUnit = null, this.events.notifySceneChanges({\n                time: !0\n              }), this.chart.notifyTimeChanged(t, e, o, \"user\"), {\n                from: a.from,\n                to: a.to,\n                unit: o\n              };\n            }, e.prototype.onPositionChanged = function (t, e, i) {\n              var n;\n              isNaN(t) && isNaN(e) || (n = this.animationUnit ? this.animationUnit : this.computeDisplayUnit(t, e).unit, this.scene.setTimeRange(t, e, n), this.chart.timeStart = t, this.chart.timeEnd = e, this.chart.displayUnit = n, this.events.notifySceneChanges({\n                position: !0,\n                time: !0\n              }));\n            }, e.prototype.onAnimationDone = function (t, e) {\n              if (this.targetUnit) {\n                var i = this.targetUnit ? this.targetUnit : this.computeDisplayUnit(t, e).unit;\n                this.chart.displayUnit = i, this.scene.setTimeRange(t, e, i);\n              }\n\n              this.targetUnit = null, this.animationUnit = null, this.chart.notifyAnimationDone();\n            }, e.prototype.onPointerDown = function (e) {\n              null !== this.pointer1 && null === this.pointer2 && (this.dragStartUnit = this.scene.displayUnit), t.prototype.onPointerDown.call(this, e);\n            }, e.prototype.onPointerDrag = function (e) {\n              this.scene.displayUnit && t.prototype.onPointerDrag.call(this, e);\n            }, e.prototype.computeZoomOut = function (t, e) {\n              var n,\n                  r = this.scene.settings.toolbar.zoomOutFunction,\n                  s = this.scene.displayUnit,\n                  a = null,\n                  o = null,\n                  l = e - t,\n                  h = e - l / 2;\n              r && (o = r(s.unit, s.count, t, e)), null != o && o.unit && (a = new i(o.unit, o.count || 1)), a || (a = this.timeSetup.getBiggerDisplayUnit(s));\n              var u = a.approxTime(),\n                  c = this.timeSetup.getUnitRange(this.scene, [a]);\n\n              if (null != o && (null != o.from || null != o.to)) {\n                n = Math.min(c.maxTime, o.to - o.from);\n                var d = this.timeSetup.verifyUnitWidth(o.from, o.to, a);\n\n                if (d.min || d.max) {\n                  var p = this.timeSetup.adjustTimeRangeToUnits(this.chart.scene, o.from, o.to, a);\n                  t = p.from, e = p.to;\n                }\n              } else {\n                n = u * Math.min(30 * l / u, Math.floor(c.maxTime / u));\n              }\n\n              return (!o || o && !o.from) && (t = h - n / 2, e = h + n / 2), {\n                from: t,\n                to: e,\n                center: h,\n                unit: a\n              };\n            }, e.prototype.snap = function (t, e, i, n, r, s) {\n              if ((s || r) && this.scene.settings.interaction.scrolling.limitMode) {\n                var a = this._preventOverscale(t, e, n, i, !0);\n\n                t = a.from, e = a.to;\n              }\n\n              var o, l;\n\n              if (n ? o = n : !s || !s && r ? o = this.scene.displayUnit : (o = (l = this.computeDisplayUnit(t, e)).unit, t = l.from, e = l.to), r || s) {\n                var h = e - t,\n                    u = this._preventOverscroll(t, e, o, !1);\n\n                t = u.from, e = u.to, t = (u = this._preventOverscroll(t, e, o, !0)).from, e = u.to, s = s || e - t !== h;\n              }\n\n              if (!n && s) return t = (l = this.computeDisplayUnit(t, e)).from, e = l.to, this.snap(t, e, i, o, r, s);\n              var c = s ? null : this.scene.period,\n                  d = this.scene.anchor,\n                  p = this.scene.settings.interaction.snapMode;\n\n              if (p) {\n                var f = this.scene.majorTimeUnit && \"y\" === this.scene.majorTimeUnit.unit,\n                    g = void 0;\n                if (\"displayUnit\" === p) g = o;else if (\"multiperiod\" === p || \"period\" === p) {\n                  var m = e - t,\n                      v = this.chart.getDisplayLimits(),\n                      y = v.from,\n                      S = v.to;\n                  null !== y && (m = Math.min(m, S - y));\n                  var b = this.timeSetup.getClosestDisplayPeriod(m, this.scene.majorTimeUnit, \"multiperiod\" === p || f);\n                  g = b, c = b.toString();\n                }\n                var C = this.scene.timeStepSettings;\n                if (\"period\" !== p || f) {\n                  if (s) t = g.roundTimeRound(t, C), e = g.roundTimeRound(e, C);else {\n                    var x = Math.max(g.numberOfUnits(t, e), 1);\n                    Math.abs(g.roundTimeRound(t, C) - t) < Math.abs(g.roundTimeRound(e, C) - e) ? (t = g.roundTimeRound(t, C), e = g.add(t, x)) : (e = g.roundTimeRound(e, C), t = g.sub(e, x));\n                  }\n                } else t = g.roundTimeDown(i, C), e = g.add(t, 1);\n              } else t = Math.round(t), e = Math.round(e);\n\n              return {\n                from: t,\n                to: e,\n                unit: o,\n                period: c,\n                anchor: d\n              };\n            }, e.prototype._preventOverscroll = function (t, e, i, n) {\n              return this.timeSetup.preventOverscroll(i, t, e, n);\n            }, e.prototype._preventOverscale = function (t, e, i, n, r) {\n              var s;\n              return i ? s = [i] : (i = this.scene.displayUnit, s = this.scene.settings._displayUnitsParsed), this.timeSetup.preventOverscale(this.scene, s, n, t, e, i, r);\n            }, e;\n          }(a.Scrolling);\n\n          t.Scrolling = g;\n\n          var m = function () {\n            return function () {\n              this.enabled = !0, this.tolerance = 6, this.moveByDragging = !1, this.resizeSensitivity = 2, this.resizeTolerance = 20, this.clearOnRightClick = !0;\n            };\n          }();\n\n          t.SettingsInteractionSelection = m;\n\n          var v = function () {\n            return function () {\n              this.lineColor = \"rgba(0,0,0,0.5)\", this.lineWidth = 2, this.fillColor = \"rgba(30,160,220,0.15)\", this.behindSeries = !1;\n            };\n          }();\n\n          t.SettingsAreaStyleSelection = v;\n\n          var y = function (e) {\n            function i(t) {\n              var i = e.call(this) || this;\n              i.selectStart = null, i.selectingPointer = null, i.isSelecting = !1, i.isHoveringEdge = !1, i.lastX = 0, i.lastY = 0, i.roundAround = !1, i.selectionRemoved = !1, i.animationOrder = 500, i.updateOrder = 1300, i.isMoving = !1, i.moveStartX = 0, i.moveStartY = 0, i.moveSelectionStart = null, i.moveSelectionEnd = null, i.chart = t, i.scene = t.scene;\n              var n = t.settings;\n              return i.settings = n.interaction.selection, i.styleSettings = n.area.style.selection, i.labelStyle = n.area.style.selectionLabel, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i;\n            }\n\n            return r(i, e), i.prototype.onSceneChange = function (t) {\n              if ((t.changes.time || t.changes.bounds) && null !== this.selectStart && this.dragPointer(null, this.lastX, this.lastY, t.changes), t.changes.settings) {\n                var e = this.styleSettings.behindSeries ? 3 : 15;\n                this.paintOrder !== e && (this.paintOrder = e, this.chart.events.refreshElementOrder());\n              }\n            }, i.prototype.getLineCoordinates = function () {\n              var t = this.scene,\n                  e = this.styleSettings,\n                  i = Math.round(t.timeToX(t.selectionStart)),\n                  n = Math.round(t.timeToX(t.selectionEnd)),\n                  r = e.lineWidth,\n                  s = Math.round(t.x0),\n                  a = Math.round(s + t.width);\n              return i - r < s && i > s - 4 * r && (i = s + r), n + r > a && n < a + 4 * r && (n -= r), {\n                start: i,\n                end: n\n              };\n            }, i.prototype.paintScene = function (e) {\n              var i = this.scene;\n\n              if (null != i.minorTimeUnit && null != i.selectionStart && null != i.selectionEnd && this.chart.assetsLoaded) {\n                var n = this.styleSettings,\n                    r = n.lineWidth,\n                    s = Math.round(i.x0),\n                    a = Math.round(s + i.width),\n                    o = Math.round(i.y0),\n                    l = Math.round(o + i.height + i.bottomAxisSize),\n                    u = this.getLineCoordinates(),\n                    c = u.start,\n                    d = u.end,\n                    p = i.minorTimeUnit.roundTimeRound(i.selectionStart, i.timeStepSettings),\n                    f = i.minorTimeUnit.roundTimeRound(Math.max(i.selectionStart, i.selectionEnd - 1), i.timeStepSettings),\n                    g = i.height + i.bottomAxisSize,\n                    m = t.moment.utc(p).locale(i.momentLocale).format(i.minorTimeFormat),\n                    v = t.moment.utc(f).locale(i.momentLocale).format(i.minorTimeFormat),\n                    y = e.context;\n                h.Graphics.pushClip(e, s, o, i.width, g), h.Graphics.rectStyle(y, n);\n                var S = c + r % 2 / 2,\n                    b = d + r % 2 / 2;\n                y.fillRect(S + r / 2, o, d - c - r, g), y.beginPath(), y.moveTo(S, o), y.lineTo(S, l), y.moveTo(b, o), y.lineTo(b, l), h.Graphics.stroke(y, n);\n                var C = e.labelRenderer,\n                    x = this.labelStyle,\n                    w = h.Graphics.getTextWidth(y, x, m),\n                    L = h.Graphics.getTextWidth(y, x, v),\n                    T = new h.Label({\n                  text: m,\n                  textStyle: x\n                }, !0),\n                    k = new h.Label({\n                  text: v,\n                  textStyle: x\n                }, !0);\n                c < s && (c = s), d > a && (d = a), w + L + 20 < d - c ? (c += 5, d = d - L - 5) : (c = c - w - 5, d += 5);\n                var A = this.chart.shell.getChartInnerArea(),\n                    M = A.findTopPosition(c, c + w),\n                    I = A.findTopPosition(d, d + L);\n                C.paint(y, c + w / 2, M + 10, 1, T), C.paint(y, d + L / 2, I + 10, 1, k), h.Graphics.popClip(e);\n              }\n            }, i.prototype.onPointerMove = function (t) {\n              var e = this.scene,\n                  i = this.settings;\n\n              if (i.enabled) {\n                e.xyInBottom(t.x, t.y) && (t.cursor = \"text\");\n                var n = !1;\n\n                if (null != e.selectionStart && null != e.selectionEnd && e.xyInChartOrBottom(t.x, t.y) && e.timeStart < e.timeEnd) {\n                  var r = this.getLineCoordinates();\n                  Math.abs(r.start - t.x) <= i.tolerance ? (t.cursor = \"e-resize\", t.consumed = !0, n = !0) : Math.abs(r.end - t.x) <= i.tolerance ? (t.cursor = \"w-resize\", t.consumed = !0, n = !0) : i.moveByDragging && r.start < t.x && r.end > t.x && (t.cursor = \"move\", t.consumed = !0);\n                }\n\n                this.isHoveringEdge = n;\n              }\n            }, i.prototype.onPointerDown = function (t) {\n              var e = this.scene,\n                  i = this.settings;\n\n              if (e.xyInChartOrBottom(t.x, t.y) && null === this.selectingPointer && i.enabled) {\n                this.selectionRemoved = !1, this.lastX = t.x;\n\n                if (null !== e.selectionStart || null !== e.selectionEnd) {\n                  var n = this.getLineCoordinates(),\n                      r = Math.abs(n.start - t.x),\n                      s = Math.abs(n.end - t.x),\n                      a = !1;\n                  if (r < i.tolerance && r <= s ? (this.selectStart = e.selectionEnd, a = !0) : s < i.tolerance && s <= r ? (this.selectStart = e.selectionStart, a = !0) : i.moveByDragging && n.start < t.x && n.end > t.x && (this.isMoving = !0, this.moveStartX = t.x, this.moveStartY = t.y, this.moveSelectionStart = e.selectionStart, this.moveSelectionEnd = e.selectionEnd, this.selectStart = e.xToTime(t.x), a = !0), a) return this.selectingPointer = t.identifier, t.consumed = !0, this.roundAround = !0, void (this.isSelecting = !0);\n                }\n\n                e.xyInBottom(t.x, t.y) && (this.selectingPointer = t.identifier, this.selectStart = e.xToTime(t.x), t.capture = !0, this.roundAround = !0, this.isSelecting = !0, t.x >= null && t.x <= null || null !== e.selectionStart && (this.selectionRemoved = !0, e.selectionStart = null, e.selectionEnd = null, t.changes.selection = !0));\n              }\n            }, i.prototype.onPointerDrag = function (t) {\n              this.scene.displayUnit && this.selectingPointer === t.identifier && (this.dragPointer(t, t.x, t.y, t.changes), t.consumed = !0);\n            }, i.prototype.dragPointer = function (t, e, i, n) {\n              var r,\n                  s,\n                  a = this.scene;\n\n              if (this.isMoving) {\n                var o = a.dxToDtime(e - this.moveStartX);\n                r = this.moveSelectionStart + o, s = this.moveSelectionEnd + o;\n                var l = i - this.moveStartY,\n                    u = this.settings.resizeTolerance;\n\n                if (Math.abs(l) > u) {\n                  l = l < 0 ? l + u : l - u;\n                  var c = this.moveSelectionEnd - this.moveSelectionStart,\n                      d = Math.min(c, a.dxToDtime(l * this.settings.resizeSensitivity)),\n                      p = 0 === c ? .5 : (this.selectStart - this.moveSelectionStart) / c;\n                  r += d * p, s -= d * (1 - p);\n                }\n              } else {\n                var f = this.selectStart,\n                    g = this.scene.xToTime(e),\n                    m = Math.abs(f - g),\n                    v = a.snapTimeRound(f),\n                    y = (o = v - f, h.Helpers.sign(o));\n                (v = f + Math.min(o * y, .9 * m) * y) < g ? (r = v, s = g) : (r = g, s = v);\n              }\n\n              this.lastX = e, this.lastY = i, a.selectionStart = r, a.selectionEnd = s, n.selection = !0, a.settings.events.selectionChangeDuringInteraction && this.chart.notifySelectionChanged(this.chart.createEventArguments(t, \"user\"));\n            }, i.prototype.onPointerUp = function (t) {\n              if (this.selectingPointer === t.identifier) {\n                if (this.isSelecting) {\n                  var e = this.snapSelection(),\n                      i = e.st,\n                      n = e.en;\n                  i === n && (i = null, n = null);\n                  var r = this.scene;\n                  r.selectionStart = i, r.selectionEnd = n, null != i && (r.hoverFrom = i, r.hoverTo = n), this.chart.notifySelectionChanged(this.chart.createEventArguments(t, \"user\")), t.changes.selection = !0;\n                }\n\n                (this.isSelecting || this.selectionRemoved) && (t.consumed = !0), this.isSelecting = !1, this.isMoving = !1, this.selectStart = null, this.selectingPointer = null;\n              }\n            }, i.prototype.onPointerCancel = function (t) {\n              this.onPointerUp(t);\n            }, i.prototype.snapSelection = function () {\n              var t,\n                  e,\n                  i = this.scene;\n              return null != i.selectionStart ? this.roundAround ? (t = i.snapTimeRound(i.selectionStart), e = i.snapTimeRound(i.selectionEnd)) : (t = i.snapTimeDown(i.selectionStart), e = i.snapTimeUp(i.selectionEnd)) : (t = null, e = null), {\n                st: t,\n                en: e\n              };\n            }, i;\n          }(h.ChartElement);\n\n          t.Selection = y;\n\n          var S = function (e) {\n            function i() {\n              var t = e.apply(this, arguments) || this;\n              return t.timeStart = 0, t.timeEnd = 0, t.anchor = null, t.period = null, t.displayUnit = null, t.data = {}, t.markers = [], t.mainData = null, t.selectionStart = null, t.selectionEnd = null, t.minorTimeFormat = null, t.minorTimeUnit = null, t.majorTimeUnit = null, t.majorTimeFormat = null, t.hoverFrom = null, t.hoverTo = null, t.timeScale = 0, t.lastUnit = null, t.disableScaleLimiter = !1, t.momentLocale = \"zc\" + (i._momentLocaleCounter++).toFixed(0), t;\n            }\n\n            return r(i, e), i.prototype.setTimeRange = function (t, e, i) {\n              i || h.Helpers.error(\"Scene.setTimeRange: no display unit\"), this.timeStart = t, this.timeEnd = e, this.displayUnit = i;\n            }, i.prototype.pixelsPerTime = function () {\n              return this.width / (this.timeEnd - this.timeStart);\n            }, i.prototype.getScale = function () {\n              return (this.timeEnd - this.timeStart) / this.width;\n            }, i.prototype.timeToX = function (t) {\n              return this.x0 + this.width * (t - this.timeStart) / (this.timeEnd - this.timeStart);\n            }, i.prototype.timeToXCoefs = function () {\n              return {\n                tadd: this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart),\n                tmul: this.width / (this.timeEnd - this.timeStart)\n              };\n            }, i.prototype.xToTime = function (t) {\n              return this.timeStart + (this.timeEnd - this.timeStart) * (t - this.x0) / this.width;\n            }, i.prototype.xToFraction = function (t) {\n              return (t - this.x0) / this.width;\n            }, i.prototype.dTimeToDx = function (t) {\n              return this.width * t / (this.timeEnd - this.timeStart);\n            }, i.prototype.dxToDtime = function (t) {\n              return t / this.width * (this.timeEnd - this.timeStart);\n            }, i.prototype.snapTimeDown = function (t) {\n              return this.displayUnit.roundTimeDown(t, this.timeStepSettings);\n            }, i.prototype.snapTimeUp = function (t) {\n              return this.displayUnit.roundTimeUp(t, this.timeStepSettings);\n            }, i.prototype.snapTimeRound = function (t) {\n              return this.displayUnit.roundTimeRound(t, this.timeStepSettings);\n            }, i.prototype.getClickBar = function (t) {\n              var e = this.displayUnit;\n              return e ? {\n                time0: e.roundTimeDown(t, this.timeStepSettings),\n                time1: e.roundTimeUp(t + 1, this.timeStepSettings)\n              } : {\n                time0: null,\n                time1: null\n              };\n            }, i.prototype.getCurTime = function () {\n              var t,\n                  e = this.settings.currentTime;\n              return t = null != e.time ? e.time : new Date().getTime(), this.timestampToInternal(t, !0);\n            }, i.prototype.timestampToInternal = function (e, i) {\n              if (null == e) return null;\n              e = +e;\n              var n = this.settings.timeAxis;\n\n              if (i) {\n                if (!t.moment || !t.moment.tz) return null;\n                var r = t.moment.utc(e).tz(n.timeZone);\n                e = +r + 6e4 * (r.utcOffset ? r.utcOffset() : r.zone());\n              }\n\n              return e + 6e4 * n.timeZoneOffset;\n            }, i.prototype.timestampFromInternal = function (e, i) {\n              if (null == e) return null;\n              var n = this.settings.timeAxis;\n\n              if (i) {\n                if (!t.moment || !t.moment.tz) return null;\n                var r = t.moment.utc(e).tz(n.timeZone);\n                e = +r - 6e4 * (r.utcOffset ? r.utcOffset() : r.zone());\n              }\n\n              return e - 6e4 * n.timeZoneOffset;\n            }, i;\n          }(a.Scene);\n\n          S._momentLocaleCounter = 0, t.Scene = S;\n\n          var b = function () {\n            function e(t, e, i, n, r, s, a) {\n              void 0 === i && (i = []), void 0 === n && (n = null), void 0 === r && (r = null), void 0 === s && (s = !0), void 0 === a && (a = 2), this.scene = null, this.step = null, this.uniform = !1, this.currentFrom = 0, this.currentTo = 0, this.fromBar = null, this.toBar = null, this.fromIndex = 0, this.toIndex = 0, this.times = [], this.xes = [], this.oldMul = 0, this.oldAdd = 0, this.values = [], this.counts = [], this.arrays = [], this.extraArrays = [], this.bufExpandSize = 100, this.extraSteps = 2, this.uniformTolerance = 0, this.approxExtraTime = 0, this.extraSteps = a, this.uniform = s, this.step = e, this.scene = t, n = n || this.scene.timeStart, r = r || this.scene.timeEnd, this.extraArrays = i.slice(0), this.arrays = i.slice(0), this.arrays.push(\"xes\"), this.arrays.push(\"times\"), this.uniformTolerance = Math.min(1, this.step.count - 2), this.approxExtraTime = this.extraSteps * e.approxTime(), this.init(n - this.approxExtraTime, r + this.approxExtraTime);\n            }\n\n            return e.prototype.getArray = function (t) {\n              switch (t) {\n                case \"xes\":\n                  return this.xes;\n\n                case \"times\":\n                  return this.times;\n\n                case \"values\":\n                  return this.values;\n\n                case \"counts\":\n                  return this.counts;\n\n                default:\n                  return h.Helpers.error(\"TimeSlicer: Invalid get array: '\" + t + \"'\"), null;\n              }\n            }, e.prototype.setArray = function (t, e) {\n              switch (t) {\n                case \"xes\":\n                  return void (this.xes = e);\n\n                case \"times\":\n                  return void (this.times = e);\n\n                case \"values\":\n                  return void (this.values = e);\n\n                case \"counts\":\n                  return void (this.counts = e);\n\n                default:\n                  return void h.Helpers.error(\"TimeSlicer: Invalid set array: '\" + t + \"'\");\n              }\n            }, e.prototype._getOrigin = function (t) {\n              var e = this.scene.timeStepSettings;\n              if (1 === this.step.count || this.uniform) return this.step.roundTimeDown(t, e);\n              var i = this.step.getBigger().roundTimeDown(t, e),\n                  n = this.step.numberOfUnits(i, t);\n              return this.step.add(i, n);\n            }, e.prototype._add = function (t) {\n              if (this.uniform || 1 === this.step.count || \"d\" !== this.step.unit) return t.add(this.step.count, this.step.unit);\n              var e = t.daysInMonth(),\n                  i = t.date();\n              return i + 2 * this.step.count > e + 1 + this.uniformTolerance ? t.add(e - i + 1, \"d\") : t.add(this.step.count, this.step.unit);\n            }, e.prototype._sub = function (t) {\n              if (this.uniform || 1 === this.step.count || \"d\" !== this.step.unit) return t.subtract(this.step.count, this.step.unit);\n\n              if (t.date() <= this.step.count) {\n                t.subtract(1, \"M\");\n                var e = t.daysInMonth() - 1 + 1 - this.step.count + this.uniformTolerance;\n                return t.date(1 + e - (e % this.step.count | 0));\n              }\n\n              return t.subtract(this.step.count, this.step.unit);\n            }, e.prototype.init = function (e, i) {\n              for (var n = this, r = 0; r < this.arrays.length; r++) {\n                var s = this.arrays[r];\n                this.setArray(s, []);\n              }\n\n              if (e >= i) return this.fromIndex = 0, this.toIndex = 0, this.fromBar = null, void (this.toBar = null);\n              this.fromBar = t.moment(this._getOrigin(e)).utc(), this.fromIndex = 0;\n              var a = t.moment(this.fromBar).utc();\n\n              for (this.times.push(a.valueOf()); a.valueOf() < i;) {\n                this._add(a), this.times.push(a.valueOf());\n              }\n\n              this.toIndex = this.times.length, this.toBar = a, this.currentFrom = e, this.currentTo = i, this.xes = this.times.map(function (t) {\n                return n.scene.timeToX(t);\n              });\n\n              for (var o = 0; o < this.extraArrays.length; o++) {\n                var l = this.extraArrays[o],\n                    h = [];\n                h.length = this.times.length, this.setArray(l, h);\n              }\n            }, e.prototype.makeMiniSlice = function (e) {\n              var i = this.scene.timeToXCoefs(),\n                  n = i.tadd,\n                  r = i.tmul,\n                  s = t.moment(this._getOrigin(e)).utc(),\n                  a = s.valueOf(),\n                  o = n + a * r;\n\n              this._add(s);\n\n              var l = s.valueOf();\n              return {\n                t0: a,\n                x0: o,\n                t1: l,\n                x1: n + l * r\n              };\n            }, e.prototype.update = function (t, e) {\n              if (void 0 === t && (t = this.scene.timeStart), void 0 === e && (e = this.scene.timeEnd), null == e && (e = this.scene.timeEnd), null == t && (t = this.scene.timeStart), t -= this.approxExtraTime, e += this.approxExtraTime, t === this.currentFrom && e === this.currentTo) return this.updateXes(this.fromIndex, this.toIndex), {\n                offset: 0,\n                newBefore: this.fromIndex,\n                newAfter: this.toIndex\n              };\n              if (null === this.fromBar || t > this.toBar.valueOf() || e < this.fromBar.valueOf()) return this.init(t, e), {\n                offset: 0,\n                newBefore: this.toIndex,\n                newAfter: this.toIndex\n              };\n              var i = 0,\n                  n = this.fromIndex,\n                  r = this.toIndex,\n                  s = this.scene.timeToXCoefs(),\n                  a = s.tadd,\n                  o = s.tmul,\n                  l = this.fromBar.valueOf() - t;\n\n              if (l > 0) {\n                var h = 2 + (l / this.step.approxTime() | 0);\n\n                if (this.fromIndex < h) {\n                  var u = [];\n                  u.length = h + this.bufExpandSize;\n\n                  for (var c = 0; c < this.arrays.length; c++) {\n                    var d = this.arrays[c];\n                    this.setArray(d, u.concat(this.getArray(d)));\n                  }\n\n                  i += u.length, n += u.length, r += u.length, this.fromIndex += u.length, this.toIndex += u.length;\n                }\n\n                for (var p = this.fromBar.valueOf(); p > t;) {\n                  this._sub(this.fromBar), this.fromIndex -= 1, p = this.fromBar.valueOf(), this.times[this.fromIndex] = p, this.xes[this.fromIndex] = a + p * o;\n                }\n              }\n\n              var f = e - this.toBar.valueOf();\n\n              if (f > 0) {\n                h = 2 + (f / this.step.approxTime() | 0);\n\n                if (this.times.length < this.toIndex + h) {\n                  var g = this.toIndex + h + this.bufExpandSize;\n\n                  for (c = 0; c < this.arrays.length; c++) {\n                    d = this.arrays[c];\n                    this.getArray(d).length = g;\n                  }\n                }\n\n                for (p = this.toBar.valueOf(); p < e;) {\n                  this._add(this.toBar), p = this.toBar.valueOf(), this.times[this.toIndex] = p, this.xes[this.toIndex] = a + p * o, this.toIndex += 1;\n                }\n              }\n\n              for (this._add(this.fromBar); this.fromBar.valueOf() < t;) {\n                this.fromIndex += 1, this._add(this.fromBar);\n              }\n\n              for (this._sub(this.fromBar), this._sub(this.toBar); this.toBar.valueOf() >= e;) {\n                this.toIndex -= 1, this._sub(this.toBar);\n              }\n\n              this._add(this.toBar);\n\n              var m = this.toIndex - this.fromIndex + this.bufExpandSize;\n\n              if (this.fromIndex > m) {\n                var v = this.fromIndex - this.bufExpandSize;\n\n                for (c = 0; c < this.arrays.length; c++) {\n                  d = this.arrays[c];\n                  this.getArray(d).splice(0, v);\n                }\n\n                i -= v, n -= v, r -= v, this.fromIndex -= v, this.toIndex -= v;\n              }\n\n              if (this.toIndex < this.times.length - m) for (c = 0; c < this.arrays.length; c++) {\n                d = this.arrays[c];\n                this.getArray(d).length = this.toIndex + this.bufExpandSize;\n              }\n              return this.updateXes(n, r), this.currentFrom = t, this.currentTo = e, {\n                offset: i,\n                newBefore: n,\n                newAfter: r\n              };\n            }, e.prototype.updateXes = function (t, e) {\n              var i = this.scene.timeToXCoefs(),\n                  n = i.tadd,\n                  r = i.tmul;\n\n              if (this.oldAdd !== n || this.oldMul !== r) {\n                this.oldAdd = n, this.oldMul = r;\n\n                for (var s = t; s <= e - 1; s++) {\n                  this.xes[s] = n + this.times[s] * r;\n                }\n              }\n            }, e;\n          }();\n\n          t.TimeSlicer = b;\n\n          var C = function () {\n            return function () {\n              this.enabled = !0, this.vgrid = !0, this.minUnitWidth = 1, this.maxUnitWidth = 200, this.showHolidays = !0, this.miniTimeRuler = !0, this.unitSizePolicy = \"auto\", this.timeZoneOffset = null, this.timeZone = \"UTC\", this.style = {\n                showMinorTimeBalloons: !1,\n                showMajorTimeBalloons: !0,\n                minorTimeBalloonStyle: {\n                  fillColor: \"#FFF\"\n                },\n                majorTimeBalloonStyle: {\n                  fillColor: null\n                },\n                minorTimeLabel: {\n                  fillColor: \"#000000\",\n                  font: \"12px Arial\"\n                },\n                majorTimeLabel: {\n                  fillColor: \"#FFF\",\n                  font: \"11px Arial\"\n                },\n                dateLighten: {\n                  fillColor: \"rgba(255,255,255,0.2)\"\n                },\n                dateHolidays: {\n                  fillColor: \"rgba(230,230,230,0.2)\"\n                },\n                minorTimeRuler: {\n                  lineColor: \"rgba(0,0,0,0.2)\"\n                },\n                vgrid: {\n                  lineColor: \"rgba(0,0,0,0.1)\"\n                }\n              };\n            };\n          }();\n\n          t.SettingsTimeAxis = C;\n\n          var x = function (e) {\n            function n(t) {\n              var i = e.call(this) || this;\n              return i.curSceneScale = 0, i.minorFormat = null, i.majorFormat = null, i.minorTimeUnit = null, i.majorTimeUnit = null, i.minorLabelHeight = null, i.majorLabelHeight = null, i.minorLabelWidths = null, i.minorLabelBallonWidths = null, i.majorLabelWidths = null, i.fullLabelWidths = null, i.multiYearWidth = 0, i.majorSlices = null, i.minorSlices = null, i.animationOrder = 610, i.paintOrder = 30, i.updateOrder = 1e3, i.multiples = {\n                ms: [1, 10, 100],\n                s: [1, 2, 5, 15, 30],\n                m: [1, 2, 5, 15, 30],\n                h: [1, 3, 6, 12, 24],\n                d: [1, 2, 5, 10],\n                w: [1, 5, 10, 20],\n                M: [1, 3, 6],\n                y: [1, 10, 100, 1e3]\n              }, i.chart = t, i.scene = i.chart.scene, i.tt = new l(t), i.options = i.scene.settings.timeAxis, i.panel = new h.ChartPanel(), i.panel.side = \"bottom\", i.panel.packingOrder = 100, i.panel.computeSize = function (t, e, n, r) {\n                return i.computeSize(t, e, n, r);\n              }, i;\n            }\n\n            return r(n, e), n.prototype.computeSize = function (e, n, r, s) {\n              if (!this.options.enabled) return this.scene.bottomAxisSize = 0, {\n                width: e,\n                height: 0\n              };\n              var a,\n                  o = t.moment(0xc694d6e77ef8).utc(),\n                  l = this.scene.settings.localization.timeAxisDates,\n                  u = this.options.style.minorTimeLabel;\n\n              for (this.minorLabelHeight = .8 * h.Graphics.getTextHeight(r, this.options.style.minorTimeLabel.font), this.minorLabelWidths = {}, this.minorLabelBallonWidths = {}, a = 0; a < i.knownUnits.length; a++) {\n                var c = i.knownUnits[a],\n                    d = h.Graphics.getTextWidth(r, u, o.format(l.minorLabelTimeFormats[c]));\n                this.minorLabelWidths[c] = d, this.minorLabelBallonWidths[c] = d + this.minorLabelHeight;\n              }\n\n              for (u = this.options.style.majorTimeLabel, this.majorLabelHeight = .8 * h.Graphics.getTextHeight(r, this.options.style.majorTimeLabel.font), this.majorLabelWidths = {}, this.fullLabelWidths = {}, a = 0; a < i.knownUnits.length; a++) {\n                c = i.knownUnits[a];\n                this.majorLabelWidths[c] = this.majorLabelHeight + h.Graphics.getTextWidth(r, u, o.format(l.majorLabelTimeFormats[c])), this.fullLabelWidths[c] = this.majorLabelHeight + h.Graphics.getTextWidth(r, u, o.format(l.majorLabelFullTimeFormats[c]));\n              }\n\n              this.multiYearWidth = h.Graphics.getTextWidth(r, u, \"8888 - 8888\") + this.majorLabelHeight;\n              var p = Math.round(Math.min(2.3913043 * (this.minorLabelHeight + this.majorLabelHeight), n));\n              return this.scene.bottomAxisSize = p, {\n                width: e,\n                height: p\n              };\n            }, n.prototype.onSceneChange = function (t) {\n              var e = t.changes.settingsChanges;\n              e && e.timeAxis && (t.changes.bounds = !0);\n            }, n.prototype.getPanels = function () {\n              return [this.panel];\n            }, n.prototype.getMajorLabelWidth = function (t, e) {\n              return \"y\" === t.unit && t.count > 1 ? this.multiYearWidth : e ? this.majorLabelWidths[t.unit] : null !== this.fullLabelWidths && this.fullLabelWidths[t.unit] || null;\n            }, n.prototype.computeLabels = function (t) {\n              var e,\n                  n,\n                  r = new l(this.chart),\n                  s = this.scene.timeEnd - this.scene.timeStart,\n                  a = r.toBiggerDisplayUnit(t);\n\n              if (a) {\n                var o = new i(\"s\", 1);\n\n                for (e = a.isSmaller(o) ? o : a, n = this.computeMinorUnit(e), a = r.toBiggerDisplayUnit(e); a && (a.approxTime() <= .5 * s || e.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(e, null != n)));) {\n                  e = a, n = this.computeMinorUnit(e), a = r.toBiggerDisplayUnit(a);\n                }\n              }\n\n              if (!a) {\n                e = \"y\" === t.unit ? t : new i(\"y\", 1);\n\n                for (var h = 0; h < this.multiples.y.length; h++) {\n                  var u = this.multiples.y[h];\n                  if (e = new i(\"y\", u), n = this.computeMinorUnit(e), e.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(e, null != n))) break;\n                }\n              }\n\n              return {\n                minorUnit: n,\n                majorUnit: e\n              };\n            }, n.prototype.computeMinorUnit = function (t) {\n              var e = this.scene.displayUnit.clone(),\n                  n = new i(i.toSmallerUnit[t.unit], 1);\n              n.unit && n.isBigger(e) && (e = n);\n              e.approxTime();\n              var r = null;\n              if (null === this.minorLabelWidths) return null;\n\n              for (var s = 1.5 * this.scene.dxToDtime(this.minorLabelWidths[e.unit]), a = 0; a < this.multiples[e.unit].length; a++) {\n                var o = this.multiples[e.unit][a];\n\n                if (o < e.count && (o = e.count), e.count = o, s <= e.approxTime()) {\n                  r = e;\n                  break;\n                }\n              }\n\n              return r && r.isEqual(t) && (r = null), r;\n            }, n.prototype.doAnimations = function (t) {\n              if (this.scene.displayUnit && this.scene.timeStart < this.scene.timeEnd) {\n                var e = this.scene.getScale();\n\n                if (!(Math.abs(1 - this.curSceneScale / e) < .001)) {\n                  this.curSceneScale = e;\n                  var i = this.computeLabels(this.scene.displayUnit),\n                      n = i.minorUnit,\n                      r = i.majorUnit;\n                  n ? (this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[n.unit], this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[r.unit]) : (this.minorFormat = null, this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[r.unit]), this.minorTimeUnit = n, this.majorTimeUnit = r, null !== this.majorSlices && r.approxTime() === this.majorSlices.step.approxTime() || (this.majorSlices = new b(this.scene, r)), !n || null !== this.minorSlices && n.approxTime() === this.minorSlices.step.approxTime() ? null === n && (this.minorSlices = null) : this.minorSlices = new b(this.scene, n, [], null, null, !1);\n                }\n\n                this.majorSlices.update(), this.minorSlices && this.minorSlices.update(), this.minorTimeUnit ? (this.scene.minorTimeFormat = this.minorFormat, this.scene.minorTimeUnit = this.minorTimeUnit) : this.scene.displayUnit && (this.scene.minorTimeUnit = this.scene.displayUnit, this.scene.minorTimeFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[this.scene.displayUnit.unit]), this.scene.majorTimeFormat = this.majorFormat, this.scene.majorTimeUnit = this.majorTimeUnit;\n              }\n            }, n.prototype.paintScene = function (e) {\n              if (this.scene.displayUnit && this.options.enabled && this.scene.timeStart < this.scene.timeEnd) {\n                var i = this.scene.settings.timeAxis.style,\n                    n = e.context,\n                    r = e.labelRenderer,\n                    s = this.scene.x0,\n                    a = s + this.scene.width,\n                    o = this.panel.top + 1,\n                    l = this.panel.bottom,\n                    u = l - o,\n                    c = this.scene.y0,\n                    d = this.scene.height,\n                    p = l - 1.8 * this.majorLabelHeight;\n                h.Graphics.pushClip(e, s, c, this.scene.width, u + d);\n                var f = this.majorSlices.xes,\n                    g = this.majorSlices.times,\n                    m = this.majorSlices.fromIndex,\n                    v = this.majorSlices.toIndex,\n                    y = i.dateLighten;\n\n                if (y && y.fillColor) {\n                  var S = this.majorSlices.step.numberOfUnits(0, g[m]);\n                  n.beginPath();\n\n                  for (var b = m + (0 | S) % 2; b <= v - 2; b += 2) {\n                    var C = 1 + (0 | Math.max(f[b], s)),\n                        x = 0 | Math.min(f[b + 1], a);\n                    n.rect(C, o - 1, x - C, u);\n                  }\n\n                  h.Graphics.fill(n, y);\n                }\n\n                if (this.options.showHolidays && this.minorSlices && (\"w\" === this.minorSlices.step.unit || \"d\" === this.minorSlices.step.unit || \"h\" === this.minorSlices.step.unit)) {\n                  var w = this.scene.timeToXCoefs(),\n                      L = w.tadd,\n                      T = w.tmul,\n                      k = this.scene.timeStart;\n                  k = Math.round(k - k % 864e5);\n                  var A = t.moment(k).utc().isoWeekday(),\n                      M = this.scene.settings.localization.holidayWeekdays,\n                      I = i.dateHolidays,\n                      P = h.Graphics.beginStrokeAndFill(n, I);\n\n                  for (C = k * T + L; C <= a;) {\n                    x = C + 864e5 * T;\n                    M.indexOf(A) > -1 && P.rect(C, c, x - C, Math.min(5, u) + d), A = A % 7 + 1, C = x;\n                  }\n\n                  h.Graphics.endStrokeAndFill(n, P, I);\n                }\n\n                if (this.options.vgrid) {\n                  var D = h.Graphics.beginStrokeAndFill(n, this.options.style.vgrid);\n\n                  for (b = m + 1; b <= v - 2; b++) {\n                    if ((Y = .5 + (0 | f[b])) >= a) break;\n                    D.moveTo(Y, c), D.lineTo(Y, l);\n                  }\n\n                  h.Graphics.endStrokeAndFill(n, D, this.options.style.vgrid);\n                }\n\n                var N = \"y\" === this.majorSlices.step.unit && this.majorSlices.step.count > 1,\n                    F = this.getMajorLabelWidth(this.majorSlices.step, null != this.minorFormat),\n                    O = this.scene.momentLocale;\n\n                if (!this.minorSlices || this.majorSlices.step.unit !== this.minorSlices.step.unit) {\n                  if (i.showMajorTimeBalloons) {\n                    n.beginPath();\n\n                    for (b = m; b <= v - 2; b++) {\n                      var E = f[b],\n                          R = f[b + 1];\n\n                      if (!(E >= a || R <= s)) {\n                        var H = (E + R) / 2;\n                        E < s && (E = s, H = Math.min((E + R) / 2, R - F)), R > a && (R = a, H = Math.max((E + R) / 2, E + F)), h.Graphics.strokeBalloon2(n, H, p + 1, F, this.majorLabelHeight);\n                      }\n                    }\n\n                    h.Graphics.paint(n, i.majorTimeBalloonStyle);\n                  }\n\n                  for (b = m; b <= v - 2; b++) {\n                    E = f[b], R = f[b + 1];\n\n                    if (!(E >= a || R <= s)) {\n                      k = g[b];\n                      var B = void 0;\n\n                      if (N) {\n                        var z = g[b + 1] - 1;\n                        B = t.moment.utc(k).locale(O).format(this.majorFormat) + \" - \" + t.moment(z).locale(O).utc().format(this.majorFormat);\n                      } else B = t.moment.utc(k).locale(O).format(this.majorFormat);\n\n                      H = (E + R) / 2;\n                      E < s && (E = s, H = Math.min((E + R) / 2, R - F)), R > a && (R = a, H = Math.max((E + R) / 2, E + F));\n                      var U = new h.Label({\n                        text: B,\n                        textStyle: i.majorTimeLabel\n                      }, !0);\n                      r.paint(n, H, p, 1, U);\n                    }\n                  }\n                }\n\n                var G = this.scene.settings.timeAxis,\n                    j = G.style.minorTimeRuler;\n\n                if (this.minorSlices) {\n                  g = this.minorSlices.times, f = this.minorSlices.xes, m = this.minorSlices.fromIndex, v = this.minorSlices.toIndex, F = this.minorLabelWidths[this.minorSlices.step.unit];\n                  var W = o + .4 * this.minorLabelHeight | 0,\n                      V = o - 1,\n                      Z = W + 1.6 * this.minorLabelHeight | 0;\n\n                  if (i.showMinorTimeBalloons) {\n                    n.beginPath();\n\n                    for (b = m; b <= v - 1; b++) {\n                      var Y = f[b];\n                      h.Graphics.strokeBalloon(n, Y, o - 5, F, this.minorLabelHeight);\n                    }\n\n                    h.Graphics.paint(n, i.minorTimeBalloonStyle);\n                  } else {\n                    var q = this.majorSlices.fromIndex,\n                        _ = this.majorSlices.xes;\n                    n.beginPath();\n                    var X = q;\n\n                    for (b = m; b <= v - 1; b++) {\n                      for (Y = f[b]; Y > _[X];) {\n                        X += 1;\n                      }\n\n                      if (_[X] !== Y) {\n                        if (Y >= a) break;\n                        Y = (0 | Y) - .5, n.moveTo(Y, V), n.lineTo(Y, Z);\n                      }\n                    }\n\n                    h.Graphics.stroke(n, j);\n                  }\n\n                  var Q = i.showMinorTimeBalloons ? \"center\" : \"left\",\n                      J = i.showMinorTimeBalloons ? 0 : 3;\n\n                  for (b = m; b <= v - 1; b++) {\n                    Y = f[b], k = g[b], B = t.moment(k).locale(O).utc().format(this.minorFormat), U = new h.Label({\n                      text: B,\n                      aspectRatio: 1e9,\n                      align: Q,\n                      textStyle: i.minorTimeLabel\n                    });\n                    r.measure(n, U);\n                    var K = Y + J + U.hwidth;\n                    r.paint(n, K, W + U.hheight, 1, U);\n                  }\n                }\n\n                var $ = this.chart.dataWarehouse.getDisplayUnitsSlicer();\n\n                if (G.miniTimeRuler && j && $ && $.xes[$.fromIndex + 1] - $.xes[$.fromIndex] > 4) {\n                  var tt = o - 1,\n                      et = o + 3;\n                  f = $.xes;\n                  var it = this.majorSlices.fromIndex,\n                      nt = this.minorSlices ? this.minorSlices.fromIndex : it,\n                      rt = this.majorSlices.xes,\n                      st = this.minorSlices ? this.minorSlices.xes : rt;\n                  n.beginPath();\n                  var at = it,\n                      ot = nt,\n                      lt = 0;\n\n                  for (b = $.fromIndex; b <= $.toIndex - 2; b++) {\n                    for (Y = f[b]; Y > rt[at];) {\n                      at += 1;\n                    }\n\n                    if (rt[at] !== Y) {\n                      for (; Y > st[ot];) {\n                        ot += 1;\n                      }\n\n                      if (st[ot] !== Y) {\n                        if (Y >= a) break;\n                        Y = (0 | Y) - .5, n.moveTo(Y, tt), n.lineTo(Y, et), lt++;\n                      }\n                    }\n                  }\n\n                  if (lt && h.Graphics.stroke(n, j), -1 !== this.scene.settings.advanced.themeCSSClass.indexOf(\"gradient\")) {\n                    var ht = h.Colors.colorTone(j.lineColor, 2, 2);\n                    lt = 0, n.beginPath(), at = it, ot = nt;\n\n                    for (b = $.fromIndex; b <= $.toIndex - 2; b++) {\n                      for (Y = f[b]; Y > rt[at];) {\n                        at += 1;\n                      }\n\n                      if (rt[at] !== Y) {\n                        for (; Y > st[ot];) {\n                          ot += 1;\n                        }\n\n                        if (st[ot] !== Y) {\n                          if (Y >= a) break;\n                          Y = .5 + (0 | Y), n.moveTo(Y, tt), n.lineTo(Y, et), lt++;\n                        }\n                      }\n                    }\n\n                    lt && h.Graphics.stroke(n, {\n                      lineColor: ht.color\n                    });\n                  }\n                }\n\n                h.Graphics.popClip(e);\n              }\n            }, n;\n          }(h.ChartElement);\n\n          t.TimeAxis = x;\n\n          var w = function () {\n            return function () {\n              this.enabled = !0, this.label = {\n                padding: 3,\n                margin: 3,\n                aspectRatio: 3,\n                align: \"center\",\n                textStyle: {\n                  fillColor: \"white\",\n                  font: \"12px Arial\"\n                },\n                backgroundStyle: {\n                  lineColor: \"#0099cc\",\n                  fillColor: \"#0099cc\"\n                }\n              }, this.align = \"left\", this.side = \"top\", this.style = {\n                lineColor: \"#0099cc\"\n              }, this.time = null, this.overrideLimits = !1, this.showTime = !1;\n            };\n          }();\n\n          t.SettingsMarker = w;\n\n          var L = function () {\n            return function (t, e, i) {\n              if (this.labelCacheUnit = null, this.labelCacheTime = null, this.initialText = null, this.isMilestone = !0, this.settings = e, this.label = new h.Label(e.label), i) {\n                var n = h.Helpers.clone(i);\n                h.Helpers.extendStyleTo(this.label.style.textStyle, n), n.fillColor || (n.fillColor = e.style.lineColor), this.label.style.textStyle = n;\n              }\n\n              null != e.time ? this.time = t.timestampToInternal(e.time, !0) : this.time = null, this.initialText = this.label.text || null;\n            };\n          }();\n\n          t.Marker = L;\n\n          var T = function (e) {\n            function i(t) {\n              var i = e.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 40, i.updateOrder = 800, i.scene = null, i._initialized = !1, i.chart = t, i.scene = i.chart.scene, i;\n            }\n\n            return r(i, e), i.prototype.onSceneChange = function (t) {\n              if (this.chart.assetsLoaded) {\n                var e = t.changes,\n                    i = e.settingsChanges,\n                    n = i && i.milestones;\n                (!this._initialized || n || e.assets) && (this.createMarkers(), this._initialized = !0), (e.time || n) && this.scene.markers.sort(function (t, e) {\n                  return t.time - e.time;\n                });\n              }\n            }, i.prototype.paintScene = function (t) {\n              var e = this.scene,\n                  i = e.markers,\n                  n = t.labelRenderer,\n                  r = t.context;\n\n              if (0 !== i.length && e.displayUnit) {\n                var s = Math.round(e.y0);\n                r.textBaseline = \"middle\", h.Graphics.pushClip(t, e.x0, Math.round(e.y0), e.width, e.height + e.bottomAxisSize);\n\n                for (var a = this.getRenderingParts(t, i), o = a.lines, l = 0; l < o.length; l++) {\n                  var u = o[l],\n                      c = h.Graphics.beginStrokeAndFill(r, u.style),\n                      d = \"bottom\" === u.side ? this.getTopPos(u.x, 0) : s + e.height;\n                  d = Math.round(d), c.moveTo(u.x, d), c.lineTo(u.x, u.y), h.Graphics.endStrokeAndFill(r, c, u.style);\n                }\n\n                for (var p = a.labels, f = 0; f < p.length; f++) {\n                  var g = p[f];\n                  n.paint(r, g.x, g.y, 1, g.label);\n                }\n\n                h.Graphics.popClip(t);\n              }\n            }, i.prototype.getRenderingParts = function (e, i) {\n              for (var n = e.context, r = this.scene, s = e.labelRenderer, a = r.displayUnit.unit, o = r.settings.localization.markerDates.timeFormats[a], l = r.x0, h = l + r.width, u = Math.round(r.y0), c = Math.round(u + r.height), d = [], p = [], f = [], g = [], m = [], v = [], y = [], S = [], b = this.scene.momentLocale, C = 0; C < i.length; C++) {\n                var x = i[C],\n                    w = r.timeToX(x.time);\n                w = Math.floor(w) + .5, x.labelCacheUnit === a && x.labelCacheTime === x.time || (null !== x.initialText ? (x.label.text = x.initialText, x.settings.showTime && (x.label.text += \" \" + t.moment(x.time).locale(b).utc().format(o).replace(/ /g, \" \"))) : x.settings.showTime && (x.label.text = t.moment(x.time).locale(b).utc().format(o).replace(/ /g, \" \")), s.measure(n, x.label), x.labelCacheUnit = a, x.labelCacheTime = x.time);\n                var L = x.label.style.margin || 0,\n                    T = x.label.hwidth + L,\n                    k = x.label.hheight + L,\n                    A = 2 * T,\n                    M = 2 * k;\n\n                if (w + T >= l - 1 && w - T <= h + 1) {\n                  var I = x.settings.align,\n                      P = \"center\" === I ? T : A;\n                  w + P >= h ? (I = \"left\", w -= 2) : w - P <= l && (I = \"right\", w += 2);\n                  var D = w - T,\n                      N = w + T,\n                      F = w;\n                  \"left\" === I ? (F = w - T + L, N = w, D = w - A) : \"right\" === I && (F = w + T - L, N = w + A, D = w);\n                  var O = [],\n                      E = -1,\n                      R = D < l ? Math.max(l, D) : D > h ? Math.min(h, D) : D,\n                      H = this.getTopPos(R, P),\n                      B = \"top\" === x.settings.side ? H : Math.round(r.height + .5 * r.bottomAxisSize);\n                  if (0 !== d.length) for (;;) {\n                    var z = -1 !== E ? f[E] + m[E] : B,\n                        U = z + M;\n                    E = -1;\n\n                    for (var G = 0; G < d.length; G++) {\n                      if (-1 === O.indexOf(G)) {\n                        var j = p[G],\n                            W = d[G],\n                            V = f[G],\n                            Z = g[G];\n\n                        if ((D >= W && D <= j || N >= W && N <= j || D <= W && N >= j) && (z >= V && z <= Z || U >= V && U <= Z || z <= V && U >= Z)) {\n                          O.push(G), B = f[G] + m[G], E = G;\n                          break;\n                        }\n                      }\n                    }\n\n                    if (-1 === E) break;\n                  }\n                  var Y = void 0;\n                  \"top\" === x.settings.side ? Y = B + k : (c = u + r.height - k + L, Y = Math.min(B, r.height + .5 * r.bottomAxisSize)), Y = .5 + (0 | Y), m.push(M), v.push(A), f.push(B), g.push(B + M), d.push(D), p.push(D + A);\n                  var q = {\n                    value: c,\n                    changes: !1\n                  };\n                  null != x.animator && (q = x.animator.updateAndGet(Y, e.timeStamp)), y.push({\n                    x: w,\n                    y: q.value + k - L,\n                    style: x.settings.style,\n                    side: x.settings.side\n                  }), S.push({\n                    x: F,\n                    y: q.value,\n                    label: x.label\n                  }), q.changes && (e.animating = !0);\n                }\n              }\n\n              return {\n                lines: y,\n                labels: S\n              };\n            }, i.prototype.getTopPos = function (t, e) {\n              var i = this.scene.x0 + this.scene.width;\n              return this.chart.shell.getChartInnerArea().findTopPosition(t, Math.min(t + e, i));\n            }, i.prototype.createMarkers = function () {\n              var t = this.scene,\n                  e = t.markers.filter(function (t) {\n                return !t.isMilestone;\n              }),\n                  i = t.settings,\n                  n = i.milestones;\n\n              for (var r in n) {\n                var s = n[r];\n\n                if (s.enabled) {\n                  var a = new L(t, s, i.area.style.markerText);\n                  a.animator = new h.Animator(0, 0, 200), e.push(a);\n                }\n              }\n\n              t.markers = e;\n            }, i;\n          }(h.ChartElement);\n\n          t.Markers = T;\n\n          var k = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.showTime = !0, e.align = \"left\", e.side = \"bottom\", e.label = {\n                margin: 4,\n                padding: 3,\n                textStyle: {\n                  font: \"12px Arial\",\n                  fillColor: \"red\"\n                }\n              }, e.style = {\n                lineColor: \"red\"\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(w);\n\n          t.SettingsCurrentTime = k;\n\n          var A = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 100, i.paintOrder = 35, i.updateOrder = 900, i.marker = null, i.timeTimerUnit = null, i.timeTimer = null, i.timeTimerTarget = -1 / 0, i.timeTickerEnabled = !1, i.timeTimerCheckAlways = !1, i._lastAnchor = null, i.chart = e, i.settings = i.chart.settings, i.scene = i.chart.scene, i.events = i.chart.events, i.createMarker(), i.updateTimers(), i;\n            }\n\n            return r(e, t), e.prototype.updateTimers = function () {\n              var t = this,\n                  e = this.settings.advanced;\n              this.timeTickerEnabled = e.timeUpdateInterval && (this.settings.currentTime.enabled || \"now\" === this.scene.anchor), this.timeTickerEnabled ? this.updateCurTime() : this.timeTimer && (clearTimeout(this.timeTimer), this.timeTimer = null), e.dataUpdateInterval ? this.dataTimer = setInterval(function () {\n                return t.dataTick();\n              }, e.dataUpdateInterval) : this.dataTimer && (clearInterval(this.dataTimer), this.dataTimer = null);\n            }, e.prototype.createMarker = function () {\n              var t = this.settings.currentTime,\n                  e = this.marker,\n                  i = this.scene.markers;\n              e && (i.splice(i.indexOf(e), 1), this.marker = null), t.enabled && ((e = this.marker = new L(this.scene, t, null)).isMilestone = !1, i.push(e));\n            }, e.prototype.onSceneChange = function (t) {\n              var e = !1,\n                  i = t.changes.settingsChanges;\n              i && ((i.advanced || i.currentTime) && (this.updateTimers(), e = !0), i.currentTime && this.createMarker()), this._lastAnchor !== this.scene.anchor && (e || this.updateTimers(), this._lastAnchor = this.scene.anchor), this.timeTickerEnabled && (t.changes.timeMarker || t.changes.time && (this.timeTimerCheckAlways || !this.timeTimer || this.scene.getScale() < this.timeTimerUnit)) && (this.updateCurTime(), this.updateVisiblePeriod());\n            }, e.prototype.timerTick = function () {\n              this.timeTimer = null, this.chart.removed || (this.updateCurTime(), this.updateVisiblePeriod());\n            }, e.prototype.dataTick = function () {\n              var t = this;\n\n              if (this.dataTimer = null, !this.chart.removed && this.scene.displayUnit) {\n                var e = this.scene.getCurTime(),\n                    i = function i() {\n                  t.updateVisiblePeriod();\n                };\n\n                for (var n in this.chart.data) {\n                  this.chart.data[n].updateData(this.scene.displayUnit, e, i);\n                }\n              }\n            }, e.prototype.doAnimations = function (t) {\n              t.changes.data && this.updateVisiblePeriod();\n            }, e.prototype.updateCurTime = function (t) {\n              var e = this,\n                  i = this.scene;\n              this.timeTimerUnit = i.getScale();\n              var n = i.getCurTime();\n              this.marker && (this.marker.time = n);\n              var r = i.timeToX(n);\n\n              if (!isNaN(r)) {\n                var s = r + 200 > i.x0 && r - 200 < i.x0 + i.width,\n                    a = this.settings.advanced.timeUpdateInterval,\n                    o = 0;\n                if (s) this.timeTimerCheckAlways = !1, void 0 === t && this.events.notifySceneChanges({\n                  requestPaint: !0\n                }), i.displayUnit.approxTime() >= 36e5 && (o = (i.xToTime(r + 1 | 0) - n) / 2, a = Math.max(a, o), o /= 4);else {\n                  if (r > 0) return;\n                  a = Math.max(a, i.dxToDtime(-r - 200) / 2), this.timeTimerCheckAlways = !0;\n                }\n                var l = +new Date();\n\n                if (this.timeTimer) {\n                  if (this.timeTimerTarget - l < a + o) return;\n                  window.clearTimeout(this.timeTimer);\n                }\n\n                s && i.dTimeToDx(a) > 1 ? this.events.notifySceneChanges({\n                  timeMarker: !0\n                }) : (this.timeTimerTarget = l + a, this.timeTimer = setTimeout(function () {\n                  return e.timerTick();\n                }, a));\n              }\n            }, e.prototype.updateVisiblePeriod = function () {\n              var t = this.scene,\n                  e = t.displayUnit;\n\n              if (e && this.settings.navigation.followAnchor) {\n                var i = null;\n                if (\"now\" === t.anchor) i = t.getCurTime();else if (\"newestData\" === t.anchor) {\n                  i = this.chart.getDataLimits().to;\n                }\n\n                if (null !== i) {\n                  var n = this.chart.scrolling,\n                      r = n.getTo();\n\n                  if (r < i) {\n                    var s = n.getFrom(),\n                        a = e.roundTimeUp(i, t.timeStepSettings) - r;\n                    this.chart.scrolling.setTimeRangeSnap(s + a, r + a, r + a, t.displayUnit, !0, \"timer\", !0, !1);\n                  }\n                }\n              }\n            }, e;\n          }(h.ChartElement);\n\n          t.TimeUpdater = A;\n\n          var M = function (t) {\n            function e(i) {\n              var n = t.call(this, h.SettingsMapping.TimeChartSettings) || this;\n              return n._minUnit = null, n._displayUnitsParsed = [], n._displayPeriodsParsed = [], n._computedDataMap = {}, n.theme = e.FlatTheme, n.navigation = {\n                initialDisplayAnchor: \"newestData\",\n                initialDisplayPeriod: \"max\",\n                initialDisplayUnit: \"auto\",\n                followAnchor: !1\n              }, n.area = new j(), n.chartTypes = {\n                columns: {\n                  type: \"columns\"\n                },\n                line: {\n                  type: \"line\"\n                },\n                candlestick: {\n                  type: \"candlestick\"\n                }\n              }, n.currentTime = new k(), n.milestones = [], n.timeAxis = new C(), n.data = [], n.toolbar = new s(), n.localization = new B(), n.interaction = new U(), n.advanced = new H(), n.events = new R(), n.advanced.assets.push({\n                url: \"assets://moment.js\",\n                required: function required() {\n                  return !window.moment;\n                }\n              }), n.advanced.assets.push({\n                url: \"assets://moment-tz.js\",\n                required: function required() {\n                  return !window.moment || !window.moment.tz;\n                }\n              }), n.apply(i), n._initializing = !1, n;\n            }\n\n            return r(e, t), e.prototype.timeZoneCompatibility = function () {\n              var t = this.timeAxis;\n              null == t.timeZone && (t.timeZone = \"UTC\", h.Helpers.warn(\"`null` is not a valid value for `timeAxis.timeZone`, using `UTC`\")), \"local\" === t.timeZoneOffset && (t.timeZoneOffset = -new Date().getTimezoneOffset());\n\n              for (var e = this.data, i = 0; i < e.length; i++) {\n                var n = e[i];\n                null != n.timeZoneOffset && (h.Helpers.error(\"Setting `data.timeZoneOffset` has been deprecated. Please use `timeZone` in the data response instead.\"), \"local\" === n.timeZoneOffset && (n.timeZoneOffset = -new Date().getTimezoneOffset()));\n              }\n            }, e.prototype.apply = function (e) {\n              this.applyCompatibility(e, [{\n                from: \"toolbars\",\n                to: \"toolbar\"\n              }, {\n                from: \"toolbar.periodSelection\",\n                to: \"toolbar.displayPeriod\"\n              }, {\n                from: \"toolbar.zoomOutButton\",\n                to: \"toolbar.zoomOut\"\n              }, {\n                from: \"toolbar.backButton\",\n                to: \"toolbar.back\"\n              }, {\n                from: \"interaction.scrolling.noData\",\n                to: \"interaction.scrolling.limitMode\"\n              }, {\n                from: \"interaction.scrolling.noDataSnapBackProportion\",\n                to: \"interaction.scrolling.overscrollProportion\",\n                transform: function transform(t) {\n                  return 1 - t;\n                }\n              }, {\n                from: \"area.initialDisplayPeriod\",\n                to: \"navigation.initialDisplayPeriod\"\n              }, {\n                from: \"area.initialDisplayAnchor\",\n                to: \"navigation.initialDisplayAnchor\"\n              }, {\n                from: \"area.initialDisplayUnit\",\n                to: \"navigation.initialDisplayUnit\"\n              }, {\n                from: \"area.followAnchor\",\n                to: \"navigation.followAnchor\"\n              }, {\n                from: \"timeAxis.timeZoneOffset\",\n                alternative: \"timeAxis.timeZone\"\n              }, {\n                from: \"timeAxis.style.vgrid\",\n                to: \"timeAxis.style.vgrid.lineColor\",\n                filter: function filter(t) {\n                  return \"string\" == typeof t;\n                }\n              }, {\n                from: \"currentTime.overrideCurTime\",\n                to: \"currentTime.time\"\n              }, {\n                from: \"advanced.maxUnitsToDisplay\",\n                alternative: \"timeAxis.minUnitWidth\"\n              }]);\n              var i = t.prototype.apply.call(this, e, I);\n              return this.timeZoneCompatibility(), this._calcMinUnit(), this._displayUnitsParsed = this._parseUnits(this.area.displayUnits), this._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods), i;\n            }, e.prototype._parseUnits = function (t) {\n              for (var e = [], n = 0; n < t.length; n++) {\n                var r = t[n],\n                    s = i.parse(r.unit, r.name);\n                this._minUnit.isSmallerOrEqual(s) && e.push(s);\n              }\n\n              return e.sort(function (t, e) {\n                return t.approxTime() - e.approxTime();\n              });\n            }, e.prototype._parsePeriods = function (t) {\n              for (var e = [], n = 0; n < t.length; n++) {\n                var r = i.parse(t[n].unit);\n                r && this._minUnit.isSmallerOrEqual(r) && e.push(r);\n              }\n\n              return e.sort(function (t, e) {\n                return t.approxTime() - e.approxTime();\n              });\n            }, e.prototype._calcMinUnit = function () {\n              for (var t = new i(\"y\", 1e6), e = t, n = 0; n < this.area.displayUnits.length; n++) {\n                var r = this.area.displayUnits[n],\n                    s = i.parse(r.unit, r.name);\n                s.isSmaller(t) && (t = s);\n              }\n\n              for (n = 0; n < this._computedSeries.length; n++) {\n                var a = this._computedSeries[n],\n                    o = this._computedDataMap[a.data.source];\n                if (!o) throw new Error(\"Data source `\" + a.data.source + \"` for series not found!\");\n\n                for (var l = 0; l < o.units.length; l++) {\n                  var h = o.units[l],\n                      u = i.parse(h);\n                  u.isSmaller(e) && (e = u);\n                }\n              }\n\n              e.isBigger(t) && (t = e), this._minUnit = t;\n            }, e;\n          }(a.Settings);\n\n          M.StaticChart = {\n            interaction: {\n              zooming: {\n                enabled: !1,\n                click: !1\n              },\n              selection: {\n                enabled: !1\n              },\n              scrolling: {\n                enabled: !1\n              },\n              resizing: {\n                enabled: !1\n              }\n            },\n            toolbar: {\n              items: [\"export\"]\n            }\n          }, M.DarkTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat DVSL-dark\",\n              style: {\n                loadingArcStyle: {\n                  lineColor: \"#EEE\"\n                },\n                messageTextStyle: {\n                  fillColor: \"#EEE\"\n                }\n              }\n            },\n            area: {\n              style: {\n                fillColor: \"rgba(28,26,28,1)\",\n                noData: {\n                  fillColor: \"#DDD\",\n                  image: \"builtin://linearchart-no-data-light\"\n                },\n                selection: {\n                  lineColor: \"#838283\"\n                },\n                selectionLabel: {\n                  fillColor: \"#BFBBB9\"\n                },\n                zoomHighlight: {\n                  fillColor: \"rgba(142,142,142,0.15)\"\n                },\n                zoomHighlightInactive: {\n                  fillColor: \"rgba(142,142,142,0.15)\"\n                }\n              }\n            },\n            title: {\n              margin: 15,\n              style: {\n                fillColor: \"#A8A7A8\"\n              }\n            },\n            chartTypes: {\n              columns: {\n                style: {\n                  gradient: 1,\n                  depth: 0\n                }\n              }\n            },\n            valueAxisDefault: {\n              style: {\n                valueLabel: {\n                  textStyle: {\n                    fillColor: \"#A8A7A8\"\n                  }\n                },\n                title: {\n                  textStyle: {\n                    fillColor: \"#A8A7A8\"\n                  }\n                }\n              }\n            },\n            timeAxis: {\n              style: {\n                majorTimeLabel: {\n                  fillColor: \"#A8A7A8\",\n                  shadowColor: null\n                },\n                minorTimeLabel: {\n                  fillColor: \"#A8A7A8\",\n                  shadowColor: null\n                },\n                minorTimeRuler: {\n                  lineColor: \"#838283\"\n                },\n                dateLighten: {\n                  fillColor: \"rgba(142,142,142,0.15)\"\n                },\n                dateHolidays: {\n                  fillColor: \"rgba(139,139,139,0.11)\"\n                }\n              }\n            },\n            info: {\n              style: {\n                highlight: {\n                  fillColor: \"rgba(142,142,142,0.15)\"\n                }\n              }\n            },\n            currentTime: {\n              style: {\n                lineColor: \"#D12E2B\"\n              }\n            },\n            legend: {\n              text: {\n                fillColor: \"#A8A7A8\"\n              },\n              advanced: {\n                disabledSeries: {\n                  textColor: \"rgba(168,167,168,0.5)\",\n                  lineColor: \"rgba(117,117,117,0.8)\"\n                }\n              }\n            }\n          }, M.FlatTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\"\n            },\n            area: {\n              style: {\n                noData: {\n                  fillColor: \"#DDD\",\n                  image: \"builtin://linearchart-no-data-light\"\n                }\n              }\n            },\n            chartTypes: {\n              columns: {\n                style: {\n                  gradient: 1,\n                  depth: 0\n                }\n              }\n            },\n            timeAxis: {\n              style: {\n                showMajorTimeBalloons: !1,\n                showMinorTimeBalloons: !1,\n                majorTimeLabel: {\n                  fillColor: \"#000\",\n                  shadowColor: null\n                },\n                minorTimeLabel: {\n                  fillColor: \"#000\",\n                  shadowColor: null\n                },\n                dateLighten: {\n                  fillColor: \"rgba(0,0,0,0.05)\"\n                }\n              }\n            }\n          }, M.RoundTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-round\"\n            },\n            valueAxisDefault: {\n              style: {\n                valueLabel: {\n                  textStyle: {\n                    fillColor: \"#000000\",\n                    font: \"11px Arial\",\n                    shadowOffsetX: 0,\n                    shadowOffsetY: 1,\n                    shadowBlur: 0,\n                    shadowColor: \"rgba(255,255,255,0.5)\"\n                  }\n                }\n              }\n            },\n            timeAxis: {\n              style: {\n                showMinorTimeBalloons: !1,\n                showMajorTimeBalloons: !0,\n                minorTimeBalloonStyle: {\n                  fillColor: \"#FFF\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 2,\n                  shadowBlur: 2,\n                  shadowColor: \"#888\"\n                },\n                majorTimeBalloonStyle: {\n                  fillColor: \"#AAA\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0,\n                  shadowColor: \"rgba(0,0,0,0.3)\"\n                },\n                minorTimeLabel: {\n                  fillColor: \"#000000\",\n                  font: \"12px Arial\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 1,\n                  shadowBlur: 0,\n                  shadowColor: \"rgba(255,255,255,0.5)\"\n                },\n                majorTimeLabel: {\n                  fillColor: \"#FFF\",\n                  font: \"11px Arial\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 1,\n                  shadowBlur: 1,\n                  shadowColor: \"#7c7c7c\"\n                },\n                minorTimeRuler: {\n                  lineColor: \"rgba(0,0,0,0.2)\"\n                },\n                dateLighten: {\n                  fillColor: \"rgba(0,0,0,0.05)\"\n                }\n              }\n            },\n            chartTypes: {\n              columns: {\n                style: {\n                  gradient: .8,\n                  depth: 3\n                }\n              }\n            },\n            area: {\n              style: {\n                noData: {\n                  image: \"builtin://linearchart-no-data-dark\"\n                }\n              }\n            }\n          }, M.GradientTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-gradient\"\n            },\n            valueAxisDefault: {\n              style: {\n                valueLabel: {\n                  textStyle: {\n                    fillColor: \"#000000\",\n                    font: \"11px Arial\",\n                    shadowOffsetX: 0,\n                    shadowOffsetY: 1,\n                    shadowBlur: 0,\n                    shadowColor: \"rgba(255,255,255,0.5)\"\n                  }\n                }\n              }\n            },\n            timeAxis: {\n              style: {\n                showMinorTimeBalloons: !1,\n                showMajorTimeBalloons: !0,\n                minorTimeBalloonStyle: {\n                  fillColor: \"#FFF\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 2,\n                  shadowBlur: 2,\n                  shadowColor: \"#888\"\n                },\n                majorTimeBalloonStyle: {\n                  fillColor: \"AAA\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: -1,\n                  shadowBlur: 0,\n                  shadowColor: \"rgba(0,0,0,0.3)\"\n                },\n                minorTimeLabel: {\n                  fillColor: \"#000000\",\n                  font: \"12px Arial\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 1,\n                  shadowBlur: 0,\n                  shadowColor: \"rgba(255,255,255,0.5)\"\n                },\n                majorTimeLabel: {\n                  fillColor: \"#FFF\",\n                  font: \"11px Arial\",\n                  shadowOffsetX: 0,\n                  shadowOffsetY: 1,\n                  shadowBlur: 1,\n                  shadowColor: \"#7c7c7c\"\n                },\n                minorTimeRuler: {\n                  lineColor: \"rgba(0,0,0,0.2)\"\n                },\n                dateLighten: {\n                  fillColor: \"rgba(255,255,255,0.2)\"\n                }\n              }\n            },\n            chartTypes: {\n              columns: {\n                style: {\n                  gradient: .8,\n                  depth: 3\n                }\n              }\n            },\n            area: {\n              style: {\n                noData: {\n                  image: \"builtin://linearchart-no-data-dark\"\n                }\n              }\n            }\n          }, t.Settings = M;\n\n          var I = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = new P(), e;\n            }\n\n            return r(e, t), e.getMapping = function (t, e) {\n              if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n              switch (t ? t.type : e.type) {\n                case \"columns\":\n                case void 0:\n                  return h.SettingsMapping.TimeChartSettingsSeriesColumns;\n\n                case \"candlestick\":\n                  return h.SettingsMapping.TimeChartSettingsSeriesCandleStick;\n\n                case \"line\":\n                  return h.SettingsMapping.TimeChartSettingsSeriesLines;\n\n                default:\n                  throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.\");\n              }\n            }, e.createInstance = function (t, e) {\n              switch (e || t.type) {\n                case \"columns\":\n                case void 0:\n                  return new D();\n\n                case \"candlestick\":\n                  return new E();\n\n                case \"line\":\n                  return new N();\n\n                default:\n                  throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.\");\n              }\n            }, e;\n          }(a.SettingsSeries);\n\n          t.SettingsSeries = I;\n\n          var P = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.index = 1, e.countIndex = null, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesData);\n\n          t.SettingsSeriesData = P;\n\n          var D = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = new P(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesColumns);\n\n          t.SettingsSeriesColumns = D;\n\n          var N = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = new P(), e.style = new F(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesLines);\n\n          t.SettingsSeriesLines = N;\n\n          var F = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.markerStyleFunction = null, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesLinesStyle);\n\n          t.SettingsSeriesLinesStyle = F;\n\n          var O = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.high = null, e.open = null, e.close = null, e.low = null, e;\n            }\n\n            return r(e, t), e;\n          }(P);\n\n          t.SettingsSeriesCandleStickData = O;\n\n          var E = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = new O(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesCandleStick);\n\n          t.SettingsSeriesCandleStick = E;\n\n          var R = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.selectionChangeDuringInteraction = !1, e.onTimeChange = null, e.chartUpdateDelay = 400, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsEvents);\n\n          t.SettingsEvents = R;\n\n          var H = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.timeUpdateInterval = 900, e.dataUpdateInterval = null, e.maxUnitsToDisplay = 2e4, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsAdvanced);\n\n          t.SettingsAdvanced = H;\n\n          var B = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.calendar = {\n                parentLocale: null\n              }, e.holidayWeekdays = [6, 7], e.toolbar = new z(), e.timeUnitsNames = {\n                ms: \"millisecond\",\n                s: \"second\",\n                m: \"minute\",\n                h: \"hour\",\n                d: \"day\",\n                w: \"week\",\n                M: \"month\",\n                y: \"year\"\n              }, e.timeUnitsNamesPlural = {\n                ms: \"milliseconds\",\n                s: \"seconds\",\n                m: \"minutes\",\n                h: \"hours\",\n                d: \"days\",\n                w: \"weeks\",\n                M: \"months\",\n                y: \"years\"\n              }, e.markerDates = {\n                timeFormats: {\n                  ms: \"HH:mm:ss\",\n                  s: \"HH:mm:ss\",\n                  m: \"HH:mm:ss\",\n                  h: \"HH:mm\",\n                  d: \"D, HH:mm\",\n                  w: \"MMM D\",\n                  M: \"MMM D\",\n                  y: \"YYYY, MMM D\"\n                }\n              }, e.infoDates = {\n                majorTimeFormats: {\n                  y: null,\n                  M: \"YYYY\",\n                  w: \"GGGG\",\n                  d: \"YYYY\",\n                  h: \"MMM D, YYYY\",\n                  m: \"MMM D, YYYY\",\n                  s: \"MMM D, YYYY\",\n                  ms: \"MMM D, YYYY\"\n                },\n                minorTimeFormats: {\n                  y: \"YYYY\",\n                  M: \"MMM\",\n                  w: \"[Week] W\",\n                  d: \"MMM D\",\n                  h: \"HH:mm\",\n                  m: \"HH:mm\",\n                  s: \"HH:mm:ss\",\n                  ms: \"ss.SSS\"\n                },\n                fullTimeFormats: {\n                  ms: \"MMM D, YYYY HH:mm:ss\",\n                  s: \"MMM D, YYYY HH:mm:ss\",\n                  m: \"MMM D, YYYY, HH:mm\",\n                  h: \"MMM D, YYYY HH:00\",\n                  d: \"MMM D, YYYY\",\n                  w: \"[Week] W, GGGG\",\n                  M: \"MMM YYYY\",\n                  y: \"YYYY\"\n                }\n              }, e.timeAxisDates = {\n                minorLabelTimeFormats: {\n                  ms: \"ss.SSS\",\n                  s: \"HH:mm:ss\",\n                  m: \"HH:mm\",\n                  h: \"HH:00\",\n                  d: \"MMM D\",\n                  w: \"MMM D\",\n                  M: \"MMM\",\n                  y: \"YYYY\"\n                },\n                majorLabelTimeFormats: {\n                  ms: \"MMM D, YYYY HH:mm:ss\",\n                  s: \"MMM D, YYYY HH:mm:ss\",\n                  m: \"MMM D, YYYY\",\n                  h: \"MMM D, YYYY HH:00\",\n                  d: \"MMM D, YYYY\",\n                  w: \"[Week] W, GGGG\",\n                  M: \"MMM YYYY\",\n                  y: \"YYYY\"\n                },\n                majorLabelFullTimeFormats: {\n                  ms: \"MMM D, YYYY HH:mm:ss\",\n                  s: \"MMM D, YYYY HH:mm:ss\",\n                  m: \"MMM D, YYYY\",\n                  h: \"MMM D, YYYY HH:00\",\n                  d: \"MMM D, YYYY\",\n                  w: \"[Week] W, GGGG\",\n                  M: \"MMM YYYY\",\n                  y: \"YYYY\"\n                }\n              }, e.determiningDataBounds = \"Determining data bounds\", e.loadingLabel = \"Loading...\", e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsLocalization);\n\n          t.SettingsLocalization = B;\n\n          var z = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.customPeriod = \"Custom\", e.periodDropdownTitle = \"Select units in which to show the data\", e.unitDropdownTitle = \"Select units in which to show the data\", e.zoomoutButton = \"Zoom-out\", e.zoomoutTitle = \"Zoom out\", e.unavailableUnitTitle = \"zoom in for more\", e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsLocalizationToolbar);\n\n          t.SettingsLocalizationToolbar = z;\n\n          var U = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.snapMode = \"displayUnit\", e.selection = new m(), e.scrolling = new f(), e.zooming = new G(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsInteraction);\n\n          t.SettingsInteraction = U;\n\n          var G = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.enabled = !0, e.click = !0, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsInteractionZooming);\n\n          t.SettingsInteractionZooming = G;\n\n          var j = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.displayUnits = [{\n                unit: \"1 ms\",\n                name: \"millisecond\"\n              }, {\n                unit: \"1 s\",\n                name: \"second\"\n              }, {\n                unit: \"5 s\",\n                name: \"5 seconds\"\n              }, {\n                unit: \"1 m\",\n                name: \"minute\"\n              }, {\n                unit: \"5 m\",\n                name: \"5 minutes\"\n              }, {\n                unit: \"1 h\",\n                name: \"hour\"\n              }, {\n                unit: \"6 h\",\n                name: \"6 hours\"\n              }, {\n                unit: \"1 d\",\n                name: \"day\"\n              }, {\n                unit: \"1 M\",\n                name: \"month\"\n              }, {\n                unit: \"1 y\",\n                name: \"year\"\n              }], e.displayPeriods = [{\n                unit: \"10 ms\"\n              }, {\n                unit: \"100 ms\"\n              }, {\n                unit: \"s\"\n              }, {\n                unit: \"m\"\n              }, {\n                unit: \"h\"\n              }, {\n                unit: \"d\"\n              }, {\n                unit: \"M\"\n              }, {\n                unit: \"y\"\n              }, {\n                unit: \"10 y\"\n              }, {\n                unit: \"100 y\"\n              }], e.style = new W(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsArea);\n\n          t.SettingsArea = j;\n\n          var W = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.markerText = {\n                font: \"12px Arial\"\n              }, e.selection = new v(), e.selectionLabel = {\n                fillColor: \"#000000\",\n                font: \"12px Arial\"\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsAreaStyle);\n\n          t.SettingsAreaStyle = W;\n\n          var V = function (e) {\n            function n(t) {\n              var i = e.call(this, t) || this;\n              return i.animationOrder = 700, i.paintOrder = 25, i.updateOrder = 1100, i;\n            }\n\n            return r(n, e), n.prototype.doAnimations = function (t) {\n              var e = this.scene;\n\n              if (null != e.selectionStart && this.chart.selection.isSelecting && e.settings.info.enabled) {\n                var i = e.selectionStart,\n                    n = e.selectionEnd;\n                this.showInfoPopup(i, n, null, this.buildContent(i, n, null, null), t);\n              }\n            }, n.prototype.getPopupAreaMouseMoved = function (t, e) {\n              var i = this.scene;\n              return i.displayUnit && i.xyInChartOrBottom(t, e) ? {\n                t0: i.hoverFrom,\n                t1: i.hoverTo\n              } : null;\n            }, n.prototype.getContentsFunctionRange = function (t, e) {\n              var n = i.timeUnitDiffs,\n                  r = this.scene,\n                  s = !r.displayUnit || n[r.displayUnit.unit] < n.d;\n              return [r.timestampFromInternal(t, s), r.timestampFromInternal(e, s)];\n            }, n.prototype.buildContent = function (t, i, n, r) {\n              return t = this.scene.displayUnit.roundTimeRound(t, this.scene.timeStepSettings), i = this.scene.displayUnit.roundTimeRound(i, this.scene.timeStepSettings), e.prototype.buildContent.call(this, t, i, n, r);\n            }, n.prototype.buildHeader = function (e, i) {\n              var n = this.scene.displayUnit;\n              if (!n) return \"\";\n              var r,\n                  s = this.scene.settings.localization,\n                  a = s.infoDates,\n                  o = Math.max(1, Math.ceil(n.numberOfUnits(e, i))),\n                  l = o * n.count | 0,\n                  h = l % 10 == 1 && l % 100 != 11 ? s.timeUnitsNames[n.unit] : s.timeUnitsNamesPlural[n.unit],\n                  u = this.scene.momentLocale;\n\n              if (1 === o) {\n                r = \"\" + (c = t.moment(e).locale(u).utc()).format(a.fullTimeFormats[n.unit]);\n              } else {\n                \"d\" !== n.unit && \"M\" !== n.unit && \"y\" !== n.unit && \"ms\" !== n.unit || (i -= 1);\n                var c = t.moment.utc(e).locale(u),\n                    d = t.moment.utc(i).locale(u),\n                    p = n.getBigger() || n;\n                \"w\" === p.unit && (p = p.getBigger());\n                var f = this.scene.timeStepSettings;\n\n                if (\"y\" !== n.unit && p.roundTimeDown(e, f) === p.roundTimeDown(i, f)) {\n                  var g = c.format(a.majorTimeFormats[n.unit]);\n                  r = c.format(a.minorTimeFormats[n.unit]) + \" - \" + d.format(a.minorTimeFormats[n.unit]) + \", \" + g;\n                } else {\n                  r = c.format(a.fullTimeFormats[n.unit]) + \" - \" + d.format(a.fullTimeFormats[n.unit]);\n                }\n              }\n\n              return \"<em></em><strong>\" + r + \"<small>(\" + l + \" \" + h + \")</small></strong>\";\n            }, n;\n          }(a.InfoPopup);\n\n          t.InfoPopup = V;\n\n          var Z = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 600, i.paintOrder = 20, i.updateOrder = 1200, i.chart = null, i.scene = null, i.pointer = null, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.prototype.previewPointerMove = function (t) {\n              this.pointer = null, this.updateHover(t);\n            }, e.prototype.onPointerOut = function (t) {\n              var e = this.scene;\n              e.hoverFrom = null, e.hoverTo = null, e.hoverSeriesItem = null, t.changes.hover = !0, this.chart.notifyHoverChanged(t, this.chart.createEventArguments(t, \"user\"));\n            }, e.prototype.previewPointerDown = function (t) {\n              this.pointer = t.identifier, this.updateHover(t);\n            }, e.prototype.updateHover = function (t) {\n              var e = this.chart,\n                  i = e.scene,\n                  n = this.getClickRange(t.x, t.y),\n                  r = null,\n                  s = null,\n                  a = null;\n              if (n && (r = n.t0, s = n.t1, a = e.renderer.hitTest(t.x, t.y)), e.legend) if (a) e.legend.notifyHoveredSeries(i.settings._computedSeries[a.seriesIndex]);else {\n                e.legend.notifyHoveredSeries(null);\n                var o = e.legend.getLastHoveredSeries();\n                o && (a = {\n                  x0: null,\n                  y0: null,\n                  x1: null,\n                  y1: null,\n                  isMarker: !1,\n                  seriesIndex: i.settings._computedSeries.indexOf(o)\n                });\n              }\n              (r !== i.hoverFrom || s !== i.hoverTo || !a != !i.hoverSeriesItem || a && (a.seriesIndex !== i.hoverSeriesItem.seriesIndex || a.x0 !== i.hoverSeriesItem.x0)) && (i.hoverFrom = r, i.hoverTo = s, i.hoverSeriesItem = a, t.changes.hover = !0, e.notifyHoverChanged(t, e.createEventArguments(t, \"user\")));\n            }, e.prototype.onClick = function (t) {\n              t.identifier === this.pointer && this.chart.notifyClick(t, this.chart.createEventArguments(t, \"user\"));\n            }, e.prototype.defaultClick = function (t, e) {\n              var i = this.scene,\n                  n = this.chart;\n\n              if (i.settings.interaction.zooming.click) {\n                var r = i.xToTime(t.x);\n                if (null !== i.selectionStart && (i.selectionStart > r || i.selectionEnd < r)) this.clearSelection(t, \"user\");else if (null !== i.hoverFrom && !n.selection.isHoveringEdge) {\n                  var s = i.displayUnit,\n                      a = n.scrolling,\n                      o = i.hoverFrom,\n                      l = i.hoverTo,\n                      h = a.timeSetup.getLimits(s, !0);\n                  null != h.from && (o = Math.max(o, h.from)), null != h.to && (l = Math.min(l, h.to)), a.setTimeRangeSnap(o, l, null, null, !0, \"user\", !1, !0);\n                  var u = a.targetUnit || i.displayUnit;\n                  s.isSmallerOrEqual(u) && (u = a.timeSetup.getSmallerDisplayUnit(u)) && a.setTimeRangeSnap(o, l, null, u, !0, \"user\", !1, !0), null !== i.selectionStart && this.clearSelection(t, \"user\"), t.consumed = !0;\n                }\n              }\n            }, e.prototype.onRightClick = function (t) {\n              var e = this.chart.settings.interaction.selection.clearOnRightClick;\n              null !== this.scene.selectionStart && e && this.clearSelection(t, \"user\"), null !== this.scene.hoverFrom && (this.chart.notifyRightClick(t, this.chart.createEventArguments(t, \"user\")), t.defaultPrevented && (t.consumed = !0));\n            }, e.prototype.onDoubleClick = function (t) {\n              null !== this.scene.hoverFrom && (this.chart.notifyDoubleClick(t, this.chart.createEventArguments(t, \"user\")), t.consumed = !0);\n            }, e.prototype.clearSelection = function (t, e) {\n              this.scene.selectionStart = null, this.scene.selectionEnd = null, this.chart.notifySelectionChanged(this.chart.createEventArguments(t, e)), t.changes.selection = !0, t.consumed = !0;\n            }, e.prototype.onTripleClick = function (t) {\n              void 0 !== this.scene.hoverFrom && null !== this.scene.hoverFrom && (this.chart.notifyTripleClick(t, this.chart.createEventArguments(t, \"user\")), t.consumed = !0);\n            }, e.prototype.getClickRange = function (t, e) {\n              var i = this.scene;\n              if (!i.xyInChartOrBottom(t, e)) return null;\n              var n,\n                  r,\n                  s,\n                  a = this.scene.xToTime(t);\n              if (null !== i.selectionStart && a >= i.selectionStart && a < i.selectionEnd) n = i.selectionStart, r = i.selectionEnd, s = Math.max(2, i.displayUnit.numberOfUnits(n, r));else if (i.displayUnit) {\n                var o = !0,\n                    l = i.timeStepSettings;\n\n                if (i.majorTimeUnit) {\n                  var h = i.majorTimeUnit.roundTimeDown(a, l),\n                      u = i.majorTimeUnit.roundTimeUp(a + 1, l);\n                  e > i.y0 + i.height && (h > i.timeStart || u < i.timeEnd) && (n = h, r = u, n = i.displayUnit.roundTimeDown(n, l), r = i.displayUnit.roundTimeUp(r, l), s = i.displayUnit.numberOfUnits(n, r), o = !1);\n                }\n\n                o && (n = i.displayUnit.roundTimeDown(a, l), r = i.displayUnit.roundTimeUp(a + 1, l), s = 1);\n              } else n = null, r = null, s = null;\n              return {\n                t0: n,\n                t1: r,\n                numBars: s\n              };\n            }, e;\n          }(h.ChartElement);\n\n          t.ClickNotifier = Z;\n\n          var Y = function () {\n            function t(t) {\n              this.requests = {}, this.results = {}, this.dataSlicesCache = {}, this.nextRequestId = 0, this.hasNewRequests = !1, this.lastSlicer = null, this.chart = t, this.scene = this.chart.scene;\n            }\n\n            return t.prototype.registerDataProcessingRequest = function (t) {\n              this.requests[this.nextRequestId] = t;\n              var e = this.chart;\n              return this.results[this.nextRequestId] = {\n                leadIn: null,\n                leadOut: null,\n                times: [],\n                xes: [],\n                values: [],\n                counts: [],\n                fromIndex: 0,\n                toIndex: 0,\n                data: [],\n                from: 0,\n                to: 0,\n                slicer: null,\n                dataExistsFrom: null,\n                dataExistsTo: null,\n                externalItems: function externalItems(t, n) {\n                  for (var r = i.timeUnitDiffs, s = !e.displayUnit || r[e.displayUnit.unit] < r.d, a = new Array(n - t), o = t; o < n; o++) {\n                    a[o - t] = e.scene.timestampFromInternal(this.times[o], s);\n                  }\n\n                  return a;\n                }\n              }, this.hasNewRequests = !0, this.nextRequestId++;\n            }, t.prototype.removeDataProcessingRequest = function (t) {\n              delete this.requests[t], delete this.results[t];\n            }, t.prototype.getDisplayUnitsSlicer = function () {\n              return this.lastSlicer;\n            }, t.prototype.getData = function (t) {\n              return this.results[t];\n            }, t.prototype.clear = function () {\n              this.requests = {}, this.results = {};\n            }, t.prototype.process = function (t) {\n              var e = t.changes;\n              if (e.time || e.data || e.displayUnit || e.bounds || e.settings || this.hasNewRequests) if (this.scene.timeStart >= this.scene.timeEnd) for (var i in this.requests) {\n                (s = this.results[i]).dataExistsFrom = null, s.dataExistsTo = null;\n              } else {\n                this.hasNewRequests = !1, this.loading = !1, this.hasSomeData = !1;\n                var n = !!e.data || e.time;\n\n                for (var i in this.requests) {\n                  var r = this.requests[i],\n                      s = this.results[i],\n                      a = this.updateData(n, r, s);\n                  this.updateSlices(a, i, r, s);\n                }\n\n                this.scene.loading = this.loading, this.loading ? this.scene.setMessage(\"noData\", this.scene.settings.localization.loadingLabel, 10) : this.hasSomeData ? this.scene.setMessage(\"noData\", null) : this.scene.setMessage(\"noData\", this.scene.settings.localization.noDataLabel, 999);\n              }\n            }, t.prototype.exportData = function (t, e, i, n) {\n              for (var r = new b(this.scene, i, [], t, e, !0, 0), s = r.times, a = [], o = 0; o < n.length; o++) {\n                var l = n[o].data,\n                    h = this.chart.getData(l.source).getDataForRange(t, e, i, null),\n                    u = new Array(s.length - 1);\n                this.fillValues(h.values, r.times, u, r.counts, r.fromIndex, r.toIndex, l, i), a.push(u);\n              }\n\n              return {\n                timestamps: r.times.slice(r.fromIndex, r.toIndex - 1),\n                values: a\n              };\n            }, t.prototype.updateData = function (t, e, i) {\n              var n = this,\n                  r = e.source,\n                  s = this.chart.getData(r),\n                  a = this.getUnitToUse(e),\n                  o = (this.scene.timeEnd - this.scene.timeStart) * s.dataSettings.prefetchRatio;\n\n              if (t || !i.from && this.scene.timeStart || !i.to && this.scene.timeEnd || i.from >= i.to || this.scene.timeStart - o < i.from || this.scene.timeEnd + o > i.to || null !== i.dataExistsFrom && i.dataExistsFrom > this.scene.timeEnd || null !== i.dataExistsTo && i.dataExistsTo < this.scene.timeStart) {\n                t = !0;\n                var l = this.scene.timeStart - 2 * o,\n                    h = this.scene.timeEnd + 2 * o,\n                    u = s.getDataForRange(l, h, a, function () {\n                  return n._newDataArrived(r);\n                });\n                s.noData || (this.hasSomeData = !0), u.from > this.scene.timeEnd || u.to < this.scene.timeStart ? (i.data = [], i.from = 0, i.to = 0, i.dataExistsFrom = null, i.dataExistsTo = null, this.loading = this.loading || u.loading) : (this.loading = this.loading || u.loading && (u.from > this.scene.timeStart || u.to < this.scene.timeEnd), i.data = u.values, i.from = l, i.to = h, i.dataExistsFrom = u.from, i.dataExistsTo = u.to);\n              }\n\n              return t;\n            }, t.prototype.updateSlices = function (t, e, i, n) {\n              var r = this.getUnitToUse(i),\n                  s = i.index,\n                  a = i.valueFunction,\n                  o = n.data,\n                  l = n.slicer = this.getSlice(e, i, r),\n                  h = l.update(this.scene.timeStart, this.scene.timeEnd),\n                  u = h.newBefore,\n                  c = h.newAfter,\n                  d = n.times = l.times,\n                  p = n.counts = l.counts;\n              n.xes = l.xes;\n              var f = n.values = l.values;\n              if (o = n.data, n.fromIndex = l.fromIndex, n.toIndex = l.toIndex, o) o.length > 0 && !a && s >= o[0].length ? this.chart.error(\"No data for this DataIndex: \" + s + \", only \" + (o[0].length - 1) + \" values present\") : (t ? this.fillValues(o, d, f, p, l.fromIndex, l.toIndex, i, r) : (this.fillValues(o, d, f, p, l.fromIndex, u + 1, i, r), this.fillValues(o, d, f, p, c - 1, l.toIndex, i, r)), this.setLeads(i, n, r));else {\n                f = n.values = new Array(d.length);\n\n                for (var g = 0; g < f.length; g++) {\n                  f[g] = null;\n                }\n\n                n.leadIn = null, n.leadOut = null;\n              }\n            }, t.prototype.getSlice = function (t, e, i) {\n              var n,\n                  r = t + \"-\" + i.toString();\n              return n = this.dataSlicesCache.hasOwnProperty(r) ? this.dataSlicesCache[r] : this.dataSlicesCache[r] = new b(this.scene, i, [\"values\", \"counts\"]), this.lastSlicer = n, n;\n            }, t.prototype.getUnitToUse = function (t) {\n              return this.scene.displayUnit;\n            }, t.prototype.setLeads = function (t, e, i) {\n              var n = t.noDataPolicy,\n                  r = t.index,\n                  s = t.valueFunction,\n                  a = e.data,\n                  o = e.values,\n                  l = e.times,\n                  h = null,\n                  u = null;\n\n              if (\"join\" === n && a) {\n                var d = e.fromIndex;\n\n                if (null === o[d]) {\n                  var p = c.binSearch(a, l[d]);\n\n                  if (-1 !== (p = c.linSearchDown(a, p, r, s))) {\n                    var f = a[p][0],\n                        g = [(b = e.slicer.makeMiniSlice(f)).t0, b.t1],\n                        m = [b.x0, b.x1],\n                        v = [null, null],\n                        y = [null, null];\n                    this.fillValues(a, g, v, y, 0, 2, t, i), h = {\n                      times: g,\n                      xes: m,\n                      values: v,\n                      counts: y,\n                      fromIndex: 0,\n                      toIndex: 2\n                    };\n                  }\n                }\n\n                var S = e.toIndex;\n\n                if (null === o[S - 2]) {\n                  p = c.binSearch(a, l[S - 1]);\n\n                  if (-1 !== (p = c.linSearchUp(a, p, r, s))) {\n                    var b;\n                    f = a[p][0], g = [(b = e.slicer.makeMiniSlice(f)).t0, b.t1], m = [b.x0, b.x1], v = [null, null], y = [null, null];\n                    this.fillValues(a, g, v, y, 0, 2, t, i), u = {\n                      times: g,\n                      xes: m,\n                      values: v,\n                      counts: y,\n                      fromIndex: 0,\n                      toIndex: 2\n                    };\n                  }\n                }\n              }\n\n              e.leadIn = h, e.leadOut = u;\n            }, t.prototype.fillValues = function (t, e, i, n, r, s, a, o) {\n              var l = a.aggregation,\n                  h = 0 | a.index,\n                  u = 0 | a.countIndex,\n                  c = a.valueFunction,\n                  d = a.aggregatedValueFunction;\n              if (!(r + 1 >= s) && (\"sum\" === l ? this.fillValueSum(t, e, i, n, r, s, h, u, c) : \"min\" === l ? this.fillValueMin(t, e, i, n, r, s, h, u, c) : \"max\" === l ? this.fillValueMax(t, e, i, n, r, s, h, u, c) : \"avg\" === l ? this.fillValueAvg(t, e, i, n, r, s, h, u, c) : \"count\" === l ? this.fillValueCount(t, e, i, n, r, s, h, u, c) : \"first\" === l ? this.fillValueFirst(t, e, i, n, r, s, h, u, c) : \"last\" === l ? this.fillValueLast(t, e, i, n, r, s, h, u, c) : this.chart.error(\"Unrecognized aggregation function: \" + l), d)) for (var p = r; p <= s - 2; p++) {\n                i[p] = d(i[p], e[p], o ? o.toString() : null);\n              }\n            }, t.prototype.fillValueSum = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = 0, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (f += m, g += 0 === o ? 1 : t[u][o]), u += 1;\n                }\n\n                n[d] = g, i[d] = 0 === g ? null : f;\n              }\n            }, t.prototype.fillValueMin = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = 1 / 0, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (f = Math.min(f, m), g += 0 === o ? 1 : t[u][o]), u += 1;\n                }\n\n                n[d] = g, i[d] = 0 === g ? null : f;\n              }\n            }, t.prototype.fillValueMax = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = -1 / 0, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (f = Math.max(f, m), g += 0 === o ? 1 : t[u][o]), u += 1;\n                }\n\n                n[d] = g, i[d] = 0 === g ? null : f;\n              }\n            }, t.prototype.fillValueCount = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = 0; u < h && t[u][0] < p;) {\n                  null != (l ? l(t[u]) : t[u][a]) && (f += o ? t[u][o] : 1), u += 1;\n                }\n\n                n[d] = f, i[d] = f;\n              }\n            }, t.prototype.fillValueAvg = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = 0, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (f += m, g += o ? t[u][o] : 1), u += 1;\n                }\n\n                n[d] = g, i[d] = 0 === g ? null : f / g;\n              }\n            }, t.prototype.fillValueFirst = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = null, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (null === f && (f = m), g += o ? t[u][o] : 1), u += 1;\n                }\n\n                n[d] = g, i[d] = f;\n              }\n            }, t.prototype.fillValueLast = function (t, e, i, n, r, s, a, o, l) {\n              for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n                for (var p = e[d + 1], f = null, g = 0, m = void 0; u < h && t[u][0] < p;) {\n                  null != (m = l ? l(t[u]) : t[u][a]) && (f = m, g += o ? t[u][o] : 1), u += 1;\n                }\n\n                n[d] = g, i[d] = f;\n              }\n            }, t.prototype._newDataArrived = function (t) {\n              var e = {};\n              e[t] = !0, this.chart.events.notifySceneChanges({\n                data: e\n              });\n            }, t;\n          }();\n\n          t.DataWarehouse = Y;\n\n          var q = function (t) {\n            function e(e, i) {\n              var n = t.call(this) || this;\n              return n.animationOrder = 400, n.paintOrder = 5, n.updateOrder = 1500, n.dataWarehouse = i, n.chart = e, n.scene = n.chart.scene, n.events = n.chart.events, n.buildSeries(), n;\n            }\n\n            return r(e, t), e.prototype.buildSeries = function () {\n              this.valueAxis = new a.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.r = new a.Renderer(this.chart, this.valueAxis), this.dataWarehouse.clear(), this.requestIds = [];\n\n              for (var t = 0; t < this.scene.settings._computedSeries.length; t++) {\n                var e = this.scene.settings._computedSeries[t];\n                this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(e.data));\n              }\n            }, e.prototype.onSceneChange = function (t) {\n              var e = t.changes;\n              (e.linearChartSeries || e.linearChartValueAxis) && this.buildSeries(), e.linearChartValueAxis && (e.bounds = !0), (e.bounds || e.settings) && (e.time = !0), e.data && h.Helpers.hasProperties(e.data) && this.chart.notifyChartUpdate(\"data\", !0);\n            }, e.prototype.getPanels = function () {\n              return this.valueAxis.getPanels(!1);\n            }, e.prototype.doAnimations = function (t) {\n              var e = t.changes;\n\n              if (this.dataWarehouse.process(t), this.scene.displayUnit) {\n                if (this.displayUnit !== this.scene.displayUnit && (this.displayUnit = this.scene.displayUnit, e.displayUnit = !0), e.time || e.data || e.displayUnit || e.bounds) {\n                  for (var i = [], n = 0; n < this.requestIds.length; n++) {\n                    i.push(this.dataWarehouse.getData(this.requestIds[n]));\n                  }\n\n                  this.r.process(i);\n                }\n\n                this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t);\n              }\n            }, e.prototype.paintScene = function (t) {\n              this.valueAxis.paintUnder(t), h.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height), this.r.paint(t), h.Graphics.popClip(t), this.valueAxis.paint(t);\n            }, e.prototype.hitTest = function (t, e) {\n              return this.scene.xyInChart(t, e) ? this.r.hitTest(t, e, this.scene.settings.interaction.selection.tolerance) : null;\n            }, e.prototype.exportData = function (t, e) {\n              return this.r.exportData(t, e);\n            }, e;\n          }(h.ChartElement);\n\n          t.Renderer = q;\n\n          var _ = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.chart = e, i.scene = e.scene, i.settings = e.settings, i.reinitializePeriod = !0, i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              var e = t.changes.settingsChanges;\n              e && e.navigation && (this.reinitializePeriod = !0), this.reinitializePeriod && this.chart.assetsLoaded && this.setupInitialDisplayPeriod();\n            }, e.prototype.onNewDataObject = function () {}, e.prototype.setupInitialDisplayPeriod = function () {\n              var t = this;\n\n              if (this.scene.width) {\n                this.reinitializePeriod = !1;\n                var e = this.settings.navigation.initialDisplayAnchor,\n                    i = this.settings.navigation.initialDisplayPeriod,\n                    n = this.settings.navigation.initialDisplayUnit;\n                this.computeDisplayPeriod(i, e, n, function (n, r, s) {\n                  if (t.scene.setMessage(\"impl\", null, 0), t.scene.loading = !1, t.scene.displayUnit && (s = t.scene.displayUnit), !t.scene.timeStart && !t.scene.timeEnd) {\n                    var a = t.chart.scrolling.timeSetup.getLimits(s, !0);\n                    null !== a.from && (n = Math.round(Math.max(n, a.from))), null !== a.to && (r = Math.round(Math.min(r, a.to))), t.chart.scrolling.setTimeRange(n, r, s, !1, \"init\", e, i);\n                  }\n                });\n              }\n            }, e.prototype.computeDisplayPeriod = function (t, e, i, n) {\n              var r = this,\n                  s = this.chart.scrolling.computeDisplayPeriod(t, e, i, this.scene.mainData.dataFrom, this.scene.mainData.dataTo),\n                  a = s.from,\n                  o = s.to,\n                  l = s.unit;\n              if (null !== a && null !== o && l) return n(a, o, l);\n\n              if (this.scene.mainData.dataSettings.dataFunction || this.scene.mainData.dataSettings.url || this.scene.mainData.dataSettings.urlByUnit || this.scene.mainData.dataSettings.preloaded) {\n                var h = function h(l, u, c, d, p, f) {\n                  if (!r.chart.removed) {\n                    if (null === l || null === u || 0 === l && 0 === u && r.scene.mainData.noData) return void n(d, p, f);\n                    s = r.chart.scrolling.computeDisplayPeriod(t, e, i, l, u), a = s.from, o = s.to;\n                    var g = s.unit;\n                    return null === a || null === o ? void r.chart.error(\"Could not setup display time interval. Check your configuration.\") : void (g.isMultipleOf(c) ? n(a, o, g) : r.scene.mainData.determineDataLimits(g, !0, !0, function (t, e, i) {\n                      return h(t, e, i, l, u, g);\n                    }));\n                  }\n                };\n\n                this.scene.mainData.determineDataLimits(null, !0, !0, function (t, e, i) {\n                  return h(t, e, i, 0, 0, null);\n                });\n              } else this.chart.error(\"Cannot compute data dependant display period, no data given. DisplayPeriod = \" + t + \", DisplayAnchor = \" + e);\n            }, e;\n          }(h.Navigator);\n\n          t.Navigator = _, t.moment = null;\n\n          var X = !1,\n              Q = function (e) {\n            function n(i, n) {\n              var r = e.call(this, new M(i), new S(), n) || this;\n              return r.timeAxis = null, r.timeStart = 0, r.timeEnd = 0, r.displayUnit = null, r.selectionStart = 0, r.selectionEnd = 0, r._cachedDataLimits = null, r.dataWarehouse = new Y(r), r.renderer = r.events.addElement(new q(r, r.dataWarehouse)), r.scrolling = r.events.addElement(new g(r)), r.selection = r.events.addElement(new y(r)), r.navigator = r.events.addElement(new _(r)), r.clickNotifier = r.events.addElement(new Z(r)), r.infoPopup = r.events.addElement(new V(r)), r.events.addElement(new A(r)), r.events.addElement(new t.Markers(r)), r.events.addElement(new a.Highlights(r)), r.finalInitialize(), r;\n            }\n\n            return r(n, e), n.prototype.notifyAssetsLoaded = function () {\n              if (!this.removed) {\n                if (!t.moment) {\n                  if (t.moment = window.moment, !t.moment) return void this.error(\"Unable to load moment library. Please check that the assets are configured properly.\");\n                  h.Helpers.compareVersions(t.moment.version, [2, 9]) || this.error(\"ZoomCharts requires moment version 2.9.0 or newer. The loaded version is \" + t.moment.version);\n                }\n\n                !X && t.moment.tz && (h.Helpers.compareVersions(t.moment.tz.version, [0, 5]) || this.error(\"ZoomCharts requires moment-timezone version 0.5.0 or newer. The loaded version is \" + t.moment.tz.version), X = !0), this.setMomentLocale();\n                var i = this.settings.timeAxis;\n                t.moment.tz && \"local\" === i.timeZone && (i.timeZone = t.moment.tz.guess(), h.Helpers.warn(\"Instead of using `local` for `timeAxis.timeZone` it is recommended to specify the exact timezone since the local timezone detection is error prone. The timezone was detected as `\" + i.timeZone + \"`.\")), this.timeAxis || (this.timeAxis = this.events.addElement(new x(this)));\n\n                for (var n = Object.keys(this.data), r = 0; r < n.length; r++) {\n                  this.data[n[r]].notifyAssetsLoaded();\n                }\n\n                e.prototype.notifyAssetsLoaded.call(this), this.api._notifyAssetsLoaded();\n              }\n            }, n.prototype.createDataObj = function (t) {\n              return new c(this, t);\n            }, n.prototype.getData = function (t) {\n              return e.prototype.getData.call(this, t);\n            }, n.prototype.setMomentLocale = function () {\n              var e = this.scene.momentLocale,\n                  i = t.moment.locale(),\n                  n = this.settings.localization.calendar;\n              n.parentLocale && !h.Helpers.compareVersions(t.moment.version, [2, 12]) && this.error(\"Using `parentLocale` requires moment.js 2.12.0 or newer. The loaded version is \" + t.moment.version), t.moment.locale(e, null), t.moment.locale(e, n), this.scene.timeStepSettings = {\n                week: {\n                  dow: t.moment.localeData().firstDayOfWeek()\n                }\n              }, t.moment.locale(i);\n            }, n.prototype.remove = function () {\n              t.moment && t.moment.locale(this.scene.momentLocale, null), e.prototype.remove.call(this), this.infoPopup.remove();\n            }, n.prototype.onSettingsChanged = function (t) {\n              if (t.data && (t.toolbar = !0), t.area && t.area.displayUnits) {\n                var e = this.scene,\n                    i = new l(this);\n\n                if (e.displayUnit && !i.isAllowedDisplayUnit(e.displayUnit)) {\n                  var n = i.computeDisplayUnit(e.timeStart, e.timeEnd, e.displayUnit, e.timeStart, e.timeEnd, e);\n                  this.scrolling.setTimeRangeSnap(e.timeStart, e.timeEnd, null, n.unit, !0, \"api\", !0, !0);\n                }\n              }\n\n              this.assetsLoaded && t.localization && t.localization.calendar && this.setMomentLocale(), this.events.notifySceneChanges({\n                time: !0\n              });\n            }, n.prototype.save = function () {\n              var t = this.scene;\n              return JSON.stringify({\n                from: this.timeStart,\n                to: this.timeEnd,\n                unit: this.displayUnit.toString(),\n                selFrom: t.selectionStart,\n                selTo: t.selectionEnd,\n                anchor: t.anchor,\n                period: t.period\n              });\n            }, n.prototype.restore = function (t, e) {\n              if (t) {\n                var n = JSON.parse(t),\n                    r = i.parse(n.unit);\n                r && (this.scrolling.setTimeRange(n.from, n.to, r, e, \"api\", n.anchor, n.period), this.setSelection(n.selFrom, n.selTo));\n              }\n            }, n.prototype.warnInvisibleChart = function (t) {\n              this.scene.width || h.Helpers.warn(\"`\" + t + \"()` method has been called on a hidden chart. This might produce invalid results since the chart width impacts the calculations.\");\n            }, n.prototype.setSelection = function (t, e, i) {\n              void 0 === i && (i = \"api\");\n              var n = this.scene;\n              n.selectionStart === t && n.selectionEnd === e || (n.selectionStart = t, n.selectionEnd = e, this.events.notifySceneChanges({\n                selection: !0\n              }), this.notifySelectionChanged(this.createEventArguments(null, i)));\n            }, n.prototype.setTimeRange = function (t, e, n, r) {\n              void 0 === r && (r = \"api\"), this.warnInvisibleChart(\"time\"), this.setSelection(null, null, r);\n              var s = this.displayUnit;\n\n              if (!s) {\n                var a = this.settings.navigation.initialDisplayUnit;\n                a && \"auto\" !== a && (s = i.parse(a));\n              }\n\n              if (this.scene.displayUnit = s, this.scene.width) {\n                var o = this.scrolling.onSnapWhileDragging(t, e, null, !0, 2);\n                o.unit && (this.scene.displayUnit = o.unit, o = this.scrolling.onSnapAfterDragging(o.from, o.to, null, !0, 2)), t = o.from, e = o.to, s = o.unit;\n              }\n\n              this.scrolling.setTimeRange(t, e, s, n, r);\n            }, n.prototype.setDisplayPeriod = function (t, e, i, n, r) {\n              var s = this;\n              return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !0), void 0 === r && (r = \"api\"), this.warnInvisibleChart(\"setDisplayPeriod\"), null === e && (e = this.scene.anchor), this.setSelection(null, null), \"string\" == typeof e && (e = e.trim()), \"string\" == typeof t && (t = t.trim()), this.navigator.computeDisplayPeriod(t, e, i, function (i, a, o) {\n                return s.scrolling.setTimeRange(i, a, o, n, r, e, t);\n              });\n            }, n.prototype.scroll = function (t, e, i) {\n              void 0 === i && (i = !1);\n              var n = t.trim().split(\" \");\n\n              if (3 === n.length) {\n                var r = n[0],\n                    s = parseInt(n[1], 10),\n                    a = n[2];\n                if (\"<\" !== r && \">\" !== r || \"number\" != typeof s) this.error(\"Scroll:Incorrect scroll format: \" + t);else {\n                  var o = new l(this).scroll(this.timeStart, this.timeEnd, this.displayUnit, r, s, a),\n                      h = o.from,\n                      u = o.to;\n                  i ? this.scrolling.setTimeRangeSnap(h, u, 0, this.displayUnit, e, \"api\", null, null) : this.scrolling.setTimeRange(h, u, this.displayUnit, e, \"api\", null, this.scene.period);\n                }\n              } else this.error(\"Incorrect scroll format: \" + t);\n            }, n.prototype.zoomOut = function (t, e, i) {\n              void 0 === t && (t = !0), void 0 === e && (e = \"api\"), void 0 === i && (i = null), this.setSelection(null, null), this.scrolling.zoomOut(i, this.scene.timeStart, this.scene.timeEnd, t, e), this.scene.period = null;\n            }, n.prototype.zoomOutPossible = function () {\n              return !!this.scene.displayUnit;\n            }, n.prototype.zoomIn = function (t, e, i, n) {\n              void 0 === e && (e = null), void 0 === i && (i = !0), void 0 === n && (n = \"api\"), this.setSelection(null, null), this.scrolling.zoomIn(t, e, this.scene.timeStart, this.scene.timeEnd, i, n), this.scene.period = null;\n            }, n.prototype.setDisplayUnit = function (t, e, n, r) {\n              var s, a, o;\n\n              if (void 0 === n && (n = \"api\"), void 0 === r && (r = !1), this.warnInvisibleChart(\"displayUnit\"), \"auto\" === t) {\n                var l = this.scrolling.timeSetup.computeDisplayUnit(null, null, null, this.timeStart, this.timeEnd, this.scene);\n                s = l.unit, a = l.from, o = l.to;\n              } else {\n                if (!(s = i.parse(t))) return;\n\n                if (r) {\n                  for (var u = s.toString(), c = this.scene.settings._displayUnitsParsed, d = !1, p = 0; p < c.length; p++) {\n                    if (c[p].toString() === u) {\n                      d = !0;\n                      break;\n                    }\n                  }\n\n                  d || h.Helpers.warn(\"The display unit `\" + u + \"` does not match a display unit configured in `area.displayUnits`.\");\n                }\n\n                var f = this.scene.timeStepSettings;\n                a = s.roundTimeDown(this.timeStart, f), o = s.roundTimeUp(this.timeEnd, f);\n              }\n\n              var g = this.scrolling.snap(a, o, null, s, !1, !0);\n              this.scrolling.setTimeRange(g.from, g.to, s, e, n, g.anchor, g.period);\n            }, n.prototype.invalidateDataLimits = function () {\n              this._cachedDataLimits = null;\n            }, n.prototype.getDataLimits = function (t) {\n              void 0 === t && (t = this.displayUnit);\n              var e = this._cachedDataLimits;\n              if (e && e.unit === t) return e;\n\n              for (var i = this.settings._computedSeries, n = Object.create(null), r = 0; r < i.length; r++) {\n                var s = i[r];\n                s.enabled && (n[s.data.source] = !0);\n              }\n\n              var a = 1 / 0,\n                  o = -1 / 0;\n\n              for (var l in n) {\n                var h = this.data[l];\n                h && (h.dataLimitFrom || h.dataLimitTo) && (a = Math.min(a, h.dataLimitFrom), o = Math.max(o, h.dataLimitTo));\n              }\n\n              return a > o ? (a = null, o = null) : t && (a = t.roundTimeDown(a, this.scene.timeStepSettings), o = t.roundTimeUp(o, this.scene.timeStepSettings)), this._cachedDataLimits = {\n                from: a,\n                to: o,\n                unit: t\n              };\n            }, n.prototype.getDisplayLimits = function (t) {\n              var e = this.getDataLimits(t),\n                  i = e.from,\n                  n = e.to;\n              if (null === i) return e;\n\n              for (var r = 0; r < this.scene.markers.length; r++) {\n                var s = this.scene.markers[r];\n                s.settings.overrideLimits && (i = Math.min(i, s.time), n = Math.max(n, s.time));\n              }\n\n              return {\n                from: i,\n                to: n\n              };\n            }, n.prototype.exportVisibleData = function () {\n              if (!this.displayUnit) return [];\n\n              for (var e = this.settings._computedSeries, i = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, e), n = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit], r = i.timestamps, s = i.values, a = [\"timestamp\", \"time\"], o = 0; o < e.length; o++) {\n                var l = e[o];\n                a.push(l.name || l.id || \"\");\n              }\n\n              for (var h = [a], u = this.scene.momentLocale, c = 0; c < r.length; c++) {\n                for (var d = r[c], p = [d, t.moment.utc(d).locale(u).format(n)], f = 0; f < e.length; f++) {\n                  p.push(s[f][c]);\n                }\n\n                h.push(p);\n              }\n\n              return h;\n            }, n.prototype.isThisDisplayPeriod = function (t, e, i) {\n              if (!this.displayUnit) return !1;\n              var n = this.scene.mainData.dataFrom,\n                  r = this.scene.mainData.dataTo,\n                  s = this.scrolling.computeDisplayPeriod(t, e, i, n, r);\n              n = s.from, r = s.to;\n              var a = this.scrolling.getFrom(),\n                  o = this.scrolling.getTo(),\n                  l = o - a;\n              return !(Math.abs(a - n) / l > .1) && !(Math.abs(o - r) / l > .1);\n            }, n.prototype.notifyTimeChanged = function (t, e, i, n) {\n              this.timeStart = t, this.timeEnd = e, this.displayUnit = i, this.notifyChartUpdate(n);\n            }, n.prototype.saveNavigation = function () {\n              return this.displayUnit ? {\n                timeStart: this.timeStart,\n                timeEnd: this.timeEnd,\n                displayUnit: this.displayUnit,\n                anchor: this.scene.anchor,\n                period: this.scene.period\n              } : null;\n            }, n.prototype.restoreNavigation = function (t, e, i) {\n              this.timeStart = t.timeStart, this.timeEnd = t.timeEnd, this.displayUnit = t.displayUnit, this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, e, i, t.anchor, t.period);\n            }, n.prototype.doChartUpdateNotify = function (t) {\n              e.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams(\"timeChange\", this.createEventArguments(null, t), null);\n            }, n.prototype.createEventArguments = function (t, e) {\n              var n = this.scene,\n                  r = n.hoverSeriesItem,\n                  s = r && null != r.seriesIndex ? n.settings._computedSeries[r.seriesIndex] : null,\n                  a = !!r && r.isMarker,\n                  o = i.timeUnitDiffs,\n                  l = !this.displayUnit || o[this.displayUnit.unit] < o.d,\n                  h = n.timestampFromInternal(n.hoverFrom, l),\n                  u = n.timestampFromInternal(n.hoverTo, l);\n              return {\n                chart: this.api,\n                origin: e,\n                timeStart: n.timestampFromInternal(this.timeStart, l),\n                timeEnd: n.timestampFromInternal(this.timeEnd, l),\n                displayUnit: this.displayUnit ? this.displayUnit.toString() : null,\n                selectionStart: n.timestampFromInternal(n.selectionStart, l),\n                selectionEnd: n.timestampFromInternal(n.selectionEnd, l),\n                hoverStart: h,\n                hoverEnd: u,\n                hoverSeries: s,\n                hoverMarker: a,\n                clickStart: h,\n                clickEnd: u,\n                clickSeries: s,\n                clickMarker: a\n              };\n            }, n.prototype.defaultClick = function (t, i) {\n              e.prototype.defaultClick.call(this, t, i), this.clickNotifier.defaultClick(t, i);\n            }, n.prototype.defaultRightClick = function (t) {\n              this.infoPopup.show(t), t.preventDefault();\n            }, n.prototype.getBottomHeight = function () {\n              return this.scene.height - this.scene.bottomAxisSize;\n            }, n.prototype.showInfoPopup = function (t, e, i) {\n              if (null != t) {\n                if (null == e || t === e) e = t + 1;else if (t > e) {\n                  var n = t;\n                  t = e, e = n;\n                }\n                var r = this.displayUnit,\n                    s = this.scene.timeStepSettings;\n                t = r.roundTimeDown(t, s), (e = r.roundTimeUp(e, s)) < this.scene.timeStart || t > this.scene.timeEnd || this.infoPopup.manualShowInfoPopup(t, e, i);\n              } else this.infoPopup.hideInfoPopup(null);\n            }, n;\n          }(a.Impl);\n\n          t.Impl = Q;\n        }(n.TimeChart || (n.TimeChart = {})), function (t) {\n          t.Renderers || (t.Renderers = {});\n\n          var e = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.itemsToLoad = 50, e.partialLoad = !0, e.autoCategories = null, e.sortField = null, e.dataFunction = null, e.preloaded = null, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsData);\n\n          t.SettingsData = e;\n\n          var i = {\n            values: 1,\n            id: 1,\n            offset: 1,\n            limit: 1,\n            afterSum: 1,\n            beforeSum: 1,\n            subvalues: 1,\n            sum: 1,\n            extra: 1,\n            name: 1,\n            totalCount: 1,\n            total: 1,\n            valuesSum: 1,\n            done: 1,\n            afterFraction: 1,\n            beforeFraction: 1\n          },\n              s = function () {\n            return function () {\n              this.name = null, this.values = [], this.offset = 0, this.totalCount = null, this.total = 0, this.valuesSum = 0, this.beforeSum = 0, this.afterSum = 0, this.done = !1, this.extra = null;\n            };\n          }();\n\n          t.PieData = s;\n\n          var a = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e, i) || this;\n              return r.pies = {}, r.pendingPies = {}, r.requestedPies = {}, r.nextId = 0, r._isFacetChart = n, r;\n            }\n\n            return r(e, t), e.exportValues = function (t) {\n              var e = [\"id\", \"name\", \"value\"],\n                  i = {\n                id: 0,\n                name: 1,\n                value: 2\n              },\n                  n = 3,\n                  r = t.values,\n                  s = new Array(r.length + 1);\n              s[0] = e;\n\n              for (var a = 0; a < r.length; a++) {\n                var o = r[a],\n                    l = new Array(n);\n                s[a + 1] = l;\n\n                for (var u = Object.keys(o), c = 0; c < u.length; c++) {\n                  var d = u[c];\n\n                  if (\"_\" !== d.charAt(0) && \"fraction\" !== d) {\n                    var p = o[d];\n                    if (Array.isArray(p)) p = p.length;else if (h.Helpers.isObjectOrArray(p)) continue;\n                    var f = i[d];\n                    void 0 === f && (i[d] = f = n++, e.push(d)), l[f] = p;\n                  }\n                }\n              }\n\n              return s;\n            }, e.prototype.hasDataFunc = function () {\n              return !!this.dataSettings.dataFunction || !!this.dataSettings.url;\n            }, e.prototype.applyPreloadedData = function () {\n              if (t.prototype.applyPreloadedData.call(this), !this.hasDataFunc()) {\n                for (var e = Object.keys(this.pies), i = 0; i < e.length; i++) {\n                  var n = this.pies[e[i]];\n                  n.done || (n.done = !0, n.afterSum = 0, n.totalCount = n.offset + n.values.length);\n                }\n\n                this.chart.scene.loading = !1;\n              }\n            }, e.prototype.getRootId = function () {\n              return this.settings.navigation.initialDrilldown && this.settings.navigation.initialDrilldown.length > 0 ? this.settings.navigation.initialDrilldown[0] : \"\";\n            }, e.prototype.canExpand = function (t) {\n              return !!h.Helpers.hasProperty(this.pies, t) || !(!this.hasDataFunc() || this.dataSettings.autoCategories) && !(!t || t[0] === h.Helpers.SeparatorChar);\n            }, e.prototype.getPieData = function (t) {\n              if (!h.Helpers.hasProperty(this.pies, t)) return null;\n              var e = this.pies[t];\n              return this.needPostprocessing() && (e = this.filterAndSortData(e)), e;\n            }, e.prototype.requestMorePieData = function (t, e) {\n              return void 0 === e && (e = this.dataSettings.itemsToLoad), null == e && (e = this.dataSettings.itemsToLoad), !(!h.Helpers.hasProperty(this.pies, t) || this.pies[t].done || (this.requestPieData(t, this.pies[t].offset + this.pies[t].values.length, e), 0));\n            }, e.prototype.requestLessPieData = function (t, e) {\n              if (void 0 === e && (e = this.dataSettings.itemsToLoad), !h.Helpers.hasProperty(this.pies, t)) return !1;\n              var i = this.pies[t];\n              return !(0 === i.offset && (i.done || i.values.length > 1) || (this.requestPieData(t, Math.max(i.offset - this.dataSettings.itemsToLoad, 0), e), 0));\n            }, e.prototype.requestPieData = function (t, e, i) {\n              if (void 0 === i && (i = this.dataSettings.itemsToLoad), this.dataSettings.autoCategories) {\n                if (h.Helpers.hasProperties(this.pies)) throw new Error(\"Cannot request additional data when autoCategories is in use!\");\n                t = \"\";\n              }\n\n              if (t[0] === h.Helpers.SeparatorChar) throw new Error(\"Invalid Id: \" + t);\n\n              if (h.Helpers.hasProperty(this.pies, t)) {\n                var n = this.pies[t],\n                    r = n.offset,\n                    s = r + n.values.length;\n                if (e < r) i = r - e;else {\n                  if (!(e + i > s)) return;\n                  i = e + i - s, e = s;\n                }\n              } else (this.needPostprocessing() || !this.dataSettings.partialLoad || this.dataSettings.autoCategories) && (i = 2147483647, e = 0);\n\n              if (!h.Helpers.hasProperty(this.requestedPies, t)) if (h.Helpers.hasProperty(this.pendingPies, t)) {\n                var a = this.pendingPies[t],\n                    o = Math.min(a.offset, e),\n                    l = Math.max(a.offset + a.limit, e + i);\n                a.offset = o, a.limit = l - o;\n              } else this.dataFunc && (this.pendingPies[t] = {\n                id: t,\n                offset: e,\n                limit: i\n              }, this.scheduleRequests());\n            }, e.prototype.autoCategorize = function (t, e) {\n              if (0 === e.length) return t;\n\n              for (var i = h.Helpers.clone(t), n = [i], r = 0; r < e.length; r++) {\n                for (var s = e[r], a = [], o = 0; o < n.length; o++) {\n                  for (var l = n[o], u = [], c = {}, d = 0; d < l.subvalues.length; d++) {\n                    var p = l.subvalues[d],\n                        f = void 0;\n                    f = void 0 === (f = h.Helpers.isFunction(s) ? s(p) : p[s]) || null === f ? \"None\" : f.toString();\n                    var g = void 0;\n                    h.Helpers.hasProperty(c, f) ? g = c[f] : (g = {\n                      id: l.id + h.Helpers.SeparatorChar + f,\n                      __id: l.id + h.Helpers.SeparatorChar + f,\n                      value: 0,\n                      subvalues: [],\n                      name: f,\n                      __category: s\n                    }, c[f] = g, u.push(g), a.push(g)), g.subvalues.push(p), g.value += h.Helpers.tryParseFloat(p.value, 0);\n                  }\n\n                  l.subvalues = u;\n                }\n\n                n = a;\n              }\n\n              return i;\n            }, e.prototype.valueSum = function (t) {\n              if (this._isFacetChart) return 0;\n\n              for (var e = 0, i = 0; i < t.length; i++) {\n                e += t[i].value;\n              }\n\n              return e;\n            }, e.prototype.addDataInt = function (t, e, n, r, a, o, l, u, c) {\n              var d,\n                  p = (d = h.Helpers.hasProperty(this.pies, t) ? this.pies[t] : this.pies[t] = new s()).offset + d.values.length,\n                  f = n + e.length;\n              if (0 === d.values.length || f < d.offset || p < n) d.offset = n, d.done = r > e.length, d.values = e.slice(), d.valuesSum = this.valueSum(e), d.totalCount = d.done ? d.values.length + d.offset : null, d.afterSum = d.done ? 0 : a, d.beforeSum = 0 === d.offset ? 0 : o, d.total = d.done && 0 === d.offset ? d.valuesSum : l;else {\n                var g = null,\n                    m = null,\n                    v = 0,\n                    y = 0;\n                d.offset < n && (n === p ? (g = d.values, v = d.valuesSum) : (g = d.values.slice(0, n - d.offset), v = this.valueSum(g))), p > f && e.length >= r && (d.offset === f ? (m = d.values, y = d.valuesSum) : (m = d.values.slice(f - d.offset), y = this.valueSum(m))), d.values = m ? g ? g.concat(e, m) : e.concat(m) : g ? g.concat(e) : e.slice(), d.offset = Math.min(d.offset, n), d.valuesSum = this.valueSum(e) + v + y, e.length < r && (d.done = !0), g || (d.beforeSum = o), m || (d.afterSum = a), d.total = l, d.done && (d.afterSum = 0), 0 === d.offset && (d.beforeSum = 0), d.done && 0 === d.offset && (d.total = d.valuesSum);\n              }\n              if (d.extra = u.extra, d.name = u.name, u) for (var S in u) {\n                h.Helpers.hasProperty(i, S) || (d[S] = u[S]);\n              }\n\n              for (var b = 0; b < e.length; b++) {\n                var C = e[b];\n                C.subvalues && (c[C.__id] = !0, this.addDataInt(C.__id, C.subvalues, 0, 1 / 0, null, null, null, C, c));\n              }\n            }, e.prototype.needPostprocessing = function () {\n              var t = this.chart.settings.filters;\n              return !!t.sliceFilter || !t.allowZeroValues || !!this.dataSettings.sortField;\n            }, e.prototype.filterAndSortData = function (t) {\n              var e = this.chart.settings.filters,\n                  i = e.allowZeroValues,\n                  n = e.sliceFilter;\n\n              if (!i || n) {\n                t.total;\n\n                for (var r = [], a = 0; a < t.values.length; a++) {\n                  var o = t.values[a];\n                  n && !n(o) || !i && 0 === o.value ? o.value : r.push(o);\n                }\n\n                var l = new s();\n                l.values = r, l.done = t.done, l.beforeSum = t.beforeSum, l.afterSum = t.afterSum, l.total = t.total || null, l.totalCount = t.totalCount || null, l.extra = t.extra, t = l;\n              }\n\n              return this.dataSettings.sortField && this.sortData(t), t;\n            }, e.prototype.sortData = function (t) {\n              var e = this.dataSettings.sortField;\n              if (h.Helpers.isFunction(e)) t.values.sort(e);else {\n                var i;\n                i = Array.isArray(e) ? e.slice() : [e];\n\n                for (var n = new Array(i.length), r = 0; r < i.length; r++) {\n                  var s = i[r];\n                  \"-\" === s.charAt(0) ? (i[r] = s.substr(1), n[r] = -1) : n[r] = 1;\n                }\n\n                t.values.sort(function (t, e) {\n                  for (var r = 0; r < i.length; r++) {\n                    var s = t[i[r]],\n                        a = e[i[r]],\n                        o = void 0;\n                    if (null == s ? o = null == a ? 0 : a < 0 ? -1 : 1 : null == a ? o = s < 0 ? 1 : -1 : (o = a - s, isNaN(o) && (o = (\"\" + a).localeCompare(s))), 0 !== o) return n[r] * o;\n                  }\n\n                  return 0;\n                });\n              }\n            }, e.prototype.buildRequest = function () {\n              if (!h.Helpers.hasProperties(this.pendingPies)) return null;\n              var t = h.Helpers.removePropertyValue(this.pendingPies),\n                  e = t.key,\n                  i = t.value;\n              return this.requestedPies[e] = i, i;\n            }, e.prototype.dataFunc = function (t, e, i) {\n              var n = this.dataSettings;\n              if (n.dataFunction) n.dataFunction(t.id, t.limit, t.offset, e, i);else if (n.url) {\n                var r = [];\n                t.id && r.push([\"id\", t.id]), r.push([\"limit\", t.limit.toString(10)]), r.push([\"offset\", t.offset.toString(10)]), h.Data.doRequest(n.url, n, r, e, i);\n              } else i({\n                error: \"Chart configuration does not define data retrieval function\"\n              });\n            }, e.prototype.verifySlices = function (t, e, i) {\n              for (var n = !0, r = 0; r < t.length; r++) {\n                var s = t[r],\n                    a = s.id ? \" Slice id: `\" + s.id + \"`\" : \"\";\n\n                if (h.Helpers.isObjectOrArray(s)) {\n                  if (!this._isFacetChart) if (s.value = h.Helpers.tryParseFloat(s.value, null), null === s.value) {\n                    if (!i) {\n                      h.Helpers.warn(\"Slices must have a numeric `value` property!\" + a), t.splice(r, 1), r--;\n                      continue;\n                    }\n\n                    this.chart.error(\"Slices must have a numeric `value` property!\" + a), n = !1;\n                  } else if (s.value < 0) {\n                    if (!i) {\n                      h.Helpers.warn(\"Slice values cannot be negative.\" + a), t.splice(r, 1), r--;\n                      continue;\n                    }\n\n                    this.chart.error(\"Slice values cannot be negative.\" + a), n = !1;\n                  }\n                  h.Helpers.hasProperty(s, \"id\") ? (s.__id = \"\" + s.id, h.Helpers.hasProperty(e, s.__id) && (this.chart.error(\"Multiple slices with the same ID.\" + a), n = !1), e[s.__id] = !0) : (s.__id = h.Helpers.SeparatorChar + this.nextId, this.nextId++), h.Helpers.hasProperty(s, \"subvalues\") && (Array.isArray(s.subvalues) ? this.verifySlices(s.subvalues, e, i) || (n = !1) : (this.chart.error(\"Field `subvalues` is not an array!\" + a), n = !1));\n                } else this.chart.error(\"Slices must be objects!\"), n = !1;\n              }\n\n              return n;\n            }, e.prototype.verifyData = function (t, e) {\n              if (h.Helpers.hasProperty(e, \"id\") || (e.id = t ? t.id : this.getRootId()), t && e.id && e.id !== t.id) return this.chart.error(\"Requested data for ID `\" + t.id + \"` but got data with ID `\" + e.id + \"`. Consider specifying `navigation.initialDrilldown`.\"), !1;\n\n              if (delete this.requestedPies[e.id], e.limit = h.Helpers.tryParseInt(e.limit, 1 / 0), e.offset = h.Helpers.tryParseInt(e.offset, 0), e.beforeSum = h.Helpers.tryParseFloat(e.beforeSum, null), e.afterSum = h.Helpers.tryParseFloat(e.afterSum, null), e.sum = h.Helpers.tryParseFloat(e.sum, null), !h.Helpers.hasProperty(e, \"subvalues\")) {\n                if (!h.Helpers.hasProperty(e, \"values\")) return this.chart.error(\"Field `subvalues` not set in root data object\"), !1;\n                h.Helpers.warn(\"Use of property `values` within PieChart data object is being deprecated. Please use `subvalues` instead.\", null, !0), e.subvalues = e.values;\n              }\n\n              if (!Array.isArray(e.subvalues)) return this.chart.error(\"Field `subvalues` is not an array!\"), !1;\n              var i = !0;\n              e.offset < 0 && (this.chart.error(\"Data `offset` must be greater or equal to 0.\"), i = !1), e.limit < 1 && (this.chart.error(\"Data `limit` must be greater than 0.\"), i = !1);\n              var n = e.offset > 0 || e.limit <= e.subvalues.length;\n              if (!this.verifySlices(e.subvalues, {}, n)) return !1;\n              var r = e.limit > e.subvalues.length,\n                  s = e.offset + e.subvalues.length;\n\n              if (t && (e.offset >= t.offset + t.limit || t.offset >= s && !r) && (this.chart.error(\"Response and request do not overlap. Requested \" + t.limit + \" items starting at \" + t.offset + \". Received \" + e.subvalues.length + \" items starting at \" + e.offset), i = !1), h.Helpers.hasProperty(this.pies, e.id)) {\n                var a = this.pies[e.id];\n\n                if (a.values.length > 0) {\n                  var o = a.offset + a.values.length;\n                  (o < e.offset || s < a.offset && !r) && (this.chart.error(\"Data cannot be merged - there is a gap between old data and new data! Old data spans slices from \" + a.offset + \" to \" + (o - 1) + \"; new data spans slices from \" + e.offset + \" to \" + (s - 1) + \".\"), i = !1);\n                }\n              }\n\n              (n && this.dataSettings.autoCategories && (this.chart.error(\"Cannot auto categorize partial data\"), i = !1), !this._isFacetChart && n) && ((null == e.beforeSum ? 0 : 1) + (null == e.afterSum ? 0 : 1) + (null == e.sum ? 0 : 1) < 2 ? (this.chart.error(\"For partial loading, at least 2 of the following need to be set: beforeSum, afterSum, sum.\"), i = !1) : (e.__valuesSum = this.valueSum(e.subvalues), null == e.beforeSum ? e.beforeSum = e.sum - e.afterSum - e.__valuesSum : null == e.afterSum ? e.afterSum = e.sum - e.beforeSum - e.__valuesSum : null == e.sum && (e.sum = e.beforeSum + e.afterSum + e.__valuesSum), e.sum !== e.beforeSum + e.afterSum + e.__valuesSum && (this.chart.error(\"For partial loading, beforeSum + (sum of subvalues) + afterSum must equal sum!\"), i = !1), this._isFacetChart || (e.beforeSum < 0 && (this.chart.error(\"beforeSum cannot be negative!\"), i = !1), e.afterSum < 0 && (this.chart.error(\"afterSum cannot be negative!\"), i = !1), e.sum < 0 && (this.chart.error(\"sum cannot be negative!\"), i = !1))));\n              return i;\n            }, e.prototype.addVerifiedData = function (t, e) {\n              this.chart.scene.loading = this.hasPendingRequests();\n              var i = e.id,\n                  n = {};\n              return n[i] = !0, t ? this.chart.log(\"Data arrived, id=\" + i + \", offset=\" + t.offset + \", len=\" + e.subvalues.length + \" of \" + (t.limit || \"unset\")) : this.chart.log(\"Data arrived, id=\" + i + \", offset=\" + e.offset + \", len=\" + e.subvalues.length + \" of \" + (e.limit || \"unset\")), this.dataSettings.autoCategories && (e = this.autoCategorize(e, this.dataSettings.autoCategories)), this.addDataInt(i, e.subvalues, e.offset, e.limit, e.afterSum, e.beforeSum, e.sum, e, n), {\n                pieChartPieIds: n\n              };\n            }, e.prototype.requestFailedPermanently = function (t) {\n              if (this.chart.scene.loading = this.hasPendingRequests(), t) {\n                var e = new s();\n                e.done = !0, this.pies[t.id] = e, this.chart.error(\"Data request failed for pie with ID `\" + t.id + \"`.\"), delete this.requestedPies[t.id];\n              } else this.chart.error(\"Data request failed.\");\n            }, e;\n          }(h.Data);\n\n          t.Data = a;\n\n          var o = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.marker = new u(), e.showOthers = !1, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegend);\n\n          t.SettingsLegend = o;\n\n          var u = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.shape = \"square\", e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLegendMarker);\n\n          t.SettingsLegendMarker = u;\n\n          var c = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e, i, null, null) || this;\n              return r.sliceHovered = !1, r.data = n, r;\n            }\n\n            return r(e, t), e.prototype.isHovered = function () {\n              return this.hoverCount > 0 || this.sliceHovered;\n            }, e;\n          }(h.LegendEntry),\n              d = function (t) {\n            function e(e) {\n              var i = t.call(this, e) || this;\n              return i.paintOrder = 20, i.updateOrder = 1e3, i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (e) {\n              t.prototype.onSceneChange.call(this, e);\n              var i = e.changes;\n              i.pie && (this.rebuildItems(), i.bounds = !0);\n            }, e.prototype.getLastHoveredSlice = function () {\n              var t = this.getLastHoveredEntry();\n              return t ? t.data : null;\n            }, e.prototype.doAnimations = function () {\n              for (var t = this.chart.scene.hoverSlice, e = 0; e < this.entries.length; e++) {\n                this.entries[e].sliceHovered = this.entries[e].data === t;\n              }\n\n              var i = this.chart.scene.selection;\n\n              for (e = 0; e < i.length; e++) {\n                var n = this.entryIndex[i[e].id];\n                n && (n.sliceHovered = !0);\n              }\n            }, e.prototype.paintMarker = function (t, e, i, n, r) {\n              var s = {\n                fillColor: r.data.currentFillColor,\n                lineColor: this.settings.marker.lineColor\n              },\n                  a = t.context;\n              a.beginPath();\n              var o = this.settings.marker.shape;\n              o || (o = \"circle\"), h.Graphics.strokeMarker(a, o, e, i, n), h.Graphics.paint(a, s);\n            }, e.prototype.rebuildItems = function () {\n              var t = [],\n                  e = this.chart.scene.peek();\n\n              if (e) {\n                var i = this.settings.text.fillColor,\n                    n = function n(t) {\n                  return new c(t.data.nameLegend || t.label.text || t.data.name, i, t);\n                },\n                    r = this.settings.showOthers,\n                    s = e.slices,\n                    a = e.previousSlice,\n                    o = e.othersSlice;\n\n                r && a && !a.removed && t.push(n(a)), t.push.apply(t, s.map(n)), r && o && !o.removed && t.push(n(o));\n              }\n\n              this.entryIndex = {};\n\n              for (var l = 0; l < t.length; l++) {\n                this.entryIndex[t[l].data.id] = t[l];\n              }\n\n              this.resetEntries(t);\n            }, e.prototype.itemClicked = function (t, e) {}, e;\n          }(h.Legend);\n\n          t.Legend = d;\n\n          var p = function () {\n            return function () {\n              this.hwidth = 0, this.hheight = 0, this.x = null, this.y = null, this.userPlaced = !1, this.inside = !0;\n            };\n          }();\n\n          t.Icon = p;\n\n          var f = function () {\n            function t(t, e) {\n              this.id = null, this.pie = null, this.data = null, this.index = 0, this.value = 0, this.percent = null, this.fraction = 0, this.cutoutDistance = 0, this.selectDistance = 15, this.selection = 0, this.brightness = 1, this.expandable = !0, this.selected = !1, this.active = !1, this.removed = !1, this.icon = null, this.iconOffset = null, this.url = null, this.urlTarget = null, this.userPlaced = !1, this.inside = !0, this.x = 0, this.y = 0, this.originalId = null, this.currentCutoutDistance = null, this.currentFraction = null, this.currentInsideLabel = null, this.currentLabel = null, this.currentIcon = null, this.currentLineColor = null, this.currentFillColor = null, this.targetFillColor = null, this.targetLineColor = null, this._resetLabelText = !1, this._label = {\n                textStyle: {}\n              }, this._insideLabel = {\n                textStyle: {}\n              }, this.lineColor = null, this.fillColor = null, this.fillColor2 = null, this.lineWidth = 1, this.lineDash = null, this.lineBrightness = 0, this._animatorF = null, this._animatorLineColor = null, this._animatorFillColor = null, this._animatorCutout = null, this._renderParams = null, this.index = e, this.pie = t;\n            }\n\n            return Object.defineProperty(t.prototype, \"label\", {\n              get: function get() {\n                return this._label;\n              },\n              set: function set(t) {\n                h.Helpers.isObjectOrArray(t) ? this._label = t : (h.Helpers.warn(\"Slice.label should no longer be set to the text value - instead use Slice.label.text.\"), this._label.text = t ? \"\" + t : null, this._resetLabelText = !1);\n              },\n              enumerable: !0,\n              configurable: !0\n            }), Object.defineProperty(t.prototype, \"insideLabel\", {\n              get: function get() {\n                return this._insideLabel;\n              },\n              set: function set(t) {\n                h.Helpers.isObjectOrArray(t) ? this._insideLabel = t : (h.Helpers.warn(\"Slice.insideLabel should no longer be set to the text value - instead use Slice.insideLabel.text.\"), this._insideLabel.text = t ? \"\" + t : null, this._resetLabelText && (this._resetLabelText = !1, this._label.text = null));\n              },\n              enumerable: !0,\n              configurable: !0\n            }), Object.defineProperty(t.prototype, \"labelStyle\", {\n              get: function get() {\n                return h.Helpers.warn(\"Slice.labelStyle is deprecated - use Slice.label instead.\"), this._label;\n              },\n              set: function set(t) {\n                h.Helpers.warn(\"Slice.labelStyle is deprecated - use Slice.label instead.\"), t && (t.text || (t.text = this._label.text), h.Helpers.extendDeep(this._label, t));\n              },\n              enumerable: !0,\n              configurable: !0\n            }), Object.defineProperty(t.prototype, \"insideLabelStyle\", {\n              get: function get() {\n                return h.Helpers.warn(\"Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.\"), this._insideLabel;\n              },\n              set: function set(t) {\n                h.Helpers.warn(\"Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.\"), t && (t.text || (t.text = this._insideLabel.text), h.Helpers.extendDeep(this._insideLabel, t));\n              },\n              enumerable: !0,\n              configurable: !0\n            }), t;\n          }();\n\n          t.Slice = f;\n\n          var g = function () {\n            function t() {\n              this.id = null, this.data = null, this.total = 1, this.parentSlice = null, this.othersSlice = null, this.previousSlice = null, this.slices = [], this.allSlices = [], this.offset = 0, this.count = 0, this.background = !1, this.activeSliceId = null, this.brightness = 1, this.loading = !1, this.scrollOffset = 0, this.fillColor = null, this.x = 0, this.y = 0, this.startAngle = 0, this.endAngle = 0, this.rotationSpeed = 0, this.currentlyRotating = !1, this.currentStartAngle = null, this.currentEndAngle = null, this.currentRadius = 0, this.innerRadius = 0, this.radius = 0, this.currentInnerRadius = 0, this.colorDistribution = null, this.sliceColors = null, this.removed = !1, this.visibleFraction = 1, this.removeTime = null, this._animatorA0 = null, this._animatorA1 = null, this._animatorR0 = null, this._animatorR1 = null;\n            }\n\n            return t.prototype.getActiveSlice = function () {\n              if (!this.activeSliceId) return null;\n\n              for (var t = 0; t < this.slices.length; t++) {\n                var e = this.slices[t];\n                if (e.id === this.activeSliceId) return e;\n              }\n\n              return null;\n            }, t;\n          }();\n\n          t.Pie = g;\n\n          var m = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.radius = 100, e.innerRadius = 0, e.currentRadius = null, e.currentInnerRadius = null, e.pies = [], e.stack = [], e.selectionIds = [], e.hoverBack = !1, e.hoverSlice = null, e.hoverLabel = null, e.hoverPie = null, e.view = null, e.selection = [], e.pendingAction = null, e.pendingOffset = null, e;\n            }\n\n            return r(e, t), e.prototype.addPie = function (t) {\n              return this.pies.push(t), this.stack.push(t), t;\n            }, e.prototype.removePie = function (t) {\n              if (null !== t) {\n                t.removed = !0, t.removeTime = null, h.Helpers.removeFromArray(this.stack, t);\n\n                for (var e = 0; e < this.selection.length;) {\n                  var i = this.selection[e];\n                  i.pie === t ? h.Helpers.removeFromArray(this.selection, i) : e++;\n                }\n              }\n            }, e.prototype.deletePie = function (t) {\n              return h.Helpers.removeFromArray(this.pies, t), h.Helpers.removeFromArray(this.stack, t);\n            }, e.prototype.length = function () {\n              return this.stack.length;\n            }, e.prototype.peek = function () {\n              return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n            }, e.prototype.push = function (t, e) {\n              void 0 === e && (e = null);\n              var i = this.peek();\n              if (i && !e) for (var n = 0; n < i.slices.length; n++) {\n                if ((a = i.slices[n]).id === t.id) {\n                  e = a;\n                  break;\n                }\n              }\n\n              if (e) {\n                t.parentSlice = e;\n                var r = e.pie,\n                    s = this.getSliceAngles(e);\n                t.currentStartAngle = s.a0, t.currentEndAngle = s.a1, t.currentRadius = r.currentRadius, t.currentInnerRadius = r.currentInnerRadius, i.activeSliceId = e.id;\n\n                for (n = 0; n < t.allSlices.length; n++) {\n                  var a;\n                  (a = t.allSlices[n]).currentFillColor = e.currentFillColor, a.currentLineColor = e.currentLineColor;\n                }\n              } else i && (i.activeSliceId = null);\n\n              return i && (i.background = !0), this.addPie(t);\n            }, e.prototype.pop = function () {\n              if (0 !== this.stack.length) {\n                this.removePie(this.peek());\n                var t = this.peek();\n                t && (t.background = !1, t.brightness = 1);\n              }\n            }, e.prototype.getParent = function (t) {\n              for (var e = null, i = 0; i < this.stack.length; i++) {\n                var n = this.stack[i];\n                if (n === t) return e;\n                e = n;\n              }\n\n              return null;\n            }, e.prototype.getChild = function (t) {\n              for (var e = null, i = 0; i < this.stack.length; i++) {\n                var n = this.stack[i];\n                if (e === t) return n;\n                e = n;\n              }\n\n              return null;\n            }, e.prototype.updateOnPieChanged = function (t) {\n              var e = this.getParent(t),\n                  i = this.getChild(t);\n              if (e && !t.parentSlice) for (var n = 0; n < e.slices.length; n++) {\n                if ((r = e.slices[n]).id === t.id) {\n                  t.parentSlice = r, e.activeSliceId = r.id;\n                  break;\n                }\n              }\n              if (i && !i.parentSlice) for (n = 0; n < t.slices.length; n++) {\n                var r;\n\n                if ((r = t.slices[n]).id === i.id) {\n                  i.parentSlice = r, t.activeSliceId = r.id;\n                  break;\n                }\n              }\n            }, e.prototype.findPieAt = function (t, e, i) {\n              return this.view.findPieAt(t, e, i);\n            }, e.prototype.findSliceAt = function (t, e, i, n) {\n              return this.view.findSliceAt(t, e, i, n);\n            }, e.prototype.findLabelAt = function (t, e, i) {\n              return this.view.findLabelAt(t, e, i);\n            }, e.prototype.getSliceAngles = function (t) {\n              for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {\n                var s = i.allSlices[r];\n                if (n = e, e += s.currentFraction, s.id === t.id) break;\n              }\n\n              var a = i.currentEndAngle - i.currentStartAngle,\n                  o = i.currentStartAngle;\n              return {\n                a0: o + a * n,\n                a1: o + a * e\n              };\n            }, e.prototype.getSliceTargetAngles = function (t) {\n              for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {\n                var s = i.allSlices[r];\n                if (n = e, e += s.currentFraction, s.id === t.id) break;\n              }\n\n              var a = i.currentEndAngle - i.currentStartAngle,\n                  o = i.currentStartAngle;\n              return {\n                a0: o + a * n,\n                a1: o + a * e\n              };\n            }, e;\n          }(h.Scene);\n\n          t.Scene = m;\n\n          var v = function (t) {\n            function e(i) {\n              var n = t.call(this, h.SettingsMapping.PieChartSettings) || this;\n              return n.theme = e.FlatTheme, n.data = [], n.legend = new o(), n.navigation = {\n                initialDrilldown: [\"\"],\n                initialOffset: 0\n              }, n.pie = {\n                radius: null,\n                adaptiveRadius: !0,\n                outerMargin: 1,\n                margin: 2,\n                centerMargin: 5,\n                showInnerPiesExport: !0,\n                showInnerPies: !0,\n                innerRadius: .3,\n                innerRadiusWhenDrilldown: .2,\n                startAngle: -Math.PI / 2,\n                endAngle: 1.5 * Math.PI,\n                rotationSpeed: 0,\n                theme: \"flat\",\n                depth: 0,\n                x: null,\n                y: null,\n                style: {\n                  fillColor: \"transparent\",\n                  sliceColors: [\"#2fc32f\", \"#b0dc0b\", \"#eab404\", \"#de672c\", \"#ec2e2e\", \"#d5429b\", \"#6f52b8\", \"#1c7cd5\", \"#56b9f7\", \"#0ae8eb\"],\n                  colorDistribution: \"list\",\n                  brightness: 1\n                },\n                noDataStyle: {\n                  fillColor: \"#ddd\"\n                },\n                backgroundStyle: {},\n                backgroundHoveredStyle: {\n                  brightness: .7\n                },\n                styleFunction: null\n              }, n.slice = {\n                margin: 2,\n                minFraction: 0,\n                style: {\n                  lineBrightness: 0,\n                  brightness: 1,\n                  lineWidth: 1,\n                  label: {\n                    backgroundStyle: null,\n                    textStyle: {\n                      fillColor: \"#000\",\n                      font: \"12px Arial\"\n                    },\n                    lineSpacing: .2,\n                    margin: 4,\n                    padding: 0,\n                    borderRadius: 999,\n                    text: null\n                  },\n                  insideLabel: {\n                    textStyle: {\n                      fillColor: \"#fff\",\n                      font: \"12px Arial\"\n                    },\n                    lineSpacing: .2,\n                    margin: 4,\n                    padding: 0,\n                    borderRadius: 0,\n                    text: null\n                  }\n                },\n                hoverStyle: {\n                  brightness: 1.2,\n                  lineBrightness: 2,\n                  lineWidth: .35\n                },\n                selectedStyle: null,\n                backgroundStyle: {\n                  fillColor: \"#e2e2e2\",\n                  fillColor2: \"#e0e0e0\"\n                },\n                backgroundActiveStyle: {\n                  brightness: 1.3\n                },\n                othersStyle: {\n                  fillColor: \"#ccc\",\n                  lineDecoration: \"zigzag\"\n                },\n                previousStyle: {\n                  fillColor: \"#ccc\",\n                  lineDecoration: \"zigzag\"\n                },\n                connectorStyle: {\n                  lineColor: \"#333\",\n                  lineWidth: 1\n                },\n                expandableMarkStyle: {\n                  lineWidth: 1,\n                  lineColor: \"rgba(255,255,255,0.8)\",\n                  distance: 4,\n                  lineDash: null\n                },\n                styleFunction: null\n              }, n.filters = {\n                sliceFilter: null,\n                allowZeroValues: !1\n              }, n.labels = new y(), n.icons = {\n                sizeExtent: [16, 64],\n                placement: \"auto\",\n                autohideWhenTooSmall: !0\n              }, n.advanced = new x(), n.interaction = new C(), n.info = {\n                enabled: !0,\n                contentsFunction: null\n              }, n.events = new S(), n.toolbar = new h.SettingsToolbar(!1, [new h.SettingsToolbarItem(\"back\"), new h.SettingsToolbarItem(\"export\"), new h.SettingsToolbarItem(\"zoomOut\"), new h.SettingsToolbarItem(\"fullscreen\")]), n.localization = new b(), n.toolbar.zoomOut = !1, n.apply(i), n._initializing = !1, n;\n            }\n\n            return r(e, t), e.prototype.apply = function (e) {\n              return this.applyCompatibility(e, [{\n                from: \"slice.labelStyle\",\n                to: \"slice.style.label\"\n              }, {\n                from: \"slice.insideLabelStyle\",\n                to: \"slice.style.insideLabel\"\n              }, {\n                from: \"labels.connectorStyle\",\n                to: \"slice.connectorStyle\"\n              }, {\n                from: \"labels.textStyle\",\n                to: \"slice.style.label.textStyle\"\n              }, {\n                from: \"labels.backgroundStyle\",\n                to: \"slice.style.label.backgroundStyle\"\n              }, {\n                from: \"labels.insideTextStyle\",\n                to: \"slice.style.insideLabel.textStyle\"\n              }, {\n                from: \"labels.padding\",\n                to: \"slice.style.label.padding\"\n              }, {\n                from: \"labels.borderRadius\",\n                to: \"slice.style.label.borderRadius\"\n              }, {\n                from: \"area.initialPieId\",\n                to: \"navigation.initialDrilldown\"\n              }, {\n                from: \"area.initialPieOffset\",\n                to: \"navigation.initialOffset\"\n              }, {\n                from: \"area.initialAnimation\",\n                to: \"advanced.initialAnimation\"\n              }, {\n                from: \"advanced.iconMinSize\",\n                alternative: \"icons.sizeExtent[0]\"\n              }, {\n                from: \"advanced.pointer.dragSensitivity\",\n                to: \"interaction.selection.swipeSensitivity\"\n              }]), t.prototype.apply.call(this, e);\n            }, e;\n          }(h.Settings);\n\n          v.FlatTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\",\n              assets: []\n            },\n            pie: {\n              theme: \"flat\",\n              depth: 0\n            }\n          }, v.DarkTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-dark\",\n              assets: []\n            },\n            area: {\n              style: {\n                fillColor: \"rgba(28,26,28,1)\"\n              }\n            },\n            title: {\n              margin: 15,\n              style: {\n                fillColor: \"#A8A7A8\"\n              }\n            },\n            pie: {\n              theme: \"flat\",\n              depth: 0,\n              style: {\n                sliceColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\", \"#0b83ea\", \"#3ca20d\", \"#BC438F\"]\n              }\n            },\n            slice: {\n              connectorStyle: {\n                lineColor: \"#4C4C4C\"\n              },\n              style: {\n                label: {\n                  textStyle: {\n                    fillColor: \"#A8A7A8\"\n                  }\n                }\n              }\n            },\n            legend: {\n              text: {\n                fillColor: \"#A8A7A8\"\n              },\n              marker: {\n                lineColor: null\n              }\n            }\n          }, v.BevelTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\",\n              assets: []\n            },\n            pie: {\n              theme: \"bevel\",\n              depth: 0\n            }\n          }, v.GradientTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\",\n              assets: []\n            },\n            pie: {\n              theme: \"smoothy\",\n              depth: 0\n            }\n          }, v.CanTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\",\n              assets: []\n            },\n            pie: {\n              theme: \"can\",\n              depth: 10\n            }\n          }, t.Settings = v;\n\n          var y = function () {\n            return function () {\n              this.enabled = !0, this.connectors = !0, this.connectorLength = 20, this.angle = 0, this.insideLabel = \"append\", this.insideLabelVisibilityFraction = .8, this.interLabelSpacing = .6, this.placement = \"aligned\";\n            };\n          }();\n\n          t.SettingsLabels = y;\n\n          var S = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.onPieChange = null, e.onPieReadyStateChanged = null, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsEvents);\n\n          t.SettingsEvents = S;\n\n          var b = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.othersLabel = \"Others\", e.previousLabel = \"Previous\", e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsLocalization);\n\n          t.SettingsLocalization = b;\n\n          var C = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.mode = \"drilldown\", e.coverCenter = !1, e.selection = {\n                enabled: !0,\n                tolerance: 2,\n                swipe: !1,\n                swipeSensitivity: 10,\n                partialSwipe: !1,\n                maxSwipeDistance: 45\n              }, e.animation = {\n                scrollDuration: 500,\n                hoverDuration: 200\n              }, e.others = {\n                enabled: !0,\n                centerGoesToPrevious: !1,\n                navigationFraction: .15,\n                maxSlicesVisible: 15,\n                minSlices: 1,\n                maxOthersFraction: .6,\n                minSliceFraction: .01\n              }, e.scrolling = {\n                enabled: !1\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsInteraction);\n\n          t.SettingsInteraction = C;\n\n          var x = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.iconMinSize = null, e.initialAnimation = !0, e.renderQuality = 1, e.backImage = \"builtin://piechart-back\", e.backImageBackground = null, e.backAlwaysVisible = !1, e.labelInsideTreshold = 1, e.builtinAssets[\"piechart-back\"] = l.PiechartBack, e.pointer.noClickOnDoubleClick = !1, e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsAdvanced);\n\n          t.SettingsAdvanced = x;\n\n          var w = function (e) {\n            function i(i) {\n              var n = e.call(this) || this;\n              return n.animationOrder = 1100, n.paintOrder = 10, n.updateOrder = 1200, n.currentSlice = null, n.currentLabel = null, n.currentPie = null, n.hoveringLegend = !1, n.draggedLabelSlice = null, n.draggedLabel = null, n.hoverEvent = null, n.dragStartConditions = {\n                angle: 1 / 0,\n                distance: 1 / 0,\n                slice: null,\n                pie: null\n              }, n.isScrolling = !1, n.px = 0, n.py = 0, n.chart = i, n.scene = i.scene, n.events = i.events, n.scrolling = new t.Scrolling(i), n;\n            }\n\n            return r(i, e), i.prototype.doAnimations = function (t) {\n              this.hoverEvent && this.onPointerMove(this.hoverEvent);\n            }, i.prototype.previewPointerDrag = function (t) {\n              this.hoverEvent = t;\n            }, i.prototype.onPointerMove = function (t) {\n              this.hoverEvent = t, this.updateCurrentObject(t);\n            }, i.prototype.onPointerOut = function (t) {\n              this.updateCurrentObject(t), this.switchCurrentSlice(null, null, !1, t), this.hoverEvent = null;\n            }, i.prototype.onPointerDown = function (t) {\n              this.handlePointerDown(t), this.scrolling.handlePointerDown(t);\n            }, i.prototype.handlePointerDown = function (t) {\n              this.updateCurrentObject(t);\n              var e = this.currentSlice;\n              (e || this.currentPie) && (t.consumed = !0), this.px = t.x, this.py = t.y;\n              var i = this.scene.settings.interaction.selection;\n\n              if (i.swipe || i.partialSwipe) {\n                var n = this.scene.settings.interaction,\n                    r = this.scene.pies[0],\n                    s = r && n.others.centerGoesToPrevious && r.previousSlice,\n                    a = n.coverCenter && !s && (!r || !r.background),\n                    o = this.scene.findSliceAt(t.x, t.y, n.selection.tolerance, a);\n\n                if (this.dragStartConditions.slice = null, this.dragStartConditions.pie = null, this.dragStartConditions.distance = 1 / 0, this.dragStartConditions.angle = 0, o && null !== o.id) {\n                  this.dragStartConditions.slice = e, this.dragStartConditions.pie = r;\n                  var l = t.x - r.x,\n                      h = t.y - r.y,\n                      u = Math.sqrt(l * l + h * h);\n                  this.dragStartConditions.distance = u - e.currentCutoutDistance, this.dragStartConditions.angle = 180 * Math.atan2(h, l) / Math.PI;\n                }\n              }\n\n              var c = this.scene.findLabelAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);\n              this.draggedLabelSlice = c.slice, this.draggedLabel = c.label, this.draggedLabel = null, this.draggedLabelSlice = null;\n            }, i.prototype.onPointerDrag = function (t) {\n              this.handlePointerDrag(t), this.scrolling.handlePointerDrag(t);\n            }, i.prototype.handlePointerDrag = function (t) {\n              var e = this.scene.settings.interaction.selection;\n\n              if (!this.isScrolling) {\n                if (t.distance({\n                  x: this.px,\n                  y: this.py\n                }) < e.swipeSensitivity) return;\n                this.isScrolling = !0;\n              }\n\n              if ((e.swipe || e.partialSwipe) && (this.currentSlice || this.dragStartConditions.slice)) {\n                var i = this.dragStartConditions.slice;\n\n                if (null !== i) {\n                  var n = this.dragStartConditions.pie,\n                      r = this.dragStartConditions.distance,\n                      s = this.dragStartConditions.angle;\n                  s === 1 / 0 && (s = 180 * Math.atan2(t.y - n.y, t.x - n.x) / Math.PI);\n                  var a = t.x - n.x,\n                      o = t.y - n.y,\n                      l = 180 * Math.atan2(o, a) / Math.PI,\n                      h = Math.abs(s - l);\n\n                  if (h <= 90) {\n                    var u = Math.sqrt(a * a + o * o);\n                    this.dragStartConditions.distance === 1 / 0 && (r = u - i.currentCutoutDistance);\n                    var c = this.scene.innerRadius >= i.selectDistance / 2 ? -i.selectDistance / 2 : 0,\n                        d = u * Math.cos(h * Math.PI / 180),\n                        p = d - r > e.maxSwipeDistance,\n                        f = d - r > c;\n                    i.userPlaced = !0, p ? i.currentCutoutDistance = e.maxSwipeDistance : f && (i.currentCutoutDistance = d - r > c ? d - r | 0 : 0), i.selection = i.currentCutoutDistance > 0 ? i.currentCutoutDistance / e.maxSwipeDistance * 100 : 0, t.changes.pie = !0;\n                  }\n                }\n              }\n\n              if (this.draggedLabel) {\n                var g = this.draggedLabel;\n                g.userPlaced = !0, g.x += t.dx, g.y += t.dy, t.consumed = !0, t.changes.pie = !0;\n              }\n            }, i.prototype.onPointerUp = function (t) {\n              this.handlePointerUp(t), this.scrolling.handlePointerUp(t);\n            }, i.prototype.handlePointerUp = function (t) {\n              this.isScrolling = !1;\n              var e = this.scene.settings.interaction.selection;\n\n              if (e.swipe || e.partialSwipe) {\n                var i = this.dragStartConditions.slice;\n\n                if (i) {\n                  var n = i.currentCutoutDistance >= i.selectDistance / 2 && !i.selected,\n                      r = i.currentCutoutDistance < i.selectDistance / 2 && i.selected;\n                  e.swipe || i.currentCutoutDistance <= 0 && e.partialSwipe ? i.userPlaced = !1 : e.partialSwipe && (i.userPlaced = !0), r || n ? this.updateSelection(t, i, !1) : i.currentCutoutDistance >= i.selectDistance / 2 && i.selected && this.setSelection([i], [], !0);\n                }\n              }\n\n              this.draggedLabel && (this.draggedLabel = null, t.consumed = !0);\n            }, i.prototype.onPointerCancel = function (t) {\n              this.onPointerUp(t);\n            }, i.prototype.defaultClick = function (t, e) {\n              var i = this.chart,\n                  n = e.clickSlice,\n                  r = e.clickPie;\n              if (\"drilldown\" === i.settings.interaction.mode || n && (n === n.pie.othersSlice || n === n.pie.previousSlice)) if (n) {\n                if (n.url) h.Helpers.openUrl(n.url, n.urlTarget), t.preventDefault();else {\n                  i.settings.interaction.selection.enabled && t.ctrlKey || !this.chart.navigator.expandSlice(n, \"user\") || t.preventDefault();\n                }\n              } else r && \"back\" === e.clickOrigin && (this.setSelection([], [], !1, \"user\"), this.chart.navigator.goCenter(\"user\"), t.preventDefault());\n            }, i.prototype.onClick = function (t) {\n              this.onPointerMove(t);\n              var e = this.createClickArgs(t);\n\n              if (\"legend\" !== e.clickOrigin || this.chart.settings.legend.interaction.click ? (this.chart.notifyClick(t, e), (this.currentSlice || this.currentPie) && (t.consumed = !0), t.defaultPrevented || this.updateSelection(t, this.currentSlice, !1)) : \"legend\" === e.clickOrigin && (e.clickSlice = null, e.clickPie = null, this.chart.notifyClick(t, e)), t.touch) {\n                var i = t.x;\n                t.x = 1e9, this.onPointerOut(t), t.x = i;\n              }\n            }, i.prototype.onLongPress = function (t) {\n              this.updateSelection(t, this.currentSlice, !1);\n            }, i.prototype.onRightClick = function (t) {\n              this.onPointerMove(t), (this.currentSlice || this.currentPie) && (t.consumed = !0), this.chart.notifyRightClick(t, this.createClickArgs(t)), t.defaultPrevented && (t.consumed = !0);\n            }, i.prototype.onDoubleClick = function (t) {\n              this.onPointerMove(t), this.chart.notifyDoubleClick(t, this.createClickArgs(t)), t.consumed = !0;\n            }, i.prototype.onTripleClick = function (t) {\n              this.onPointerMove(t), this.chart.notifyTripleClick(t, this.createClickArgs(t)), t.consumed = !0;\n            }, i.prototype.createClickArgs = function (t) {\n              var e = this.chart.createEventArguments(t, \"user\"),\n                  i = e.hoverSlice;\n\n              if (e.clickSlice = i, e.clickPie = i ? i.pie : e.hoverPie, e.clickLabel = e.hoverLabel, i) {\n                var n = e.clickLabel;\n                this.hoveringLegend ? e.clickOrigin = \"legend\" : n ? n === i.currentInsideLabel ? e.clickOrigin = \"insideLabel\" : e.clickOrigin = \"label\" : e.clickOrigin = \"slice\";\n              } else this.scene.hoverBack && (e.clickOrigin = \"back\");\n\n              return e;\n            }, i.prototype.updateSelection = function (t, e, i) {\n              var n = this.scene,\n                  r = n.settings.interaction;\n\n              if (r.selection.enabled) {\n                var s = t.shiftKey,\n                    a = \"toggle\" === r.mode || t.ctrlKey;\n                e ? s || i && e.selected || a && !e.selected ? e.selected || (this.scene.selection.push(e), e.selected = !0, this.setSelection(n.selection, n.selectionIds, !0)) : a && e.selected ? (h.Helpers.removeFromArray(n.selection, e), e.selected = !1, this.setSelection(n.selection, n.selectionIds, !0)) : !e.selected || n.selection.length > 1 ? this.setSelection([e]) : this.setSelection([]) : s || a || this.setSelection([]);\n              }\n            }, i.prototype.switchCurrentSlice = function (t, e, i, n) {\n              t === this.currentSlice && e === this.currentLabel && this.hoveringLegend === i || (n.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverSlice = t, this.scene.hoverPie = null, this.scene.hoverLabel = e, this.currentSlice = t, this.currentLabel = e, this.currentPie = null, this.hoveringLegend = i, t && (t.active = !0), this.events.notifySceneChanges({\n                pie: !0\n              }), this.chart.notifyHoverChanged(n, this.chart.createEventArguments(n, \"user\")));\n            }, i.prototype.switchCurrentPie = function (t, e) {\n              t !== this.currentPie && (e.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverPie = t, this.scene.hoverSlice = null, this.currentSlice = null, this.currentPie = t, this.hoveringLegend = !1, t && (t.active = !0), this.events.notifySceneChanges({\n                pie: !0\n              }), this.chart.notifyHoverChanged(e, this.chart.createEventArguments(e, \"user\")));\n            }, i.prototype.onSceneChange = function (t) {\n              t.changes.pie && this.updateSelectionIds() && (this.events.notifySceneChanges({\n                selection: !0\n              }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, \"api\")));\n            }, i.prototype.updateSelectionIds = function () {\n              for (var t = [], e = 0; e < this.scene.selectionIds.length; e++) {\n                for (var i = this.scene.selectionIds[e], n = 0; n < this.scene.pies.length; n++) {\n                  var r = this.scene.pies[n];\n                  if (!r.background) for (var s = 0; s < r.slices.length; s++) {\n                    if ((a = r.slices[s]).id === i) {\n                      t.push(a);\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (t.length > 0) for (s = 0; s < t.length; s++) {\n                var a;\n                (a = t[s]).selected || (a.selected = !0, this.scene.selection.push(a)), h.Helpers.removeFromArray(this.scene.selectionIds, a.id);\n              }\n              return t.length > 0;\n            }, i.prototype.setSelection = function (t, e, i, n) {\n              var r;\n              if (void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = \"user\"), this.scene.selectionIds = e, i) r = !0;else {\n                for (var s = 0; s < this.scene.selection.length; s++) {\n                  var a = this.scene.selection[s];\n                  t.indexOf(a) < 0 && (a.selected = !1, r = !0);\n                }\n\n                for (s = 0; s < t.length; s++) {\n                  (a = t[s]).selected || (a.selected = !0, r = !0);\n                }\n\n                this.scene.selection = t;\n              }\n              var o = this.updateSelectionIds();\n              (r = r || o) && (this.events.notifySceneChanges({\n                selection: !0\n              }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)));\n            }, i.prototype.updateCurrentObject = function (t) {\n              var e,\n                  i = this.scene,\n                  n = i.settings.interaction,\n                  r = i.findPieAt(t.x, t.y, n.selection.tolerance),\n                  s = r && n.others.centerGoesToPrevious && r.previousSlice,\n                  a = n.coverCenter && !s && (!r || !r.background),\n                  o = i.findLabelAt(t.x, t.y, n.selection.tolerance),\n                  l = !1;\n              e = o.slice ? o.slice : i.findSliceAt(t.x, t.y, n.selection.tolerance, a);\n              var h = this.chart.legend;\n              !e && h && (e = h.getLastHoveredSlice()) && (l = !0), e && (this.chart.settings.legend.interaction.click && (t.cursor = \"pointer\"), t.hovered = !0), this.switchCurrentSlice(e, o.label, l, t), r && (r.background || s) && !e ? (t.cursor = \"pointer\", t.hovered = !0, r.background ? this.switchCurrentPie(r, t) : (this.switchCurrentSlice(r.previousSlice, null, !1, t), this.switchCurrentPie(null, t)), i.hoverBack = !0) : (this.switchCurrentPie(null, t), i.hoverBack = !1);\n            }, i;\n          }(h.ChartElement);\n\n          t.Selection = w;\n\n          var L = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 100, i.paintOrder = 25, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.needStyleUpdate = function (t) {\n              return t.settings || t.pie || t.selection || t.style;\n            }, e.prototype.onSceneChange = function (t) {\n              if (e.needStyleUpdate(t.changes)) for (var i = 0; i < this.scene.pies.length; i++) {\n                var n = this.scene.pies[i];\n                this.updatePie(n), this.computePieColors(n);\n\n                for (var r = 0; r < n.allSlices.length; r++) {\n                  var s = n.allSlices[r];\n                  this.updateSlice(s, r);\n                }\n              }\n            }, e.prototype.updatePie = function (t) {\n              h.Helpers.extendStyleTo(this.scene.settings.pie.style, t), 0 === t.slices.length && h.Helpers.extendStyleTo(this.scene.settings.pie.noDataStyle, t), t.background && h.Helpers.extendStyleTo(this.scene.settings.pie.backgroundStyle, t), this.scene.hoverPie === t && h.Helpers.extendStyleTo(this.scene.settings.pie.backgroundHoveredStyle, t), this.scene.settings.pie.styleFunction && this.scene.settings.pie.styleFunction.call(this.chart.api, t, t.data);\n            }, e.prototype.computePieColors = function (t) {\n              for (var e = t.sliceColors, i = t.colorDistribution, n = 0, r = 0; r < t.slices.length; r++) {\n                (p = t.slices[r]).removed || (n += 1);\n              }\n\n              if (1 !== n) {\n                if (1 === e.length) e = [c = e[0], h.Colors.blend(c, \"#fff\", .8)];\n                var s = e.length;\n\n                if (\"gradient\" === i) {\n                  var a = 0;\n\n                  for (r = 0; r < t.slices.length; r++) {\n                    if (!(p = t.slices[r]).removed) {\n                      var o = e[a * (s - 1) | 0],\n                          l = e[a * (s - 1) + 1 | 0],\n                          u = a * (s - 1);\n                      u -= Math.floor(u);\n                      var c = h.Colors.blend(o, l, u, !1);\n                      p.fillColor = c, a += 1 / (n - .9);\n                    }\n                  }\n                } else if (\"gradientProportional\" === i) for (a = 0, r = 0; r < t.slices.length; r++) {\n                  if (!(p = t.slices[r]).removed) {\n                    o = e[a * (s - 1) | 0], l = e[a * (s - 1) + 1 | 0], u = a * (s - 1);\n                    u -= Math.floor(u);\n                    c = h.Colors.blend(o, l, u, !1);\n                    p.fillColor = c, a += p.fraction;\n                  }\n                } else for (var d = 0; d < t.slices.length; d++) {\n                  var p;\n\n                  if (!(p = t.slices[d]).removed) {\n                    c = e[(t.offset + d) % s];\n                    var f = d / s | 0;\n                    1 === f ? c = h.Colors.derive(c, 1.5, 1) : f >= 2 && (c = h.Colors.derive(c, .5, 1)), p.fillColor = c;\n                  }\n                }\n              } else t.slices[0].fillColor = e[0];\n            }, e.prototype.updateSlice = function (t, e) {\n              if (!t.removed) {\n                var i = t.pie,\n                    n = this.scene.settings.slice,\n                    r = n.styleFunction;\n                t.expandable = this.scene.mainData.canExpand(t.id), h.Helpers.extendDeep(t, n.style), t === i.othersSlice ? h.Helpers.extendDeep(t, n.othersStyle) : t === i.previousSlice && h.Helpers.extendDeep(t, n.previousStyle), i.total > 0 ? t.percent = t.value / i.total * 100 : t.percent = 0;\n                var s = t.label;\n                s.text ? s.text += \" \" : s.text = \"\", t.data.name && (s.text += t.data.name + \" \"), s.text += t.percent.toFixed(1) + \"%\", t.cutoutDistance = t.selected ? t.selectDistance : 0, this.scene.hoverSlice === t && h.Helpers.extendDeep(t, n.hoverStyle), t.data.style && h.SettingsHelper.updateRecursive(t, t.data.style, h.SettingsMapping.PieChartSettingsSliceStyle, {}), r && (t._resetLabelText = !0, r.call(this.chart.api, t, t.data)), i.background && (i.activeSliceId !== t.id ? (h.Helpers.extendDeep(t, n.backgroundStyle), e % 2 == 1 && (t.fillColor = t.fillColor2)) : h.Helpers.extendDeep(t, n.backgroundActiveStyle));\n                var a = \"rgba(255,255,255,0)\";\n                t.fillColor && (a = t.fillColor);\n                var o = \"rgba(255,255,255,0)\";\n                t.lineColor ? o = t.lineColor : t.lineBrightness && (o = h.Colors.derive(a, t.lineBrightness, 1));\n                var l = t.brightness * i.brightness;\n                1 !== l && (a = h.Colors.derive(a, l, 1), o = h.Colors.derive(o, l, 1), -1 !== a.indexOf(\"255,255,255\") && -1 !== o.indexOf(\"255,255,255\") && (o = \"rgb(200,200,200)\")), i.removed && i.parentSlice ? (t.targetFillColor = i.parentSlice.targetFillColor, t.targetLineColor = i.parentSlice.targetLineColor) : (t.targetFillColor = h.Colors.normalize(a), t.targetLineColor = h.Colors.normalize(o));\n              }\n            }, e;\n          }(h.ChartElement);\n\n          t.Styles = L;\n\n          var T = function (t) {\n            function e(e) {\n              return t.call(this, e) || this;\n            }\n\n            return r(e, t), e.prototype.createDom = function (e) {\n              t.prototype.createDom.call(this, e), this.backgroundImage.className += \" DVSL-PC-background-image\", this.backgroundImage.style.display = \"none\";\n            }, e.prototype.doAnimations = function (e) {\n              if (t.prototype.doAnimations.call(this, e), this.scene.settings.area.style.image && this.scene.pies.length > 0) {\n                var i = this.scene.currentInnerRadius - this.scene.settings.pie.margin,\n                    n = this.scene.pies[0].x,\n                    r = this.scene.pies[0].y;\n                (0 !== n || 0 !== r) && i > 0 ? (this.backgroundImage.style.left = Math.round(n - i) + \"px\", this.backgroundImage.style.top = Math.round(r - i) + \"px\", this.backgroundImage.style.width = Math.round(2 * i) + \"px\", this.backgroundImage.style.height = Math.round(2 * i) + \"px\", this.backgroundImage.style.display = \"\") : this.backgroundImage.style.display = \"none\";\n              }\n            }, e;\n          }(h.DomLayer);\n\n          t.DomLayer = T;\n\n          var k = function () {\n            function t(t) {\n              this.pie = null, this.chart = t, this.scene = t.scene, this.events = t.events;\n            }\n\n            return t.prototype.handlePointerDown = function (t) {\n              this.scene.settings.interaction.scrolling.enabled && (this.pointer || (this.pointer = t.identifier, this.pie = this.scene.peek()));\n            }, t.prototype.handlePointerDrag = function (t) {\n              this.pie && this.scene.settings.interaction.scrolling.enabled && (t.consumed = !0, t.identifier === this.pointer && (this.pie.scrollOffset += this.scene.view.getMovement(this.pie, t).dfraction, this.updatePieScrolling(this.pie), t.changes.pie = !0));\n            }, t.prototype.handlePointerUp = function (t) {\n              this.scene.settings.interaction.scrolling.enabled && t.identifier === this.pointer && (this.updatePieAfterScroll(this.pie), this.pie = null, this.pointer = null);\n            }, t.prototype.updatePieScrolling = function (t) {\n              if (t.scrollOffset > 0 && 0 === t.offset && (t.scrollOffset = 0), 0 !== t.scrollOffset) return this.scene.view.updatePie(this.pie, !1);\n            }, t.prototype.updatePieAfterScroll = function (t) {\n              return t.scrollOffset = 0, this.scene.view.updatePie(t, !0);\n            }, t;\n          }();\n\n          t.Scrolling = k;\n\n          var A = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 250, i.paintOrder = 30, i.updateOrder = 650, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n            }\n\n            return r(e, t), e.prototype.onNewDataObject = function () {}, e.prototype.setPie = function (t, e, i) {\n              Array.isArray(t) || (t = [t]), this.scene.pendingAction = null;\n\n              for (var n = 0; this.scene.length() > t.length;) {\n                this.scene.pop(), n++;\n              }\n\n              for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) {\n                this.scene.pop(), n++;\n              }\n\n              for (; this.scene.length() < t.length;) {\n                var r = new g();\n                r.id = t[this.scene.length()], r.offset = this.scene.length() + 1 === t.length ? e : 0, this.scene.push(r), this.scene.view.updatePie(r), n++;\n              }\n\n              var s = this.scene.peek();\n              s && s.offset !== e ? (this.scroll(s, e), n++) : n && s && this.scene.view.updatePie(s), n && (this.chart.notifyChartUpdate(i), this.events.notifySceneChanges({\n                pie: !0\n              }));\n            }, e.prototype.getPie = function () {\n              return this.scene.stack.map(function (t) {\n                return t.id;\n              });\n            }, e.prototype.getPieOffset = function () {\n              return this.scene.peek().offset;\n            }, e.prototype.goBack = function (t) {\n              var e = this.scene.length();\n              1 === e ? this.goPrevious(this.scene.peek(), t, 0) : e > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t));\n            }, e.prototype.goCenter = function (t) {\n              var e = this.scene.peek();\n              e.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious ? this.goPrevious(e, t) : this.scene.length() > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t));\n            }, e.prototype.drillDown = function (t, e) {\n              this.scene.pendingAction = null;\n              var i = new g();\n              i.id = t, i.offset = 0, this.scene.push(i), this.updateAndNotifyCurrent(e);\n            }, e.prototype.goOthers = function (t, e) {\n              this.scene.view.scrollForward(t, t.offset + t.count) || (this.scene.pendingAction = \"forward\", this.scene.pendingOffset = null), this.events.notifySceneChanges({\n                pie: !0\n              }), this.chart.notifyChartUpdate(e);\n            }, e.prototype.goPrevious = function (t, e, i) {\n              (void 0 === i && (i = null), t.offset <= 0) || (this.scene.view.scrollBackward(t, i) || (this.scene.pendingAction = \"back\", this.scene.pendingOffset = null), this.chart.notifyChartUpdate(e), this.events.notifySceneChanges({\n                pie: !0\n              }));\n            }, e.prototype.scroll = function (t, e) {\n              t.offset > e ? this.scene.view.scrollBackward(t, e) || (this.scene.pendingAction = \"back\", this.scene.pendingOffset = e) : t.offset < e && (this.scene.view.scrollForward(t, e) || (this.scene.pendingAction = \"forward\", this.scene.pendingOffset = e));\n            }, e.prototype.updateAndNotifyCurrent = function (t) {\n              var e = this.scene.peek();\n              this.scene.view.updatePie(e), this.chart.notifyChartUpdate(t), this.events.notifySceneChanges({\n                pie: !0\n              });\n            }, e.prototype.expandSlice = function (t, e) {\n              var i = t.pie;\n              if (i !== this.scene.peek()) return this.chart.setSelection([]), this.goBack(e), !0;\n              if (t === i.othersSlice) return this.chart.setSelection([]), this.goOthers(i, e), !0;\n              if (t === i.previousSlice) return this.chart.setSelection([]), this.goPrevious(i, e), !0;\n              var n = t.id;\n              return !(!t.expandable || !this.scene.mainData.canExpand(n) || (this.chart.setSelection([]), this.drillDown(n, e), 0));\n            }, e.prototype.onSceneChange = function (t) {\n              var e = !1,\n                  i = this.scene.peek();\n              if (t.changes.data || t.changes.pieChartPieIds || t.changes.dataArrived) for (var n = t.changes.pieChartPieIds || Object.create(null), r = 0; r < this.scene.stack.length; r++) {\n                var s = this.scene.stack[r];\n\n                if (n[s.id] || !s.data || s === i || t.changes.dataDeep) {\n                  if (s === i) {\n                    var a;\n                    (a = \"forward\" === this.scene.pendingAction ? this.scene.view.scrollForward(s, this.scene.pendingOffset) : \"back\" === this.scene.pendingAction ? this.scene.view.scrollBackward(s, this.scene.pendingOffset) : this.scene.view.updatePie(s)) && (this.scene.pendingAction = null, this.scene.pendingOffset = null), e = a;\n                  } else this.scene.view.updatePie(s);\n\n                  t.changes.pie = !0;\n                }\n              }\n              e && this.chart.notifyChartUpdate(\"data\", !0);\n            }, e;\n          }(h.Navigator);\n\n          t.Navigator = A;\n\n          var M = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.currentSlice = null, i.animationOrder = 500, i.paintOrder = 15, i.updateOrder = 1100, i.activePointer = null, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.events = e.events, i.popup = new h.InfoPopup(e), i;\n            }\n\n            return r(e, t), e.prototype.previewPointerMove = function (t) {\n              if (null === this.activePointer || this.activePointer === t.identifier) {\n                var e = t.y,\n                    i = t.x;\n\n                if (this.options.info.enabled && (!this.chart.legend || !this.chart.legend.containsCoordinate(i, e))) {\n                  var n = this.scene.hoverSlice,\n                      r = this.scene.hoverPie;\n                  r && !n && (n = r.getActiveSlice()), this.setCurrentObject(i, e, n);\n                }\n              }\n            }, e.prototype.previewRightClick = function (t) {\n              t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t));\n            }, e.prototype.previewPointerCancel = function (t) {\n              null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n            }, e.prototype.previewPointerUp = function (t) {\n              null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n            }, e.prototype.previewPointerDown = function (t) {\n              null === this.activePointer && (this.activePointer = t.identifier, this.hide());\n            }, e.prototype.previewPointerDrag = function (t) {\n              null !== this.activePointer && this.activePointer !== t.identifier || this.hide();\n            }, e.prototype.previewPointerOut = function (t) {\n              null !== this.activePointer && this.activePointer !== t.identifier || t.touch || this.hide();\n            }, e.prototype.hide = function () {\n              this.activePointer = null, this.setCurrentObject(0, 0, null);\n            }, e.prototype.setCurrentObject = function (t, e, i) {\n              if (i) {\n                if (i !== this.currentSlice) {\n                  var n = this.buildContents(i);\n                  this.popup.show(t, t, e, n);\n                } else this.popup.updateXY(t, t, e);\n\n                this.currentSlice = i;\n              } else this.currentSlice = null, this.popup.hide();\n            }, e.prototype.buildContents = function (t) {\n              var e = this;\n\n              if (this.options.info.contentsFunction) {\n                return this.options.info.contentsFunction.call(this.chart.api, t.data, t, function (i) {\n                  if (t === e.currentSlice) return e.popup.updateContents(i);\n                });\n              }\n\n              return t.label.text;\n            }, e.prototype.remove = function () {\n              this.popup.remove();\n            }, e;\n          }(h.ChartElement);\n\n          t.InfoPopup = M;\n\n          var I = function () {\n            function t(t) {\n              this.prevTime = 0, this.radiusAnimator = null, this.innerRadiusAnimator = null, this.chart = t, this.scene = t.scene, this.events = t.events;\n            }\n\n            return t.prototype.doAnimations = function (t) {\n              this.prevTime && Math.min(30, t.timeStamp - this.prevTime);\n              var e = this.scene.settings.interaction.animation.scrollDuration,\n                  i = this.scene.settings.interaction.animation.hoverDuration,\n                  n = t.timeStamp,\n                  r = [],\n                  s = [],\n                  a = !1;\n\n              if (this.scene.settings.pie.adaptiveRadius) {\n                this.innerRadiusAnimator || (this.innerRadiusAnimator = new h.Animator(0, this.scene.innerRadius, e, \"<>\", n), this.radiusAnimator = new h.Animator(0, this.scene.radius, e, \"<>\", n));\n                var o = this.radiusAnimator.updateAndGet(this.scene.radius, n);\n                this.scene.currentRadius = o.value;\n                var l = o.changes;\n                o = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, n), this.scene.currentInnerRadius = o.value;\n                var u = o.changes;\n                a = a || l || u, t.animating = t.animating || a;\n              } else this.scene.currentRadius === this.scene.radius && this.scene.currentInnerRadius === this.scene.innerRadius || (a = !0, this.scene.currentRadius = this.scene.radius, this.scene.currentInnerRadius = this.scene.innerRadius);\n\n              for (var c = 0; c < this.scene.pies.length; c++) {\n                var d = this.scene.pies[c],\n                    p = t.changes.bounds || L.needStyleUpdate(t.changes),\n                    f = !1;\n                if (!0 === d.removed && null === d.removeTime && (d.removeTime = n + e), d.removed && (t.animating = !0, f = d.removeTime < n), f) r.push(d);else {\n                  if (d._animatorA0 || (p = !0, d._animatorA0 = new h.Animator(d.currentStartAngle, d.startAngle, e, \"<>\", n), d._animatorA1 = new h.Animator(d.currentEndAngle, d.endAngle, e, \"<>\", n), d._animatorR0 = new h.Animator(d.currentInnerRadius, d.innerRadius, e, \"<>\", n), d._animatorR1 = new h.Animator(d.currentRadius, d.radius, e, \"<>\", n), this.scene.settings.advanced.initialAnimation || (d._animatorA0.jump(d.startAngle), d._animatorA1.jump(d.endAngle), d._animatorR0.jump(d.innerRadius), d._animatorR1.jump(d.radius))), d.rotationSpeed) {\n                    if (null === d.currentStartAngle) d.currentStartAngle = d.startAngle, d.currentEndAngle = d.endAngle;else {\n                      var g = t.dtime * d.rotationSpeed / 1e3;\n                      d.currentStartAngle += g, d.currentEndAngle += g;\n                    }\n                    d.currentlyRotating = !0, p = !0;\n                  } else if (d.currentlyRotating) {\n                    var m = 2 * Math.PI;\n                    d._animatorA0.reset(d.currentStartAngle % m - m, d.startAngle, t.timeStamp), d._animatorA1.reset(d.currentEndAngle % m, d.endAngle, t.timeStamp), d.currentlyRotating = !1, p = !0;\n                  } else {\n                    var v = d._animatorA0.updateAndGet(d.startAngle, n);\n\n                    d.currentStartAngle = v.value, p = p || v.changes;\n\n                    var y = d._animatorA1.updateAndGet(d.endAngle, n);\n\n                    d.currentEndAngle = y.value, p = p || y.changes;\n                  }\n\n                  var S = d._animatorR1.updateAndGet(d.radius, n);\n\n                  d.currentRadius = S.value, p = p || S.changes, S = d._animatorR0.updateAndGet(d.innerRadius, n), d.currentInnerRadius = S.value, p = p || S.changes, d.currentInnerRadius = Math.min(d.currentInnerRadius, d.currentRadius);\n\n                  for (var b = [], C = 0, x = 0; x < d.allSlices.length; x++) {\n                    (T = d.allSlices[x])._animatorF || (p = !0, T._animatorF = new h.Animator(T.currentFraction, T.fraction, e, \"<>\", n));\n\n                    var w = T._animatorF.updateAndGetFixed(T.fraction, n);\n\n                    T.currentFraction = w.value, p = p || w.changes, T.removed && 0 === T.currentFraction && b.push(T), C += T.currentFraction;\n                  }\n\n                  if (Math.abs(C - 1) > .001) {\n                    C = 1 / C;\n\n                    for (x = 0; x < d.allSlices.length; x++) {\n                      (T = d.allSlices[x]).currentFraction *= C;\n                    }\n                  }\n\n                  if (b.length > 0) {\n                    p = !0;\n\n                    for (x = 0; x < b.length; x++) {\n                      var T = b[x];\n                      h.Helpers.removeFromArray(d.slices, T), h.Helpers.removeFromArray(d.allSlices, T), T === d.othersSlice && (d.othersSlice = null), T === d.previousSlice && (d.previousSlice = null);\n                    }\n                  }\n\n                  for (x = 0; x < d.allSlices.length; x++) {\n                    (T = d.allSlices[x])._animatorLineColor || (p = !0, T._animatorLineColor = new h.ColorAnimator(T.currentLineColor, T.targetLineColor, i, \"<>\", n), T._animatorFillColor = new h.ColorAnimator(T.currentFillColor, T.targetFillColor, i, \"<>\", n), T._animatorCutout = new h.Animator(T.currentCutoutDistance, T.cutoutDistance, i, \"<>\", n));\n                    var k = T._animatorLineColor,\n                        A = T._animatorFillColor,\n                        M = T._animatorCutout,\n                        I = k.updateAndGet(T.targetLineColor, n);\n                    if (T.currentLineColor = I.value, p = p || I.changes, I = A.updateAndGet(T.targetFillColor, n), T.currentFillColor = I.value, p = p || I.changes, T.userPlaced) M.jump(T.currentCutoutDistance);else {\n                      o = M.updateAndGet(T.cutoutDistance, n);\n                      T.currentCutoutDistance = o.value, p = p || o.changes;\n                    }\n                  }\n\n                  (p || a) && s.push(d), t.animating = t.animating || p;\n                }\n              }\n\n              for (c = 0; c < r.length; c++) {\n                d = r[c];\n                this.scene.deletePie(d);\n              }\n\n              return this.prevTime = n, s;\n            }, t;\n          }();\n\n          t.Animations = I;\n\n          var P = function () {\n            function t(t, e) {\n              this.view = e, this.chart = t, this.scene = t.scene, this.events = t.events;\n            }\n\n            return t.prototype.placeStack = function (t, e) {\n              var i = this.scene,\n                  n = i.settings,\n                  r = n.pie,\n                  s = i.stack,\n                  a = r.depth,\n                  o = !1,\n                  l = i.height - 2 * a;\n              l = Math.max(2, l);\n              var h = r.x,\n                  u = r.y;\n              null === h ? h = i.x0 + i.width / 2 : h >= 0 && h <= 1 && (h = i.x0 + i.width * h), null === u ? u = i.y0 + l / 2 : u >= 0 && u <= 1 && (u = i.y0 + i.height * u);\n              var c = n.pie.startAngle,\n                  d = n.pie.endAngle,\n                  p = n.pie.rotationSpeed;\n              t.x === h && t.y === u && c === t.startAngle && d === t.endAngle && p === t.rotationSpeed || (o = !0, t.x = h, t.y = u, t.startAngle = c, t.endAngle = d, t.rotationSpeed = p);\n              var f = Math.min(l / 2, i.width / 2);\n              f -= n.pie.outerMargin;\n              var g = n.pie.radius;\n              if (g) g <= 1 && (g *= f);else if (n.labels.enabled && n.pie.adaptiveRadius) {\n                var m = this.computeDesiredRadiusFromLabels(t, e);\n                m = Math.min(f, m), m -= n.labels.connectorLength, g = m = Math.max(m, f / 3);\n              } else g = f;\n              var v = n.pie.innerRadius;\n\n              if (v < 1 && (v *= g), s.length > 1) {\n                var y = n.pie.innerRadiusWhenDrilldown;\n                y < 1 && (y *= g), v = Math.max(v, y);\n              }\n\n              var S = 0,\n                  b = 0;\n              g !== v && (b = -v * (S = 1 / (g - v))), i.radius === g && i.innerRadius === v || (o = !0, i.radius = g, i.innerRadius = v), t.radius = 1, t.innerRadius = v * S + b;\n              var C = s.length - 1;\n\n              if (C > 0) {\n                v -= n.pie.margin;\n\n                for (var x = C, w = Math.max(0, Math.min(g - v, (v - n.pie.centerMargin) / x)), L = C - 1; L >= 0; L--) {\n                  g = v, v -= w, u += a, (t = s[L]).x = h, t.y = u, t.radius = g * S + b, t.innerRadius = (v + n.pie.margin) * S + b, t.brightness = .8 - .8 * (x - L - 1) / x, t.startAngle = n.pie.startAngle, t.endAngle = n.pie.endAngle;\n                }\n              }\n\n              for (C = 0; C < i.pies.length; C++) {\n                if ((t = i.pies[C]).removed && t.parentSlice) {\n                  var T = i.getSliceTargetAngles(t.parentSlice);\n                  t.startAngle = T.a0, t.endAngle = T.a1;\n                }\n              }\n\n              return o;\n            }, t.prototype.computeDesiredRadiusFromLabels = function (t, e) {\n              for (var i = this.scene.settings.slice.style.label, n = new D(e, 1, 0, 100, 0, 100, i, this.scene.settings.labels), r = 2 * i.padding, s = n.lineHeight + r, a = 0, o = 0, l = 0, u = 0, c = 0, d = t.startAngle, p = t.endAngle, f = p - d, g = t.startAngle, m = g, v = 0; v < t.slices.length; v++) {\n                var y = t.slices[v],\n                    S = m;\n                m = g + (c = Math.min(1, c + y.fraction)) * f;\n                var b = Math.max(S, d),\n                    C = Math.min(m, p);\n\n                if (!(b >= p || C <= d) && y.label.text) {\n                  for (var x = \"\", w = 0, L = y.label.text.split(\" \"); w < L.length; w++) {\n                    var T = L[w];\n                    T.length > x.length && (x = T);\n                  }\n\n                  var k = h.Graphics.getTextWidth(e, y.label.textStyle, x) + r,\n                      A = s * (h.Graphics.getTextWidth(e, y.label.textStyle, y.label.text) + r) * 1.2;\n                  ((b + C) / 2 + Math.PI / 2) % (2 * Math.PI) <= Math.PI ? (u += A, o = Math.max(o, k)) : (l += A, a = Math.max(a, k));\n                }\n              }\n\n              h.Graphics.clearShadow(e);\n              var M = Math.min(this.scene.width, this.scene.height),\n                  I = this.scene.width * M,\n                  P = Math.max(1, I - 2 * Math.max(l, u) * 1.2),\n                  N = Math.sqrt(P / Math.PI),\n                  F = Math.max(a, o),\n                  O = this.scene.width / 2 - 1.1 * F;\n              return Math.min(N, O);\n            }, t.prototype.placeLabels = function (t, e) {\n              if (this.chart.assetsLoaded) {\n                var i = this.scene.settings.icons,\n                    n = this.scene.settings.labels,\n                    r = this.scene.settings.slice,\n                    s = n.enabled,\n                    a = i.sizeExtent[0],\n                    o = i.sizeExtent[1],\n                    l = i.placement,\n                    u = i.autohideWhenTooSmall;\n                this.scene.settings.advanced.iconMinSize && (a = this.scene.settings.advanced.iconMinSize);\n\n                for (var c = r.margin, d = t.x, f = t.y, g = this.scene.currentInnerRadius, m = this.scene.currentRadius - g, v = t.currentInnerRadius * m + g, y = t.currentRadius * m + g, S = 0, b = t.currentStartAngle, C = t.currentEndAngle, x = C - b, w = t.currentStartAngle, L = this.scene.x0 - d, T = L + this.scene.width, k = this.scene.y0 - f, A = k + this.scene.height, M = new D(e, y, L, T, k, A, r.style.insideLabel, this.scene.settings.labels), I = new D(e, y, L, T, k, A, r.style.label, this.scene.settings.labels), P = [], N = [], F = w, O = 0; O < t.allSlices.length; O++) {\n                  var E = t.allSlices[O],\n                      R = F;\n                  F = w + (S = Math.min(1, S + E.currentFraction)) * x;\n                  var H = Math.max(R, b),\n                      B = Math.min(F, C),\n                      z = v + E.currentCutoutDistance,\n                      U = y + E.currentCutoutDistance,\n                      G = (H + B) / 2;\n                  if (E.removed || t.background) E.currentLabel = null, E.currentInsideLabel = null;else {\n                    if (E.insideLabel.text && s) {\n                      var j = E.insideLabel.text,\n                          W = void 0;\n                      W = E.currentInsideLabel ? E.currentInsideLabel : E.currentInsideLabel = new h.Label(E.insideLabel, !0), E.currentInsideLabel.text !== j && (W.text = j);\n                      var V = M.fitLabelInSlice(e, W, z, U, H, B);\n                      W.shouldBeVisible = W.visible = \"always\" === n.insideLabel || V >= n.insideLabelVisibilityFraction;\n                    } else E.currentInsideLabel = null;\n\n                    var Z = E.label.text && s ? E.label.text : \"\";\n\n                    if (\"append\" === n.insideLabel && E.insideLabel.text && s && !E.currentInsideLabel.userPlaced && !E.currentInsideLabel.shouldBeVisible && (Z ? Z = (d = Math.cos(G)) > 0 ? E.insideLabel.text + \", \" + Z : Z + \", \" + E.insideLabel.text : Z = E.insideLabel.text), Z) {\n                      W = null;\n                      W = E.currentLabel ? E.currentLabel : E.currentLabel = new h.Label(E.label, !0), E.currentLabel.text !== Z && (W.text = Z), W.userPlaced || I.placeOutsideLabelInitial(W, G), W.x > 0 ? (W.style.align = \"left\", N.push(W)) : (W.style.align = \"right\", P.push(W));\n                    } else E.currentLabel = null;\n                  }\n                  var Y = null;\n\n                  if (E.icon && (!t.background || E.id === t.activeSliceId)) {\n                    var q = M.fitBoxInSlice(1, 1, z, U, H, B);\n                    d = q.x, f = q.y;\n                    var _ = q.prop;\n                    _ -= c, (!u || 2 * _ >= a) && (_ = Math.max(Math.min(_, o / 2), a / 2), (Y = new p()).hwidth = _, Y.hheight = _, Y.inside = !0, E.iconOffset ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, E.iconOffset, z, U, H, B)) : \"center\" === l ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, [0, 0, 0, 0], z, U, H, B)) : (Y.x = d, Y.y = f));\n                  }\n\n                  E.currentIcon = Y;\n                }\n\n                I.computeOutsideLabelLocations(e, P, N);\n              }\n            }, t.prototype.applyOffset = function (t, e, i, n, r, s) {\n              var a = 0,\n                  o = 0;\n              e.length >= 2 && (a = e[0], o = e[1]);\n              var l = 0,\n                  h = 0;\n              e.length >= 4 && (l = e[2], h = e[3]);\n              var u = i + (n - i) * (l + 1) / 2,\n                  c = r + (s - r) * (h + 1) / 2;\n              a += Math.cos(c) * u, o += Math.sin(c) * u, t.x += a, t.y += o;\n            }, t;\n          }();\n\n          t.PieLayout = P;\n\n          var D = function (t) {\n            function e(e, i, n, r, s, a, o, l) {\n              var u = t.call(this) || this;\n              return u.config = l, u.bottom = a, u.top = s, u.right = r, u.left = n, u.margin = o.margin || 0, u.rr = i + l.connectorLength, u.lineHeight = h.Graphics.getTextHeight(e, o.textStyle.font), u.interLabelSpacing = Math.max(l.interLabelSpacing * u.lineHeight, u.margin), u;\n            }\n\n            return r(e, t), e.prototype.placeOutsideLabelInitial = function (t, e) {\n              var i = this.rr * Math.cos(e),\n                  n = this.rr * Math.sin(e),\n                  r = 1;\n              n < this.top && (r = Math.min(r, this.top / n)), n > this.bottom && (r = Math.min(r, this.bottom / n)), i < this.left && (r = Math.min(r, this.left / i)), i > this.right && (r = Math.min(r, this.right / i)), t.x = i * r, t.y = n * r;\n            }, e.prototype.computeOutsideLabelLocations = function (t, e, i) {\n              var n = this.bottom - this.margin,\n                  r = this.top + this.margin,\n                  s = this.interLabelSpacing;\n              e.sort(function (t, e) {\n                return e.y - t.y;\n              }), i.sort(function (t, e) {\n                return t.y - e.y;\n              });\n\n              for (var a = 0; a < e.length; a++) {\n                (b = e[a]).originX = b.x;\n              }\n\n              for (a = 0; a < i.length; a++) {\n                (b = i[a]).originX = b.x;\n              }\n\n              for (var o = \"wrap\" === this.config.placement ? [!1] : [!0, !1], l = 0; l < o.length; l++) {\n                for (var h = o[l], u = 100, c = !1, d = 0; d < 2; d++) {\n                  var p = 0 === d ? e : i;\n\n                  for (a = 0; a < p.length; a++) {\n                    (b = p[a]).prop = this.fitLabelOutside(t, b, h);\n                  }\n\n                  var f = n - r,\n                      g = [],\n                      m = 0;\n\n                  for (a = 0; a < p.length; a++) {\n                    if ((b = p[a]).visible) {\n                      var v = 2 * b.hheight + s;\n                      m + v < f ? (g.push(b), m += v) : (b.visible = b.userPlaced, u = .5);\n                    }\n                  }\n\n                  var y = n,\n                      S = r;\n                  p === e ? S += m : y -= m;\n\n                  for (a = 0; a < g.length; a++) {\n                    var b = g[a];\n\n                    if (p === e ? S -= 2 * b.hheight + s : y += 2 * b.hheight + s, !b.userPlaced && (b.y + b.hheight > y || b.y - b.hheight < S)) {\n                      b.y = Math.min(Math.max(b.y, S + b.hheight), y - b.hheight);\n                      var C = this.fitLabelOutside(t, b, h);\n                      u = Math.min(C, u), c = c || b.rows && b.rows.subLines[b.rows.subLines.length - 1].row > 0;\n                    } else u = Math.min(u, b.prop);\n\n                    p === e ? y = b.y - b.hheight - s : S = b.y + b.hheight + s;\n                  }\n                }\n\n                if (u >= 1 || !c) break;\n              }\n            }, e.prototype.fitLabelOutside = function (t, e, i) {\n              var n = this;\n              void 0 === i && (i = !1), null == i && (i = !1);\n              return this.fitLabelInRect(t, e, function (t) {\n                return e.userPlaced ? n.getOutsideMaxWidth(e.x, e.y, t, !1) : n.placeOutsideMaxWidth(e.originX, e.y, t, i);\n              });\n            }, e.prototype.fitLabelInSlice = function (t, e, i, n, r, s) {\n              var a,\n                  o,\n                  l,\n                  h = this,\n                  u = Math.cos(r),\n                  c = Math.cos(s),\n                  d = Math.min(u, c),\n                  p = Math.max(u, c);\n              if (a = d < 0 && p < 0 || -d > 2 * p ? \"right\" : d > 0 && p > 0 || 2 * -d < p ? \"left\" : \"center\", e.userPlaced) o = e.x, l = e.y;else {\n                var f = i + (n - i) * (2 * i >= n ? .5 : .5 + (n - 2 * i) / n / 4),\n                    g = (r + s) / 2;\n                o = f * Math.cos(g), l = f * Math.sin(g);\n              }\n              var m = l - this.rayIntersectsSlice(o, l, 0, -1, i, n, r, s),\n                  v = l + this.rayIntersectsSlice(o, l, 0, 1, i, n, r, s);\n              return this.fitLabelInLines(t, e, o, l, \"center\", a, function (t, e) {\n                return !(n > 0) || e <= m || e >= v ? [1e-5, 1e-5] : [h.rayIntersectsSlice(t, e, -1, 0, i, n, r, s), h.rayIntersectsSlice(t, e, 1, 0, i, n, r, s)];\n              });\n            }, e.prototype.placeOutsideMaxWidth = function (t, e, i, n) {\n              var r,\n                  s = this.rr,\n                  a = e - i / 2,\n                  o = a + i;\n              a < this.top && (a += r = this.top - a, o += r);\n              o > this.bottom && (a += r = this.bottom - o, o += r);\n              var l,\n                  h = this.left,\n                  u = this.right;\n              return l = n ? s : a > s || o < -s ? 0 : a > 0 ? Math.sqrt(s * s - a * a) : o < 0 ? Math.sqrt(s * s - o * o) : s, t > 0 ? h = Math.max(l, t) : u = Math.min(t, -l), {\n                x: (h + u) / 2,\n                y: (a + o) / 2,\n                dx: 1,\n                dy: 0,\n                width: u - h\n              };\n            }, e.prototype.getOutsideMaxWidth = function (t, e, i, n) {\n              var r,\n                  s = e - i / 2,\n                  a = s + i,\n                  o = this.left,\n                  l = this.right,\n                  h = this.rr;\n              return r = n ? h : s > h || a < -h ? 0 : s > 0 ? Math.sqrt(h * h - s * s) : a < 0 ? Math.sqrt(h * h - a * a) : h, t > 0 ? o = r : l = -r, {\n                x: t,\n                y: e,\n                dx: 1,\n                dy: 0,\n                width: 2 * Math.min(Math.abs(t - o), Math.abs(t - l))\n              };\n            }, e.prototype.fitBoxInSlice = function (t, e, i, n, r, s) {\n              var a = i + (n - i) * (.5 + (n - i) / n / 4),\n                  o = (r + s) / 2,\n                  l = a * Math.cos(o),\n                  h = a * Math.sin(o),\n                  u = t,\n                  c = e,\n                  d = this.rayIntersectsSlice(l, h, u, c, i, n, r, s),\n                  p = this.rayIntersectsSlice(l, h, -u, c, i, n, r, s),\n                  f = this.rayIntersectsSlice(l, h, -u, -c, i, n, r, s),\n                  g = this.rayIntersectsSlice(l, h, u, -c, i, n, r, s);\n              return {\n                x: l,\n                y: h,\n                prop: Math.min(d, p, f, g)\n              };\n            }, e.prototype.rayIntersectsSlice = function (t, e, i, n, r, s, a, o) {\n              var l = h.Geometry.rayIntersectsCircle(t, e, i, n, r);\n              l = Math.min(l, h.Geometry.rayIntersectsCircle(t, e, i, n, s));\n              var u = Math.cos(a),\n                  c = Math.sin(a);\n              return l = Math.min(l, h.Geometry.rayIntersectsSegment(t, e, i, n, r * u, r * c, s * u, s * c)), u = Math.cos(o), c = Math.sin(o), Math.min(l, h.Geometry.rayIntersectsSegment(t, e, i, n, r * u, r * c, s * u, s * c));\n            }, e;\n          }(h.LabelLayoutBase);\n\n          t.LabelLayout = D, function (t) {\n            var e = function () {\n              function t(t) {\n                this.renderer = t, this.settings = this.renderer.settings;\n              }\n\n              return t.prototype.paintPie = function (t, e, i, n, r, s, a, o) {\n                o.fillColor && (t.beginPath(), t.arc(e, i, r, s, a, !1), t.arc(e, i, n, a, s, !0), t.closePath(), h.Graphics.fill(t, o));\n              }, t.prototype.paintExpandableHilights = function (t, e, i, n) {\n                var r = this.settings.slice.expandableMarkStyle.distance,\n                    s = this.settings.slice.expandableMarkStyle;\n                if (!(s.lineWidth <= 0)) for (var a = 0; a < n.length; a++) {\n                  var o = n[a];\n\n                  if (o.expandable) {\n                    var l = o._renderParams,\n                        u = e + o.x,\n                        c = i + o.y,\n                        d = l[0],\n                        p = l[1],\n                        f = Math.max((d + p) / 2, p - r),\n                        g = l[2],\n                        m = l[3];\n                    t.beginPath(), t.arc(u, c, f, g, m), h.Graphics.paint(t, s);\n                  }\n                }\n              }, t.prototype.strokeSlice = function (t, e, i, n) {\n                var r = n._renderParams;\n                e += n.x, i += n.y;\n                var s = r[0],\n                    a = r[1],\n                    o = r[2],\n                    l = r[3],\n                    h = r[4],\n                    u = r[5],\n                    c = a * Math.abs(l - o),\n                    d = a - s,\n                    p = Math.min(.1 * Math.min(c, d), 3);\n                s + a === -2 && (s = 0, a = 0), t.beginPath(), \"zigzag\" === n.lineDecoration ? this.strokeZigZag(t, e, i, a, p, o, l) : t.arc(e, i, a, o, l, !1), h === u ? t.lineTo(e + Math.cos(u) * s, i + Math.sin(h) * s) : t.arc(e, i, s, u, h, !0), t.closePath();\n              }, t.prototype.strokeZigZag = function (t, e, i, n, r, s, a) {\n                var o = 5 / n,\n                    l = s;\n\n                for (t.moveTo(e + n * Math.cos(s), i + n * Math.sin(s)); l + o < a;) {\n                  l += o, t.lineTo(e + (n + r) * Math.cos(l), i + (n + r) * Math.sin(l)), r = -r;\n                }\n\n                t.lineTo(e + n * Math.cos(a), i + n * Math.sin(a));\n              }, t.prototype.strokeAndPaint = function (t, e, i, n) {\n                var r = h.Graphics.beginStrokeAndFill(t, n);\n\n                if (this.strokeSlice(r, e, i, n), n.fillGradient) {\n                  for (var s = t.createRadialGradient(e, i, n._renderParams[0], e, i, n._renderParams[1]), a = 0; a < n.fillGradient.length; a++) {\n                    var o = n.fillGradient[a];\n                    s.addColorStop(o[0], o[1]);\n                  }\n\n                  n.fillColor = s;\n                }\n\n                h.Graphics.endStrokeAndFill(t, r, n);\n              }, t;\n            }();\n\n            t.CommonBase = e;\n\n            var i = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n                for (var r = 0; r < n.length; r++) {\n                  var s = n[r];\n                  this.strokeAndPaint(t, e, i, s);\n                }\n              }, e;\n            }(e);\n\n            t.Flat = i;\n\n            var n = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.paintPie = function (e, i, n, r, s, a, o, l) {\n                t.prototype.paintPie.call(this, e, i, n, r, s, a, o, l);\n                var h = this.settings.pie.depth;\n\n                if (h > 0 && l.allSlices.length > 0) {\n                  e.fillStyle = \"rgba(0,0,0,0.05)\";\n\n                  for (var u = 0; u < [5, 10, 18].length; u++) {\n                    var c = [5, 10, 18][u];\n                    e.beginPath(), e.arc(i, n + c + h, s, a, o, !1), e.arc(i, n + c + h, r, o, a, !0), e.closePath(), e.fill();\n                  }\n                }\n              }, e.prototype.paintSlices = function (t, e, i, n) {\n                var r = this.settings.pie.depth,\n                    s = 2 * this.settings.advanced.renderQuality,\n                    a = 1 / s,\n                    o = r * s;\n                t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 1.5 * r, t.shadowColor = \"black\", t.fillStyle = \"black\";\n\n                for (var l = 0; l < n.length; l++) {\n                  var u = n[l];\n                  this.strokeSlice(t, e, i + r, u), t.fill();\n                }\n\n                t.shadowColor = null, t.shadowBlur = 0, t.lineWidth = 1;\n\n                for (var c = 0; c <= o; c++) {\n                  for (l = 0; l < n.length; l++) {\n                    (u = n[l]).fillColor instanceof CanvasGradient ? h.Helpers.error(\"slice.fillColor cannot be gradient if `can` renderer is used\") : (this.strokeSlice(t, e, i + r - c * a, u), t.strokeStyle = c >= o - 1 ? h.Colors.derive(u.fillColor, 1.35, 1) : h.Colors.derive(u.fillColor, .5 + c / o * .2, 1), t.stroke());\n                  }\n                }\n\n                var d = Math.PI;\n                t.shadowBlur = r, t.shadowColor = \"rgba(0,0,0,0.1)\", t.fillStyle = \"black\";\n\n                for (l = 0; l < n.length; l++) {\n                  var p = (u = n[l])._renderParams,\n                      f = p[4],\n                      g = p[5];\n\n                  if (f !== g) {\n                    for (; f > d;) {\n                      f -= 2 * d, g -= 2 * d;\n                    }\n\n                    f < 0 ? g > 0 && (g = Math.min(g, d), this.strokeInnerShadowSlice(t, e, i, u, 0, g) && t.fill()) : g < d ? this.strokeInnerShadowSlice(t, e, i, u, f, g) && t.fill() : (f < d && this.strokeInnerShadowSlice(t, e, i, u, f, d) && t.fill(), g > 2 * d && this.strokeInnerShadowSlice(t, e, i, u, 2 * d, g) && t.fill());\n                  }\n                }\n\n                for (l = 0; l < n.length; l++) {\n                  u = n[l];\n                  this.strokeAndPaint(t, e, i, u);\n                }\n              }, e.prototype.strokeInnerShadowSlice = function (t, e, i, n, r, s) {\n                var a = n._renderParams,\n                    o = a[0] + 1,\n                    l = Math.min(a[1] - 1, o + 10);\n                return !(o >= a[1] || l <= a[0]) && ((r += 1 / o) >= (s -= 1 / o) ? void 0 : (t.beginPath(), t.arc(e, i, l, r, s, !1), t.arc(e, i, o, s, r, !0), t.closePath(), !0));\n              }, e;\n            }(e);\n\n            t.Can = n;\n\n            var s = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n                this.g = t;\n\n                for (var r = 0; r < n.length; r++) {\n                  var s = n[r];\n                  this.strokeAndPaint(t, e, i, s), this.elegantGradient(e, i, s);\n                }\n              }, e.prototype.getRadialGradient = function (t, e, i, n, r, s, a) {\n                var o = Math.abs(Math.sin(a)),\n                    l = this.g.createRadialGradient(t, e, i, n, r, s);\n                return this.addColorStops(l, o, a), l;\n              }, e.prototype.getLinearGradient = function (t, e, i, n, r, s, a, o) {\n                var l = a - n,\n                    h = Math.sin(o),\n                    u = Math.cos(o),\n                    c = e + u * n,\n                    d = i + h * n,\n                    p = c + u * l,\n                    f = d + h * l,\n                    g = Math.abs(h),\n                    m = this.g.createLinearGradient(c, d, p, f);\n                return this.addColorStops(m, g, o), m;\n              }, e.prototype.addColorStops = function (t, e, i) {\n                var n = \"0,0,0\",\n                    r = \"255,255,255\",\n                    s = r,\n                    a = n;\n                (i <= 0 || i > Math.PI) && (s = n, a = r);\n                var o = .4 * e,\n                    l = .2 * e,\n                    h = .1 * e,\n                    u = .3 * e,\n                    c = .5 * e;\n                t.addColorStop(0, \"rgba(\" + s + \",\" + o.toFixed(3) + \")\"), t.addColorStop(.1, \"rgba(\" + s + \",\" + l.toFixed(3) + \")\"), t.addColorStop(.1, \"rgba(\" + s + \",\" + h.toFixed(3) + \")\"), t.addColorStop(.4, \"rgba(0,0,0,0.1)\"), t.addColorStop(.9, \"rgba(\" + a + \",\" + h.toFixed(3) + \")\"), t.addColorStop(.95, \"rgba(\" + a + \",\" + u.toFixed(3) + \")\"), t.addColorStop(1, \"rgba(\" + a + \",\" + c.toFixed(3) + \")\");\n              }, e.prototype.elegantGradient = function (t, e, i) {\n                for (var n = i._renderParams[0], r = i._renderParams[1], s = i._renderParams[2], a = i._renderParams[3], o = this.settings.advanced.renderQuality, l = Math.PI / Math.max(1, 180 * o), u = s; u < a;) {\n                  var c = Math.min(u + l, a);\n                  this.g.beginPath(), this.g.arc(t, e, r, u, c), this.g.arc(t, e, n, c, u, !0), this.g.closePath(), h.Graphics.paint(this.g, {\n                    fillColor: this.getRadialGradient(t, e, n, t, e, r, u)\n                  }), u = c;\n                }\n              }, e;\n            }(e);\n\n            t.Smoothy = s;\n\n            var a = function (t) {\n              function e() {\n                return t.apply(this, arguments) || this;\n              }\n\n              return r(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n                this.g = t;\n\n                for (var r = 0; r < n.length; r++) {\n                  var s = n[r];\n                  this.strokeAndPaint(t, e, i, s), this.smartGradient(e, i, s);\n                }\n              }, e.prototype.getSmartGradient = function (t, e, i, n, r, s) {\n                var a,\n                    o,\n                    l = 0,\n                    h = 0;\n                \"inside\" === r ? \"top\" === s ? (l = n - i, h = e, a = \"rgba(0,0,0,0.3)\", o = \"rgba(0,0,0,0)\") : (l = e, h = e + i, a = \"rgba(255,255,255,0)\", o = \"rgba(255,255,255,0.3)\") : \"top\" === s ? (h = e, a = \"rgba(255,255,255,0.3)\", o = \"rgba(255,255,255,0)\") : (l = e, h = e + n, a = \"rgba(0,0,0,0)\", o = \"rgba(0,0,0,0.3)\");\n\n                try {\n                  var u = this.g.createLinearGradient(0, l, 0, h);\n                  return u.addColorStop(0, a), u.addColorStop(1, o), u;\n                } catch (t) {\n                  throw \"Could not create linear gradient: \" + t;\n                }\n              }, e.prototype.smartOuterShineTop = function (t, e, i, n, r, s, a, o) {\n                if (!(r > 0 && s < Math.PI)) {\n                  s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);\n                  var l = {\n                    _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],\n                    x: 0,\n                    y: 0,\n                    fillColor: this.getSmartGradient(t, e, i, n, \"outside\", \"top\")\n                  };\n                  this.strokeAndPaint(this.g, t, e, l);\n                }\n              }, e.prototype.smartOuterShineBottom = function (t, e, i, n, r, s, a, o) {\n                if (!(s < 0 || r > Math.PI)) {\n                  r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);\n                  var l = {\n                    _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],\n                    x: 0,\n                    y: 0,\n                    fillColor: this.getSmartGradient(t, e, i, n, \"outside\", \"bottom\")\n                  };\n                  this.strokeAndPaint(this.g, t, e, l);\n                }\n              }, e.prototype.smartInnerShineTop = function (t, e, i, n, r, s, a, o) {\n                if (!(r > 0 && s < Math.PI)) {\n                  s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);\n                  var l = {\n                    _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],\n                    x: 0,\n                    y: 0,\n                    fillColor: this.getSmartGradient(t, e, i, n, \"inside\", \"top\")\n                  };\n                  this.strokeAndPaint(this.g, t, e, l);\n                }\n              }, e.prototype.smartInnerShineBottom = function (t, e, i, n, r, s, a, o) {\n                if (!(s < 0 || r > Math.PI)) {\n                  r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);\n                  var l = {\n                    _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],\n                    x: 0,\n                    y: 0,\n                    fillColor: this.getSmartGradient(t, e, i, n, \"inside\", \"bottom\")\n                  };\n                  this.strokeAndPaint(this.g, t, e, l);\n                }\n              }, e.prototype.smartGradient = function (t, e, i) {\n                t += i.x, e += i.y;\n                var n = i._renderParams[0],\n                    r = i._renderParams[1],\n                    s = i._renderParams[2],\n                    a = i._renderParams[3],\n                    o = i._renderParams[4],\n                    l = i._renderParams[5];\n                this.smartOuterShineTop(t, e, n, r, s, a, o, l), this.smartOuterShineBottom(t, e, n, r, s, a, o, l), this.smartInnerShineTop(t, e, n, r, s, a, o, l), this.smartInnerShineBottom(t, e, n, r, s, a, o, l);\n              }, e;\n            }(e);\n\n            t.Bevel = a;\n          }(t.Renderers || (t.Renderers = {}));\n\n          var N = function () {\n            function t(t) {\n              this.renderer = null, this.chart = t, this.settings = t.settings, this.scene = t.scene;\n            }\n\n            return t.prototype.onSceneChange = function (t) {\n              t.changes.settings && this.buildSeries();\n            }, t.prototype.buildSeries = function () {\n              var t = this.settings.pie.theme,\n                  e = t.charAt(0).toUpperCase() + t.slice(1);\n\n              try {\n                this.renderer = new n.PieChart.Renderers[e](this);\n              } catch (e) {\n                throw \"Renderer \" + t + \" is not available: \" + e;\n              }\n            }, t.prototype.paintScene = function (t) {\n              for (var e = t.context, i = t.labelRenderer, n = t.isExport ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies, r = !1, s = 0; s < this.scene.pies.length; s++) {\n                var a = this.scene.pies[s];\n                !n && a.background || this.paintPie(e, i, a), r = r || a.background;\n              }\n\n              !t.isExport && (this.scene.hoverBack || this.scene.settings.advanced.backAlwaysVisible && r) && this.paintBackArrow(t);\n            }, t.prototype.paintBackArrow = function (t) {\n              var e = this.scene.assetsLoader.getAssetImage(this.scene.settings.advanced.backImage);\n\n              if (e) {\n                var i = this.scene.pies[this.scene.pies.length - 1],\n                    n = i.x,\n                    r = i.y,\n                    s = this.settings.pie.depth;\n                r += (this.scene.pies.length - 1) * s;\n                var a = e.width / 2,\n                    o = e.height / 2,\n                    l = .707106781186547 * i.innerRadius,\n                    u = Math.min(a, Math.max(l, a / 2)) / a,\n                    c = Math.min(o, Math.max(l, o / 2)) / o,\n                    d = Math.min(u, c),\n                    p = t.context;\n\n                if (this.settings.advanced.backImageBackground) {\n                  var f = this.settings.slice.margin,\n                      g = this.scene.currentInnerRadius,\n                      m = this.scene.currentRadius - g,\n                      v = Math.max(this.scene.pies[0].currentInnerRadius * m + g, f / 2);\n                  p.beginPath(), p.arc(n, r, v, 0, 2 * Math.PI), p.closePath(), p.fillStyle = this.settings.advanced.backImageBackground, p.fill();\n                }\n\n                p.globalAlpha = .5, h.Graphics.drawImageHighQuality(p, e, n - a * d, r - o * d, 2 * a * d, 2 * o * d), p.globalAlpha = 1;\n              }\n            }, t.prototype.paintPie = function (t, e, i) {\n              var n = this.settings.slice.margin;\n              i.allSlices.length < 2 && (n = 0);\n              var r = this.scene.currentInnerRadius,\n                  s = this.scene.currentRadius - r,\n                  a = Math.max(i.currentInnerRadius * s + r, n / 2),\n                  o = i.currentRadius * s + r,\n                  l = i.currentStartAngle,\n                  u = i.currentEndAngle,\n                  c = u - l,\n                  d = l;\n\n              if (o > 0 && c > 0) {\n                for (var p = n / 2 * (a > 0 ? 1 / a : 0), f = n / 2 * (1 / o), g = [], m = 0; m < i.allSlices.length; m++) {\n                  var v = (H = i.allSlices[m]).currentFraction * c;\n\n                  if (!(H.currentFraction <= 0)) {\n                    var y = d;\n                    d += v;\n                    var S = a + H.currentCutoutDistance,\n                        b = o + H.currentCutoutDistance,\n                        C = void 0,\n                        x = void 0;\n\n                    if (v <= 4 * f) {\n                      var w = (y + d) / 2,\n                          L = v / 4;\n                      C = w - L, x = w + L;\n                    } else C = y + f, x = d - f;\n\n                    var T = y + p,\n                        k = d - p;\n                    T > k && (T = k = (T + k) / 2), x < l || C > u || (C = Math.max(C, l), x = Math.min(x, u), (T = Math.max(T, l)) > (k = Math.min(k, u)) && (T = k = (T + k) / 2), H._renderParams = [S, b, C, x, T, k, H.fillColor, H.lineColor], H.fillColor = H.currentFillColor, H.lineColor = H.currentLineColor, g.push(H));\n                  }\n                }\n\n                var A = i.x,\n                    M = i.y;\n                this.renderer.paintPie(t, A, M, a, o, i.currentStartAngle, i.currentEndAngle, i), this.renderer.paintSlices(t, A, M, g), i === this.scene.peek() && this.renderer.paintExpandableHilights(t, A, M, g);\n\n                for (var I = 0; I < g.length; I++) {\n                  var P = g[I];\n                  P.fillColor = P._renderParams[6], P.lineColor = P._renderParams[7];\n                }\n\n                if (!i.removed) {\n                  h.Graphics.clearShadow(t);\n\n                  for (m = 0; m < i.allSlices.length; m++) {\n                    if ((H = i.allSlices[m]).currentIcon) {\n                      var D = this.scene.assetsLoader.getAssetImage(H.icon);\n\n                      if (D) {\n                        var N = H.currentIcon,\n                            F = A + N.x,\n                            O = M + N.y,\n                            E = Math.min(D.width / 2, N.hwidth),\n                            R = Math.min(D.height / 2, N.hheight);\n                        h.Graphics.drawImageHighQuality(t, D, F - E, O - R, 2 * E, 2 * R);\n                      }\n                    }\n                  }\n\n                  d = l;\n\n                  for (m = 0; m < i.allSlices.length; m++) {\n                    var H;\n                    d = (y = d) + (v = (H = i.allSlices[m]).currentFraction * c);\n                    var B = (Math.max(y, l) + Math.min(d, u)) / 2,\n                        z = H === this.scene.hoverSlice,\n                        U = o + H.currentCutoutDistance;\n                    H.currentInsideLabel && H.currentInsideLabel.visible && this.paintLabel(t, e, A, M, U, B, H.currentInsideLabel, z), H.currentLabel && H.currentLabel.visible && this.paintLabel(t, e, A, M, U, B, H.currentLabel, z);\n                  }\n                }\n              }\n            }, t.prototype.paintLabel = function (t, e, i, n, r, s, a, o) {\n              var l,\n                  u,\n                  c = this.scene.y0 + 3,\n                  d = c + this.scene.height - 6,\n                  p = this.settings.labels,\n                  f = a.x,\n                  g = a.y,\n                  m = a.hwidth,\n                  v = r + p.connectorLength;\n\n              if (f < 0 ? (l = f + m, u = g) : f >= 0 && (l = f - m, u = g), p.connectors && l * l + u * u > r * r) {\n                var y = Math.sin(s),\n                    S = Math.cos(s);\n                t.beginPath();\n                var b = i + r * S,\n                    C = n + r * y;\n                t.moveTo(b, C);\n                var x = i + v * S,\n                    w = n + v * y;\n                w = Math.min(Math.max(w, c), d), l += i, u += n, u = Math.min(Math.max(u, c), d);\n                var L = (r + v) / 2,\n                    T = h.Geometry.rayIntersectsCircle(l - i, u - n, b - l, C - u, r),\n                    k = h.Geometry.lineTouchingCircle(l - i, u - n, x - i, w - n, v);\n\n                if (T < .9 && k) {\n                  for (var A = k.x, M = k.y, I = Math.atan2(M, A); I - s > Math.PI;) {\n                    I -= 2 * Math.PI;\n                  }\n\n                  for (; I - s < -Math.PI;) {\n                    I += 2 * Math.PI;\n                  }\n\n                  var P = I - s;\n                  A += i, M += n, x = i + L * S, w = n + L * y, w = Math.min(Math.max(w, c), d);\n                  var D = i + L * Math.cos(s + .2 * P),\n                      N = n + L * Math.sin(s + .2 * P);\n                  N = Math.min(Math.max(N, c), d), t.quadraticCurveTo(x, w, D, N);\n                  var F = i + v * Math.cos(I),\n                      O = n + v * Math.sin(I);\n                  O = Math.min(Math.max(O, c), d), h.Graphics.arcBetweenTwoPoints(t, i, n, L, D, N, F, O), t.lineTo(l, u);\n                } else t.quadraticCurveTo(x, w, l, u);\n\n                var E = this.settings.slice.connectorStyle,\n                    R = E.lineWidth;\n                o && (E.lineWidth += 2), h.Graphics.stroke(t, E), E.lineWidth = R;\n              }\n\n              e.paint(t, i + a.x, n + a.y, 1, a), h.Graphics.clearShadow(t);\n            }, t;\n          }();\n\n          t.PieRenderer = N;\n\n          var F = function () {\n            function t(t) {\n              this.chart = t, this.scene = t.scene;\n            }\n\n            return t.prototype.updatePie = function (t, e) {\n              var i = this.getPieData(t);\n              this.rectifyScrollOffsets(t, i);\n              var n = this.getForwardCount(t.id, i, t.offset),\n                  r = n.numberOfSlices,\n                  s = n.isReady;\n\n              if (t.data = i, t.loading = !s, s) {\n                var a = this.buildSlices(t, t.offset, r),\n                    o = a.slices,\n                    l = a.othersSlice,\n                    h = a.previousSlice;\n                this.applyNewSlices(t, o, l, h, e);\n              }\n\n              return s;\n            }, t.prototype.scrollForward = function (t, e) {\n              var i = this.getPieData(t);\n              t.data = i;\n              var n,\n                  r,\n                  s = !0;\n              null !== e && void 0 !== e || (n = (r = this.getForwardCount(t.id, i, t.offset)).numberOfSlices, s = r.isReady, e = t.offset + n);\n              s && (n = (r = this.getForwardCount(t.id, i, e)).numberOfSlices, s = r.isReady);\n\n              if (s) {\n                var a = this.buildSlices(t, e, n),\n                    o = a.slices,\n                    l = a.othersSlice,\n                    h = a.previousSlice;\n\n                if (t.othersSlice) {\n                  var u = Math.min(o.length, Math.max(0, t.offset + t.count - e));\n                  this.fitSlicesInOrigin(t.othersSlice, o.slice(u), l), l || ((l = t.othersSlice).fraction = 0, l.currentFraction = 0, l.removed = !0);\n                }\n\n                return t.offset = e, this.applyNewSlices(t, o, l, h), t.loading = !1, !0;\n              }\n\n              return t.loading = !0, !1;\n            }, t.prototype.scrollBackward = function (t, e) {\n              var i = this.getPieData(t);\n              t.data = i;\n              var n = !0,\n                  r = 0;\n\n              if (i && i.done && t.offset > i.offset + i.values.length && (t.offset = i.offset + i.values.length), null == e) {\n                var s = this.getBackOffset(t.id, i, t.offset);\n                if (e = s.newOffset, n = s.isReady) do {\n                  e += r, r = (a = this.getForwardCount(t.id, i, e)).numberOfSlices, n = a.isReady;\n                } while (n && e + r < t.offset);\n              } else {\n                var a;\n                r = (a = this.getForwardCount(t.id, i, e)).numberOfSlices, n = a.isReady;\n              }\n\n              if (n) {\n                var o = this.buildSlices(t, e, r),\n                    l = o.slices,\n                    h = o.othersSlice,\n                    u = o.previousSlice;\n\n                if (t.previousSlice) {\n                  var c = Math.min(l.length, Math.max(0, t.offset - e));\n                  this.fitSlicesInOrigin(t.previousSlice, l.slice(0, c), u), u || ((u = t.previousSlice).fraction = 0, u.currentFraction = 0, u.removed = !0);\n                }\n\n                return t.offset = e, this.applyNewSlices(t, l, h, u), t.loading = !1, !0;\n              }\n\n              return t.loading = !0, !1;\n            }, t.prototype.fitSlicesInOrigin = function (t, e, i) {\n              for (var n = Math.max(1e-6, t.currentFraction), r = 0, s = 0; s < e.length; s++) {\n                r += (o = e[s]).fraction;\n              }\n\n              i && (r += i.fraction);\n              var a = n / r;\n\n              for (s = 0; s < e.length; s++) {\n                var o;\n                (o = e[s]).currentFraction = o.fraction * a, o.currentFillColor = t.currentFillColor, o.currentLineColor = t.currentLineColor;\n              }\n\n              i && (i.currentFraction = i.fraction * a, i.currentFillColor = t.currentFillColor, i.currentLineColor = t.currentLineColor);\n            }, t.prototype.rectifyScrollOffsets = function (t, e) {\n              if (null != e) {\n                var i,\n                    n = t.offset;\n\n                if (t.scrollOffset < 0) {\n                  for (0 === n && (t.scrollOffset -= this.scene.settings.interaction.others.navigationFraction); t.scrollOffset < 0 && n - e.offset < e.values.length;) {\n                    i = e.values[n - e.offset], t.scrollOffset += i.fraction / t.visibleFraction, n++;\n                  }\n\n                  var r = this.scene.settings.interaction.others.maxSlicesVisible + 1;\n                  n + r > e.values.length && (t.scrollOffset = 0, n = Math.max(e.values.length - r, 0));\n                } else if (t.scrollOffset > 0) {\n                  var s = 0;\n\n                  for (1 === n && (s = this.scene.settings.interaction.others.navigationFraction); n > 0 && t.scrollOffset + s > e.values[n - e.offset - 1].fraction / t.visibleFraction;) {\n                    i = e.values[n - e.offset - 1], t.scrollOffset -= i.fraction / t.visibleFraction, n--;\n                  }\n\n                  0 === n && (t.scrollOffset = 0);\n                }\n\n                t.offset = n;\n              } else t.scrollOffset = 0;\n            }, t.prototype.getForwardCount = function (t, e, i) {\n              if (!e || e.offset > i || e.offset + e.values.length <= i) return !e || !e.done || e.offset > i ? (this.scene.mainData.requestPieData(t, i), {\n                numberOfSlices: 0,\n                isReady: !1\n              }) : {\n                numberOfSlices: 0,\n                isReady: !0\n              };\n              var n = e.offset,\n                  r = n + e.values.length,\n                  s = this.scene.settings.interaction.others,\n                  a = s.minSliceFraction,\n                  o = s.maxOthersFraction,\n                  l = s.maxSlicesVisible;\n              if (!s.enabled || r - i <= s.minSlices) return e.done || this.scene.mainData.requestMorePieData(t), {\n                numberOfSlices: Math.max(r - i, 0),\n                isReady: e.done\n              };\n\n              for (var h = e.afterFraction, u = i; u <= r - 1; u++) {\n                h += e.values[u - n].fraction;\n              }\n\n              for (var c = 0, d = 0, p = e.done; c + i < r;) {\n                c++;\n                var f = e.values[i + c - n - 1].fraction,\n                    g = (h -= f) / (h + (d += f)),\n                    m = Math.min(g, o);\n\n                if (c > l || f / d * (1 - m) < a) {\n                  e.done && c + i !== r && c--, p = !0;\n                  break;\n                }\n              }\n\n              return p || this.scene.mainData.requestMorePieData(t), {\n                numberOfSlices: c,\n                isReady: p\n              };\n            }, t.prototype.getBackOffset = function (t, e, i) {\n              if (0 === i) return {\n                newOffset: 0,\n                isReady: !0\n              };\n              if (!e || e.offset >= i || !e.done && e.offset + e.values.length < i) return this.scene.mainData.requestPieData(t, Math.max(0, i - this.scene.mainData.dataSettings.itemsToLoad)), {\n                newOffset: 0,\n                isReady: !1\n              };\n              if (0 === i) return {\n                newOffset: 0,\n                isReady: !0\n              };\n\n              for (var n = e.offset, r = n + e.values.length, s = this.scene.settings.interaction.others.minSliceFraction, a = this.scene.settings.interaction.others.maxOthersFraction, o = this.scene.settings.interaction.others.maxSlicesVisible, l = e.afterFraction, h = i; h < r; h++) {\n                l += e.values[h - n].fraction;\n              }\n\n              for (var u = i, c = e.values[i - n - 1].fraction, d = 0, p = 0 === e.offset; u > e.offset;) {\n                u--, d += e.values[u - n].fraction;\n                var f = i - u,\n                    g = Math.min(l / (l + d), a);\n\n                if (0 === u || f > o || c / d * (1 - g) < s) {\n                  0 !== u && u++, p = !0;\n                  break;\n                }\n              }\n\n              return p || this.scene.mainData.requestLessPieData(t), {\n                newOffset: u,\n                isReady: p\n              };\n            }, t.prototype.buildSlices = function (t, e, i) {\n              var n,\n                  r = this.scene.settings,\n                  s = t.data;\n              if (!s) throw new Error(\"Internal error - buildSlices\");\n\n              for (var a = 0, o = [], l = e; l < e + i; l++) {\n                var h = new f(t, l);\n                h.data = s.values[l - s.offset], h.id = h.data.__id, a += h.data.fraction, o.push(h);\n              }\n\n              var u = r.interaction.others,\n                  c = s.afterFraction,\n                  d = s.afterSum;\n\n              for (l = e + i; l < s.offset + s.values.length; l++) {\n                var p = s.values[l - s.offset];\n                d += p.value, c += p.fraction;\n              }\n\n              c > 0 && (e > 0 || s.values.length > u.minSlices) ? (n = new f(t, 1 / 0)).data = {\n                value: d,\n                fraction: c,\n                name: r.localization.othersLabel\n              } : n = null;\n              var g = null,\n                  m = 0;\n\n              if (e > 0) {\n                var v = s.beforeSum;\n\n                for (l = s.offset; l <= Math.min(e, s.offset + s.values.length) - 1; l++) {\n                  v += Math.abs(s.values[l - s.offset].value);\n                }\n\n                g = new f(t, -1), m = u.navigationFraction, m += t.scrollOffset, g.data = {\n                  value: v,\n                  name: r.localization.previousLabel\n                }, g.fraction = m;\n              }\n\n              t.visibleFraction = (a + c) * (1 + m / (1 - m)), n && (c = Math.max(u.navigationFraction, c), c = Math.min(u.maxOthersFraction, c), n.fraction = c);\n              var y = (1 - m - c) / a;\n              a = 1 - m - c;\n\n              for (var S = 0; S < o.length; S++) {\n                (T = o[S]).fraction = T.data.fraction * y;\n              }\n\n              var b = r.slice.minFraction;\n              if (b > 0) for (var C = 0;;) {\n                var x = 0,\n                    w = 0;\n\n                for (S = 0; S < o.length; S++) {\n                  (T = o[S]).fraction <= b && (x += 1, w += T.fraction);\n                }\n\n                if (x === o.length) {\n                  var L = a / o.length;\n\n                  for (S = 0; S < o.length; S++) {\n                    (T = o[S]).fraction = L;\n                  }\n\n                  break;\n                }\n\n                y = (a - x * b) / (a - w);\n\n                for (S = 0; S < o.length; S++) {\n                  var T;\n                  (T = o[S]).fraction <= b ? T.fraction = b : T.fraction = T.fraction * y;\n                }\n\n                if (x === C) break;\n                C = x;\n              }\n              return {\n                slices: o,\n                othersSlice: n,\n                previousSlice: g\n              };\n            }, t.prototype.applyNewSlices = function (t, e, i, n, r) {\n              void 0 === r && (r = !0);\n              var s = t.allSlices,\n                  a = 0 === s.length,\n                  o = [],\n                  l = [],\n                  u = 0,\n                  c = 0,\n                  d = s.length,\n                  p = e.length + (i ? 1 : 0) + (n ? 1 : 0);\n\n              for (n ? (t.previousSlice ? (t.previousSlice.removed = n.removed, t.previousSlice.data = n.data, t.previousSlice.fraction = n.fraction, t.previousSlice.value = n.value, r || this.jumpSliceToAnimationEnd(t.previousSlice)) : (a || (n.currentFraction = 0), t.previousSlice = n), l.push(t.previousSlice)) : t.previousSlice && (t.previousSlice.removed = !0, t.previousSlice.fraction = 0, l.push(t.previousSlice)); u < s.length || c < e.length;) {\n                var f = s[u],\n                    g = e[c];\n                !f || f.index !== 1 / 0 && -1 !== f.index ? f && g && (f.originalId || f.id) === g.id ? (f.removed = !1, f.fraction = g.fraction, f.data = g.data, g.currentFraction && r && (f.currentFraction = g.currentFraction, f._animatorF = null), r || this.jumpSliceToAnimationEnd(f), o.push(f), l.push(f), u++, c++) : !g || f && (f.index < g.index || d > p) ? (f.removed = !0, f.fraction = 0, f.originalId || (f.originalId = f.id), f.id = h.Helpers.getIdentifierStr(), r && l.push(f), u++) : (g.currentFraction || a || (g.currentFraction = 0), r || this.jumpSliceToAnimationEnd(g), o.push(g), l.push(g), c++) : u++;\n              }\n\n              i ? (t.othersSlice ? (t.othersSlice.removed = i.removed, t.othersSlice.data = i.data, t.othersSlice.fraction = i.fraction, t.othersSlice.value = i.value, r || this.jumpSliceToAnimationEnd(t.othersSlice)) : (a || (i.currentFraction = 0), t.othersSlice = i), l.push(t.othersSlice)) : t.othersSlice && (l.push(t.othersSlice), t.othersSlice.removed = !0, t.othersSlice.fraction = 0), !r && t.othersSlice && this.jumpSliceToAnimationEnd(t.othersSlice), t.total = t.data ? t.data.total : 0, t.count = e.length, t.slices = o, t.allSlices = l;\n\n              for (var m = 0; m < l.length; m++) {\n                var v = l[m];\n                v.value = v.data.value, r || this.jumpSliceToAnimationEnd(v);\n              }\n\n              this.scene.updateOnPieChanged(t), this.resetSelection();\n            }, t.prototype.resetSelection = function () {\n              for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {\n                var n = i[e];\n                t.selectionIds.push(n.id), n.selected = !1;\n              }\n\n              return t.selection = [], t.selectionIds.length > 0;\n            }, t.prototype.jumpSliceToAnimationEnd = function (t) {\n              t._animatorF ? t._animatorF.jump(t.fraction) : t._animatorF = new h.Animator(t.fraction, t.fraction, this.scene.settings.interaction.animation.scrollDuration, \"<>\", 0), t.currentFraction = t.fraction;\n            }, t.prototype.getPieData = function (t) {\n              var e = this.scene.mainData.getPieData(t.id);\n              if (!e) return null;\n              var i = e.total;\n              if (i > 0) for (var n = 0; n < e.values.length; n++) {\n                (r = e.values[n]).fraction = Math.max(1e-9, r.value / i);\n              } else {\n                i = e.values.length;\n\n                for (n = 0; n < e.values.length; n++) {\n                  var r;\n                  (r = e.values[n]).fraction = 1 / i;\n                }\n              }\n              return e.afterSum > 0 ? e.afterFraction = e.afterSum / i : e.afterFraction = 0, e.beforeSum > 0 ? e.beforeFraction = e.beforeSum / i : e.beforeFraction = 0, e;\n            }, t;\n          }();\n\n          t.PieBuilder = F;\n\n          var O = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 500, i.paintOrder = 30, i.updateOrder = 700, i.chart = e, i.scene = e.scene, i.renderer = new N(e), i.animator = new I(e), i.layout = new P(e, i), i.builder = new F(e), i;\n            }\n\n            return r(e, t), e.prototype.updatePie = function (t, e) {\n              return void 0 === e && (e = !0), this.builder.updatePie(t, e);\n            }, e.prototype.scrollForward = function (t, e) {\n              return this.builder.scrollForward(t, e);\n            }, e.prototype.scrollBackward = function (t, e) {\n              return this.builder.scrollBackward(t, e);\n            }, e.prototype.onSceneChange = function (t) {\n              this.renderer.onSceneChange(t);\n            }, e.prototype.doAnimations = function (t) {\n              var e = !1;\n              (t.changes.settings || t.changes.pie || t.changes.bounds || t.changes.assets) && (r = this.scene.peek()) && this.chart.assetsLoaded && (e = this.layout.placeStack(r, t.context));\n\n              for (var i = this.animator.doAnimations(t), n = 0; n < i.length; n++) {\n                var r = i[n];\n                this.layout.placeLabels(r, t.context);\n              }\n\n              (e || i) && (t.changes.position = !0);\n            }, e.prototype.paintScene = function (t) {\n              this.renderer.paintScene(t);\n            }, e.prototype.getMovement = function (t, e) {\n              var i = e.x - e.dx - t.x,\n                  n = e.y - e.dy - t.y,\n                  r = e.x - t.x,\n                  s = e.y - t.y,\n                  a = h.Geometry.normalizeAngle(Math.atan2(n, i)),\n                  o = h.Geometry.normalizeAngle(Math.atan2(s, r)),\n                  l = h.Geometry.subtractAngle(o, a) / (t.currentEndAngle - t.currentStartAngle),\n                  u = Math.sqrt(i * i + n * n);\n              return {\n                dfraction: l,\n                doffset: Math.sqrt(r * r + s * s) - u\n              };\n            }, e.prototype.findPieAt = function (t, e, i) {\n              for (var n = this.scene.currentInnerRadius, r = this.scene.currentRadius - n, s = this.scene.pies.length - 1; s >= 0; s--) {\n                var a = this.scene.pies[s],\n                    o = a.x,\n                    l = a.y,\n                    h = a.currentInnerRadius * r + n,\n                    u = a.currentRadius * r + n,\n                    c = Math.max(0, h - i),\n                    d = (c = u + i) * c,\n                    p = t - o,\n                    f = e - l,\n                    g = p * p + f * f;\n                if ((a.background || 1 === this.scene.pies.length) && g <= d) return a;\n              }\n\n              return null;\n            }, e.prototype.findSliceAt = function (t, e, i, n) {\n              for (var r = this.scene.currentInnerRadius, s = this.scene.currentRadius - r, a = this.scene.pies.length - 1; a >= 0; a--) {\n                var o = this.scene.pies[a];\n\n                if (!o.background) {\n                  var l = o.x,\n                      h = o.y,\n                      u = n ? 0 : o.currentInnerRadius * s + r,\n                      c = o.currentRadius * s + r;\n                  Math.max(0, u - i);\n                  c + i;\n                  var d = t - l,\n                      p = e - h,\n                      f = d * d + p * p,\n                      g = Math.sqrt(f);\n                  d /= g, p /= g;\n\n                  for (var m = o.currentStartAngle, v = o.currentEndAngle - m, y = Math.cos(m), S = Math.sin(m), b = 0; b < o.allSlices.length; b++) {\n                    var C = o.allSlices[b],\n                        x = y,\n                        w = S;\n\n                    if (m += v * C.currentFraction, y = Math.cos(m), S = Math.sin(m), g >= u + C.currentCutoutDistance && g <= c + C.currentCutoutDistance) {\n                      var L = w * d - x * p,\n                          T = S * d - y * p;\n                      if (L < 0 && T > 0) return C;\n                      if (Math.abs(v * C.currentFraction) > Math.PI && (L < 0 && T < 0 || L > 0 && T > 0)) return C;\n                    }\n                  }\n                }\n              }\n\n              return null;\n            }, e.prototype.findLabelAt = function (t, e, i) {\n              for (var n = this.scene.pies.length - 1; n >= 0; n--) {\n                for (var r = this.scene.pies[n], s = t - r.x, a = e - r.y, o = 0; o < r.allSlices.length; o++) {\n                  var l,\n                      h = r.allSlices[o];\n                  if (h.currentLabel) if ((l = h.currentLabel).visible && l.x - l.hwidth <= s && l.x + l.hwidth >= s && l.y - l.hheight <= a && l.y + l.hheight >= a) return {\n                    slice: h,\n                    label: l\n                  };\n                  if (h.currentInsideLabel) if ((l = h.currentInsideLabel).visible && l.x - l.hwidth <= s && l.x + l.hwidth >= s && l.y - l.hheight <= a && l.y + l.hheight >= a) return {\n                    slice: h,\n                    label: l\n                  };\n                }\n              }\n\n              return {\n                slice: null,\n                label: null\n              };\n            }, e;\n          }(h.ChartElement);\n\n          t.PieView = O;\n\n          var E = function (t) {\n            function e(e, i) {\n              var n = t.call(this, new v(e), new m(), i) || this;\n              return n.scene.loading = !1, n.selection = n.events.addElement(new w(n)), n.scene.view = new O(n), n.popup = n.events.addElement(new M(n)), n.legend = n.events.addElement(new d(n)), n.events.addElement(new L(n)), n.navigator = n.events.addElement(new A(n)), n.events.addElement(n.scene.view), n.finalInitialize(), n.navigator.setPie(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, \"init\"), n;\n            }\n\n            return r(e, t), e.prototype.createDataObj = function (t) {\n              return new a(this, t, !1);\n            }, e.prototype.getData = function (e) {\n              return t.prototype.getData.call(this, e);\n            }, e.prototype.createDomLayer = function () {\n              return new T(this);\n            }, e.prototype.onSettingsChanged = function (t) {\n              t.navigation && (t.navigation.initialDrilldown || t.navigation.initialOffset) && this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset), (t.labels || t.icons || t.pie || t.slice || t.interaction) && this.events.notifySceneChanges({\n                pie: !0\n              });\n            }, e.prototype.save = function () {\n              var t = this.saveSelection();\n              return JSON.stringify({\n                pie: this.navigator.getPie(),\n                offset: this.navigator.getPieOffset(),\n                selection: t\n              });\n            }, e.prototype.zoomOut = function (t, e) {\n              void 0 === t && (t = !0), void 0 === e && (e = \"api\"), this.setSelection([]), this.navigator.goBack(e);\n            }, e.prototype.zoomOutPossible = function () {\n              var t = this.scene;\n              return t.length() > 1 || t.peek().offset > 0;\n            }, e.prototype.restore = function (t, e) {\n              if (t) {\n                var i = JSON.parse(t);\n                this.setPie(i.pie, i.offset, e), this.setSelection(i.selection);\n              }\n            }, e.prototype.updateFilters = function () {\n              this.updateFilter(!0);\n            }, e.prototype.updateFilter = function (t) {\n              void 0 === t && (t = !1), this.log(\"Update filter\");\n              var e = {};\n\n              for (var i in this.settings._computedDataMap) {\n                e[i] = !0;\n              }\n\n              this.events.notifySceneChanges({\n                data: e,\n                dataDeep: t\n              });\n            }, e.prototype.setSelection = function (t, e) {\n              void 0 === e && (e = \"api\"), this.log(\"Set selection\");\n\n              for (var i = [], n = [], r = 0; r < t.length; r++) {\n                var s = t[r];\n                s instanceof f ? i.push(s) : h.Helpers.isString(s) ? n.push(s) : this.error(\"SetSelection: Selection contents must be Piechart_Slice object or string, got \" + s);\n              }\n\n              this.selection.setSelection(i, n, !1, e);\n            }, e.prototype.saveSelection = function () {\n              for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {\n                var i = this.scene.selection[e];\n                t.push(i.id);\n              }\n\n              return t;\n            }, e.prototype.exportVisibleData = function () {\n              var t = this.scene.peek();\n              return t ? a.exportValues(t.data) : [];\n            }, e.prototype.setPie = function (t, e, i, n) {\n              void 0 === i && (i = !0), void 0 === n && (n = \"api\"), this.log(\"Set pie\"), this.navigator.setPie(t, e, n);\n            }, e.prototype.setPieOffset = function (t, e, i) {\n              void 0 === e && (e = !0), void 0 === i && (i = \"api\"), this.log(\"Set pie offset\"), this.navigator.setPie(this.getPie(), t, i);\n            }, e.prototype.getPie = function () {\n              return this.navigator.getPie();\n            }, e.prototype.getActiveSlices = function () {\n              for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n                var i = this.scene.stack[e];\n                i.parentSlice && t.push(i.parentSlice);\n              }\n\n              return t;\n            }, e.prototype.getActivePies = function () {\n              return this.scene.stack;\n            }, e.prototype.expandSlice = function (t, e) {\n              return void 0 === e && (e = \"api\"), this.navigator.expandSlice(t, e);\n            }, e.prototype.getSliceDimensions = function (t, e) {\n              if (!Array.isArray(t)) return this.error(\"getSliceDimensions: slice Id must be an array\"), null;\n              if (t.length < 2) return null;\n              if (!e && this.scene.stack.length + 1 < t.length) return null;\n\n              for (var i, n = 0, r = 0; r < this.scene.stack.length; r++) {\n                if ((i = this.scene.stack[r]).id !== t[n]) return null;\n                if ((n += 1) === t.length - 1) break;\n              }\n\n              for (var s = t[n], a = 0; a < i.slices.length; a++) {\n                var o = i.slices[a];\n\n                if (o.id === s) {\n                  var l = o._renderParams;\n                  return l ? {\n                    centerX: i.x,\n                    centerY: i.y,\n                    r0: l[0],\n                    r1: l[1],\n                    a0: l[2],\n                    a1: l[3]\n                  } : null;\n                }\n              }\n\n              return null;\n            }, e.prototype.saveNavigation = function () {\n              var t = this.scene.peek();\n              return !t || t.loading ? null : {\n                pie: this.navigator.getPie(),\n                offset: this.navigator.getPieOffset()\n              };\n            }, e.prototype.restoreNavigation = function (t, e, i) {\n              this.navigator.setPie(t.pie, t.offset, i);\n            }, e.prototype.doChartUpdateNotify = function (e) {\n              t.prototype.doChartUpdateNotify.call(this, e);\n              var i = this.createEventArguments(null, e);\n              this.dispatchEventParams(\"pieChange\", i, null), this.dispatchEventParams(\"pieReadyStateChanged\", i, null);\n            }, e.prototype.createEventArguments = function (t, e) {\n              var i = this.scene;\n              if (!i) return {\n                chart: this.api,\n                origin: e\n              };\n              var n = i.peek();\n              return {\n                chart: this.api,\n                origin: e,\n                pie: n,\n                offset: n && n.offset,\n                count: n && n.count,\n                selection: i.selection.slice(),\n                slice: i.hoverSlice,\n                hoverSlice: i.hoverSlice,\n                hoverPie: i.hoverPie,\n                label: i.hoverLabel,\n                hoverLabel: i.hoverLabel\n              };\n            }, e.prototype.defaultClick = function (t, e) {\n              this.selection.defaultClick(t, e);\n            }, e.prototype.remove = function () {\n              t.prototype.remove.call(this), this.popup.remove();\n            }, e;\n          }(h.Impl);\n\n          t.Impl = E;\n        }(s = n.PieChart || (n.PieChart = {})), function (t) {\n          var e = function () {\n            return function () {\n              this.enabled = !0, this.size = 40, this.defaultUnitWidth = 50, this.maxUnitWidth = 400, this.zoomOutUnitWidth = 20, this.labels = {\n                enabled: !0,\n                angle: 0,\n                lineSpacing: .2,\n                interLabelSpacing: .6,\n                textStyle: {\n                  fillColor: \"#000\",\n                  font: \"12px Arial\"\n                },\n                margin: 4,\n                padding: 0,\n                aspectRatio: 3,\n                allowOverflow: !1\n              }, this.title = {\n                enabled: !1,\n                aspectRatio: 0,\n                align: \"center\",\n                useFacetName: !0,\n                textStyle: {\n                  font: \"13px Arial\",\n                  fillColor: \"#000\"\n                }\n              };\n            };\n          }();\n\n          t.SettingsFacetAxis = e;\n\n          var i = function () {\n            function t(t, e) {\n              this.title = null, this.titleHeight = null, this.facet = e, this.chart = t, this.scene = this.chart.scene, this.options = this.scene.settings.facetAxis, this.currentItemWidth = 1, this.currentItemHeight = 1, this.panel = new h.ChartPanel(), this.panel.side = \"bottom\", this.createTitle(), this.panel.packingOrder = 100;\n            }\n\n            return t.prototype.getPanel = function () {\n              var t = this.options,\n                  e = this.panel;\n              return t.enabled && t.size > 0 ? (e.desiredHeight = t.size, e.visible = !0, this.scene.bottomAxisSize = t.size) : (e.desiredHeight = 0, e.visible = !1, this.scene.bottomAxisSize = 0), e.enableClipping = !t.labels.allowOverflow, e;\n            }, t.prototype.createTitle = function () {\n              this.options.title.enabled ? this.title = new h.Label(this.options.title) : (this.title = null, this.titleHeight = 0);\n            }, t.prototype.updateTitle = function (t, e) {\n              var i = this.title,\n                  n = this.options.title,\n                  r = this.facet.data ? this.facet.data.name : \"\",\n                  s = n.useFacetName && r || n.text || \"\";\n              i && (i.text = s, e.measure(t, i), this.titleHeight = s ? 2 * ((i.style.margin || 0) + i.hheight) : 0);\n            }, t.prototype.paintTitle = function (t, e) {\n              var i = this.title;\n\n              if (i) {\n                this.updateTitle(t, e);\n                var n = this.titleHeight;\n\n                if (n) {\n                  var r = this.panel.left,\n                      s = this.panel.right,\n                      a = this.scene.y0 + this.scene.height + this.scene.bottomAxisSize - n / 2,\n                      o = void 0,\n                      l = i.style.align;\n                  o = (r + s) / 2, \"left\" === l && (o = r + i.hwidth), \"right\" === l && (o = s - i.hwidth), e.paint(t, o, a, 1, i);\n                }\n              }\n            }, t.prototype.paint = function (t, e, i, n) {\n              var r = this.options.labels;\n\n              if (n.length > 1 && this.panel.visible && r.enabled && this.chart.assetsLoaded) {\n                var s = t.context,\n                    a = t.labelRenderer,\n                    o = n[1] - n[0],\n                    l = this.panel.top,\n                    u = n[0];\n                this.paintTitle(s, a);\n                var c = this.panel.bottom - this.panel.top - this.titleHeight,\n                    d = !1;\n                (Math.abs(1 - this.currentItemWidth / o) > .01 || Math.abs(1 - this.currentItemHeight / c) > .01) && (this.currentItemWidth = o, this.currentItemHeight = c, d = !0), t.changes && t.changes.settings && (d = !0), this.layout = new h.LabelLayoutBase();\n                var p = this.facet.items,\n                    f = (r.angle || 0) * Math.PI / 180,\n                    g = Math.abs(Math.sin(f));\n                this.panel.pushClip(t);\n\n                for (var m = 0; m < p.length; m++) {\n                  var v = n[m];\n\n                  if (!(u > v)) {\n                    var y = p[m],\n                        S = y.currentLabel,\n                        b = this.htmlDecodeLabel(y.label || y.data.name || r.text, this.layout, s);\n\n                    if (y.currentLabel = null, b) {\n                      (null === y.currentLabel || d || y.currentLabel.text !== b) && (S = this.buildLabel(s, b, o, c), y.currentLabel = S);\n                      var C = Math.max.apply(Math, S.rows.rowWidths);\n\n                      if (u = v + S.x + C / 2, 0 !== f) {\n                        for (var x = 1, w = g * (n[m + 1] - n[m]); w < S.lineHeight + (r.margin || 0) + (r.padding || 0);) {\n                          w = g * (n[m + ++x] - n[m]);\n                        }\n\n                        u = n[m + x], void 0 === n[m + x] && (u = 1 / 0);\n                      }\n\n                      a.paint(s, v + S.x, l + S.y, 1, S);\n                    }\n                  }\n                }\n\n                this.panel.popClip(t);\n              }\n            }, t.prototype.htmlDecodeLabel = function (t, e, i) {\n              if (null == t || 0 === t.length) return \"\";\n\n              for (var n = e.styleTagParser2(i, t, {}), r = \"\", s = 0, a = n.words, o = 0; o < a.length; o++) {\n                var l = a[o];\n                if (r += l.word, o === a.length - 1) break;\n                n.breaks[s] === o + 1 ? (r += \" \", s++) : l.spaceWidth && (r += \" \");\n              }\n\n              return r;\n            }, t.prototype.buildLabel = function (t, e, i, n) {\n              var r = new h.Label(this.options.labels),\n                  s = r.style;\n              r.text = e;\n              var a = (s.angle || 0) * Math.PI / 180,\n                  o = s.align;\n              o || (o = a > 0 ? \"left\" : a < 0 ? \"right\" : \"center\", s.align = o);\n              return this.layout.getFormatedText(t, r, i, n, function (t, e, r) {\n                var s,\n                    o,\n                    l,\n                    h,\n                    u = 0,\n                    c = 1;\n                return 0 !== a ? (u = Math.sin(a), c = Math.cos(a), o = r / Math.abs(u), s = i / 2) : (s = e / 2, o = 2 * t <= n ? e : 0), a > 0 ? (l = s + o / 2 * c - 2 * t * c, h = e / 2 * u) : a < 0 ? (l = s - o / 2 * c + 2 * t * c, h = -e / 2 * u) : (l = s, h = t), {\n                  x: l,\n                  y: h,\n                  dx: c,\n                  dy: u,\n                  width: o\n                };\n              }), r;\n            }, t;\n          }();\n\n          t.FacetAxis = i;\n\n          var n = function () {\n            return function () {\n              this.enabled = !0, this.tolerance = 4;\n            };\n          }();\n\n          t.SettingsInteractionSelection = n;\n\n          var o = function () {\n            return function () {\n              this.lineColor = \"rgba(0,0,0,0.5)\", this.lineWidth = 2, this.fillColor = \"rgba(30,160,220,0.15)\", this.behindSeries = !1;\n            };\n          }();\n\n          t.SettingsAreaStyleSelection = o;\n\n          var l = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.paintOrder = 15, i.updateOrder = 1e3, i.scene = null, i.events = null, i.currentItem = null, i.currentFacet = null, i.hoverEvent = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.settings = e.settings.interaction.selection, i.styleSettings = e.settings.area.style.selection, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i;\n            }\n\n            return r(e, t), e.prototype.paintScene = function (t) {\n              var e = this.scene,\n                  i = e.selection,\n                  n = !this.settings.enabled;\n\n              if (n || i && i.length) {\n                var r = e.width,\n                    s = this.styleSettings,\n                    a = s.lineWidth,\n                    o = Math.round(e.x0),\n                    l = Math.round(e.y0),\n                    u = Math.round(l + e.height + e.bottomAxisSize),\n                    c = e.height + e.bottomAxisSize,\n                    d = [],\n                    p = e.activeFacet;\n                if (n) for (var f = 0, g = p.items; f < g.length; f++) {\n                  var m = g[f];\n                  m.selected && d.push(m.index);\n                } else for (var v = 0; v < i.length; v++) {\n                  var y = i[v];\n                  y.facet === p && d.push(y.index);\n                }\n                d.sort(function (t, e) {\n                  return t - e;\n                });\n                var S;\n\n                for (v = 0; v < d.length;) {\n                  for (var b = d[v], C = b; ++v < d.length && (S = d[v]) === C + 1;) {\n                    C = S;\n                  }\n\n                  var x = e.getItemPlacement(p, b, C),\n                      w = Math.round(o + r * x.left),\n                      L = Math.round(o + r * x.right),\n                      T = t.context;\n                  h.Graphics.pushClip(t, o, l, r, c), h.Graphics.rectStyle(T, s);\n                  var k = w + a % 2 / 2,\n                      A = L + a % 2 / 2;\n                  T.fillRect(k + a / 2, l, L - w - a, c), T.beginPath(), T.moveTo(k, l), T.lineTo(k, u), T.moveTo(A, l), T.lineTo(A, u), h.Graphics.stroke(T, s), h.Graphics.popClip(t);\n                }\n              }\n            }, e.prototype.doAnimations = function (t) {\n              this.hoverEvent && this.onPointerMove(this.hoverEvent);\n            }, e.prototype.previewPointerDrag = function (t) {\n              this.hoverEvent = t;\n            }, e.prototype.onPointerMove = function (t) {\n              var e = this.chart,\n                  i = e.scene;\n              this.hoverEvent = t;\n              var n = i.findItemAt(t.x, t.y);\n              n && (t.cursor = \"pointer\");\n              var r = e.renderer.hitTest(t.x, t.y);\n              if (e.legend) if (r) e.legend.notifyHoveredSeries(i.settings._computedSeries[r.seriesIndex]);else {\n                e.legend.notifyHoveredSeries(null);\n                var s = e.legend.getLastHoveredSeries();\n                s && (r = {\n                  x0: null,\n                  y0: null,\n                  x1: null,\n                  y1: null,\n                  isMarker: !1,\n                  seriesIndex: i.settings._computedSeries.indexOf(s)\n                });\n              }\n              (!r != !i.hoverSeriesItem || r && (r.seriesIndex !== i.hoverSeriesItem.seriesIndex || r.x0 !== i.hoverSeriesItem.x0)) && (i.hoverSeriesItem = r, t.changes.hover = !0), this.switchCurrentItem(n, t);\n            }, e.prototype.onPointerOut = function (t) {\n              this.hoverEvent = this.scene.hoverSeriesItem = null, this.events.notifySceneChanges({\n                selection: !0\n              }), t.changes.hover = !0, this.switchCurrentItem(null, t);\n            }, e.prototype.defaultClick = function (t, e) {\n              var i = e.clickItem;\n              i && (i.url ? (h.Helpers.openUrl(i.url, i.urlTarget), t.preventDefault()) : this.settings.enabled && t.ctrlKey || \"drilldown\" !== this.chart.settings.interaction.mode || !this.chart.expandItem(i, \"user\") || t.preventDefault());\n            }, e.prototype.getClickArgs = function (t) {\n              var e = this.scene.findItemAt(t.x, t.y, !0),\n                  i = this.chart.createEventArguments(t, \"user\", e);\n              return e && (t.cursor = \"pointer\", i.clickOrigin = this.scene.xyInBottom(t.x, t.y) ? \"label\" : \"item\"), i;\n            }, e.prototype.onClick = function (t) {\n              var e = this.getClickArgs(t);\n              t.consumed = !0, this.chart.notifyClick(t, e), t.defaultPrevented || this.updateSelection(t, e.clickItem);\n            }, e.prototype.onLongPress = function (t) {\n              var e = this.scene.findItemAt(t.x, t.y);\n              this.updateSelection(t, e);\n            }, e.prototype.onRightClick = function (t) {\n              var e = this.getClickArgs(t);\n              this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0);\n            }, e.prototype.onDoubleClick = function (t) {\n              var e = this.getClickArgs(t);\n              this.chart.notifyDoubleClick(t, e), t.consumed = !0;\n            }, e.prototype.onTripleClick = function (t) {\n              var e = this.getClickArgs(t);\n              this.chart.notifyTripleClick(t, e), t.consumed = !0;\n            }, e.prototype.updateSelection = function (t, e) {\n              if (this.settings.enabled) {\n                var i = this.scene,\n                    n = i.selection;\n                if (t.ctrlKey || \"toggle\" === this.chart.settings.interaction.mode) e && (e.selected = !e.selected, e.selected ? n.push(e) : h.Helpers.removeFromArray(n, e), this.setSelection(n, i.selectionIds, !0));else if (t.shiftKey) {\n                  var r = i.activeFacet;\n\n                  if (e && e.facet === r) {\n                    for (var s = 0, a = 0; a < n.length; a++) {\n                      var o = n[a];\n\n                      if (o.facet === r) {\n                        s = o.index;\n                        break;\n                      }\n                    }\n\n                    var l = Math.min(e.index, s),\n                        u = Math.max(e.index, s);\n                    n = new Array(u - l + 1);\n\n                    for (a = l; a <= u; a++) {\n                      n[a - l] = r.items[a];\n                    }\n\n                    this.setSelection(n);\n                  }\n                } else !e || e.selected && 1 === n.length ? this.setSelection([]) : this.setSelection([e]);\n              }\n            }, e.prototype.switchCurrentItem = function (t, e) {\n              var i = this.chart.createEventArguments(e, \"user\");\n              t !== this.currentItem && (e.changes.current = !0, this.scene.hoverItem && (this.scene.hoverItem.active = !1), this.scene.hoverItem = t, this.currentItem = t, this.currentFacet = null, this.currentItem && (this.scene.hoverItem.active = !0, i.hoverItem = this.currentItem), this.events.notifySceneChanges({\n                items: !0\n              })), e.changes.hover && this.chart.notifyHoverChanged(e, i);\n            }, e.prototype.onSceneChange = function (t) {\n              if (t.changes.items) {\n                var e = this.chart;\n                this.updateSelectionIds() && (this.events.notifySceneChanges({\n                  selection: !0\n                }), e.notifySelectionChanged(e.createEventArguments(null, \"api\")));\n              }\n            }, e.prototype.updateSelectionIds = function () {\n              for (var t = this.scene, e = [], i = 0, n = t.selectionIds; i < n.length; i++) {\n                for (var r = n[i], s = 0, a = t.stack; s < a.length; s++) {\n                  for (var o = 0, l = a[s].items; o < l.length; o++) {\n                    var u = l[o];\n\n                    if (u.id === r) {\n                      e.push(u);\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (0 === e.length) return !1;\n\n              for (var c = 0, d = e; c < d.length; c++) {\n                var p = d[c];\n                p.selected || (p.selected = !0, t.selection.push(p)), h.Helpers.removeFromArrayHasty(t.selectionIds, p.id);\n              }\n\n              return !0;\n            }, e.prototype.setSelection = function (t, e, i, n) {\n              void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = \"user\"), this.scene.selectionIds = e;\n              var r = !1;\n              if (i) r = !0;else {\n                for (var s = 0; s < this.scene.selection.length; s++) {\n                  var a = this.scene.selection[s];\n                  t.indexOf(a) < 0 && (a.selected = !1, r = !0);\n                }\n\n                for (s = 0; s < t.length; s++) {\n                  (a = t[s]).selected || (a.selected = !0, r = !0);\n                }\n\n                this.scene.selection = t;\n              }\n              var o = this.updateSelectionIds();\n              (r = r || o) && (this.events.notifySceneChanges({\n                selection: !0\n              }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)));\n            }, e;\n          }(h.ChartElement);\n\n          t.Selection = l;\n\n          var u = function (t) {\n            function e(e) {\n              var i = t.call(this, e) || this;\n              return i.animationOrder = 500, i.paintOrder = 25, i.updateOrder = 800, i;\n            }\n\n            return r(e, t), e.prototype.doAnimations = function (t) {\n              (t.changes.position || t.changes.navigation) && this.updatePopup(t);\n            }, e.prototype.getPopupAreaMouseMoved = function (t, e) {\n              if (!this.scene.xyInChartOrBottom(t, e) || !this.scene.activeFacet) return null;\n              var i = this.scene.activeFacet,\n                  n = this.scene.xToPosition(t);\n              if (isNaN(n)) return null;\n              var r = Math.floor(n),\n                  s = Math.ceil(n);\n              return r === s && (s = r + 1), r < i.offset || r >= i.items.length + i.offset ? null : {\n                t0: r,\n                t1: s\n              };\n            }, e.prototype.buildHeader = function (t, e) {\n              var i = this.scene.activeFacet,\n                  n = i.items[t - i.offset];\n              return \"<em></em><strong>\" + (n.label || n.data.name || \"\") + \"</strong>\";\n            }, e;\n          }(a.InfoPopup);\n\n          t.InfoPopup = u;\n\n          var c = function () {\n            return function () {\n              this.enabled = !0, this.enabledOnExport = !1, this.size = 28, this.style = {\n                fillColor: \"rgba(255,255,255,0.5)\",\n                lineColor: \"rgba(0,0,0,0.5)\",\n                hoverFillColor: \"rgba(255,255,255,0.9)\",\n                hoverLineColor: \"rgba(0,0,0,0.9)\"\n              };\n            };\n          }();\n\n          t.SettingsScrollButtons = c;\n\n          var d = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              i.paintOrder = 75, i.chart = e, i.scene = e.scene, i.settings = e.settings.scrollButtons, i.panels = [];\n\n              for (var n = 0; n < 2; n++) {\n                var r = new h.ChartPanel();\n                r.packingOrder = 115, r.side = 1 === n ? \"left\" : \"right\", r.location = \"inside\", r.align = \"center\", i.panels.push(r);\n              }\n\n              return i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              this.settings.enabled && (this.activeFacet = this.chart.scene.activeFacet, this.showLeft = Math.floor(this.activeFacet.from) > 0, this.showRight = Math.ceil(this.activeFacet.to) < this.activeFacet.totalCount);\n            }, e.prototype.getPanels = function (t) {\n              for (var e = 0; e < 2; e++) {\n                var i = this.panels[e];\n                i.visible = t ? this.settings.enabledOnExport : this.settings.enabled, i.desiredWidth = i.desiredHeight = this.settings.size;\n              }\n\n              return this.panels;\n            }, e.prototype.paintScene = function (t) {\n              if (this.panels[0].visible) {\n                var e = this.settings.style,\n                    i = t.context;\n                i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor;\n\n                for (var n = this.settings.size, r = n / 2, s = n / 4, a = this.scene.y0 + this.scene.height / 2 - n / 2, o = 0; o < this.panels.length; o++) {\n                  var l = this.panels[o],\n                      h = l.left;\n                  this.showRight && \"right\" === l.side && (this.rightActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(h, a, n, n), i.moveTo(h + r - s / 2 + 2, a + s), i.lineTo(h + r + s - 3, a + r), i.lineTo(h + r - s / 2 + 2, a + n - s), i.stroke()), this.showLeft && \"left\" === l.side && (this.leftActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(h, a, n, n), i.moveTo(h + r + s / 2 - 2, a + s), i.lineTo(h + r - s + 3, a + r), i.lineTo(h + r + s / 2 - 2, a + n - s), i.stroke()), i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor;\n                }\n              }\n            }, e.prototype.findItemAt = function (t, e, i) {\n              if (!this.panels[0].visible) return null;\n\n              for (var n = i.touch ? 10 : 0, r = 0; r < 2; r++) {\n                var s = this.panels[r];\n                if (t >= s.left - n && t <= s.right + n && e >= s.top - n && e <= s.bottom + n && (\"left\" === s.side && this.showLeft || \"right\" === s.side && this.showRight)) return s.side;\n              }\n\n              return null;\n            }, e.prototype.onClick = function (t) {\n              if (this.panels[0].visible) {\n                var e = h.Helpers.performanceNow(),\n                    i = this.findItemAt(t.x, t.y, t);\n\n                if (null !== i) {\n                  var n = this.chart.scrolling,\n                      r = this.activeFacet,\n                      s = r.from,\n                      a = r.to,\n                      o = r.totalCount,\n                      l = a - s;\n                  \"right\" === i && (a + l > o ? (a = a - l + (o - a), n.goToPosition(a, o, !0, e, !0)) : n.goToPosition(a, a + l, !0, e, !0)), \"left\" === i && (s - l < 0 ? n.goToPosition(0, l, !0, e, !0) : n.goToPosition(s - l, s, !0, e, !0)), t.consumed = !0;\n                }\n              }\n            }, e.prototype.onPointerMove = function (t) {\n              var e = this.findItemAt(t.x, t.y, t);\n              null !== e ? (\"left\" === e && (this.leftActive = !0), \"right\" === e && (this.rightActive = !0), t.changes.hover = !0, t.consumed = !0) : (this.leftActive = !1, this.rightActive = !1);\n            }, e;\n          }(h.ChartElement);\n\n          t.ScrollButtons = d;\n\n          var p = \"#A8A7A8\",\n              f = function (t) {\n            function i(i) {\n              var n = t.call(this, h.SettingsMapping.FacetChartSettings) || this;\n              return n.area = new g(), n.data = [], n.filters = {\n                sliceFilter: null,\n                allowZeroValues: !0\n              }, n.navigation = {\n                initialDrilldown: [\"\"],\n                initialOffset: 0\n              }, n.items = {\n                style: {\n                  label: null,\n                  expandable: !0\n                },\n                styleFunction: null\n              }, n.chartTypes = {\n                columns: {\n                  type: \"columns\"\n                },\n                line: {\n                  type: \"line\"\n                },\n                candlestick: null\n              }, n.facetAxis = new e(), n.interaction = new y(), n.toolbar = new v(), n.legend = new a.SettingsLegend(), n.scrollButtons = new c(), n.localization.toolbar.zoomoutTitle = \"Zoom-out to previous level\", n.apply(i), n._initializing = !1, n;\n            }\n\n            return r(i, t), i.prototype.apply = function (e) {\n              if (this.applyCompatibility(e, [{\n                from: \"area.initialPieId\",\n                to: \"navigation.initialDrilldown\"\n              }, {\n                from: \"area.initialPieOffset\",\n                to: \"navigation.initialOffset\"\n              }]), e.series) for (var i = 0; i < e.series.length; i++) {\n                var n = e.series[i];\n                n && void 0 !== n.styleFunction && h.Helpers.error(\"Setting `series[\" + i + \"].styleFunction` is no longer supported. Consider using `items.styleFunction` instead. See the example: https://zoomcharts.com/developers/en/facet-chart/examples/series/stacked-colored.html\");\n              }\n              return t.prototype.apply.call(this, e, S);\n            }, i;\n          }(a.Settings);\n\n          f.DarkTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-dark\"\n            },\n            area: {\n              style: {\n                fillColor: \"rgba(28,26,28,1)\",\n                selection: {\n                  lineColor: \"#838283\"\n                }\n              }\n            },\n            title: {\n              margin: 15,\n              style: {\n                fillColor: p\n              }\n            },\n            valueAxisDefault: {\n              style: {\n                valueLabel: {\n                  textStyle: {\n                    fillColor: p\n                  }\n                },\n                title: {\n                  textStyle: {\n                    fillColor: p\n                  }\n                }\n              }\n            },\n            facetAxis: {\n              labels: {\n                textStyle: {\n                  fillColor: p\n                }\n              },\n              title: {\n                textStyle: {\n                  fillColor: p\n                }\n              }\n            },\n            legend: {\n              text: {\n                fillColor: p\n              },\n              advanced: {\n                disabledSeries: {\n                  textColor: \"rgba(168,167,168,0.5)\",\n                  lineColor: \"rgba(117,117,117,0.3)\"\n                }\n              }\n            }\n          }, t.Settings = f;\n\n          var g = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.style = new m(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsArea);\n\n          t.SettingsArea = g;\n\n          var m = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.selection = new o(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsAreaStyle);\n\n          t.SettingsAreaStyle = m;\n\n          var v = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.logScale = !0, e.zoomOut = !0, e.enabled = !0, e.items = [new h.SettingsToolbarItem(\"fullscreen\", \"left\"), new h.SettingsToolbarItem(\"back\", \"left\"), new h.SettingsToolbarItem(\"zoomOut\", \"left\"), new h.SettingsToolbarItem(\"logScale\", \"right\"), new h.SettingsToolbarItem(\"export\", \"right\")], e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsToolbar);\n\n          t.SettingsToolbar = v;\n\n          var y = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.selection = new n(), e.mode = \"drilldown\", e.animation = {\n                scrollDuration: 500\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsInteraction);\n\n          t.SettingsInteraction = y;\n\n          var S = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.type = \"columns\", e.data = new b(), e;\n            }\n\n            return r(e, t), e.getMapping = function (t, e) {\n              if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n              switch (t ? t.type : e.type) {\n                case \"columns\":\n                case void 0:\n                  return h.SettingsMapping.FacetChartSettingsSeriesColumns;\n\n                case \"line\":\n                  return h.SettingsMapping.FacetChartSettingsSeriesLines;\n\n                default:\n                  throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a series. Valid values are: columns, line.\");\n              }\n            }, e.createInstance = function (t, e) {\n              switch (e || t.type) {\n                case \"columns\":\n                case void 0:\n                  return new C();\n\n                case \"line\":\n                  return new x();\n\n                default:\n                  throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a series. Valid values are: columns, line.\");\n              }\n            }, e;\n          }(a.SettingsSeries);\n\n          t.SettingsSeries = S;\n\n          var b = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.field = null, e.valueFunction = null, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesData);\n\n          t.SettingsSeriesData = b;\n\n          var C = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.style = new L(), e.data = new b(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesColumns);\n\n          t.SettingsSeriesColumns = C;\n\n          var x = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = new b(), e.style = new w(), e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesLines);\n\n          t.SettingsSeriesLines = x;\n\n          var w = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.markerStyleFunction = null, e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesLinesStyle);\n\n          t.SettingsSeriesLinesStyle = w;\n\n          var L = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.previewContents = !1, e.previewLineColor = \"rgba(255,255,255,.5)\", e;\n            }\n\n            return r(e, t), e;\n          }(a.SettingsSeriesColumnsStyle);\n\n          t.SettingsSeriesColumnsStyle = L;\n\n          var T = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(L);\n\n          t.SettingsFacetStyle = T;\n\n          var k = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.sortField = null, e.dataFunction = null, e.preloaded = null, e;\n            }\n\n            return r(e, t), e;\n          }(s.SettingsData);\n\n          t.SettingsData = k;\n\n          var A = function () {\n            function t() {\n              this.id = null, this.data = null, this.items = [], this.parentItem = null, this.activeItemId = null, this.offset = 0, this.count = 0, this.totalCount = 0, this.from = 0, this.to = 0, this.left = 0, this.right = 1, this.opacity = 1, this.loading = null, this.rebuild = !0;\n            }\n\n            return t.prototype.getActiveItem = function () {\n              if (!this.activeItemId) return null;\n\n              for (var t = 0; t < this.items.length; t++) {\n                var e = this.items[t];\n                if (e.id === this.activeItemId) return e;\n              }\n\n              return null;\n            }, t;\n          }();\n\n          t.Facet = A;\n\n          var M = function () {\n            return function (t, e, i, n) {\n              this.expandable = !0, this.selected = !1, this.active = !1, this.url = null, this.urlTarget = null, this.values = [], this.innerFacet = null, this.label = null, this.currentLabel = null, this.facet = t, this.id = e, this.index = i, this.data = n;\n            };\n          }();\n\n          t.Item = M;\n\n          var I = function () {\n            return function (t, e, i, n, r) {\n              this.value = 0, this.label = null, this.currentLabel = null, this.style = new T(), this.previewData = null, this.data = n, this.index = i, this.id = e, this.facet = t, this.seriesId = r;\n            };\n          }();\n\n          t.ItemValue = I;\n\n          var P = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.data = null, e.stack = [], e.activeFacet = null, e.hoverItem = null, e.selection = [], e.selectionIds = [], e;\n            }\n\n            return r(e, t), e.prototype.xToPosition = function (t) {\n              var e = this.activeFacet,\n                  i = this.x0 + e.left * this.width,\n                  n = this.x0 + e.right * this.width;\n              return e.from + (t - i) / (n - i) * (e.to - e.from);\n            }, e.prototype.positionToX = function (t) {\n              var e = this.activeFacet,\n                  i = this.x0 + e.left * this.width,\n                  n = this.x0 + e.right * this.width;\n              return i + (t - e.from) * (n - i) / (e.to - e.from);\n            }, e.prototype.timeToX = function (t) {\n              return this.positionToX(t);\n            }, e.prototype.xToTime = function (t) {\n              return this.xToPosition(t);\n            }, e.prototype.length = function () {\n              return this.stack.length;\n            }, e.prototype.peek = function () {\n              return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n            }, e.prototype.push = function (t, e) {\n              var i = this.peek();\n              if (i && !e) for (var n = 0; n < i.items.length; n++) {\n                var r = i.items[n];\n\n                if (r.data.__id === t.id) {\n                  e = r;\n                  break;\n                }\n              }\n\n              if (e) {\n                t.parentItem = e, e.innerFacet = t;\n                var s = this.getItemPlacement(e.facet, e.index);\n                t.left = s.left, t.right = s.right, i.activeItemId = e.id;\n              } else i && (i.activeItemId = null);\n\n              this.stack.push(t), this.activeFacet = t;\n            }, e.prototype.pop = function () {\n              if (this.stack.length > 0) {\n                var t = this.stack.pop();\n                t.parentItem && (t.parentItem.facet.activeItemId = null);\n              }\n\n              return this.stack.length > 0 ? this.activeFacet = this.peek() : this.activeFacet = null, this.activeFacet;\n            }, e.prototype.getParent = function (t) {\n              for (var e = null, i = 0; i < this.stack.length; i++) {\n                var n = this.stack[i];\n                if (n === t) return e;\n                e = n;\n              }\n\n              return null;\n            }, e.prototype.getChild = function (t) {\n              for (var e = null, i = 0; i < this.stack.length; i++) {\n                var n = this.stack[i];\n                if (e === t) return n;\n                e = n;\n              }\n\n              return null;\n            }, e.prototype.updateLinks = function (t) {\n              var e = this.getParent(t),\n                  i = this.getChild(t);\n              if (e && !t.parentItem) for (var n = 0; n < e.items.length; n++) {\n                if ((r = e.items[n]).id === t.id) {\n                  t.parentItem = r, e.activeItemId = r.id;\n                  break;\n                }\n              }\n              if (i && !i.parentItem) for (n = 0; n < t.items.length; n++) {\n                var r;\n\n                if ((r = t.items[n]).id === i.id) {\n                  i.parentItem = r, t.activeItemId = r.id;\n                  break;\n                }\n              }\n            }, e.prototype.getItemPlacement = function (t, e, i) {\n              void 0 === i && (i = e);\n              var n = t.to - t.from,\n                  r = t.from,\n                  s = (e - r) / n,\n                  a = (i - r + 1) / n;\n              return {\n                left: t.left + s * (t.right - t.left),\n                right: t.left + a * (t.right - t.left)\n              };\n            }, e.prototype.getFacetPlacementFromItem = function (t, e, i) {\n              var n = t.facet,\n                  r = t.index,\n                  s = r + 1,\n                  a = (r - n.from) / (n.to - n.from),\n                  o = (s - n.from) / (n.to - n.from),\n                  l = e - a * (e - i) / (a - o);\n              return {\n                left: l,\n                right: l + (e - i) / (a - o)\n              };\n            }, e.prototype.findItemAt = function (t, e, i) {\n              var n = this.activeFacet;\n\n              if (n) {\n                if (!i && !this.xyInChart(t, e)) return null;\n                if (i && !this.xyInChartOrBottom(t, e)) return null;\n                var r = Math.floor(this.xToPosition(t));\n                if (r >= n.offset && r < n.offset + n.count) return n.items[r - n.offset];\n              }\n\n              return null;\n            }, e;\n          }(a.Scene);\n\n          t.Scene = P;\n\n          var D = function (t) {\n            function e(e) {\n              var i = t.call(this, e) || this;\n              return i.animationOrder = 100, i.paintOrder = 10, i.updateOrder = 1100, i.animatingFacet = null, i.leftAnimator = null, i.rightAnimator = null, i.activePieReady = !1, i._shouldZoomOut = !1, i;\n            }\n\n            return r(e, t), e.prototype.setState = function (t, e, i, n) {\n              if (0 !== t.length) {\n                for (var r = 0; this.scene.length() > t.length;) {\n                  this.scene.pop(), r++;\n                }\n\n                for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) {\n                  this.scene.pop(), r++;\n                }\n\n                for (; this.scene.length() < t.length;) {\n                  var s = t[this.scene.length()];\n                  this.drillDown(s, null), r++;\n                }\n\n                var a = this.scene.peek();\n\n                if (this.facet = a, r && this.goToPositionDragging(a.from, a.to), a.offset !== e || i && a.count !== i) {\n                  var o,\n                      l = e;\n                  o = i > 0 ? l + i : e + a.count, r ? (this.goToPositionDragging(l, o), this.animateFillChart()) : this.goToPosition(l, o, !0, h.Helpers.performanceNow(), !0);\n                } else r && this.animateFillChart();\n\n                this.chart.notifyChartUpdate(n), r && this.events.notifySceneChanges({\n                  navigation: !0\n                });\n              } else this.chart.error(\"setPie - array needs at least one item.\");\n            }, e.prototype.getState = function () {\n              for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n                var i = this.scene.stack[e];\n                t.push(i.id);\n              }\n\n              var n = this.scene.peek();\n              return {\n                idArray: t,\n                offset: n.offset,\n                count: n.count\n              };\n            }, e.prototype.goUp = function (t) {\n              if (this.scene.length() > 1) {\n                this.scene.pop();\n                var e = this.facet = this.scene.peek();\n                this.goToPositionDragging(e.from, e.to), this.animateFillChart(), this.events.notifySceneChanges({\n                  navigation: !0\n                }), this.updateAndNotifyCurrent(t);\n              } else this.goToPosition(0, this.getMaxItems(), !0, h.Helpers.performanceNow(), !0);\n            }, e.prototype.getMaxItems = function () {\n              var t = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;\n              return this.facet.data.totalCount && (t = Math.min(t, this.facet.data.totalCount)), t;\n            }, e.prototype.drillDown = function (t, e) {\n              this.stopAnimations();\n              var i = new A();\n              i.id = t, this.scene.push(i, null), this.chart.builder.updateFacet(i), this.facet = i, this.setFrom(i.from), this.setTo(i.to), this.animateFillChart(), this.events.notifySceneChanges({\n                navigation: !0\n              }), this.updateAndNotifyCurrent(e);\n            }, e.prototype.updateAndNotifyCurrent = function (t) {\n              this.chart.builder.updateFacet(this.facet), this.chart.notifyChartUpdate(t);\n            }, e.prototype.onSceneChange = function (t) {\n              var e = this.facet,\n                  i = t.timeStamp,\n                  n = t.changes.settingsChanges;\n\n              if (n && n.series) {\n                t.changes.items = !0;\n\n                for (var r = 0; r < this.scene.stack.length; r++) {\n                  var s = this.scene.stack[r];\n                  this.chart.builder.rebuildValues(s);\n                }\n              }\n\n              if ((t.changes.pieChartPieIds || t.changes.dataArrived || t.changes.data) && (this.activePieReady = !1, t.changes.data || t.changes.dataArrived)) for (var a = t.changes.pieChartPieIds || Object.create(null), o = 0; o < this.scene.stack.length; o++) {\n                (!(s = this.scene.stack[o]).data || s === e || a[s.id] || t.changes.dataDeep) && (s.rebuild = !0, this.chart.builder.updateFacet(s, t), t.changes.items = !0, this.activePieReady = this.activePieReady || s === e && !s.loading);\n              }\n              this.activePieReady && this.scene.width > 0 && (this.activePieReady = !1, this.inertiaT.finished(i) && e.from < e.to && (this.setFrom(e.from), this.setTo(e.to), this.animateFillChart()), this.chart.notifyChartUpdate(null));\n            }, e.prototype.doAnimations = function (e) {\n              var i = this.facet;\n              this.animatingFacet ? (i.left = this.leftAnimator.get(e.timeStamp), i.right = this.rightAnimator.get(e.timeStamp), (this.leftAnimator.finished(e.timeStamp) || this.rightAnimator.finished(e.timeStamp)) && (this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null), this.events.notifySceneChanges({\n                position: !0\n              }), e.animating = !0) : i.opacity = 1;\n              this.layoutFacets();\n\n              for (var n = 0; n < this.scene.stack.length; n++) {\n                i = this.scene.stack[n], this.chart.builder.updateFacet(i, e);\n              }\n\n              t.prototype.doAnimations.call(this, e);\n            }, e.prototype.xyInArea = function (t, e) {\n              return this.scene.xyInChartOrBottom(t, e);\n            }, e.prototype.xyToPosition = function (t, e) {\n              return this.scene.xToPosition(t);\n            }, e.prototype.onGoHome = function (t, e) {\n              return {\n                from: 0,\n                to: e - t,\n                origin: 0\n              };\n            }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {\n              t < 0 && (e -= t, t = 0);\n              var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);\n              t = s.from, e = s.to;\n              var a = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);\n              return a ? void this.goToPosition(a.from, a.to, !0, n, !0) : void (this.wheelOrigin = null);\n            }, e.prototype.onStartDragging = function (t, e, i) {\n              this.stopAnim();\n            }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {\n              var s = e - t,\n                  a = this.facet,\n                  o = a.totalCount,\n                  l = !1;\n              return this.scene.stack.length > 1 && (s > 2 * o || this.scene.width / s < this.scene.settings.facetAxis.zoomOutUnitWidth) && (l = !0), this._shouldZoomOut = l, a.left = 0, a.right = 1, {\n                from: t,\n                to: e\n              };\n            }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {\n              if (this._shouldZoomOut) return this._shouldZoomOut = !1, this.goUp(\"user\"), null;\n              var s = this.snap(t, e, i, n, r);\n              return t = s.from, e = s.to, this.animateFillChart(), this.chart.notifyChartUpdate(\"user\"), {\n                from: t,\n                to: e\n              };\n            }, e.prototype.onPositionChanged = function (t, e) {\n              var i = this.facet;\n              i.from = t, i.to = e, this.chart.builder.updateFacet(i), this.events.notifySceneChanges({\n                position: !0\n              });\n            }, e.prototype.onAnimationDone = function (t, e) {\n              this.chart.notifyChartUpdate(null), this.chart.notifyAnimationDone();\n            }, e.prototype.snap = function (t, e, i, n, r) {\n              var s = this.facet,\n                  a = s.totalCount;\n              s.right < 1 && (0 === s.right && (s.right = 1e-10), e = t + (e - t) / s.right), s.left > 0 && (1 === s.left && (s.left = 1 - 1e-10), t = e - (e - t) / (1 - s.left));\n              var o = this.scene.width / (e - t),\n                  l = o;\n              a > 0 && (l = Math.max(l, this.scene.width / a));\n              var h = o / (l = Math.min(this.scene.settings.facetAxis.maxUnitWidth, l));\n              if (t = i + (t - i) * h, e = i + (e - i) * h, t = Math.round(t), e = Math.round(e), t < 0) e -= t, t = 0;else if (e > a) {\n                var u = Math.max(0, a - (e - t));\n                e = e - t + u, t = u;\n              }\n              return {\n                from: t,\n                to: e\n              };\n            }, e.prototype.animateFillChart = function () {\n              0 === this.facet.left && 1 === this.facet.right && this.animatingFacet === this.facet || (this.animatingFacet = this.facet, this.leftAnimator = new h.Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, \"<>\"), this.rightAnimator = new h.Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, \"<>\"), this.events.notifySceneChanges({\n                requestPaint: !0\n              }));\n            }, e.prototype.stopAnim = function () {\n              var t = this.facet;\n              this.animatingFacet && (t.opacity = 1, this.animatingFacet = null), this.leftAnimator && (t.left = this.leftAnimator.get(1 / 0), this.leftAnimator = null), this.rightAnimator && (t.right = this.rightAnimator.get(1 / 0), this.rightAnimator = null), this.layoutFacets();\n            }, e.prototype.layoutFacets = function () {\n              for (var t = this.scene.stack.length - 2; t >= 0; t--) {\n                var e = this.scene.stack[t + 1],\n                    i = this.scene.stack[t];\n\n                if (e.parentItem) {\n                  var n = this.scene.getFacetPlacementFromItem(e.parentItem, e.left, e.right);\n                  i.left = n.left, i.right = n.right;\n                }\n\n                i.opacity = e.left > 0 || e.right < 1 ? .5 : 0;\n              }\n\n              this._shouldZoomOut ? (this.facet.opacity = .65, this.facet.parentItem && this.facet.parentItem.facet && (this.facet.parentItem.facet.opacity = 1)) : this.facet.opacity = 1;\n            }, e;\n          }(a.Scrolling);\n\n          t.Scrolling = D;\n\n          var N = function () {\n            function t(t, e, n) {\n              this.bounds = {\n                x0: 0,\n                y0: 0,\n                width: 0,\n                height: 0\n              }, this.facet = n, this.chart = e, this.scene = this.chart.scene, this.valueAxis = new a.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.xes = [], this.facetAxis = new i(e, n), this.r = new a.Renderer(this.chart, this.valueAxis);\n            }\n\n            return t.prototype.getPanels = function () {\n              var t = this.valueAxis.getPanels(!0);\n              return t.push(this.facetAxis.getPanel()), t;\n            }, t.prototype.setPanels = function (t) {\n              this.valueAxis.setPanels(t), this.facetAxis.panel = t[t.length - 1];\n            }, t.prototype.doAnimations = function (t, e) {\n              var i = e.x0,\n                  n = e.y0,\n                  r = e.width,\n                  s = e.height,\n                  a = this.facet,\n                  o = a.offset,\n                  l = a.left,\n                  h = a.right;\n              l = i + r * l, h = i + r * h;\n              var u = Math.max(i, l),\n                  c = Math.min(i + r, h);\n              this.bounds = {\n                x0: u,\n                y0: n,\n                width: c - u,\n                height: s\n              };\n              var d = t.changes;\n\n              if (d.position || d.data || d.bounds || d.items) {\n                for (var p = (h - l) / (a.to - a.from), f = l - a.from * p, g = a.count, m = o, v = o + g, y = new Array(g + 1), S = new Array(g + 1), b = m; b < v + 1; b++) {\n                  y[b - m] = b, S[b - m] = b * p + f;\n                }\n\n                this.xes = S;\n\n                for (var C = new Array(this.scene.settings._computedSeries.length), x = 0; x < C.length; x++) {\n                  var w = new Array(g),\n                      L = new Array(g),\n                      T = new Array(g);\n\n                  for (b = m; b < v; b++) {\n                    var k = this.facet.items[b - o].values[x];\n                    w[b - m] = k.value, T[b - m] = 1, L[b - m] = k;\n                  }\n\n                  C[x] = {\n                    xes: S,\n                    times: y,\n                    counts: T,\n                    fromIndex: 0,\n                    toIndex: g + 1,\n                    values: w,\n                    config: L,\n                    externalItems: function externalItems(t, e) {\n                      return this.config.slice(t, e);\n                    }\n                  };\n                }\n\n                this.r.process(C);\n              }\n\n              this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t);\n            }, t.prototype.paintScene = function (t) {\n              var e = t.context,\n                  i = this.bounds,\n                  n = this.facet.opacity,\n                  r = 1 === n ? n : .2;\n              0 !== n && (e.globalAlpha = r, this.valueAxis.paintUnder(t), e.globalAlpha = n, h.Graphics.pushClip(t, i.x0, i.y0, i.width, i.height), this.r.paint(t), h.Graphics.popClip(t), e.globalAlpha = r, this.facetAxis.paint(t, i.x0, i.width, this.xes), this.valueAxis.paint(t), e.globalAlpha = 1);\n            }, t;\n          }();\n\n          t.Layer = N;\n\n          var F = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 400, i.paintOrder = 5, i.updateOrder = 1200, i.chart = e, i.scene = i.chart.scene, i.events = i.chart.events, i.layers = [], i.panels = [], i;\n            }\n\n            return r(e, t), e.prototype.onSceneChange = function (t) {\n              var e = t.changes;\n\n              if (e.settings || e.navigation || e.linearChartSeries || e.linearChartValueAxis) {\n                var i = e.settingsChanges;\n                e.linearChartValueAxis || i && i.facetAxis ? (e.bounds = !0, this.layers = []) : e.linearChartSeries && (this.layers = []);\n\n                for (var n = 0; n < this.layers.length; n++) {\n                  this.layers[n].facet !== this.scene.stack[n] && (this.layers = this.layers.slice(0, n));\n                }\n\n                for (; this.layers.length < this.scene.stack.length;) {\n                  var r = this.scene.stack[this.layers.length],\n                      s = new N(t, this.chart, r);\n                  this.layers.push(s);\n                }\n\n                0 === this.layers.length && this.layers.push(new N(t, this.chart, new A()));\n                var a = this.layers[0].getPanels();\n                this.panels = a.filter(function (t) {\n                  return null != t;\n                });\n\n                for (var o = 0; o < this.layers.length; o++) {\n                  this.layers[o].setPanels(a);\n                }\n              }\n            }, e.prototype.getPanels = function () {\n              return this.panels;\n            }, e.prototype.doAnimations = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                this.layers[e].doAnimations(t, this.scene);\n              }\n            }, e.prototype.paintScene = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                this.layers[e].paintScene(t);\n              }\n            }, e.prototype.exportData = function (t, e) {\n              return this.layers[this.layers.length - 1].r.exportData(t, e);\n            }, e.prototype.hitTest = function (t, e) {\n              var i = this.scene,\n                  n = this.layers;\n              return i.xyInChart(t, e) && n.length > 0 ? n[n.length - 1].r.hitTest(t, e, i.settings.interaction.selection.tolerance) : null;\n            }, e;\n          }(h.ChartElement);\n\n          t.Renderer = F;\n\n          var O = function () {\n            function t(t) {\n              this.chart = t, this.scene = t.scene, this.loading = !1;\n            }\n\n            return t.prototype.updateFacet = function (t, e) {\n              void 0 === e && (e = null);\n              var i = this.chart.getData(\"default\"),\n                  n = t.data;\n              if ((!n || e && (e.changes.data || e.changes.dataArrived || e.changes.filters)) && !(n = t.data = i.getPieData(t.id))) return t.loading = !0, void i.requestPieData(t.id, Math.floor(t.from));\n              var r = !1;\n\n              if (this.scene.width && (!(t.from < t.to) || t.rebuild)) {\n                t.rebuild = !1;\n                var s = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth)),\n                    a = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));\n                n.totalCount && (a = Math.min(n.totalCount, a)), a = Math.max(s, a), t.offset = Math.floor(t.from), t.count = 0, t.to = t.from + (0 | a), t.items = [];\n              }\n\n              var o = Math.max(0, (0 | t.from) - 2),\n                  l = Math.ceil(t.to + 2),\n                  h = n.values.length + n.offset,\n                  u = n.offset;\n              t.loading = !1, u > o && (o = u, i.requestLessPieData(t.id), t.loading = !0), h < l && (l = h, n.done || (i.requestMorePieData(t.id), t.loading = !0));\n              var c = t.offset + t.items.length;\n              if ((l < t.offset || o > c) && (t.offset = o, t.items = [], c = o), o > t.offset) t.items = t.items.slice(o - t.offset);else if (o < t.offset) {\n                for (var d = [], p = o; p <= t.offset - 1; p++) {\n                  d.push(this.buildItem(t, n, p));\n                }\n\n                t.items = d.concat(t.items), r = !0;\n              }\n              if (t.offset = o, l < c) t.items = t.items.slice(0, l - t.offset);else if (l > c) {\n                for (p = c; p < l; p++) {\n                  t.items.push(this.buildItem(t, n, p));\n                }\n\n                r = !0;\n              }\n\n              if (t.count = t.items.length, t.totalCount = Math.max(t.offset + t.count, n.totalCount || 0), r) {\n                if (e) e.changes.items = !0, e.changes.changedItems || (e.changes.changedItems = {}), e.changes.changedItems[t.id] = !0;else {\n                  var f = {};\n                  f[t.id] = !0, this.chart.events.notifySceneChanges({\n                    items: !0,\n                    changedItems: f\n                  });\n                }\n                this.resetSelection() && this.chart.events.notifySceneChanges({\n                  items: !0\n                });\n              }\n\n              this.scene.updateLinks(t);\n            }, t.prototype.resetSelection = function () {\n              for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {\n                var n = i[e];\n                t.selectionIds.push(n.id), n.selected = !1;\n              }\n\n              return t.selection = [], t.selectionIds.length > 0;\n            }, t.prototype.rebuildValues = function (t) {\n              for (var e = 0; e < t.items.length; e++) {\n                var i = t.items[e];\n                this.updateItem(i);\n              }\n            }, t.prototype.buildItem = function (t, e, i) {\n              var n = e.values[i - e.offset],\n                  r = new M(t, n.__id, i, n);\n              return this.updateItem(r), r;\n            }, t.prototype.updateItem = function (t) {\n              for (var e = [], i = 0; i < this.scene.settings._computedSeries.length; i++) {\n                var n = this.scene.settings._computedSeries[i],\n                    r = new I(t.facet, t.id, t.index, t.data, n.id);\n                t.data ? r.value = this.getSeriesValue(t.data, n) : r.value = null, e.push(r);\n              }\n\n              t.values = e;\n            }, t.prototype.getSeriesValue = function (t, e) {\n              var i = e.data.valueFunction,\n                  n = null;\n              i ? n = i(t) : n = t[e.data.field || \"value\"];\n              return h.Helpers.tryParseFloat(n, null);\n            }, t.prototype.buildPreviewData = function (t, e) {\n              var i = t.id,\n                  n = this.scene.mainData,\n                  r = n.getPieData(i),\n                  s = null;\n              if (r) {\n                if (r.offset > 0) n.requestLessPieData(t.id);else {\n                  s = [];\n\n                  for (var a = 0, o = 0; o < r.values.length; o++) {\n                    var l = r.values[o],\n                        h = this.getSeriesValue(l, e);\n                    s.push(h), a += h;\n                  }\n\n                  if (a > 0) {\n                    a = 1 / a;\n\n                    for (var u = 0; u < s.length; u++) {\n                      s[u] = s[u] * a;\n                    }\n                  } else s = null;\n                }\n              } else t.expandable && n.canExpand(i) && n.requestPieData(t.id, 0);\n              return s;\n            }, t;\n          }();\n\n          t.Builder = O;\n\n          var E = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 200, i.paintOrder = 20, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i;\n            }\n\n            return r(e, t), e.prototype.doAnimations = function (t) {\n              var e = t.changes;\n\n              if (e.settings || e.items || e.selection || e.navigation || e.style) {\n                var i = this.scene.activeFacet;\n                if (i) for (this.computeFacetStyleRec(i); i && i.parentItem;) {\n                  i = i.parentItem.facet, this.computeFacetStyleRec(i);\n                }\n              }\n            }, e.prototype.computeFacetStyleRec = function (t) {\n              this.computeFacetStyle(t);\n\n              for (var e = 0; e < t.items.length; e++) {\n                var i = t.items[e];\n                this.computeItemStyle(t, i), i.innerFacet && this.computeFacetStyleRec(i.innerFacet);\n              }\n            }, e.prototype.computeFacetStyle = function (t) {}, e.prototype.computeItemStyle = function (t, e) {\n              var i = this.scene.settings._computedSeries;\n              if (h.Helpers.extendStyleTo(this.scene.settings.items.style, e), e.data.style && h.SettingsHelper.updateRecursive(e, e.data.style, h.SettingsMapping.FacetChartSettingsFacetStyle, {}), e.id === e.facet.activeItemId) for (var n = 0; n < e.values.length; n++) {\n                (r = e.values[n]).style.fillColor = null, r.style.lineColor = null;\n              } else for (n = 0; n < e.values.length; n++) {\n                var r = e.values[n];\n                h.Helpers.extendStyleTo(i[n].style, r.style);\n              }\n              if (this.scene.settings.items.styleFunction ? (this.scene.settings.items.styleFunction(e, e.data), e.label && !h.Helpers.isString(e.label) && (e.label = \"\" + e.label)) : e.data.name && (e.label = e.data.name), e.id !== e.facet.activeItemId) for (n = 0; n < e.values.length; n++) {\n                r = e.values[n];\n                var s = i[n];\n                r.style.previewContents ? r.previewData = this.chart.builder.buildPreviewData(e, s) : r.previewData = null;\n              } else e.values[e.values.length - 1].previewData = null;\n            }, e;\n          }(h.ChartElement);\n\n          t.Styles = E;\n\n          var R = function (t) {\n            function e(e, i) {\n              var n = t.call(this, new f(e), new P(), i) || this;\n              return n.builder = new O(n), n.renderer = n.events.addElement(new F(n)), n.scrolling = n.events.addElement(new D(n)), n.selection = n.events.addElement(new l(n)), n.events.addElement(new E(n)), n.infoPopup = new u(n), n.events.addElement(n.infoPopup), n.events.addElement(new a.Highlights(n)), n.scrollButtons = n.events.addElement(new d(n)), n.finalInitialize(), n.scrolling.setState(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, 0, \"init\"), n;\n            }\n\n            return r(e, t), e.prototype.createDataObj = function (t) {\n              return new s.Data(this, t, !0);\n            }, e.prototype.getData = function (e) {\n              return t.prototype.getData.call(this, e);\n            }, e.prototype.onSettingsChanged = function (t) {\n              var e = {\n                settings: !0,\n                settingsChanges: t,\n                items: !1\n              };\n              t.navigation && this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, \"api\"), (t.series || t.interaction) && (e.items = !0), this.events.notifySceneChanges(e), (t.data || t.facetAxis) && this.updateSize(!0);\n            }, e.prototype.updateFilters = function () {\n              return this.updateFilter(!0);\n            }, e.prototype.updateFilter = function (t) {\n              void 0 === t && (t = !1), this.log(\"Update filter\");\n              var e = {};\n\n              for (var i in this.settings._computedDataMap) {\n                e[i] = !0;\n              }\n\n              this.events.notifySceneChanges({\n                data: e,\n                dataDeep: t\n              });\n            }, e.prototype.setSelection = function (t, e) {\n              void 0 === e && (e = \"api\"), this.log(\"Set selection\");\n\n              for (var i = [], n = [], r = 0; r < t.length; r++) {\n                var s = t[r];\n                s instanceof M ? i.push(s) : h.Helpers.isString(s) ? n.push(s) : this.error(\"SetSelection: Selection contents must be FacetChart.Item object or string, got \" + typeof s);\n              }\n\n              this.selection.setSelection(i, n, !1, e);\n            }, e.prototype.exportVisibleData = function () {\n              var t = this.scene.peek();\n              return t ? s.Data.exportValues(t.data) : [];\n            }, e.prototype.setPie = function (t, e, i, n) {\n              void 0 === i && (i = null), void 0 === n && (n = !0), this.log(\"Set pie\"), this.scrolling.setState(t, e, i, \"api\");\n            }, e.prototype.getPie = function () {\n              return this.scrolling.getState().idArray;\n            }, e.prototype.getPieOffset = function () {\n              return this.scrolling.getState().offset;\n            }, e.prototype.getActiveItems = function () {\n              for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n                var i = this.scene.stack[e];\n                i.parentItem && t.push(i.parentItem);\n              }\n\n              return t;\n            }, e.prototype.getActiveFacets = function () {\n              return this.scene.stack;\n            }, e.prototype.zoomOut = function (t, e) {\n              void 0 === t && (t = !0), void 0 === e && (e = \"api\"), this.setSelection([]), this.scrolling.goUp(e);\n            }, e.prototype.zoomOutPossible = function () {\n              var t = this.scene;\n              return t.length() > 1 || t.peek() && t.peek().offset > 0;\n            }, e.prototype.getBottomHeight = function () {\n              return this.scene.chartHeight - this.settings.facetAxis.size;\n            }, e.prototype.expandItem = function (t, e) {\n              if (t.facet === this.scene.peek()) {\n                var i = t.id;\n                if (t.expandable && this.scene.mainData.canExpand(i)) return this.setSelection([]), this.scrolling.drillDown(i, e), !0;\n              }\n\n              return !1;\n            }, e.prototype.saveNavigation = function () {\n              return !this.scene.peek() || this.scrolling.isActive() ? null : this.scrolling.getState();\n            }, e.prototype.restoreNavigation = function (t, e, i) {\n              return this.scrolling.setState(t.idArray, t.offset, t.count, i);\n            }, e.prototype.save = function () {\n              for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {\n                var i = this.scene.selection[e];\n                t.push(i.id);\n              }\n\n              var n = this.scrolling.getState();\n              return JSON.stringify({\n                pie: n.idArray,\n                offset: n.offset,\n                count: n.count,\n                selection: t\n              });\n            }, e.prototype.restore = function (t, e) {\n              if (t) {\n                var i = JSON.parse(t);\n                this.setPie(i.pie, i.offset, i.count, e), this.setSelection(i.selection);\n              }\n            }, e.prototype.createEventArguments = function (t, e, i) {\n              var n = this.scene;\n              if (!n) return {\n                chart: this.api,\n                origin: e\n              };\n              var r = n.peek(),\n                  s = i && i.facet,\n                  a = n.hoverSeriesItem,\n                  o = a && null != a.seriesIndex ? n.settings._computedSeries[a.seriesIndex] : null;\n              return {\n                chart: this.api,\n                origin: e,\n                facet: r,\n                offset: r && r.offset,\n                count: r && r.count,\n                hoverItem: n.hoverItem,\n                hoverSeries: o,\n                hoverMarker: !!a && a.isMarker,\n                selection: n.selection.slice(),\n                clickItem: i,\n                clickFacet: s,\n                clickOrigin: null\n              };\n            }, e.prototype.defaultClick = function (t, e) {\n              this.selection.defaultClick(t, e);\n            }, e.prototype.remove = function () {\n              t.prototype.remove.call(this), this.infoPopup.remove();\n            }, e;\n          }(a.Impl);\n\n          t.Impl = R;\n        }(n.FacetChart || (n.FacetChart = {})), function (t) {\n          function i(t) {\n            return t ? t.properties && t.properties.id && h.Helpers.isString(t.properties.id) ? t.properties.id : t.id : null;\n          }\n\n          function s(t) {\n            if (!Array.isArray(t)) return \"GeoJSON LineString data contained invalid coordinate collection.\";\n            if (t.length < 2) return \"GeoJSON LineString data must contain at least 2 points.\";\n\n            for (var e = new Array(2 * t.length), i = 0; i < t.length; i++) {\n              var n = t[i];\n              if (!n || !h.Helpers.isNumber(n[0]) || !h.Helpers.isNumber(n[1])) return \"GeoJSON LineString data contained invalid coordinates.\";\n              e[2 * i] = n[0], e[2 * i + 1] = n[1];\n            }\n\n            return e;\n          }\n\n          function a(t, e) {\n            if (!Array.isArray(t)) return \"GeoJSON Polygon data contained invalid coordinate collection.\";\n            if (t.length < 1) return \"GeoJSON Polygon data doesn't contain any LinearRings.\";\n\n            for (var i = 0; i < t.length; i++) {\n              var n = s(t[i]);\n              if (h.Helpers.isString(n)) return n;\n              e.push(n);\n            }\n\n            return null;\n          }\n\n          function l(t) {\n            return h.Helpers.isNumber(t[0]) && h.Helpers.isNumber(t[1]) ? [t[0], t[1]] : \"GeoJSON data contained invalid coordinates.\";\n          }\n\n          function u(t) {\n            var e = s(t.coordinates);\n            return h.Helpers.isString(e) ? e : [e];\n          }\n\n          function c(t) {\n            var e = t.coordinates;\n            if (!Array.isArray(e)) return \"GeoJSON MultiLineString data contained invalid coordinates\";\n            if (e.length < 1) return \"GeoJSON MultiLineString data doesn't contain any lines.\";\n\n            for (var i = new Array(e.length), n = 0; n < e.length; n++) {\n              var r = s(e[n]);\n              if (h.Helpers.isString(r)) return r;\n              i[n] = r;\n            }\n\n            return i;\n          }\n\n          function d(t, e, n, r, s, a) {\n            h.Helpers.isString(e) ? a(e, r) : t.push({\n              _x: 0,\n              _y: 0,\n              id: i(r),\n              loaded: !0,\n              coordinates: e,\n              type: n,\n              shapeFeature: r,\n              shapeGeometry: s\n            });\n          }\n\n          function p(t, e, i, n) {\n            if (Array.isArray(e.coordinates)) switch (e.type) {\n              case \"Point\":\n                d(t, l(e.coordinates), \"point\", i, e, n);\n                break;\n\n              case \"MultiPoint\":\n                var r = e;\n                if (Array.isArray(r.coordinates)) for (var s = 0; s < r.coordinates.length; s++) {\n                  d(t, l(r.coordinates[s]), \"point\", i, e, n);\n                } else n(\"GeoJSON data contained invalid MultiPoint object.\", i);\n                break;\n\n              case \"LineString\":\n                d(t, u(e), \"line\", i, e, n);\n                break;\n\n              case \"MultiLineString\":\n                d(t, c(e), \"line\", i, e, n);\n                break;\n\n              case \"Polygon\":\n                d(t, function (t) {\n                  var e = [],\n                      i = a(t.coordinates, e);\n                  return i || e;\n                }(e), \"polygon\", i, e, n);\n                break;\n\n              case \"MultiPolygon\":\n                d(t, function (t) {\n                  var e = t.coordinates;\n                  if (!Array.isArray(e)) return \"GeoJSON MultiPolygon data contained invalid coordinates\";\n                  if (e.length < 1) return \"GeoJSON MultiPolygon data doesn't contain any Polygons.\";\n\n                  for (var i = [], n = 0; n < e.length; n++) {\n                    var r = a(e[n], i);\n                    if (r) return r;\n                  }\n\n                  return i;\n                }(e), \"polygon\", i, e, n);\n                break;\n\n              default:\n                return void n('GeoJSON data contained unknown object with type \"' + e.type + '\" .', i);\n            } else n(\"GeoJSON data contained invalid object.\", i);\n          }\n\n          function f(t, e, i, n) {\n            if (\"GeometryCollection\" === e.type) {\n              var r = e;\n              if (Array.isArray(r.geometries)) for (var s = 0; s < r.geometries.length; s++) {\n                f(t, r.geometries[s], i, n);\n              } else n(\"GeoJSON data contained invalid GeometryCollection object.\", i);\n            } else p(t, e, i, n);\n          }\n\n          function g(t, e, i) {\n            return e.geometry && \"Feature\" === e.type ? void f(t, e.geometry, e, i) : void i(\"GeoJSON data contained invalid feature object.\", e);\n          }\n\n          function m(t, e) {\n            function n(t, n) {\n              e.error(\"Error: \" + t + \" Feature id: '\" + i(n) + \"'\");\n            }\n\n            if (!t) return [];\n            var r = [];\n\n            switch (t.type) {\n              case \"FeatureCollection\":\n                !function (t, e, i) {\n                  if (Array.isArray(e.features) && \"FeatureCollection\" === e.type) for (var n = 0; n < e.features.length; n++) {\n                    g(t, e.features[n], i);\n                  } else i(\"GeoJSON data contained invalid FeatureCollection object.\", null);\n                }(r, t, n);\n                break;\n\n              case \"Feature\":\n                g(r, t, n);\n                break;\n\n              case \"GeometryCollection\":\n                f(r, t, null, n);\n                break;\n\n              case \"Point\":\n              case \"MultiPoint\":\n              case \"LineString\":\n              case \"MultiLineString\":\n              case \"Polygon\":\n              case \"MultiPolygon\":\n                p(r, t, null, n);\n                break;\n\n              default:\n                return void n('GeoJSON data contained unknown object with type \"' + t.type + '\" .', null);\n            }\n\n            for (var s = {\n              \"##default\": 0\n            }, a = 0; a < r.length; a++) {\n              var o = r[a];\n              null == o.id ? o.id = \"##default\" + h.Helpers.SeparatorChar + s[\"##default\"]++ : h.Helpers.hasProperty(s, o.id) ? o.id += h.Helpers.SeparatorChar + s[o.id]++ : s[o.id] = 0;\n            }\n\n            return r;\n          }\n\n          t.convertFromGeoJson = m;\n\n          var v = function () {\n            return function (t, e, i) {\n              this.nodes = {}, this.links = {}, this.area = new h.AreaCollection(), this.requestedArea = new h.AreaCollection(), this.pendingArea = null, this.cacheId = i, this.id = e, this.level = t;\n            };\n          }();\n\n          t.DataLayer = v;\n\n          var y = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.dataFunction = null, e.preloaded = null, e.prefetchRatio = 1, e.bounds = [-180, -85.0511287798, 180, 85.0511287798], e.wrapLng = !0, e.maxRequestRect = [256, 256], e.perBoundsData = !0, e.perZoomData = !1, e.perDrilldownData = !1, e.useGridBasedAggregation = !1, e.aggregationGridSize = 100, e.aggregationMinCount = 5, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsData);\n\n          t.SettingsData = y;\n\n          var S = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e, i) || this;\n              n.layers = {}, n.pendingLayers = [], n.nextId = 0, n.aggregationGridSize = 1, n.zoomLevel = null, n.projectFun = function (t, e) {\n                return n.chart.scene.project(t, e);\n              }, n.unprojectFun = function (t, e) {\n                return n.chart.scene.unproject(t, e);\n              };\n              var r = n.projectFun(n.dataSettings.bounds[0], n.dataSettings.bounds[1]),\n                  s = n.projectFun(n.dataSettings.bounds[2], n.dataSettings.bounds[3]);\n              return n.projectedBounds = new h.Rect(Math.min(r.x, s.x), Math.min(r.y, s.y), Math.max(r.x, s.x), Math.max(r.y, s.y)), n;\n            }\n\n            return r(e, t), e.prototype.getProjectedBounds = function () {\n              return this.projectedBounds;\n            }, e.prototype.setViewParams = function (t, e, i, n, r) {\n              this.dataSettings.perZoomData ? this.zoomLevel = e : this.zoomLevel = null, this.aggregationGridSize = t, this.loadDataArea = this.buildRectArea(r), this.returnDataArea = this.buildRectArea(n), this.visibleArea = this.buildRectArea(i), this.pendingLayers = [];\n            }, e.prototype.getLayer = function (t) {\n              var e,\n                  i = \"\",\n                  n = null;\n              return t && (i += \"\" + t), null !== this.zoomLevel && (i += \"#z\" + this.zoomLevel, n = this.zoomLevel), e = this.layers.hasOwnProperty(i) ? this.layers[i] : this.layers[i] = new v(n, t, i), this.lastLayer = e, e;\n            }, e.prototype.getData = function (t) {\n              var e,\n                  i = this.getLayer(t);\n              i.area.coversArea(this.loadDataArea) ? (i.pendingArea = new h.AreaCollection(), e = !1) : i.requestedArea.coversArea(this.loadDataArea) ? e = this.hasPendingRequests() : (i.pendingArea = this.loadDataArea.makeCopy().subtractArea(i.requestedArea), i.pendingArea.isEmpty() || (this.pendingLayers.indexOf(i) < 0 && this.pendingLayers.push(i), this.scheduleRequests(!0)), e = this.hasPendingRequests());\n              var n = this.applyFilters(i, this.returnDataArea);\n              return this.chart.log(\"Data: returned \" + n.nodes.length + \" nodes and \" + n.links.length + \" links for ID: \" + t + \", loading=\" + e), {\n                nodes: n.nodes,\n                links: n.links,\n                hasData: i.area.intersectsArea(this.visibleArea),\n                loading: e\n              };\n            }, e.prototype.applyFilters = function (t, e) {\n              var i,\n                  n = e.toRects(),\n                  r = this.settings.filters.nodeFilter,\n                  s = [],\n                  a = [],\n                  o = {};\n\n              for (var l in t.nodes) {\n                var h = t.nodes[l],\n                    u = h._bounds;\n                if (!r || r(h)) for (i = 0; i < n.length; i++) {\n                  if (n[i].overlapsRect(u.x0, u.y0, u.x1, u.y1)) {\n                    s.push(h), o[l] = !0;\n                    break;\n                  }\n                }\n              }\n\n              for (var l in t.links) {\n                var c = t.links[l],\n                    d = o[c.from],\n                    p = o[c.to];\n                if (d || p) a.push(c), d || (o[c.from] = !0, s.push(t.nodes[c.from])), p || (o[c.to] = !0, s.push(t.nodes[c.to]));else {\n                  var f = t.nodes[c.from],\n                      g = t.nodes[c.to];\n\n                  if (f._x && g._x) {\n                    var m = f._x,\n                        v = f._y,\n                        y = g._x,\n                        S = g._y;\n\n                    for (i = 0; i < n.length; i++) {\n                      if (n[i].intersectsSegment(m, v, y, S)) {\n                        s.push(f), s.push(g), o[c.from] = !0, o[c.to] = !0;\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n\n              return {\n                nodes: s,\n                links: a\n              };\n            }, e.prototype.unprojectRect = function (t) {\n              var e = this.unprojectFun(t.x0, t.y0),\n                  i = this.unprojectFun(t.x1, t.y1);\n              return new h.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat));\n            }, e.prototype.projectRect = function (t) {\n              var e = this.projectFun(t.x0, t.y0),\n                  i = this.projectFun(t.x1, t.y1);\n              return new h.Rect(Math.min(e.x, i.x), Math.min(e.y, i.y), Math.max(e.x, i.x), Math.max(e.y, i.y));\n            }, e.prototype.buildRectArea = function (t) {\n              var e = this.projectedBounds,\n                  i = t.x0,\n                  n = t.y0,\n                  r = t.x1,\n                  s = t.y1,\n                  a = new h.AreaCollection();\n\n              if (n = Math.max(n, e.y0), s = Math.min(s, e.y1), this.dataSettings.wrapLng) {\n                var o = e.x1 - e.x0;\n                if (r - i > o) i = e.x0, r = e.x1;else {\n                  for (; i < e.x0;) {\n                    i += o, r += o;\n                  }\n\n                  for (; i > e.x1;) {\n                    i -= o, r -= o;\n                  }\n                }\n                r <= e.x1 ? a.addRect(new h.Rect(i, n, r, s)) : (a.addRect(new h.Rect(i, n, e.x1, s)), a.addRect(new h.Rect(e.x0, n, r - o, s)));\n              } else a.addRect(t.clone().clip(e));\n\n              return a;\n            }, e.prototype.buildRequest = function () {\n              if (this.pendingLayers.length > 0) {\n                var t = this.pendingLayers[0],\n                    e = t.pendingArea.findOverlappingRect(this.dataSettings.maxRequestRect[0], this.dataSettings.maxRequestRect[1]);\n                t.pendingArea.subtractRect(e), t.pendingArea.isEmpty() && h.Helpers.removeFromArray(this.pendingLayers, t);\n                var i = e,\n                    n = [],\n                    r = [];\n\n                if (this.dataSettings.useGridBasedAggregation) {\n                  var s = this.buildAggregationRequest(e);\n                  i = s.rectangle, n = s.xcuts, r = s.ycuts;\n                }\n\n                t.requestedArea.addRect(i);\n                var a = this.unprojectRect(i);\n                return {\n                  id: t.id,\n                  layerId: t.cacheId,\n                  west: a.x0,\n                  north: a.y1,\n                  east: a.x1,\n                  south: a.y0,\n                  zoom: this.zoomLevel,\n                  aggregateLat: r,\n                  aggregateLng: n,\n                  aggregateMinItems: this.dataSettings.aggregationMinCount\n                };\n              }\n\n              return null;\n            }, e.prototype.buildAggregationRequest = function (t) {\n              for (var e = this.aggregationGridSize, i = Math.floor(t.x0 / e) * e, n = Math.ceil(t.x1 / e) * e, r = Math.floor(t.y0 / e) * e, s = Math.ceil(t.y1 / e) * e, a = this.dataSettings.bounds[0], o = this.dataSettings.bounds[1], l = this.dataSettings.bounds[2], u = this.dataSettings.bounds[3], c = [], d = [], p = i; p <= n; p += e) {\n                c.push(Math.min(Math.max(this.unprojectFun(p, r).lng, a), l));\n              }\n\n              for (var f = r; f <= s; f += e) {\n                d.push(Math.min(Math.max(this.unprojectFun(i, f).lat, o), u));\n              }\n\n              return {\n                rectangle: new h.Rect(i, r, n, s),\n                xcuts: c,\n                ycuts: d\n              };\n            }, e.prototype.dataFunc = function (t, e, i) {\n              var n = this.dataSettings;\n              if (n.dataFunction) n.dataFunction(t, e, i);else if (n.url) {\n                var r = [[\"id\", t.id], [\"south\", t.south.toString(10)], [\"west\", t.west.toString(10)], [\"north\", t.north.toString(10)], [\"east\", t.east.toString(10)]];\n                (t.aggregateLat.length || t.aggregateLng.length) && (r.push([\"aggregateLat\", t.aggregateLat.join(\",\")]), r.push([\"aggregateLng\", t.aggregateLng.join(\",\")]), r.push([\"aggregateMinItems\", t.aggregateMinItems.toString(10)])), null !== t.zoom && r.push([\"zoom\", t.zoom.toString(10)]), h.Data.doRequest(n.url, n, r, e, i);\n              } else i({\n                error: \"Chart configuration does not define data retrieval function\"\n              });\n            }, e.prototype.verifyData = function (t, e) {\n              \"geojson\" === this.dataSettings.format.toLowerCase() && (e.nodes = m(e, this.chart));\n              var i = !0;\n              e.hasOwnProperty(\"nodes\") || (e.nodes = []), e.hasOwnProperty(\"links\") || (e.links = []);\n              var n = h.Helpers.tryParseFloat(e.west, t ? t.west : 1 / 0),\n                  r = h.Helpers.tryParseFloat(e.east, t ? t.east : -1 / 0),\n                  s = h.Helpers.tryParseFloat(e.north, t ? t.north : 1 / 0),\n                  a = h.Helpers.tryParseFloat(e.south, t ? t.south : -1 / 0);\n              e._bounds = new h.Rect(n, a, r, s);\n\n              for (var o = {}, l = 0; l < e.nodes.length; l++) {\n                var u = e.nodes[l];\n                if (Array.isArray(u.coordinates) || (this.chart.error(\"Data response: Node has no coordinates, or not an array\"), i = !1), u.aggregate) h.Helpers.isNumber(u.count) || (this.chart.error(\"Aggregated node needs `count` field that contains a number.\"), i = !1);else if (u.hasOwnProperty(\"id\")) {\n                  var c = u.id.toString();\n                  o.hasOwnProperty(c) && this.chart.error(\"Data response: Multiple nodes with same id: \" + c), o[c] = !0;\n                } else this.chart.error(\"Data response: Node without ID\"), i = !1;\n              }\n\n              for (var d = {}, p = 0; p < e.links.length; p++) {\n                var f = e.links[p];\n                f.hasOwnProperty(\"id\") ? d.hasOwnProperty(f.id) && this.chart.error(\"Data response: Multiple links with the same ID: \" + f.id) : f.id = h.Helpers.SeparatorChar + (this.nextId++).toString(10), o[f.from] || o[f.to] || this.chart.error(\"Data response: Returned link that does not match any node: \" + f.id), d[f.id] = !0;\n              }\n\n              return i;\n            }, e.prototype.addVerifiedData = function (t, e) {\n              var i, n;\n              t ? (n = t.id, i = t.layerId) : (i = \"\", n = \"\");\n              var r,\n                  s,\n                  a = this.layers[i];\n              if (a || (a = this.getLayer(n)), e.clearCache) a.nodes = {}, a.links = {}, a.area = new h.AreaCollection(), a.area.addRect(this.projectedBounds);else if (e._bounds.x0 !== 1 / 0) {\n                var o = this.projectRect(e._bounds);\n\n                for (var l in a.nodes) {\n                  r = a.nodes[l], o.overlaps(r._bounds) && delete a.nodes[l];\n                }\n\n                for (var l in a.links) {\n                  s = a.links[l], a.nodes[s.from] && a.nodes[s.to] || delete a.links[l];\n                }\n\n                a.area.addRect(o);\n              } else a.area.addRect(this.projectedBounds);\n\n              for (var u = {}, c = 0; c < e.nodes.length; c++) {\n                (r = e.nodes[c]).loaded = !0, r.aggregate ? (r.id = h.Helpers.SeparatorChar + this.nextId, this.nextId++, a.nodes[r.id] = r) : (u[r.id] = !0, a.nodes.hasOwnProperty(r.id) ? h.Helpers.extendDeep(a.nodes[r.id], r) : a.nodes[r.id] = r), r.coordinates && (Array.isArray(r.coordinates[0]) ? this.prepareShape(r) : this.preparePoint(r));\n              }\n\n              for (var d = {}, p = 0; p < e.links.length; p++) {\n                d[(s = e.links[p]).id] = !0, a.links[s.id] = s;\n              }\n\n              var f = {};\n              f[n || \"\"] = {\n                nodes: u,\n                links: d\n              };\n              var g = {};\n              return g[this.dataSettings.id] = f, {\n                geoChartDataNodesIds: g\n              };\n            }, e.prototype.prepareShape = function (t) {\n              for (var e = [], i = h.Rect.createEmpty(), n = 0; n < t.coordinates.length; n++) {\n                var r = t.coordinates[n],\n                    s = this.projectLineString(r, i);\n                e.push(s);\n              }\n\n              t._bounds = i, t._coordinates = e;\n            }, e.prototype.preparePoint = function (t) {\n              if (2 === t.coordinates.length) {\n                var e = t.coordinates,\n                    i = e[0],\n                    n = e[1],\n                    r = this.projectFun(i, n);\n                t._x = r.x, t._y = r.y, t._bounds = new h.Rect(r.x, r.y, r.x, r.y);\n              } else this.chart.error(\"Point coordinates must be an array of two numbers.\");\n            }, e.prototype.projectLineString = function (t, e) {\n              for (var i = [], n = 0; n < t.length - 1; n += 2) {\n                var r = this.projectFun(t[n], t[n + 1]);\n                i.push(r.x), i.push(r.y), e.addPoint(r.x, r.y);\n              }\n\n              return i;\n            }, e.prototype.exportAreas = function () {\n              var t = this.lastLayer.area.toRects(),\n                  e = this.lastLayer.requestedArea.toRects(),\n                  i = this.lastLayer.pendingArea.toRects();\n              return this.projectRects(t), this.projectRects(e), this.projectRects(i), {\n                areasRects: t,\n                reqAreasRects: e,\n                pendingAreasRects: i\n              };\n            }, e.prototype.projectRects = function (t) {\n              for (var e = 0; e < t.length; e++) {\n                var i = t[e],\n                    n = this.projectFun(i.x0, i.y0);\n\n                if (i.x0 = n.x, i.y0 = n.y, n = this.projectFun(i.x1, i.y1), i.x1 = n.x, i.y1 = n.y, i.y1 < i.y0) {\n                  var r = i.y0;\n                  i.y0 = i.y1, i.y1 = r;\n                }\n              }\n            }, e;\n          }(h.Data);\n\n          t.Data = S, t.Leaflet = null, \"undefined\" != typeof L && (t.Leaflet = L);\n\n          var b = function () {\n            function e(t, e, i) {\n              var n = this;\n              this.layers = i, this.chartContainer = e, this.chart = t, this.wasDragged = null, this.wasZoomed = !1, this.translate = null, this.updatePosDelegate = function () {\n                return n.updatePos();\n              }, this.onZoomDelegate = function (t) {\n                return n.onZoom(t);\n              }, this.viewResetDelegate = function () {\n                return n.viewReset();\n              }, this.userActionEndDelegate = function () {\n                return n.userActionEnd();\n              }, this.userActionStartDelegate = function () {\n                return n.userActionStart();\n              };\n            }\n\n            return e.prototype.extendLayer = function (t) {\n              var e = this,\n                  i = t.onAdd,\n                  n = t.onRemove;\n              t.onAdd = function (n) {\n                return e.onAdd(n), i ? i.call(t, n) : t;\n              }, t.onRemove = function (i) {\n                return e.onRemove(i), n ? n.call(t, i) : t;\n              };\n            }, e.prototype.onAdd = function (t) {\n              return this.map = t, t.getPanes().overlayPane.appendChild(this.chartContainer), t.on(\"move\", this.updatePosDelegate, this), t.on(\"zoomanim\", this.onZoomDelegate, this), t.on(\"viewreset\", this.viewResetDelegate, this), t.on(\"moveend\", this.userActionEndDelegate, this), t.on(\"movestart\", this.userActionStartDelegate, this), this.updatePos(), this;\n            }, e.prototype.onRemove = function (t) {\n              return t.getPanes().overlayPane.removeChild(this.chartContainer), t.off(\"move\", this.updatePosDelegate, this), t.off(\"zoomanim\", this.onZoomDelegate, this), t.off(\"viewreset\", this.viewResetDelegate, this), t.off(\"moveend\", this.userActionEndDelegate, this), t.off(\"movestart\", this.userActionStartDelegate, this), this;\n            }, e.prototype.userActionStart = function () {\n              this.wasDragged = !0;\n            }, e.prototype.userActionEnd = function () {\n              var t;\n              t = !0 === this.wasDragged ? \"user\" : null === this.wasDragged ? \"init\" : \"api\", this.chart.notifyChartUpdate(t), this.wasDragged = !1;\n            }, e.prototype.viewReset = function () {\n              this.updatePos(), this.userActionEnd();\n            }, e.prototype.setTranslate = function () {\n              null !== this.translate && (this.chartContainer.style[t.Leaflet.DomUtil.TRANSFORM] = this.translate, this.chartContainer.style[t.Leaflet.DomUtil.TRANSFORM + \"Origin\"] = \"50% 50%\", this.translate = null);\n            }, e.prototype.getTranslateString = function (t) {\n              var e = L.Browser.webkit3d,\n                  i = (e ? \",0\" : \"\") + \")\";\n              return \"translate\" + (e ? \"3d\" : \"\") + \"(\" + t.x + \"px,\" + t.y + \"px\" + i;\n            }, e.prototype.updatePos = function () {\n              if (this.map) {\n                var e = this.map.options.crs,\n                    i = this.chart.scene;\n                this.offset = this.map.containerPointToLayerPoint(t.Leaflet.point(0, 0)), this.chartContainer.setAttribute(\"class\", \" \"), this.translate = this.getTranslateString(this.offset);\n                var n = this.map.getPixelBounds(),\n                    r = e.transformation.untransform(n.min, e.scale(this.map.getZoom()));\n                r = e.transformation.transform(r, e.scale(0));\n                var s = e.transformation.untransform(n.max, e.scale(this.map.getZoom()));\n                s = e.transformation.transform(s, e.scale(0));\n                var a = this.map.getZoom();\n                a !== i.zoomLevel && (i.zoom = Math.pow(2, a), i.zoomLevel = a, this.wasZoomed = !0), i.centerX = (s.x + r.x) / 2, i.centerY = (s.y + r.y) / 2, this.chart.events && !this.layers.resizing && (this.wasZoomed ? (this.chart.events.notifySceneChanges({\n                  zoom: !0,\n                  position: !0\n                }), this.wasZoomed = !1) : this.chart.events.notifySceneChanges({\n                  position: !0\n                }));\n              }\n            }, e.prototype.onZoom = function (e) {\n              var i = this.map.getZoomScale(e.zoom),\n                  n = this.map.latLngToLayerPoint(e.center).subtract(this.map.containerPointToLayerPoint(this.map.getSize().divideBy(2))).multiplyBy(-i).add(this.map.containerPointToLayerPoint(t.Leaflet.point(0, 0)));\n              this.chartContainer.setAttribute(\"class\", \" leaflet-zoom-animated\"), this.translate = this.getTranslateString(n) + \" scale(\" + i + \") \", this.setTranslate(), this.wasZoomed = !0;\n            }, e;\n          }(),\n              C = function () {\n            return function () {\n              this.enabled = !0, this.type = \"tile\", this.url = \"https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png\", this.params = {\n                subdomains: \"abcd\",\n                attribution: '&copy; <a target=\"_blank\" href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a>, &copy; <a href=\"https://cartodb.com/attributions\" target=\"_blank\">CartoDB</a>'\n              };\n            };\n          }();\n\n          t.SettingsBackground = C;\n\n          var x = function (e) {\n            function i(t) {\n              var i = e.call(this, t) || this;\n              return i.animationOrder = 100, i.resizing = !1, i._focusHandler = function () {\n                return i.containerOnFocusChange();\n              }, i;\n            }\n\n            return r(i, e), i.prototype.createDom = function (n) {\n              var r = this;\n              e.prototype.createDom.call(this, n), this.leafletContainer = h.Helpers.createDom(\"div\", \"DVSL-leaflet\", null, null), this.container.insertBefore(this.leafletContainer, this.canvas), this.container.removeChild(this.canvas), this.container.removeChild(this.outerBorder), this.container.removeChild(this.interactionContainer), this.interactionContainer.appendChild(this.canvas), this.canvas.style.position = \"static\", this.outerBorder = null, this.menuContainer.className = \"DVSL-menu-container\", this.itemLayer = new b(this.chart, this.interactionContainer, this), i.setContainerStyle(this.leafletContainer), this.chart.scene.project = function (t, e) {\n                return r.projectFunc(t, e);\n              }, this.chart.scene.unproject = function (t, e) {\n                return r.unprojectFunc(t, e);\n              }, null != t.Leaflet ? this.createMap() : this.chart.assetsLoader.ensureAssetsList([\"assets://leaflet.js\"], function (t) {\n                return r.leafletLoaded(t);\n              }), h.Helpers.listen(this.interactionContainer, \"focus\", this._focusHandler), h.Helpers.listen(this.interactionContainer, \"blur\", this._focusHandler), h.Helpers.listen(this.leafletContainer, \"focus\", this._focusHandler), h.Helpers.listen(this.leafletContainer, \"blur\", this._focusHandler);\n            }, i.prototype.containerOnFocusChange = function () {\n              if (this.map) {\n                var t = h.Helpers.isParentOf(this.container, document.activeElement),\n                    e = this.map.scrollWheelZoom;\n                t || !this.chart.settings.advanced.pointer.mouseWheelRequiresFocus ? e.enable() : e.disable();\n              }\n            }, i.prototype.leafletLoaded = function (e) {\n              if (!this.removed) {\n                if (\"undefined\" == typeof L) throw new Error(\"`leaflet.js` was loaded but the global variable `L` was not found. Please make sure that `L.noConflict()` is not called.\");\n                t.Leaflet = L, this.createMap(), e && this.chart.notifyChartUpdate(\"api\");\n              }\n            }, i.prototype.ensureMap = function () {\n              if (!this.map) throw new Error(\"This method is only available after leaflet.js has been loaded.\");\n            }, i.prototype.createMap = function () {\n              var e = this.chart.settings.navigation,\n                  i = {\n                maxZoom: e.maxZoom,\n                minZoom: e.minZoom,\n                zoomDelta: 10,\n                worldCopyJump: !1\n              };\n              this.map = t.Leaflet.map(this.leafletContainer, i), this.map.attributionControl.setPrefix(\"\");\n              var n = e.maxBounds;\n\n              if (this.map.setMaxBounds(new t.Leaflet.LatLngBounds(new t.Leaflet.LatLng(n.south, n.west), new t.Leaflet.LatLng(n.north, n.east))), this.createMapBackground(), L.Layer) {\n                var r = new L.Layer();\n                this.itemLayer.extendLayer(r), this.map.addLayer(r);\n              } else this.map.addLayer(this.itemLayer);\n\n              this.crs = this.map.options.crs, this.containerOnFocusChange(), this.chart.domLayerCreated();\n            }, i.prototype.createMapBackground = function () {\n              var e = this.map,\n                  i = this.tileLayer;\n              i && (e.removeLayer(i), i = null);\n              var n = this.scene.settings.background;\n              n.enabled && (\"tile\" === n.type ? (i = t.Leaflet.tileLayer(n.url, n.params), e.addLayer(i)) : \"wms\" === n.type && (i = t.Leaflet.tileLayer.wms(n.url, n.params), e.addLayer(i))), this.tileLayer = i;\n            }, i.prototype.onSceneChange = function (t) {\n              this.itemLayer.setTranslate();\n            }, i.prototype.remove = function () {\n              this.removed = !0, h.Helpers.unlisten(this.interactionContainer, \"focus\", this._focusHandler), h.Helpers.unlisten(this.interactionContainer, \"blur\", this._focusHandler), h.Helpers.unlisten(this.leafletContainer, \"focus\", this._focusHandler), h.Helpers.unlisten(this.leafletContainer, \"blur\", this._focusHandler), this.map && this.map.remove(), this.map = null;\n            }, i.prototype.updateSettings = function (i) {\n              if (e.prototype.updateSettings.call(this, i), !this.removed && this.leafletContainer && (this.map && i.background && this.createMapBackground(), i.navigation && ((i.navigation.minZoom || i.navigation.maxZoom) && h.Helpers.warn(\"Changing of navigation.minZoom or navigation.maxZoom with updateSettings() is not yet supported.\"), this.map && i.navigation.maxBounds))) {\n                var n = i.navigation.maxBounds;\n                this.map.setMaxBounds(new t.Leaflet.LatLngBounds(new t.Leaflet.LatLng(n.south, n.west), new t.Leaflet.LatLng(n.north, n.east)));\n              }\n            }, i.prototype.projectFunc = function (e, i) {\n              return this.ensureMap(), this.crs.latLngToPoint(new t.Leaflet.LatLng(i, e), 0);\n            }, i.prototype.unprojectFunc = function (e, i) {\n              return this.ensureMap(), this.crs.pointToLatLng(new t.Leaflet.Point(e, i), 0);\n            }, i.prototype.doAnimations = function (t) {\n              if (e.prototype.doAnimations.call(this, t), t.changes.bounds) {\n                var i = this.scene;\n                i.x0 = i.chartLeft, i.y0 = i.chartTop, i.width = i.chartWidth, i.height = i.chartHeight, i.leftMargin = 0, i.rightMargin = 0, i.topMargin = 0, i.bottomMargin = 0, this.map && (this.resizing = !0, this.map.invalidateSize(null), this.resizing = !1), this.interactionContainer.style.width = i.chartWidth + \"px\", this.interactionContainer.style.height = i.chartHeight + \"px\";\n              }\n            }, i;\n          }(h.DomLayer);\n\n          t.DomLayer = x;\n\n          var w = function () {\n            return function () {\n              this.enabled = !1, this.distance = 60, this.maxZoom = 18, this.weightFunction = null, this.ignoreZeroWeight = !1;\n            };\n          }();\n\n          t.SettingsAggregation = w;\n\n          var T = function () {\n            function t(t, e, i) {\n              this.zoom = e.zoom, this.scene = e, this.settings = t, this.chart = i;\n            }\n\n            return t.orientation = function (t, e, i) {\n              var n = (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x);\n              return 0 === n ? 0 : n > 0 ? 1 : -1;\n            }, t.distanceLineToPoint = function (t, e, i) {\n              var n = Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));\n              return Math.abs((i.x - t.x) * (e.y - t.y) - (i.y - t.y) * (e.x - t.x)) / n;\n            }, t.prototype.findMainNodes = function (t, e) {\n              var i = this.settings;\n              i.ignoreZeroWeight && (t = t.slice());\n              var n = {},\n                  r = {},\n                  s = {},\n                  a = h.Helpers.isFunction(i.weightFunction);\n\n              if (a) {\n                for (var o = t.length - 1; o >= 0; o--) {\n                  var l = t[o],\n                      u = i.weightFunction(l);\n\n                  if (i.ignoreZeroWeight && 0 === u) {\n                    var c = t.pop();\n                    o < t.length && (t[o] = c);\n                  } else s[l.id] = u;\n                }\n\n                t.sort(function (t, e) {\n                  return s[e.id] - s[t.id];\n                });\n              }\n\n              var d,\n                  p,\n                  f,\n                  g = this.zoom / (i.distance / 2),\n                  m = [],\n                  v = {};\n\n              for (o = 0; o < t.length; o++) {\n                l = t[o];\n                var y = Math.floor(l._x * g),\n                    S = Math.floor(l._y * g);\n\n                if (void 0 === (d = r[y] || (r[y] = {}))[S] && void 0 === d[S - 1] && void 0 === d[S + 1] && void 0 === (p = r[y - 1] || (r[y - 1] = {}))[S] && void 0 === p[S - 1] && void 0 === p[S + 1] && void 0 === (f = r[y + 1] || (r[y + 1] = {}))[S] && void 0 === f[S - 1] && void 0 === f[S + 1]) {\n                  d[S] = m.length, d[S + 1] = m.length, d[S - 1] = m.length, p[S] = m.length, p[S + 1] = m.length, p[S - 1] = m.length, f[S] = m.length, f[S + 1] = m.length, f[S - 1] = m.length;\n                  var b = a ? s[l.id] || 0 : 1,\n                      C = {\n                    id: \"__aggr_\" + l.id,\n                    aggregatedWeight: b,\n                    _originalWeight: b,\n                    _x: l._x,\n                    _y: l._y,\n                    _bounds: l._bounds,\n                    aggregatedNodes: [l],\n                    loaded: !0\n                  };\n                  m.push(C), n[l.id] = C, v[o] = !0;\n                }\n              }\n\n              var x = [];\n\n              for (o = 0; o < t.length; o++) {\n                if (!v[o]) {\n                  l = t[o], y = Math.floor(l._x * g), S = Math.floor(l._y * g);\n                  var w = m[r[y][S]];\n\n                  if (!w) {\n                    d = r[y] || (r[y] = {}), p = r[y - 1] || (r[y - 1] = {}), f = r[y + 1] || (r[y + 1] = {}), x.push(d[S]), x.push(d[S - 1]), x.push(d[S + 1]), x.push(p[S]), x.push(p[S - 1]), x.push(p[S + 1]), x.push(f[S]), x.push(f[S - 1]), x.push(f[S + 1]);\n\n                    for (var L = 1 / 0; x.length > 0;) {\n                      var T = x.pop();\n\n                      if (void 0 !== T) {\n                        var k = m[T],\n                            A = (k._x - l._x) * (k._x - l._x) + (k._y - l._y) * (k._y - l._y);\n                        A < L && (L = A, w = k);\n                      }\n                    }\n                  }\n\n                  u = a ? s[l.id] || 0 : 1;\n                  (w.aggregatedWeight > 0 || u > 0) && (w._x = (w._x * w.aggregatedWeight + l._x * u) / (w.aggregatedWeight + u), w._y = (w._y * w.aggregatedWeight + l._y * u) / (w.aggregatedWeight + u)), w._originalWeight < u && (w._originalWeight = u, w.id = \"__aggr_\" + l.id), n[l.id] = w, w.aggregatedNodes.push(l), w.aggregatedWeight += u;\n                }\n              }\n\n              for (o = 0; o < m.length; o++) {\n                l = m[o];\n                var M = this.scene.unproject(l._x, l._y);\n                l.coordinates = [M.lng, M.lat];\n              }\n\n              if (i.postProcessAggregatedNodes) {\n                var I = [];\n                i.postProcessAggregatedNodes(m, n, I);\n\n                for (o = 0; o < I.length; o++) {\n                  l = I[o];\n                  var P = this.scene.project(l.coordinates[0], l.coordinates[1]);\n                  l._x = P.x, l._y = P.y;\n                }\n              }\n\n              var D = this.aggregateLinks(e, n);\n              return this.findConvexShapes(m), {\n                nodes: m,\n                links: D\n              };\n            }, t.prototype.aggregateLinks = function (t, e) {\n              for (var i = [], n = {}, r = 0; r < t.length; r++) {\n                var s = t[r],\n                    a = e[s.from],\n                    o = e[s.to];\n\n                if (a && o) {\n                  var l = void 0,\n                      u = a.id + \"-\" + o.id;\n                  h.Helpers.hasProperty(n, u) ? n[u].aggregatedLinks.push(s) : (l = {\n                    id: u,\n                    from: a.id,\n                    to: o.id,\n                    aggregatedLinks: [s]\n                  }, i.push(l), n[u] = l);\n                }\n              }\n\n              return i;\n            }, t.prototype.findConvexShapes = function (e) {\n              for (var i = 0; i < e.length; i++) {\n                for (var n = [], r = e[i].aggregatedNodes, s = r[0], a = r[0], o = 1; o < r.length; o++) {\n                  (u = r[o])._x <= s._x && (s = r[o]), u._x >= a._x && (a = r[o]);\n                }\n\n                var l = [],\n                    h = [];\n\n                for (o = 0; o < r.length; o++) {\n                  var u;\n\n                  if (null != (u = r[o])) {\n                    var c = t.orientation({\n                      x: s._x,\n                      y: s._y\n                    }, {\n                      x: a._x,\n                      y: a._y\n                    }, {\n                      x: u._x,\n                      y: u._y\n                    });\n                    c > 0 ? l.push(u) : c < 0 && h.push(u);\n                  }\n                }\n\n                var d = [s],\n                    p = {};\n                n = [], this.separateOuterPoints(s, a, h, n, p), (d = d.concat(n.sort(function (t, e) {\n                  return t._x - e._x;\n                }))).push(a), n = [], this.separateOuterPoints(a, s, l, n, p), d = d.concat(n.sort(function (t, e) {\n                  return e._x - t._x;\n                })), e[i].convexShape = d;\n              }\n            }, t.prototype.separateOuterPoints = function (e, i, n, r, s) {\n              if (0 !== n.length) {\n                if (1 === n.length) return s[n[0].id] = 1, void r.push(n[0]);\n\n                for (var a = 0, o = null, l = 0; l < n.length; l++) {\n                  var h = n[l],\n                      u = t.distanceLineToPoint({\n                    x: e._x,\n                    y: e._y\n                  }, {\n                    x: i._x,\n                    y: i._y\n                  }, {\n                    x: h._x,\n                    y: h._y\n                  });\n                  u > a && (a = u, o = h);\n                }\n\n                s[o.id] || (r.push(o), s[o.id] = 1);\n                var c = [],\n                    d = [];\n\n                for (l = 0; l < n.length; l++) {\n                  if (!s[(h = n[l]).id]) {\n                    var p = t.orientation({\n                      x: e._x,\n                      y: e._y\n                    }, {\n                      x: o._x,\n                      y: o._y\n                    }, {\n                      x: h._x,\n                      y: h._y\n                    });\n                    0 !== p && p < 0 && d.push(h);\n                    var f = t.orientation({\n                      x: o._x,\n                      y: o._y\n                    }, {\n                      x: i._x,\n                      y: i._y\n                    }, {\n                      x: h._x,\n                      y: h._y\n                    });\n                    0 !== f && f < 0 && c.push(h);\n                  }\n                }\n\n                this.separateOuterPoints(e, o, d, r, s), this.separateOuterPoints(o, i, c, r, s);\n              }\n            }, t.prototype.aggregate = function (t, e) {\n              if (this.zoom > Math.pow(2, this.settings.maxZoom)) {\n                var i = [],\n                    n = [],\n                    r = this.settings.weightFunction,\n                    s = this.settings.ignoreZeroWeight,\n                    a = h.Helpers.isFunction(r),\n                    o = void 0,\n                    l = Object.create(null);\n\n                for (o = 0; o < t.length; o++) {\n                  var u = t[o],\n                      c = a ? r(u) : 1;\n                  0 === c && s ? l[u.id] = !0 : i.push({\n                    id: \"__aggr_\" + u.id,\n                    aggregatedWeight: c,\n                    _x: u._x,\n                    _y: u._y,\n                    _bounds: u._bounds,\n                    coordinates: u.coordinates,\n                    aggregatedNodes: [u],\n                    loaded: !0\n                  });\n                }\n\n                for (o = 0; o < e.length; o++) {\n                  var d = e[o];\n                  s && l[d.from] || l[d.to] || n.push({\n                    from: \"__aggr_\" + d.from,\n                    to: \"__aggr_\" + d.to,\n                    id: \"__aggr_\" + d.from + \"-__aggr_\" + d.to,\n                    aggregatedLinks: [d]\n                  });\n                }\n\n                return {\n                  nodes: i,\n                  links: n\n                };\n              }\n\n              return this.findMainNodes(t, e);\n            }, t;\n          }();\n\n          t.Aggregation = T;\n\n          var k = function (t) {\n            function e(i) {\n              var n = t.call(this, h.SettingsMapping.GeoChartSettings) || this;\n              return n._computedLayers = [], n.theme = e.FlatTheme, n.area = new A(), n.background = new C(), n.data = [], n.style = {\n                fadeTime: 200,\n                selection: {\n                  fillColor: \"rgba(200, 200, 255 ,0.7)\",\n                  sizeConstant: 5,\n                  sizeProportional: .2\n                }\n              }, n.layerTypes = {\n                shapes: {\n                  type: \"shapes\"\n                },\n                items: {\n                  type: \"items\",\n                  style: {\n                    item: {\n                      hoverEffect: !1,\n                      zIndex: 0\n                    }\n                  }\n                },\n                aggregateOnShapes: {\n                  type: \"aggregateOnShapes\"\n                },\n                charts: {\n                  type: \"charts\"\n                }\n              }, n.layersDefault = null, n.layers = [], n.navigation = {\n                initialLat: 40,\n                initialLng: 25,\n                initialZoom: 3,\n                minZoom: 0,\n                maxZoom: 18,\n                maxBounds: {\n                  west: -200,\n                  north: -85,\n                  east: 200,\n                  south: 85\n                },\n                initialDrilldown: [\"\"],\n                drilldownLayer: \"default\"\n              }, n.filters = {\n                nodeFilter: null\n              }, n.interaction = new R(), n.toolbar = new h.SettingsToolbar(!1, [new h.SettingsToolbarItem(\"fullscreen\")], \"bottom\", \"left\"), n.advanced.assets.push({\n                url: \"assets://leaflet.css\",\n                required: function required() {\n                  return !h.Helpers.isStyleSheetDefined(\"leaflet-tile\", \"visibility\");\n                }\n              }), n.area.defaultHeight = 500, n.advanced.style.loadingArcStyle.r = 15, n.advanced.style.loadingArcStyle.lineColor = \"red\", n.advanced.style.loadingArcStyle.lineWidth = 7, n.apply(i), n._initializing = !1, n;\n            }\n\n            return r(e, t), e.prototype.apply = function (e) {\n              this.applyCompatibility(e, [{\n                from: \"layersDefault\",\n                alternative: \"layerTypes\"\n              }]), e.toolbar && h.Helpers.error(\"`toolbar` is not supported on GeoChart\");\n              var i = t.prototype.apply.call(this, e);\n              return (this._initializing || i.layers || i.layerTypes) && (this._computedLayers = h.SettingsHelper.mergeDefaultValues(this.layers, this.layersDefault, this.layerTypes, P.createInstance, P.getMapping, \"layers\")), i;\n            }, e;\n          }(o.Settings);\n\n          k.FlatTheme = {\n            advanced: {\n              themeCSSClass: \"DVSL-flat\"\n            }\n          }, t.Settings = k;\n\n          var A = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.style = new M(), e;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsArea);\n\n          t.SettingsArea = A;\n\n          var M = function (t) {\n            function e() {\n              return t.apply(this, arguments) || this;\n            }\n\n            return r(e, t), e;\n          }(h.SettingsAreaStyle);\n\n          t.SettingsAreaStyle = M;\n\n          var I = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.aggregatedShape = {\n                mode: 1,\n                lineColor: \"rgba(0,0,128,0.5)\",\n                lineWidth: 1,\n                fillColor: \"rgba(0,0,128,0.3)\"\n              }, e.scaleObjectsWithZoom = !1, e.node.radius = 10, e.node.fillColor = \"orange\", e.node.lineColor = \"red\", e.linkLabel.scaleWithSize = !1, e.linkLabel.scaleWithZoom = !1, e.linkLabel.backgroundStyle.fillColor = \"white\", e.linkLabel.backgroundStyle.lineColor = \"black\", e.nodeLabel.scaleWithSize = !1, e.nodeLabel.scaleWithZoom = !1, e.nodeLabel.backgroundStyle.fillColor = \"white\", e.nodeLabel.backgroundStyle.lineColor = \"black\", e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsNodesLayerStyle);\n\n          t.SettingsNodesLayerStyle = I;\n\n          var P = function () {\n            function t() {\n              this.enabled = !0, this.id = \"default\", this.name = \"\", this.type = \"shapes\", this.minZoom = 0, this.maxZoom = 20, this.perZoomStyle = !1, this.data = {\n                id: \"default\"\n              };\n            }\n\n            return t.getMapping = function (t, e) {\n              if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n              switch (t ? t.type : e.type) {\n                case \"shapes\":\n                  return h.SettingsMapping.GeoChartSettingsLayerShapes;\n\n                case \"items\":\n                  return h.SettingsMapping.GeoChartSettingsLayerItems;\n\n                case \"charts\":\n                  return h.SettingsMapping.GeoChartSettingsLayerCharts;\n\n                case \"aggregateOnShapes\":\n                  return h.SettingsMapping.GeoChartSettingsLayerAggregated;\n\n                default:\n                  throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.\");\n              }\n            }, t.createInstance = function (t, e) {\n              switch (e || t.type) {\n                case \"shapes\":\n                  return new D();\n\n                case \"items\":\n                  return new N();\n\n                case \"charts\":\n                  return new E();\n\n                case \"aggregateOnShapes\":\n                  return new O();\n\n                default:\n                  throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.\");\n              }\n            }, t;\n          }();\n\n          t.SettingsLayerBase = P;\n\n          var D = function (e) {\n            function i() {\n              var i = e.call(this) || this;\n              return i.style = new t.SettingsShapesLayerStyle(), i.type = \"shapes\", i;\n            }\n\n            return r(i, e), i;\n          }(P);\n\n          t.SettingsLayerShapes = D;\n\n          var N = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.style = new I(), e.aggregation = new w(), e.layout = new z(), e.auras = new o.SettingsNodesLayerAuras(), e.type = \"items\", e;\n            }\n\n            return r(e, t), e;\n          }(P);\n\n          t.SettingsLayerItems = N;\n\n          var F = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.shapesLayer = null, e;\n            }\n\n            return r(e, t), e;\n          }(P);\n\n          t.SettingsLayerOverlay = F;\n\n          var O = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.aggregationField = null, e.aggregation = \"count\", e.aggregationFunction = null, e.styleFunction = null, e.type = \"aggregateOnShapes\", e;\n            }\n\n            return r(e, t), e;\n          }(F);\n\n          t.SettingsLayerAggregated = O;\n\n          var E = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.chartType = \"piechart\", e.settings = null, e.settingsFunction = null, e.autoSize = !1, e.data = {\n                id: null\n              }, e.type = \"charts\", e;\n            }\n\n            return r(e, t), e;\n          }(F);\n\n          t.SettingsLayerCharts = E;\n\n          var R = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.mode = \"drilldown\", e.zooming = new H(), e.nodesMovable = !1, e.selection.enabled = !1, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsInteraction);\n\n          t.SettingsInteraction = R;\n\n          var H = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.zoomInOnDoubleClick = !0, e;\n            }\n\n            return r(e, t), e;\n          }(o.SettingsInteractionZooming);\n\n          t.SettingsInteractionZooming = H;\n\n          var B = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 2e3, i.updateOrder = 1100, i.scene = null, i.events = null, i.currentObject = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.dragPointers = {}, i;\n            }\n\n            return r(e, t), e.prototype.onPointerMove = function (t) {\n              this.updateCurrentObject(t), this.currentObject && (this.updateCursor(t), t.hovered = !0);\n            }, e.prototype.onPointerOut = function (t) {\n              this.switchCurrentObject(null, null, t);\n            }, e.prototype.onPointerDown = function (t) {\n              this.updateCurrentObject(t);\n              var e = this.currentObject;\n              e instanceof o.Node && (this.updateSelection(t, e, !0), this.updateCursor(t), this.scene.settings.interaction.nodesMovable && (this.setPointerNode(t, e), t.consumed = !0));\n            }, e.prototype.onPointerUp = function (t) {\n              this.dragPointers[t.identifier] && (this.dragPointers[t.identifier].dragging && (t.consumed = !0, this.updateLastNode(t, this.dragPointers[t.identifier].node)), this.updateCursor(t), this.setPointerNode(t, null));\n            }, e.prototype.onPointerCancel = function (t) {\n              this.onPointerUp(t);\n            }, e.prototype.onPointerDrag = function (t) {\n              var e = this.dragPointers[t.identifier];\n\n              if (e) {\n                var i = this.scene.fromDisplay(t.x, t.y),\n                    n = i.x,\n                    r = i.y;\n                e.mouseX = t.x, e.mouseY = t.y, e.dragging = !0, this.dragNodes(e, n, r, this.scene.settings.interaction.selection.lockNodesOnMove), this.updateCursor(t), t.consumed = !0;\n              }\n            }, e.prototype.onClick = function (t) {\n              this.scene.xyInChart(t.x, t.y) && ((!this.currentObject || !this.scene.settings.interaction.selection.nodesSelectable && this.currentObject.isNode || !this.scene.settings.interaction.selection.linksSelectable && this.currentObject.isLink) && this.updateSelection(t, null, !1), this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n            }, e.prototype.onRightClick = function (t) {\n              if (this.scene.xyInChart(t.x, t.y)) {\n                var e = this.buildEventArgs(t);\n                this.updateSelection(t, this.currentObject, !1), this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0);\n              }\n            }, e.prototype.onDoubleClick = function (t) {\n              this.scene.xyInChart(t.x, t.y) && (this.chart.notifyDoubleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n            }, e.prototype.onTripleClick = function (t) {\n              this.scene.xyInChart(t.x, t.y) && (this.chart.notifyTripleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n            }, e.prototype.doAnimations = function (t) {\n              for (var e in this.dragPointers) {\n                var i = this.dragPointers[e],\n                    n = this.scene.fromDisplay(i.mouseX, i.mouseY),\n                    r = n.x,\n                    s = n.y;\n                this.dragNodes(i, r, s, !1), t.changes.coordinates = !0;\n              }\n            }, e.prototype.updateSelection = function (t, e, i) {\n              this.scene.settings.interaction.selection.enabled && (t.shiftKey || t.ctrlKey || !(!e || !this.scene.settings.interaction.selection.nodesSelectable && e.isNode || !this.scene.settings.interaction.selection.linksSelectable && e.isLink) ? e && t.ctrlKey ? (e.selected ? this.scene.removeFromSelection(e) : this.scene.addToSelection(e), this.notifySelectionChanged(\"user\")) : e && t.shiftKey || i && e.selected ? this.scene.addToSelection(e) && this.notifySelectionChanged(\"user\") : e && this.setSelection([e], \"user\") : this.setSelection([], \"user\"));\n            }, e.prototype.dragNodes = function (t, e, i, n) {\n              var r = e + t.x - t.node.x,\n                  s = i + t.y - t.node.y;\n\n              if (0 !== r || 0 !== s) {\n                if (this.moveNode(t.node, r, s, n), t.extraNodes && t.extraNodes.length > 0) for (var a = 0; a < t.extraNodes.length; a++) {\n                  this.moveNode(t.extraNodes[a], r, s, n);\n                }\n                this.events.notifySceneChanges({\n                  coordinates: !0\n                });\n              }\n            }, e.prototype.moveNode = function (t, e, i, n) {\n              if (t.x += e, t.y += i, n && (t.userLock = !0), !this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {\n                var r = this.scene.getVisibleBounds(),\n                    s = 1.2 * t.renderHwidth / this.scene.zoom,\n                    a = 1.2 * t.renderHheight / this.scene.zoom;\n                t.x = Math.min(Math.max(t.x, r.x0 + s), r.x1 - s), t.y = Math.min(Math.max(t.y, r.y0 + a), r.y1 - a);\n              }\n            }, e.prototype.setPointerNode = function (t, e) {\n              var i = t.identifier,\n                  n = this.dragPointers[i];\n\n              if (n) {\n                if (n.node.locks--, n.extraNodes && n.extraNodes.length > 0) for (var r = 0; r < n.extraNodes.length; r++) {\n                  n.extraNodes[r].locks--;\n                }\n                delete this.dragPointers[i];\n              }\n\n              if (e) {\n                var s = this.scene.fromDisplay(t.x, t.y),\n                    a = s.x,\n                    l = s.y,\n                    u = null;\n\n                if (!h.Helpers.hasProperties(this.dragPointers) && this.scene.selection.length > 0) {\n                  u = [];\n\n                  for (r = 0; r < this.scene.selection.length; r++) {\n                    var c = this.scene.selection[r];\n                    c !== e && c instanceof o.Node && (c.locks++, u.push(c));\n                  }\n                }\n\n                this.dragPointers[t.identifier] = {\n                  x: e.x - a,\n                  y: e.y - l,\n                  node: e,\n                  extraNodes: u,\n                  mouseX: t.x,\n                  mouseY: t.y,\n                  dragging: !1\n                }, e.locks++;\n              }\n            }, e.prototype.updateCurrentObject = function (t) {\n              if (this.chart.renderer && this.scene.xyInChart(t.x, t.y)) {\n                var e = this.chart.renderer.findObjectAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);\n                this.switchCurrentObject(e ? e.object : null, e ? e.details : null, t);\n              }\n            }, e.prototype.updateCursor = function (t) {\n              this.currentObject && this.currentObject.cursor ? t.cursor = this.currentObject.cursor : t.cursor = \"default\";\n            }, e.prototype.switchCurrentObject = function (t, e, i) {\n              t === this.currentObject && e === this.currentItem || (i.changes.current = !0, this.scene.setActiveObject(t, e), this.currentObject = t, this.currentItem = e, this.chart.notifyHoverChanged(i, this.chart.createEventArguments(null, \"api\")));\n            }, e.prototype.buildEventArgs = function (t) {\n              var e = this.chart.createEventArguments(t, \"user\");\n              e.clickItem = this.currentItem;\n              var i = this.currentObject;\n              return i instanceof o.Node ? (e.clickNode = i, this.updateLastNode(t, i)) : e.clickLink = i, e;\n            }, e.prototype.updateLastNode = function (t, e) {\n              this.scene.lastClickedNode = e, this.scene.settings.interaction.zooming.autoZoomAfterClick && (this.scene.autoZoomMode = !0, t.changes.zoom = !0);\n            }, e.prototype.setSelection = function (t, e) {\n              this.scene.setSelection(t) && this.notifySelectionChanged(e);\n            }, e.prototype.notifySelectionChanged = function (t) {\n              this.events.notifySceneChanges({\n                selection: !0\n              }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, t));\n            }, e;\n          }(h.ChartElement);\n\n          t.Selection = B;\n\n          var z = function () {\n            return function () {\n              this.mode = \"static\", this.nodeSpacing = 3, this.anchorStrength = 1;\n            };\n          }();\n\n          t.SettingsNodesLayout = z;\n\n          var U = function () {\n            return function () {};\n          }(),\n              G = function () {\n            function t(t, e, i) {\n              this.initialLoad = !0, this.scene = t, this.settings = i, this.layer = e, this.random = new h.Random(1);\n            }\n\n            return t.isNodeLocked = function (t) {\n              return t.userLock || t.locks > 0 || t.anchorMode === o.NodeAnchorMode.Fixed;\n            }, t.prototype.doAnimations = function (e, i) {\n              var r = this,\n                  s = !1,\n                  a = this.layer.hasTopologyChanges(),\n                  o = \"dynamic\" === this.settings.mode;\n\n              if (o && void 0 === n.Chipmunk) {\n                if (t.cpRequestInitiated) return;\n                if (this.scene.assetsLoader.loadAssetsList([{\n                  url: \"assets://cp.js\",\n                  required: function required() {\n                    return void 0 === n.Chipmunk;\n                  }\n                }], function () {\n                  r.layer.events.notifySceneChanges({\n                    requestPaint: !0\n                  });\n                })) return void (t.cpRequestInitiated = !0);\n              }\n\n              for (var l = this.layer.nodes(), u = this.layer.getGeometry(), c = 0; c < l.length; c += 1) {\n                l[c].shape.adaptToViewport(u.txm, u.txa, u.tym, u.tya, u.zoom);\n              }\n\n              (this.initialLoad && (a = !0, i = !0), a && (this.random = new h.Random(1), this.placeNewNodes(o), s = !0), o) ? (this.placeModifiedNodes(), this.updateLayout(e.dtime, a, i, e.changes.zoom) && (e.animating = !0, s = !0)) : (this.placeModifiedNodes(), this.computeNodeAnchorCoordinates());\n              s && (e.changes.position = !0), this.initialLoad = !1;\n            }, t.prototype.computeNodeAnchorCoordinates = function () {\n              for (var t = this.layer.getNodesSceneZoom(), e = 0, i = this.layer.nodes(); e < i.length; e++) {\n                var n = i[e],\n                    r = n.shape.getAnchor();\n                n.x = n.anchorX - r.x * t, n.y = n.anchorY - r.y * t;\n              }\n            }, t.prototype.placeNewNodes = function (t) {\n              for (var e = this.layer.getNodesSceneZoom(), i = 0, n = this.layer.nodes(); i < n.length; i++) {\n                var r = n[i],\n                    s = r.shape.getAnchor();\n                r.anchorX = r.data._x, r.anchorY = r.data._y, null !== r.x && null !== r.y || (r.x = r.anchorX - s.x * e, r.y = r.anchorY - s.y * e, t && (r.x += this.random.get() * e));\n              }\n            }, t.prototype.placeModifiedNodes = function () {\n              for (var t in this.layer.modifiedNodes) {\n                var e = this.layer.modifiedNodes[t];\n                e.anchorX = e.data._x, e.anchorY = e.data._y;\n              }\n            }, t.prototype.removeNode = function (t) {\n              var e = this.idToState[t.id],\n                  i = this.cpSpace;\n              i.removeShape(e.shape), e.locked || (i.removeBody(e.body), i.removeShape(e.anchorShape)), delete this.idToState[t.id];\n            }, t.prototype.addNode = function (t, e) {\n              var i = new U(),\n                  r = this.cpSpace,\n                  s = this.layer.getNodesSceneZoom(),\n                  a = t.shape.getAnchor();\n\n              if (i.locked = e, this.idToState[t.id] = i, !e) {\n                var o = r.addBody(new n.Chipmunk.Body(1, 1 / 0));\n                i.body = o, o.setPos(n.Chipmunk.v(t.x + a.x * s, t.y + a.y * s));\n              }\n\n              return i;\n            }, t.prototype.updateLayout = function (e, i, r, s) {\n              this.cpSpace || (this.cpSpace = new n.Chipmunk.Space(), this.cpSpace.sleepTimeThreshold = 1, this.cpSpace.damping = .2, this.idToState = {}, i = !0);\n              var a = this.cpSpace,\n                  o = this.idToState,\n                  l = this.settings.nodeSpacing,\n                  u = this.settings.anchorStrength,\n                  c = this.layer.getNodesSceneZoom();\n              this.zoom = c, this.cpSpace.collisionSlop = 2 * c, this.cpSpace.idleSpeedThreshold = 5 * c;\n              var d = this.layer.nodes();\n\n              if (i) {\n                for (var p in this.layer.deletedNodes) {\n                  this.removeNode(this.layer.deletedNodes[p]);\n                }\n\n                for (var p in this.layer.newNodes) {\n                  var f = this.layer.newNodes[p];\n                  this.addNode(f, t.isNodeLocked(f));\n                }\n              }\n\n              if (r || i) for (var g = 0; g < d.length; g += 1) {\n                var m = o[(f = d[g]).id],\n                    v = t.isNodeLocked(f),\n                    y = null;\n                m && v === m.locked || (m && (m.body && (y = m.body.p), this.removeNode(f)), m = this.addNode(f, v));\n                var S = (Math.max(f.bounds.w(), f.bounds.h()) + l) / 2 * c,\n                    b = f.shape.getAnchor(),\n                    C = f.anchorX,\n                    x = f.anchorY;\n\n                if (s || m.prevAX !== C || m.prevAY !== x || m.prevR !== S) {\n                  if (m.locked) {\n                    (w = m.shape) && a.removeShape(w), y || (y = n.Chipmunk.v(C - b.x * c, x - b.y * c)), y.x -= b.x * c, y.y -= b.y * c, w = a.addShape(new n.Chipmunk.CircleShape(a.staticBody, S, y)), m.p = y, w.setElasticity(0), w.setFriction(0), m.shape = w;\n                  } else {\n                    var w;\n                    if (m.prevR !== S) (w = m.shape) && a.removeShape(w), (w = a.addShape(new n.Chipmunk.CircleShape(m.body, S, n.Chipmunk.v(-b.x * c, -b.y * c)))).setElasticity(0), w.setFriction(0), m.shape = w;\n\n                    if (s || m.prevAX !== C || m.prevAY !== x) {\n                      var L = m.anchorShape;\n                      L && a.removeShape(L), (L = a.addShape(new n.Chipmunk.CircleShape(a.staticBody, 2 * c, n.Chipmunk.v(C, x)))).setElasticity(0), L.setFriction(0), m.anchorShape = L;\n                    }\n                  }\n\n                  m.prevAX = C, m.prevAY = x, m.prevR = S;\n                }\n              }\n\n              for (g = 0; g < d.length; g += 1) {\n                if (!(m = o[(f = d[g]).id]).locked) {\n                  var T = f.anchorX,\n                      k = f.anchorY,\n                      A = m.body.p.x,\n                      M = m.body.p.y,\n                      I = m.body,\n                      P = A - T,\n                      D = M - k;\n                  P += .5 * I.vx, D += .5 * I.vy;\n                  var N,\n                      F = -Math.abs(3 * P) * h.Helpers.sign(P);\n                  N = D < 0 ? -2 * D : -5 * D, I.f = n.Chipmunk.v(F * u, N * u);\n                }\n              }\n\n              a.step(1 / 60);\n              var O = !0;\n\n              for (g = 0; g < d.length; g += 1) {\n                m = o[(f = d[g]).id], b = f.shape.getAnchor();\n                m.locked ? m.p ? (f.x = m.p.x, f.y = m.p.y) : (f.x = f.data._x - b.x * c, f.y = f.data._y - b.y * c) : (f.x = m.body.p.x - b.x * c, f.y = m.body.p.y - b.y * c, O = O && m.body.isSleeping());\n              }\n\n              return !O;\n            }, t;\n          }();\n\n          G.cpRequestInitiated = !1, t.NodesLayout = G;\n\n          var j = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e, i, n) || this;\n              return r.layout = null, r.hoveredNode = null, r.layout = new G(e.scene, r, i.layout), r;\n            }\n\n            return r(e, t), e.prototype.postprocessStyle = function (e) {\n              t.prototype.postprocessStyle.call(this, e);\n              var i = e.changes.zoom || this.hasStyleChanges();\n              this.layout.doAnimations(e, i);\n            }, e.prototype.paintHoverShape = function (t) {\n              var e = this.style.aggregatedShape;\n\n              switch (e.mode) {\n                case 0:\n                  break;\n\n                default:\n                case 1:\n                  if (null === this.hoveredNode || !this.hoveredNode.hovered || this.hoveredNode.removed) {\n                    var i = this.modifiedNodes;\n\n                    for (var n in this.hoveredNode = null, i) {\n                      if (i[n].hovered) {\n                        this.hoveredNode = i[n];\n                        break;\n                      }\n                    }\n                  }\n\n                  this.hoveredNode && this.paintConvex(this.hoveredNode, t, e);\n                  break;\n\n                case 2:\n                  for (var r = this.nodes(), s = 0; s < r.length; s++) {\n                    (o = r[s]).removed || this.paintConvex(o, t, e);\n                  }\n\n                  break;\n\n                case 3:\n                  var a = this.nodes();\n\n                  for (s = 0; s < a.length; s++) {\n                    var o;\n                    !(o = a[s]).removed && o.selected && this.paintConvex(o, t, e);\n                  }\n\n              }\n            }, e.prototype.paintConvex = function (t, e, i) {\n              var n = t.data,\n                  r = n.convexShape;\n\n              if (r && !(r.length < 2)) {\n                var s = this.getGeometry(),\n                    a = {},\n                    o = h.Graphics.beginStrokeAndFill(e, i);\n                a[r[0].id] = 1, o.moveTo(r[0]._x * s.txm + s.txa, r[0]._y * s.tym + s.tya);\n\n                for (var l = 1; l < r.length; l++) {\n                  a[r[l].id] = 1, o.lineTo(r[l]._x * s.txm + s.txa, r[l]._y * s.tym + s.tya);\n                }\n\n                o.closePath(), h.Graphics.endStrokeAndFill(e, o, i);\n\n                for (l = 0; l < n.aggregatedNodes.length; l++) {\n                  var u = n.aggregatedNodes[l];\n                  a[u.id] || ((o = h.Graphics.beginStroke(e, i)).arc(u._x * s.txm + s.txa, u._y * s.tym + s.tya, 1, 0, 2 * Math.PI, !1), h.Graphics.endStroke(e, o, i));\n                }\n              }\n            }, e.prototype.paint = function (e) {\n              this.paintHoverShape(e.context), t.prototype.paint.call(this, e);\n            }, e;\n          }(o.NodesLayer);\n\n          t.NodesLayer = j;\n\n          var W = function (t) {\n            function e() {\n              var e = t.call(this) || this;\n              return e.stack = [], e.zoomLevel = 0, e.mainDataEnabled = !1, e.project = null, e.unproject = null, e;\n            }\n\n            return r(e, t), e.prototype.push = function (t) {\n              return this.stack.push(t);\n            }, e.prototype.peek = function () {\n              return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n            }, e.prototype.pop = function () {\n              return 0 === this.stack.length ? null : this.stack.pop();\n            }, e.prototype.getVisibleBoundsLatLon = function () {\n              var t = this.fromDisplay(this.x0, this.y0),\n                  e = t.x,\n                  i = t.y,\n                  n = (t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height)).x,\n                  r = t.y;\n              return this.unprojectRect(new h.Rect(e, i, n, r));\n            }, e.prototype.unprojectRect = function (t) {\n              var e = this.unproject(t.x0, t.y0),\n                  i = this.unproject(t.x1, t.y1);\n              return new h.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat));\n            }, e;\n          }(o.Scene);\n\n          t.Scene = W;\n\n          var V = function (t) {\n            function e() {\n              var e = t.apply(this, arguments) || this;\n              return e.shapeSimplificationPrecision = 1.5, e.node = {\n                fillColor: \"#c7dae0\",\n                lineColor: null,\n                lineWidth: null,\n                radius: 30,\n                shadowColor: null,\n                lineDash: null,\n                expandable: !1\n              }, e;\n            }\n\n            return r(e, t), e;\n          }(I);\n\n          t.SettingsShapesLayerStyle = V;\n\n          var Z = function (t) {\n            function e(e, i) {\n              return t.call(this, e, i) || this;\n            }\n\n            return r(e, t), e.prototype.postprocessNode = function (t) {\n              t.currentItems = [], t.label, this.postprocessItems(t);\n            }, e.prototype.postprocessLink = function (t) {\n              var e = [];\n\n              if (t.label) {\n                var i = new h.Label(t.labelStyle);\n                i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i);\n              }\n\n              t.currentItems = e, this.postprocessItems(t);\n            }, e;\n          }(o.ItemsStyle);\n\n          t.ShapesStyle = Z;\n\n          var Y = function (t) {\n            function e(e, i) {\n              var n = t.call(this, e, i) || this;\n              return n.style = i.style, n;\n            }\n\n            return r(e, t), e.prototype.createStyleUpdater = function (t) {\n              return new Z(t, this);\n            }, e.prototype.paintSelection = function (t, e, i) {\n              var n = this.getGeometry(),\n                  r = n.txm,\n                  s = n.txa,\n                  a = n.tym,\n                  o = n.tya,\n                  l = 1 / r,\n                  h = t.context,\n                  u = this.style.selection;\n              h.beginPath();\n\n              for (var c = 0; c < e.length; c++) {\n                for (var d = e[c], p = 0, f = this.getNodeCoords(d, l); p < f.length; p++) {\n                  var g = f[p],\n                      m = g[0] * r + s,\n                      v = g[1] * a + o;\n                  h.moveTo(m, v);\n\n                  for (var y = 2; y <= g.length - 2; y += 2) {\n                    h.lineTo(g[y] * r + s, g[y + 1] * a + o);\n                  }\n\n                  h.closePath();\n                }\n              }\n\n              h.fillStyle = u.fillColor, h.strokeStyle = u.fillColor, h.lineWidth = 2 * u.sizeConstant, h.fill(), h.stroke();\n            }, e.prototype.paintLinks = function (t, e) {}, e.prototype.paintNodes = function (t, e) {\n              for (var i = t.context, n = this.getGeometry(), r = n.txm, s = n.txa, a = n.tym, o = n.tya, l = n.zoom, u = n.x0w, c = n.y0w, d = n.x1w, p = n.y1w, f = 1 / r, g = l > this.style.nodeDetailMinZoom, m = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * f * f, v = this.style.nodeLabelScaleBase, y = 0; y < e.length; y++) {\n                var S = e[y];\n                if (S.removed) this.deleteNode(S);else if (S.data) {\n                  var b = S.bounds;\n\n                  if (!(b.x1 < u || b.x0 > d || b.y1 < c || b.y0 > p)) {\n                    var C = S.opacity,\n                        x = g && b.area() > m || S.hovered;\n\n                    if (C < 1 && (i.globalAlpha = C), x) {\n                      S.items.sort(function (t, e) {\n                        return t.zIndex - e.zIndex;\n                      });\n                      var w = (b.x1 + b.x0) / 2 * r + s,\n                          L = (b.y1 + b.y0) / 2 * a + o,\n                          T = (b.x1 - b.x0) / 2 * r,\n                          k = (b.y1 - b.y0) / 2 * a;\n                      this.paintNodeDetails(S, w, L, T, k, l, v, t, !0);\n                    }\n\n                    if (S.fillColor || S.lineColor) {\n                      for (var A = h.Graphics.beginStrokeAndFill(i, S), M = 0, I = this.getNodeCoords(S, f); M < I.length; M++) {\n                        var P = I[M],\n                            D = P[0] * r + s,\n                            N = P[1] * a + o;\n                        A.moveTo(D, N);\n\n                        for (var F = 2; F <= P.length - 2; F += 2) {\n                          A.lineTo(P[F] * r + s, P[F + 1] * a + o);\n                        }\n\n                        A.closePath();\n                      }\n\n                      h.Graphics.endStrokeAndFill(i, A, S);\n                    }\n\n                    if (x) {\n                      w = (b.x1 + b.x0) / 2 * r + s, L = (b.y1 + b.y0) / 2 * a + o, T = (b.x1 - b.x0) / 2 * r, k = (b.y1 - b.y0) / 2 * a;\n                      this.paintNodeDetails(S, w, L, T, k, l, v, t, !1);\n                    }\n\n                    C < 1 && (i.globalAlpha = 1);\n                  }\n                }\n              }\n\n              return !1;\n            }, e.prototype.findObjectAt = function (t, e, i) {\n              for (var n = this.scene.fromDisplay(t, e), r = n.x, s = n.y, a = 1 / this.scene.zoom, o = i * a, l = null, u = this.nodes(), c = u.length - 1; c >= 0; c--) {\n                var d = u[c];\n\n                if (!d.removed) {\n                  var p = this.getNodeCoords(d, a),\n                      f = h.Geometry.distanceToPolygonSq(r, s, p),\n                      g = o * o;\n                  if (f <= 0) return {\n                    object: d,\n                    details: null\n                  };\n\n                  if (f < g) {\n                    var m = Math.sqrt(f);\n                    m < o && (o = m, l = d);\n                  }\n                }\n              }\n\n              return {\n                object: l,\n                details: null\n              };\n            }, e.prototype.getNodeCoords = function (t, e) {\n              var i = this.style.shapeSimplificationPrecision;\n              if (!(i > 0)) return t.coordinates;\n              i *= e;\n              var n = t.coordinatesCachePrecision;\n              if (n <= i && 2 * n > i) return t.coordinatesCache;\n              var r,\n                  s = [];\n              r = n < i ? t.coordinatesCache : t.coordinates;\n\n              for (var a = 0; a < r.length; a++) {\n                var o = r[a];\n                h.Geometry.computeBoundsSize(o) > 4 * i && (o.length > 10 && (o = h.Geometry.simplify(o, i)), s.push(o));\n              }\n\n              return t.coordinatesCachePrecision = i, t.coordinatesCache = s, s;\n            }, e;\n          }(o.ItemsLayer);\n\n          t.ShapesLayer = Y;\n\n          var q = function (t) {\n            function e(e, i, n) {\n              var r = t.call(this, e) || this;\n              return r.layerSettings = n, r.parentId = null, r.baseLayer = i, r;\n            }\n\n            return r(e, t), e.prototype.findObjectAt = function (t, e, i) {\n              return null;\n            }, e.prototype.nodes = function () {\n              return this.baseLayer.nodes();\n            }, e.prototype.links = function () {\n              return this.baseLayer.links();\n            }, e.prototype.getModified = function () {\n              return this.baseLayer.getModified();\n            }, e.prototype.hasTopologyChanges = function () {\n              return this.baseLayer.hasTopologyChanges();\n            }, e.prototype.hasStyleChanges = function () {\n              return this.baseLayer.hasStyleChanges();\n            }, e.prototype.getGeometry = function () {\n              return this.baseLayer.getGeometry();\n            }, e;\n          }(h.Layer);\n\n          t.OverlayLayerBase = q;\n\n          var _ = function (t) {\n            function i(e, i, n, r) {\n              var s = t.call(this, e, i, n) || this;\n              return s.idToChart = {}, s.chart = r, s;\n            }\n\n            return r(i, t), i.prototype.updateStyle = function (t) {}, i.prototype.postprocessStyle = function (t) {\n              for (var e in this.baseLayer.newNodes) {\n                var i = this.baseLayer.newNodes[e];\n                this.idToChart[e] = this.createChart(i);\n              }\n\n              var n;\n\n              for (var e in this.baseLayer.modifiedNodes) {\n                i = this.baseLayer.modifiedNodes[e];\n                this.baseLayer.newNodes.hasOwnProperty(e) || ((n = this.idToChart[e]) ? this.updateChart(n, i) : this.idToChart[e] = this.createChart(i));\n              }\n\n              for (var e in this.baseLayer.deletedNodes) {\n                (n = this.idToChart[e]) && (delete this.idToChart[e], this.removeChart(n));\n              }\n\n              for (var r = 0, s = this.nodes(); r < s.length; r++) {\n                i = s[r];\n                (n = this.idToChart[i.id]) && this.updateXY(n, i);\n              }\n            }, i.prototype.paint = function (t) {}, i.prototype.createChart = function (t) {\n              var i = this.layerSettings.chartType,\n                  n = this.getChartSettings(t);\n              return n ? (n.parentChart = this.chart.api, n.area ? n.area.width || (n.area.width = 100, n.area.height = 100) : n.area = {\n                width: 100,\n                height: 100\n              }, \"piechart\" === i ? new e.PieChart(n) : \"facetchart\" === i ? new e.FacetChart(n) : \"timechart\" === i ? new e.TimeChart(n) : null) : null;\n            }, i.prototype.getChartSettings = function (t) {\n              return this.layerSettings.settingsFunction ? this.layerSettings.settingsFunction(t, t.data) : this.layerSettings.settings;\n            }, i.prototype.updateChart = function (t, e) {\n              var i = this.getChartSettings(e);\n              t.updateSettings(i);\n            }, i.prototype.removeChart = function (t) {\n              t.remove();\n            }, i.prototype.updateXY = function (t, e) {\n              var i,\n                  n,\n                  r = this.scene.toDisplay(e.x, e.y),\n                  s = r.x,\n                  a = r.y,\n                  o = t._impl.settings.area;\n              if (this.layerSettings.autoSize) throw \"TODO: implement autoSize\";\n              var l = s - (i = o.width) / 2,\n                  h = a - (n = o.height) / 2;\n              o.left === l && o.top === h && o.width === i && o.height === n || t.updateSettings({\n                area: {\n                  left: s - i / 2,\n                  top: a - n / 2,\n                  width: i,\n                  height: n\n                }\n              });\n            }, i.prototype.remove = function () {\n              for (var t in this.idToChart) {\n                this.removeChart(this.idToChart[t]);\n              }\n\n              this.idToChart = {};\n            }, i;\n          }(q);\n\n          t.ChartsLayer = _;\n\n          var X = function () {\n            function e(t, e, i, n) {\n              this.drilldownId = n, this.layerSettings = i, this.data = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.layer = this.createLayer(), this.layer.drilldownId = this.drilldownId, this.dataBounds = h.Rect.createEmpty(), this.expandedNode = null;\n            }\n\n            return e.calculateShapeCentroid = function (t) {\n              var e,\n                  i,\n                  n = 0,\n                  r = 0;\n\n              for (e = 0; e < t.coordinates.length; e++) {\n                i = h.Geometry.calculatePolyArea(t.coordinates[e]), Math.abs(i) > Math.abs(r) && (r = i, n = e);\n              }\n\n              if (0 === r) return t.x = (t.bounds.x0 + t.bounds.x1) / 2, void (t.y = (t.bounds.y0 + t.bounds.y1) / 2);\n              var s = h.Geometry.calculatePolyCentroid(t.coordinates[n], r);\n              t.x = s.x, t.y = s.y;\n            }, e.prototype.createLayer = function () {\n              return \"shapes\" === this.layerSettings.type ? new Y(this.scene, this.layerSettings) : \"items\" === this.layerSettings.type ? new t.NodesLayer(this.chart, this.layerSettings, !1) : null;\n            }, e.prototype.onSceneChange = function (t) {\n              var e,\n                  i,\n                  n,\n                  r = this.data.dataSettings,\n                  s = this.layerSettings,\n                  a = r.prefetchRatio;\n              r.perBoundsData ? (i = (e = this.chart.scene.getVisibleBounds()).clone().inflate(1 + a / 2), n = e.clone().inflate(1 + a)) : i = n = e = this.data.getProjectedBounds();\n              var o = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[r.id] || {})[this.drilldownId || \"\"] : null,\n                  l = s instanceof N && s.aggregation.enabled;\n\n              if (this.dataBounds.isEmpty() || o || !e.isInside(this.dataBounds) || t.changes.zoom && (r.perZoomData || l)) {\n                this.loading = !1, this.data.setViewParams(r.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, e, i, n);\n                var h = this.data.getData(this.drilldownId),\n                    u = h.nodes,\n                    c = h.links,\n                    d = h.hasData,\n                    p = h.loading,\n                    f = u.length;\n\n                if (d || f > 0) {\n                  if (this.chart.log(\"Layer \" + this.layerSettings.id + \": Updating view rect to \" + i + \", contains \" + f + \" objects\"), l) {\n                    var g = new T(s.aggregation, this.scene, this.chart).aggregate(u, c);\n                    u = g.nodes, c = g.links;\n                  }\n\n                  this.applyVisibleNodes(this.layer, u, c, null), this.dataBounds = i;\n                }\n\n                this.loading = p;\n              } else e.area() * (1 + a) * (1 + a) < this.dataBounds.area() / 5 && (i = e.inflate(1 + a), this.chart.log(\"Layer \" + this.layerSettings.id + \": Shrinking view to \" + i), this.shrinkVisibleBounds(i), this.dataBounds = i);\n\n              if (s.perZoomStyle && t.changes.zoom) {\n                for (var m = 0, v = this.layer.nodes(); m < v.length; m++) {\n                  this.layer.touchNode(v[m]);\n                }\n\n                for (var y = 0, S = this.layer.links(); y < S.length; y++) {\n                  this.layer.touchLink(S[y]);\n                }\n              }\n            }, e.prototype.updateStyle = function (t) {\n              this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), this.layer.updateStyle(t);\n            }, e.prototype.postprocessStyle = function (t) {\n              this.layer.postprocessStyle(t);\n            }, e.prototype.remove = function () {}, e.prototype.paint = function (t) {\n              this.layer.paint(t);\n            }, e.prototype.findObjectAt = function (t, e, i) {\n              return this.layer.findObjectAt(t, e, i);\n            }, e.prototype.findObjectById = function (t) {\n              return this.layer.findObjectById(t);\n            }, e.prototype.touchObject = function (t) {\n              var e = this.layer,\n                  i = e.findObjectById(t);\n              i && e.touchNodeOrLink(i);\n            }, e.prototype.setExpandedNode = function (t) {\n              this.expandedNode && (this.expandedNode.expanded = !1, this.layer.touchNode(this.expandedNode), this.expandedNode = null), t && (this.expandedNode = this.layer.idToNode[t], this.expandedNode && (this.expandedNode.expanded = !0, this.layer.touchNode(this.expandedNode)));\n            }, e.prototype.applyVisibleNodes = function (t, i, n, r) {\n              for (var s = t.idToNode, a = {}, o = {}, l = \"shapes\" === this.layerSettings.type, h = 0; h < i.length; h++) {\n                var u = i[h];\n                if (l && u._coordinates || !l && u.hasOwnProperty(\"_x\")) a[f = u.id] = !0, (g = t.addNode(f)).data = u, l && (g.coordinates = u._coordinates, g.bounds = u._bounds, e.calculateShapeCentroid(g)), g.parentNode = r;\n              }\n\n              for (var c = 0; c < n.length; c++) {\n                var d = n[c],\n                    p = t.addLink(d.id, d.from, d.to);\n                p.data = d, o[p.id] = !0;\n              }\n\n              for (var f in s) {\n                var g = s[f];\n\n                if (!a.hasOwnProperty(f)) {\n                  t.removeNode(g);\n\n                  for (var m = 0; m < g.links.length; m++) {\n                    t.removeLink(g.links[m]);\n                  }\n                }\n              }\n\n              var v = t.idToLink;\n\n              for (var f in v) {\n                o.hasOwnProperty(f) || t.removeLink(v[f]);\n              }\n            }, e.prototype.shrinkVisibleBounds = function (t) {\n              for (var e in this.layer.idToNode) {\n                var i = this.layer.idToNode[e];\n                i.data._bounds.isOutside(t) && this.layer.removeNode(i);\n              }\n            }, e;\n          }(),\n              Q = function () {\n            function t(t, e, i, n) {\n              this.data = null, this.drilldownId = n, this.layerSettings = i, this.baseLayer = e, this.chart = t, this.scene = t.scene, this.loading = !1, this.layer = this.createLayer();\n            }\n\n            return t.prototype.createLayer = function () {\n              return \"charts\" === this.layerSettings.type ? new _(this.scene, this.baseLayer.layer, this.layerSettings, this.chart) : null;\n            }, t.prototype.onSceneChange = function (t) {}, t.prototype.updateStyle = function (t) {\n              this.layer.updateStyle(t);\n            }, t.prototype.postprocessStyle = function (t) {\n              this.layer.postprocessStyle(t);\n            }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {\n              this.layer.paint(t);\n            }, t.prototype.findObjectAt = function (t, e, i) {\n              return null;\n            }, t.prototype.findObjectById = function (t) {\n              return null;\n            }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {\n              this.layer.remove();\n            }, t;\n          }(),\n              J = function () {\n            function t(t, e, i, n, r) {\n              this.firstTime = !0, this.drilldownId = r, this.layerSettings = n, this.data = i, this.baseLayer = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.dataBounds = h.Rect.createEmpty(), this.nodeToAggregated = {}, this.pendingNodes = {};\n            }\n\n            return t.prototype.onSceneChange = function (t) {\n              if (this.firstTime || this.layerSettings.perZoomStyle && t.changes.zoom || t.changes.data) {\n                this.firstTime = !1;\n\n                for (var e = this.baseLayer.layer, i = 0, n = e.nodes(); i < n.length; i++) {\n                  e.touchNode(n[i]);\n                }\n\n                for (var r = 0, s = e.links(); r < s.length; r++) {\n                  e.touchLink(s[r]);\n                }\n              }\n            }, t.prototype.updateStyle = function (t) {\n              var e = this.data.dataSettings,\n                  i = this.layerSettings,\n                  n = this.baseLayer.layer.modifiedNodes,\n                  r = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[e.id] || {})[this.drilldownId || \"\"] : null;\n\n              if (h.Helpers.hasProperties(n) || h.Helpers.hasProperties(r)) {\n                var s,\n                    a = i.styleFunction;\n\n                for (var o in n) {\n                  var l = n[o];\n                  this.nodeToAggregated.hasOwnProperty(l.id) ? a(l, this.nodeToAggregated[l.id]) : this.pendingNodes[o] = l;\n                }\n\n                if (!h.Helpers.hasProperties(this.pendingNodes)) return void (this.loading = !1);\n                if (e.perBoundsData) for (var o in s = h.Rect.createEmpty(), this.pendingNodes) {\n                  l = this.pendingNodes[o];\n                  s.addRect(l.data._bounds);\n                } else s = this.data.getProjectedBounds();\n                this.data.setViewParams(e.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, s, s, s);\n                var u = this.data.getData(this.drilldownId),\n                    c = u.nodes,\n                    d = u.loading;\n\n                if (!d) {\n                  for (var o in this.pendingNodes) {\n                    l = this.pendingNodes[o];\n                    var p = this.computeAggr(l.data._bounds, l.data._coordinates, c);\n                    this.nodeToAggregated[l.id] = p, a && a(l, p);\n                  }\n\n                  this.pendingNodes = {};\n                }\n\n                this.loading = d;\n              }\n            }, t.prototype.postprocessStyle = function (t) {}, t.prototype.computeAggr = function (t, e, i) {\n              var n = this.layerSettings;\n\n              if (n.aggregationFunction) {\n                for (var r = new Array(), s = 0; s < i.length; s++) {\n                  var a = i[s],\n                      o = a._x,\n                      l = a._y;\n                  t.containsPoint(o, l) && h.Geometry.isInsidePolygon(o, l, e) && r.push(a);\n                }\n\n                return n.aggregationFunction(r);\n              }\n\n              var u = n.aggregation,\n                  c = n.aggregationField,\n                  d = 0;\n              return h.Helpers.aggregate(u, function () {\n                for (; d < i.length && (!t.containsPoint(i[d]._x, i[d]._y) || !h.Geometry.isInsidePolygon(i[d]._x, i[d]._y, e));) {\n                  d += 1;\n                }\n\n                return d < i.length;\n              }, function () {\n                var t = i[d][c];\n                return d += 1, t;\n              });\n            }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {}, t.prototype.findObjectAt = function (t, e, i) {\n              return null;\n            }, t.prototype.findObjectById = function (t) {\n              return null;\n            }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {}, t;\n          }(),\n              K = function () {\n            function t(t, e, i, n) {\n              this.layers = [], this.firstTime = !0, this.layerSettings = n, this.data = i, this.renderer = e, this.chart = t, this.loading = !0, this.scene = t.scene;\n            }\n\n            return t.prototype.onSceneChange = function (t) {\n              if (t.changes.navigation || this.firstTime) {\n                this.firstTime = !1;\n\n                for (var e = this.scene.stack, i = 0; i < Math.min(this.layers.length, e.length) && e[i] === this.layers[i].drilldownId;) {\n                  i += 1;\n                }\n\n                for (; this.layers.length > i;) {\n                  var n = this.layers.pop();\n                  this.renderer.removeSimpleLayer(n), (r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null) && r.setExpandedNode(null);\n                }\n\n                for (; this.layers.length < e.length;) {\n                  var r,\n                      s = e[this.layers.length];\n                  if ((r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null) && r.setExpandedNode(s), !(n = this.renderer.createSimpleLayer(this.data, this.layerSettings, s))) break;\n                  this.layers.push(n);\n                }\n              }\n\n              this.loading = !1;\n\n              for (var a = 0; a < this.layers.length; a++) {\n                var o = this.layers[a];\n                o.onSceneChange(t), this.loading = this.loading || o.loading;\n              }\n            }, t.prototype.updateStyle = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                this.layers[e].updateStyle(t);\n              }\n            }, t.prototype.postprocessStyle = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                this.layers[e].postprocessStyle(t);\n              }\n            }, t.prototype.paint = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                this.layers[e].paint(t);\n              }\n            }, t.prototype.findObjectAt = function (t, e, i) {\n              for (var n = this.layers.length - 1; n >= 0; n--) {\n                var r = this.layers[n].findObjectAt(t, e, i);\n                if (r && r.object) return r;\n              }\n\n              return null;\n            }, t.prototype.findObjectById = function (t) {\n              for (var e = this.layers.length - 1; e >= 0; e--) {\n                var i = this.layers[e].findObjectById(t);\n                if (i) return i;\n              }\n\n              return null;\n            }, t.prototype.touchObject = function (t) {\n              for (var e = 0; e <= this.layers.length; e++) {\n                this.layers[e].touchObject(t);\n              }\n            }, t.prototype.remove = function () {\n              for (var t = 0; t < this.layers.length; t++) {\n                var e = this.layers[t];\n                this.renderer.removeSimpleLayer(e);\n              }\n\n              this.layers = [];\n            }, t;\n          }(),\n              $ = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 900, i.paintOrder = 10, i.updateOrder = 10, i.layers = [], i.idToLayer = {}, i.idToSimpleLayer = {}, i.drilldownLayer = null, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n            }\n\n            return r(e, t), e.prototype.createData = function (t) {\n              var e = null;\n              return t.id && (e = this.chart.getData(t.id)), e;\n            }, e.prototype.createSimpleLayer = function (t, e, i) {\n              var n;\n\n              if (e instanceof F) {\n                var r = this.idToSimpleLayer[e.shapesLayer + i];\n                if (!r) return this.chart.error(\"ItemsOnShape layer: shapesLayer \" + e.shapesLayer + \" not found, must come first in the layers array.\"), null;\n                \"charts\" === e.type ? n = new Q(this.chart, r, e, i) : \"aggregateOnShapes\" === e.type && (n = new J(this.chart, r, t, e, i));\n              } else n = new X(this.chart, t, e, i);\n\n              return this.idToSimpleLayer[e.id + i] = n, n;\n            }, e.prototype.removeLayer = function (t) {\n              t instanceof K ? t.remove() : this.removeSimpleLayer(t);\n            }, e.prototype.removeSimpleLayer = function (t) {\n              t.remove();\n              var e = t.layerSettings.id + t.drilldownId;\n              delete this.idToSimpleLayer[e];\n            }, e.prototype.onSceneChange = function (t) {\n              var e = !1,\n                  i = t.changes,\n                  n = i.settingsChanges;\n\n              if (n && (n.layers || n.layerTypes)) {\n                for (var r in n.layers) {\n                  (g = this.idToLayer[r]) && (this.removeLayer(g), delete this.idToLayer[r]);\n                }\n\n                e = !0;\n              } else (i.zoom || i.data) && (e = !0);\n\n              if (e) {\n                var s = this.idToLayer;\n                this.layers = [], this.idToLayer = {};\n                var a = this.scene.zoomLevel;\n                this.drilldownLayer = null;\n\n                for (var o = this.scene.settings.navigation.drilldownLayer, l = 0; l < this.chart.settings._computedLayers.length; l++) {\n                  var h = this.chart.settings._computedLayers[l],\n                      u = h.enabled && h.minZoom <= a && h.maxZoom >= a,\n                      c = s[h.id];\n\n                  if (u) {\n                    var d = this.createData(h.data),\n                        p = !1;\n\n                    if (d && d.dataSettings.perDrilldownData && (p = !0), h instanceof F) {\n                      var f = this.idToLayer[h.shapesLayer];\n\n                      if (!f) {\n                        this.chart.error(\"Overlay layer: shapeLayer \" + h.shapesLayer + \" not found, must come first in the layers array.\");\n                        continue;\n                      }\n\n                      c && c.baseLayer !== f && (this.removeLayer(c), c = null), p = p || f.data.dataSettings.perDrilldownData;\n                    }\n\n                    var g = void 0;\n                    if (c && c.data === d) g = c;else if (c && this.removeLayer(c), p) g = new K(this.chart, this, d, h);else if (!(g = this.createSimpleLayer(d, h, null))) continue;\n                    h.id === o && (this.drilldownLayer = g), this.layers.push(g), this.idToLayer[h.id] = g;\n                  } else c && this.removeLayer(c);\n                }\n\n                for (var r in s) {\n                  g = s[r];\n                  this.idToLayer.hasOwnProperty(r) || this.removeLayer(g);\n                }\n              }\n\n              for (var m = 0; m < this.layers.length; m++) {\n                (g = this.layers[m]).onSceneChange(t);\n              }\n            }, e.prototype.doAnimations = function (t) {\n              for (var e = 0; e < this.layers.length; e++) {\n                (n = this.layers[e]).updateStyle(t);\n              }\n\n              var i = !1;\n\n              for (e = 0; e < this.layers.length; e++) {\n                var n;\n                (n = this.layers[e]).postprocessStyle(t), i = i || n.loading;\n              }\n\n              this.scene.loading = i;\n            }, e.prototype.paintScene = function (t) {\n              h.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);\n\n              for (var e = !1, i = 0; i < this.layers.length; i++) {\n                var n = this.layers[i];\n                n.paint(t), e = e || n.loading;\n              }\n\n              h.Graphics.popClip(t), this.scene.loading = e;\n            }, e.prototype.findObjectById = function (t) {\n              for (var e = this.layers.length - 1; e >= 0; e--) {\n                var i = this.layers[e].findObjectById(t);\n                if (i) return i;\n              }\n\n              return null;\n            }, e.prototype.touchObjects = function (t) {\n              for (var e = this.layers.length - 1; e >= 0; e--) {\n                for (var i = this.layers[e], n = 0; n < t.length; n++) {\n                  i.touchObject(t[n]);\n                }\n              }\n            }, e.prototype.findObjectAt = function (t, e, i) {\n              for (var n = this.layers.length - 1; n >= 0; n--) {\n                var r = this.layers[n].findObjectAt(t, e, i);\n                if (r && r.object) return r;\n              }\n\n              return null;\n            }, e;\n          }(h.ChartElement);\n\n          t.Renderer = $;\n\n          var tt = function (t) {\n            function e(e) {\n              var i = t.call(this) || this;\n              return i.animationOrder = 1e3, i.paintOrder = 5, i.updateOrder = 1300, i.chart = e, i.scene = i.chart.scene, i;\n            }\n\n            return r(e, t), e.prototype.showInitialNodes = function () {\n              var t = this.scene.settings.navigation.initialDrilldown;\n              return this.scene.stack = t, this.chart.events.notifySceneChanges({\n                navigation: !0\n              });\n            }, e.prototype.onPanZoom = function () {}, e.prototype.onNewDataObject = function () {}, e.prototype.expandNode = function (t) {\n              var e = t.layer.drilldownId,\n                  i = t.id;\n              if (i === this.scene.peek()) return !1;\n\n              for (; this.scene.peek() !== e;) {\n                this.scene.pop();\n              }\n\n              return this.scene.push(i), this.chart.events.notifySceneChanges({\n                navigation: !0\n              }), !0;\n            }, e.prototype.collapseNode = function (t) {\n              throw \"Not implemented\";\n            }, e;\n          }(h.Navigator);\n\n          t.Navigator = tt;\n\n          var et = !1,\n              it = function (t) {\n            function e(e, i) {\n              var n = t.call(this, new k(e), new W(), i) || this;\n              return n.events.forceFloating = !0, n._map = n._map || null, n._pendingZoomLevel = null, n._pendingLatitude = null, n._pendingBounds = null, n.navigator = n.events.addElement(new tt(n)), n.menu = n.events.addElement(new o.Menu(n)), n.info = n.events.addElement(new o.InfoPopup(n)), n.selection = n.events.addElement(new B(n)), n._map && (n.renderer = n.events.addElement(new $(n))), n.navigator.showInitialNodes(), n.finalInitialize(), n;\n            }\n\n            return r(e, t), e.prototype.getMap = function () {\n              return this._map;\n            }, e.prototype.domLayerCreated = function () {\n              return et || (h.Helpers.compareVersions(L.version, [0, 7]) || this.error(\"ZoomCharts requires Leaflet.js version 0.7.0 or newer. The loaded version is \" + L.version), et = !0), this._map ? void this.applyGestureSettings() : (this._map = this._domLayer.map, null != this._pendingLatitude ? this.setView(this._pendingLatitude, this._pendingLongitude, this._pendingZoomLevel) : (null !== this.settings.navigation.initialLat && this.setView(this.settings.navigation.initialLat, this.settings.navigation.initialLng, this.settings.navigation.initialZoom), null != this._pendingZoomLevel && this.setZoomLevel(this._pendingZoomLevel)), null != this._pendingBounds && this.setBounds(this._pendingBounds), this.events && (this.renderer = this.events.addElement(new $(this)), this.events.notifySceneChanges({\n                settings: !0,\n                settingsChanges: this.settings,\n                zoom: !0,\n                bounds: !0\n              })), this.applyGestureSettings(), void (this.scene.loading = !1));\n            }, e.prototype.createDomLayer = function () {\n              return this._domLayer = new x(this), this._domLayer;\n            }, e.prototype.createDataObj = function (t) {\n              return new S(this, t);\n            }, e.prototype.getData = function (e) {\n              return t.prototype.getData.call(this, e);\n            }, e.prototype.onSettingsChanged = function (t) {\n              var e = {};\n              t.navigation && t.navigation.initialDrilldown && this.navigator.showInitialNodes(), t.filters && (e.filters = !0), t.style && (e.style = !0), this.events.notifySceneChanges(e);\n            }, e.prototype.saveNavigation = function () {\n              return this._map ? this.scene.getVisibleBoundsLatLon() : null;\n            }, e.prototype.restoreNavigation = function (t) {\n              this.setBounds(t);\n            }, e.prototype.save = function () {\n              return \"\";\n            }, e.prototype.restore = function (t, e) {}, e.prototype.setZoomLevel = function (t) {\n              this._map ? this._map.setZoom(t) : this._pendingZoomLevel = t;\n            }, e.prototype.setView = function (t, e, i) {\n              this._map ? this._map.setView(L.latLng(t, e), i) : (this._pendingLatitude = t, this._pendingLongitude = e, this._pendingZoomLevel = i);\n            }, e.prototype.setBounds = function (t) {\n              if (this._map) {\n                var e = t;\n                if (void 0 !== e.east) this._map.fitBounds(L.latLngBounds(L.latLng(e.south, e.west), L.latLng(e.north, e.east)));else {\n                  var i = t;\n\n                  this._map.fitBounds(L.latLngBounds(L.latLng(i.y1, i.x0), L.latLng(i.y0, i.x1)));\n                }\n              } else this._pendingBounds = t;\n            }, e.prototype.getNodeDimensions = function (t) {\n              var e = t;\n              if (h.Helpers.isString(t) && (e = this.getNode(t)), !e) return null;\n              var i = this.scene.toDisplay(e.x, e.y);\n              return {\n                x: i.x,\n                y: i.y,\n                radius: e.hHeight * this.scene.zoom,\n                hwidth: e.hWidth * this.scene.zoom\n              };\n            }, e.prototype.expandNode = function (t) {\n              var e;\n              e = h.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.expandNode(e);\n            }, e.prototype.collapseNode = function (t) {\n              var e;\n              e = h.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.collapseNode(e);\n            }, e.prototype.getNode = function (t) {\n              var e = this.renderer ? this.renderer.findObjectById(t) : null;\n              return e instanceof o.Node || (e = null), e;\n            }, e.prototype.getLink = function (t) {\n              var e = this.renderer ? this.renderer.findObjectById(t) : null;\n              return e instanceof o.Link || (e = null), e;\n            }, e.prototype.hideMenu = function () {\n              this.menu.hideMenu();\n            }, e.prototype.defaultClick = function (t, e) {\n              var i = \"drilldown\" === this.settings.interaction.mode,\n                  n = e.clickNode;\n              i && n && n.expandable && this.navigator.expandNode(n) && (this.setBounds(this.scene.unprojectRect(n.data._bounds)), t.preventDefault());\n            }, e.prototype.defaultRightClick = function (t, e) {\n              e.clickNode && (this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault());\n            }, e.prototype.applyGestureSettings = function () {\n              var t = this._map;\n              !1 === this.settings.interaction.zooming.zoomInOnDoubleClick && t.doubleClickZoom.disable(), this.settings.interaction.zooming.doubleClickZoom && (t.options.zoomDelta = this.settings.interaction.zooming.doubleClickZoom);\n            }, e;\n          }(o.Impl);\n\n          t.Impl = it;\n        }(n.GeoChart || (n.GeoChart = {}));\n      }(n = e.Internal || (e.Internal = {})), function (t) {\n        !function (t) {\n          t[t.always = 2] = \"always\", t[t.disabled = 0] = \"disabled\", t[t.hovered = 1] = \"hovered\", t[t.selected = 3] = \"selected\";\n        }(t.GeoChartSettingsAggregatedShapeStyleMode || (t.GeoChartSettingsAggregatedShapeStyleMode = {})), function (t) {\n          t[t.always = 2] = \"always\", t[t.auto = 1] = \"auto\", t[t.never = 0] = \"never\";\n        }(t.LinearChartSettingsValueAxisBaseLineLabelMode || (t.LinearChartSettingsValueAxisBaseLineLabelMode = {}));\n      }(i = e.Configuration || (e.Configuration = {}));\n\n      var s = function (t) {\n        function e(i) {\n          var r = t.call(this) || this;\n          return r.typeName = \"NetChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n            return new n.NetChart.Impl(t, r);\n          }, i) : r._impl = new n.NetChart.Impl(i, r), r;\n        }\n\n        return r(e, t), e.prototype.updateSettings = function (e) {\n          return t.prototype.updateSettings.call(this, e), this;\n        }, e.prototype.replaceSettings = function (e) {\n          return t.prototype.replaceSettings.call(this, e), this;\n        }, e.prototype.addData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.addData(t, e);\n        }, e.prototype.removeData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.removeData(t, e);\n        }, e.prototype.replaceData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.replaceData(t, e);\n        }, e.prototype.hideMenu = function () {\n          return this._impl.hideMenu(), this;\n        }, e.prototype.updateStyle = function (t) {\n          t ? (this._impl.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null);\n        }, e.prototype.getNode = function (t) {\n          return this._impl.getNode(t);\n        }, e.prototype.getLink = function (t) {\n          return this._impl.getLink(t);\n        }, e.prototype.showNode = function (t) {\n          return this._impl.showNode(t);\n        }, e.prototype.hideNode = function (t) {\n          return this._impl.hideNode(t);\n        }, e.prototype.expandNode = function (t) {\n          return this._impl.expandNode(t);\n        }, e.prototype.addFocusNode = function (t, e) {\n          return void 0 === e && (e = -1), null == e && (e = -1), this._impl.addFocusNode(t, e);\n        }, e.prototype.removeFocusNode = function (t) {\n          return this._impl.removeFocusNode(t);\n        }, e.prototype.clearFocus = function () {\n          return this._impl.clearFocus();\n        }, e.prototype.collapseNode = function (t) {\n          return this._impl.collapseNode(t);\n        }, e.prototype.closeNode = function (t) {\n          return this._impl.closeNode(t);\n        }, e.prototype.lockNode = function (t, e, i) {\n          return this._impl.lockNode(t, e, i);\n        }, e.prototype.unlockNode = function (t) {\n          return this._impl.unlockNode(t);\n        }, e.prototype.zoom = function (t, e) {\n          return void 0 === e && (e = !0), null != t && this._impl.setZoom(t, !!e), this._impl.scene.zoom;\n        }, e.prototype.resetLayout = function () {\n          return this._impl.resetLayout();\n        }, e.prototype.selection = function (t) {\n          return t && this._impl.setSelection(t), this._impl.scene.selection;\n        }, e.prototype.zoomIn = function (t, e) {\n          return void 0 === e && (e = !0), this.scrollIntoView(t);\n        }, e.prototype.nodes = function () {\n          return this._impl.getCurrentNodes();\n        }, e.prototype.links = function () {\n          return this._impl.getCurrentLinks();\n        }, e.prototype.getNodeDimensions = function (t) {\n          return this._impl.getNodeDimensions(t);\n        }, e.prototype.exportData = function (t, e) {\n          return void 0 === t && (t = !0), void 0 === e && (e = !0), this._impl.exportData(!!t, !!e);\n        }, e.prototype.scrollIntoView = function (t, e) {\n          this._impl.scrollIntoView(t, e);\n        }, e.prototype.on = function (e, i) {\n          t.prototype.on.call(this, e, i);\n        }, e;\n      }(n.Base.Api);\n\n      s.themes = {\n        flat: n.NetChart.Settings.FlatTheme,\n        dark: n.NetChart.Settings.DarkTheme\n      }, s.chartFactoryMethod = null, e.NetChart = s, n.Base.Helpers.exportSymbol(\"NetChart\", e.NetChart);\n\n      var a = function (t) {\n        function e(i) {\n          var r = t.call(this) || this;\n          return r._cachedApiCalls = [], r.typeName = \"TimeChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n            return new n.TimeChart.Impl(t, r);\n          }, i) : r._impl = new n.TimeChart.Impl(i, r), r;\n        }\n\n        return r(e, t), e.prototype._notifyAssetsLoaded = function () {\n          var t = this._cachedApiCalls;\n\n          if (null !== t) {\n            this._cachedApiCalls = null;\n\n            for (var e = 0; e < t.length; e++) {\n              t[e]();\n            }\n          }\n        }, e.prototype.updateSettings = function (e) {\n          return t.prototype.updateSettings.call(this, e), this;\n        }, e.prototype.replaceSettings = function (e) {\n          return t.prototype.replaceSettings.call(this, e), this;\n        }, e.prototype.on = function (e, i) {\n          t.prototype.on.call(this, e, i);\n        }, e.prototype.time = function (t, e, i) {\n          var r = this;\n          void 0 === i && (i = !0);\n          var s = this._impl,\n              a = s.scene,\n              o = n.TimeChart.TimeStep.timeUnitDiffs,\n              l = !s.displayUnit || o[s.displayUnit.unit] < o.d;\n\n          if (null != t && null != e) {\n            if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n              r.time(t, e, i);\n            }), [null, null];\n            s.setTimeRange(a.timestampToInternal(+t, l), a.timestampToInternal(+e, l), i);\n          }\n\n          return [a.timestampFromInternal(s.timeStart, l), a.timestampFromInternal(s.timeEnd, l)];\n        }, e.prototype.targetTime = function () {\n          var t = this._impl,\n              e = t.scene,\n              i = t.scrolling,\n              r = n.TimeChart.TimeStep.timeUnitDiffs;\n          if (!(i.targetUnit || t.displayUnit)) return [null, null];\n          var s = !t.displayUnit || r[t.displayUnit.unit] < r.d;\n          return [e.timestampFromInternal(i.getFrom(), s), e.timestampFromInternal(i.getTo(), s)];\n        }, e.prototype.targetDisplayUnit = function () {\n          var t = this._impl,\n              e = t.scrolling.targetUnit || t.displayUnit || t.scene.displayUnit;\n          return e ? e.toString() : null;\n        }, e.prototype.addData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.addData(t, e);\n        }, e.prototype.replaceData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.replaceData(t, e);\n        }, e.prototype.setDisplayPeriod = function (t, e, i) {\n          var n = this;\n          return void 0 === i && (i = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {\n            n.setDisplayPeriod(t, e, i);\n          }) : void this._impl.setDisplayPeriod(t, e, null, i);\n        }, e.prototype.displayUnit = function (t, e, i) {\n          var r = this;\n\n          if (void 0 === e && (e = !0), void 0 !== i && n.Base.Helpers.warn(\"TimeChart.displayUnit() no longer supports the `rescale` parameter.\"), t) {\n            if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n              r.displayUnit(t, e);\n            }), null;\n\n            this._impl.setDisplayUnit(t, e, \"api\", !0);\n          }\n\n          return this._impl.displayUnit ? this._impl.displayUnit.toString() : null;\n        }, e.prototype.selection = function (t, e) {\n          var i = this,\n              r = this._impl,\n              s = r.scene,\n              a = n.TimeChart.TimeStep.timeUnitDiffs,\n              o = !r.displayUnit || a[r.displayUnit.unit] < a.d;\n\n          if (void 0 !== t && void 0 !== e) {\n            if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n              i.selection(t, e);\n            }), [null, null];\n            r.setSelection(null === t ? null : s.timestampToInternal(+t, o), null === e ? null : s.timestampToInternal(+e, o));\n          }\n\n          return [s.timestampFromInternal(r.scene.selectionStart, o), s.timestampFromInternal(r.scene.selectionEnd, o)];\n        }, e.prototype.scroll = function (t, e, i) {\n          return void 0 === e && (e = !0), void 0 === i && (i = !1), this._impl.scroll(t, e);\n        }, e.prototype.zoomOut = function (t, e) {\n          var i = this;\n          return void 0 === e && (e = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {\n            i.zoomOut(t, e);\n          }) : void this._impl.zoomOut(e, \"api\", n.TimeChart.TimeStep.parse(t));\n        }, e.prototype.zoomIn = function (t, e, i) {\n          var r = this;\n          if (void 0 === e && (e = null), void 0 === i && (i = !0), this._cachedApiCalls) this._cachedApiCalls.push(function () {\n            r.zoomIn(t, e, i);\n          });else {\n            var s = this._impl,\n                a = n.TimeChart.TimeStep.parse(t);\n\n            if (null != e) {\n              var o = a || s.displayUnit,\n                  l = n.TimeChart.TimeStep.timeUnitDiffs,\n                  h = !o || l[o.unit] < l.d;\n              e = s.scene.timestampToInternal(+e, h);\n            }\n\n            s.zoomIn(a, e, i, \"api\");\n          }\n        }, e.prototype.replaceSeries = function (t) {\n          return this._impl.deprecated(\"replaceSeries\", \"replaceSettings\"), this.replaceSettings({\n            series: t\n          });\n        }, e.prototype.exportVisibleData = function () {\n          return this._impl.exportVisibleData();\n        }, e.prototype.showInfoPopup = function (t, e, i) {\n          var r = this;\n          if (this._cachedApiCalls) this._cachedApiCalls.push(function () {\n            r.showInfoPopup(t, e, i);\n          });else {\n            var s = this._impl,\n                a = s.scene,\n                o = n.TimeChart.TimeStep.timeUnitDiffs,\n                l = !s.displayUnit || o[s.displayUnit.unit] < o.d;\n            s.showInfoPopup(null == t ? null : a.timestampToInternal(+t, l), null == e ? null : a.timestampToInternal(+e, l), i);\n          }\n        }, e.prototype.getEnabledSeries = function () {\n          return this._impl.getEnabledSeries();\n        }, e.prototype.getSeries = function () {\n          return this._impl.getSeries();\n        }, e;\n      }(n.Base.Api);\n\n      a.themes = {\n        flat: n.TimeChart.Settings.FlatTheme,\n        round: n.TimeChart.Settings.RoundTheme,\n        gradient: n.TimeChart.Settings.GradientTheme,\n        static: n.TimeChart.Settings.StaticChart,\n        dark: n.TimeChart.Settings.DarkTheme\n      }, a.chartFactoryMethod = null, e.TimeChart = a, n.Base.Helpers.exportSymbol(\"TimeChart\", e.TimeChart);\n\n      var o = function (t) {\n        function e(i) {\n          var r = t.call(this) || this;\n          return r.typeName = \"PieChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n            return new n.PieChart.Impl(t, r);\n          }, i) : r._impl = new n.PieChart.Impl(i, r), r;\n        }\n\n        return r(e, t), e.prototype.updateSettings = function (e) {\n          return t.prototype.updateSettings.call(this, e), this;\n        }, e.prototype.replaceSettings = function (e) {\n          return t.prototype.replaceSettings.call(this, e), this;\n        }, e.prototype.updateFilter = function () {\n          return this._impl.updateFilter(), this;\n        }, e.prototype.addData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.addData(t, e);\n        }, e.prototype.replaceData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.replaceData(t, e);\n        }, e.prototype.selection = function (t) {\n          if (t) if (Array.isArray(t)) {\n            for (var e = t.slice(), i = 0; i < e.length; i++) {\n              var r = e[i];\n              r instanceof n.PieChart.Slice ? e[i] = r.id : n.Base.Helpers.isString(r) || this._impl.error(\"PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.\");\n            }\n\n            this._impl.setSelection(e);\n          } else this._impl.error(\"PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.\");\n          return this._impl.scene.selection.slice();\n        }, e.prototype.getPie = function () {\n          return this._impl.getPie();\n        }, e.prototype.getPieOffset = function () {\n          return this._impl.navigator.getPieOffset();\n        }, e.prototype.setPie = function (t, e) {\n          return void 0 === e && (e = 0), null == e && (e = 0), this._impl.setPie(t, e), this;\n        }, e.prototype.setPieOffset = function (t) {\n          return this._impl.setPieOffset(t), this;\n        }, e.prototype.getActiveSlices = function () {\n          return this._impl.getActiveSlices();\n        }, e.prototype.getActivePies = function () {\n          return this._impl.getActivePies();\n        }, e.prototype.getActivePie = function () {\n          var t = this._impl.getActivePies();\n\n          return t[t.length - 1];\n        }, e.prototype.expandSlice = function (t) {\n          return this._impl.expandSlice(t, \"api\");\n        }, e.prototype.getSliceDimensions = function (t, e) {\n          return void 0 === e && (e = !1), null == e && (e = !1), this._impl.getSliceDimensions(t, e);\n        }, e.prototype.on = function (e, i) {\n          t.prototype.on.call(this, e, i);\n        }, e;\n      }(n.Base.Api);\n\n      o.themes = {\n        dark: n.PieChart.Settings.DarkTheme,\n        flat: n.PieChart.Settings.FlatTheme,\n        bevel: n.PieChart.Settings.BevelTheme,\n        gradient: n.PieChart.Settings.GradientTheme,\n        raised: n.PieChart.Settings.CanTheme\n      }, o.chartFactoryMethod = null, e.PieChart = o, n.Base.Helpers.exportSymbol(\"PieChart\", e.PieChart);\n\n      var l = function (t) {\n        function e(i) {\n          var r = t.call(this) || this;\n          return r.typeName = \"FacetChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n            return new n.FacetChart.Impl(t, r);\n          }, i) : r._impl = new n.FacetChart.Impl(i, r), r;\n        }\n\n        return r(e, t), e.prototype.updateSettings = function (e) {\n          return t.prototype.updateSettings.call(this, e), this;\n        }, e.prototype.replaceSettings = function (e) {\n          return t.prototype.replaceSettings.call(this, e), this;\n        }, e.prototype.addData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.addData(t, e);\n        }, e.prototype.replaceData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.replaceData(t, e);\n        }, e.prototype.updateFilter = function () {\n          return this._impl.updateFilter(), this;\n        }, e.prototype.selection = function (t) {\n          if (t) if (Array.isArray(t)) {\n            for (var e = t.slice(), i = 0; i < e.length; i++) {\n              var r = e[i];\n              r instanceof n.FacetChart.Item ? e[i] = r.id : n.Base.Helpers.isString(r) || this._impl.error(\"FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.\");\n            }\n\n            this._impl.setSelection(e);\n          } else this._impl.error(\"FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.\");\n          return this._impl.scene.selection.slice();\n        }, e.prototype.setPie = function (t, e, i) {\n          return void 0 === e && (e = 0), void 0 === i && (i = null), Array.isArray(t) || (t = [t]), this._impl.setPie(t, e, i), this;\n        }, e.prototype.getPie = function () {\n          return this._impl.getPie();\n        }, e.prototype.getPieOffset = function () {\n          return this._impl.getPieOffset();\n        }, e.prototype.getActiveItems = function () {\n          return this._impl.getActiveItems();\n        }, e.prototype.getActiveFacets = function () {\n          return this._impl.getActiveFacets();\n        }, e.prototype.getActiveFacet = function () {\n          var t = this._impl.getActiveFacets();\n\n          return t[t.length - 1];\n        }, e.prototype.expandSlice = function (t) {\n          return this._impl.expandItem(t, \"api\");\n        }, e.prototype.replaceSeries = function (t) {\n          return this._impl.deprecated(\"replaceSeries\", \"replaceSettings\"), this.replaceSettings({\n            series: t\n          });\n        }, e.prototype.on = function (e, i) {\n          t.prototype.on.call(this, e, i);\n        }, e.prototype.getEnabledSeries = function () {\n          return this._impl.getEnabledSeries();\n        }, e.prototype.getSeries = function () {\n          return this._impl.getSeries();\n        }, e;\n      }(n.Base.Api);\n\n      l.themes = {\n        dark: n.FacetChart.Settings.DarkTheme\n      }, l.chartFactoryMethod = null, e.FacetChart = l, n.Base.Helpers.exportSymbol(\"FacetChart\", e.FacetChart);\n\n      var h = function (t) {\n        function e(i) {\n          var r = t.call(this) || this;\n          return r.typeName = \"GeoChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n            return new n.GeoChart.Impl(t, r);\n          }, i) : r._impl = new n.GeoChart.Impl(i, r), r;\n        }\n\n        return r(e, t), e.prototype.updateSettings = function (e) {\n          return t.prototype.updateSettings.call(this, e), this;\n        }, e.prototype.replaceSettings = function (e) {\n          return t.prototype.replaceSettings.call(this, e), this;\n        }, e.prototype.addData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.addData(t, e);\n        }, e.prototype.replaceData = function (t, e) {\n          null == e && (e = \"default\"), this._impl.replaceData(t, e);\n        }, e.prototype.hideMenu = function () {\n          return this._impl.hideMenu(), this;\n        }, e.prototype.getNode = function (t) {\n          return this._impl.getNode(t);\n        }, e.prototype.updateStyle = function (t) {\n          t ? this._impl.renderer && (this._impl.renderer.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null);\n        }, e.prototype.selection = function (t) {\n          return t && this._impl.setSelection(t), this._impl.scene.selection;\n        }, e.prototype.bounds = function (t) {\n          t && this._impl.setBounds(t);\n\n          var e = this._impl.scene.getVisibleBoundsLatLon();\n\n          return {\n            east: e.x1,\n            north: e.y1,\n            west: e.x0,\n            south: e.y0\n          };\n        }, e.prototype.back = function () {\n          return this._impl.back(), this;\n        }, e.prototype.zoomLevel = function (t) {\n          return t && this._impl.setZoomLevel(t), this._impl.scene.zoomLevel;\n        }, e.prototype.getNodeDimensions = function (t) {\n          return this._impl.getNodeDimensions(t);\n        }, e.prototype.leaflet = function () {\n          return this._impl.getMap();\n        }, e.prototype.on = function (e, i) {\n          t.prototype.on.call(this, e, i);\n        }, e;\n      }(n.Base.Api);\n\n      h.themes = {\n        flat: n.GeoChart.Settings.FlatTheme\n      }, h.chartFactoryMethod = null, e.GeoChart = h, n.Base.Helpers.exportSymbol(\"GeoChart\", e.GeoChart), n.Base.Helpers.exportSymbol(\"ZoomCharts\", e);\n    }(n || (n = {}));\n  }, function (t, e, i) {\n    var n = i(0);\n    t.exports.TimeChart = n.TimeChart, t.exports.PieChart = n.PieChart, t.exports.GeoChart = n.GeoChart, t.exports.NetChart = n.NetChart, t.exports.FacetChart = n.FacetChart;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}